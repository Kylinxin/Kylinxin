<!DOCTYPE html><html lang="zh-CN" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>蓝桥杯 | Ky不是枕木</title><link rel="icon" type="image/x-icon" href="/favicon.ico"><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"Enter here","blurHolder":"Search","noResult":"Data \"$0\" not found"},"code":{"codeInfo":"$0 - $1 lines","copy":"code.copy","copyFinish":"code.copyFinish","expand":"code.expand"}}</script><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/css/all.min.css"><link rel="stylesheet" href="/css/arknights.css"><script>if (window.localStorage.getItem('theme-mode') === 'light')
 document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark')
 document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: Bender;
 src: local('Bender'), url("/font/Bender.ttf"), url("/font/Bender.otf");
}
@font-face {
 font-family: BenderLight;
 src: local('BenderLight'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
  --dark-background: url('https://ak.hypergryph.com/assets/index/images/ak/pc/bk.jpg');
  --light-background: url('/img/bk.jpg');
}</style><meta name="generator" content="Hexo 6.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="Ky不是枕木" type="application/atom+xml">
</head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><nav><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Search" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>蓝桥杯</h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2023-04-10T15:14:29.000Z" id="date"> 2023-04-10</time></div></span><br><span>Last Update: <div class="control"><time datetime="2023-05-05T12:05:49.135Z" id="updated"> 2023-05-05</time></div></span></div></div><hr><div id="post-content"><h2 id=""><a href="#" class="headerlink" title=""></a></h2>
<h1>救赎</h1>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2>
<h3 id="1-欧几里得辗转相除法-求解-最大公约数-最小公倍数"><a href="#1-欧几里得辗转相除法-求解-最大公约数-最小公倍数" class="headerlink" title="1-欧几里得辗转相除法-求解-最大公约数-最小公倍数"></a>1.欧几里得辗转相除法 求解 最大公约数 最小公倍数</h3>
<pre><code class="language-c++">int gcd(int a, int b){return b == 0 ? a : gcd(b, a % b);}
int lcm(int a, int b){return a / gcd(a, b) * b;}
</code></pre>
<h3 id="2-求质数"><a href="#2-求质数" class="headerlink" title="2-求质数"></a>2.求质数</h3>
<pre><code class="language-c++">/* 判断素数 */
bool isPrime(LL n) {
	for (int i = 2; i * i &lt;= n; ++i)
		if (n % i == 0)
			return false;
	return true;
}
</code></pre>
<h3 id="3-栈"><a href="#3-栈" class="headerlink" title="3-栈"></a>3.栈</h3>
<pre><code class="language-c++">#include &lt;stack&gt;
stack&lt;类型&gt; mystack;
s.empty();         //如果栈为空则返回true, 否则返回false;
s.size();          //返回栈中元素的个数
s.top();           //返回栈顶元素, 但不删除该元素
s.pop();           //弹出栈顶元素, 但不返回其值
s.push();          //将元素压入栈顶
</code></pre>
<h3 id="4-队列"><a href="#4-队列" class="headerlink" title="4-队列"></a>4.队列</h3>
<pre><code class="language-c++">#include &lt;queue&gt;
queue&lt;类型&gt; myqueue;
push() //在队尾插入一个元素
pop() //删除队列第一个元素
size() //返回队列中元素个数
empty() //如果队列空则返回true
front() //返回队列中的第一个元素
back() //返回队列中最后一个元素
</code></pre>
<h3 id="5-DFS-深度优先"><a href="#5-DFS-深度优先" class="headerlink" title="5-DFS-深度优先"></a>5.DFS(深度优先)</h3>
<pre><code class="language-c++">int dx[4] = {0,0,-1,1};
int dy[4] = {-1,1,0,0};
int mp[N][N];//存放迷宫
int vis[N][N];//表示是否访问过，初始为flase
void DFS(int x, int y)	//x,y是坐标点的位置 
{
	if(vis[x][y] || (x==n &amp;&amp; y==n)) return; //表示已经访问过了或者到达终点,递归的出口
	vis[x][y] = true; //表示没有访问过，现在正在访问，置为访问过
	for(int i=0; i &lt; 4; i++){	//遍历四个方向，顺序依次是，上下左右
		int nx = x + dx[i];
		int ny = y + dy[i];
      //进行了合法性检验，
      //1.首先判断了该点是否越界，即是否在迷宫内  nx &gt; 0 &amp;&amp; nx &lt;= n &amp;&amp; ny &gt; 0 &amp;&amp; ny &lt;= n
      //2.然后判断是否访问过  !vis[nx][ny] 未访问过就继续
      //3.最后判断是否为路  mp[nx][ny] == '0' 为路就继续
		if(nx &gt; 0 &amp;&amp; nx &lt;= n &amp;&amp; ny &gt; 0 &amp;&amp; ny &lt;= n &amp;&amp; !vis[nx][ny] &amp;&amp; mp[nx][ny] == '0')
			dfs(nx,ny);
	} 
}
//注意!! 应该判断一下起点是否可走
</code></pre>
<h3 id="6-BFS-广度优先搜索"><a href="#6-BFS-广度优先搜索" class="headerlink" title="6-BFS-广度优先搜索"></a>6.BFS(广度优先搜索)</h3>
<pre><code class="language-c++">int X[4]={0, 0, -1, 1};
int Y[4]={-1, 1, 0, 0};
int matrix[N][N]; //存储迷宫信息
int vis[N][N];	//存储每个状态点是否走过

struct node{
	int x;
	int y;
}Node, top;

bool judge(int xx, int yy)
{
	if(xx&lt;0||yy&lt;0||xx&gt;=N||yy&gt;=N) //注意边界
		return false;
	if(vis[xx][yy]==true||matrix[xx][yy]==0)	//下一个点走过或者为墙 0不能走，1能走
		return false;
	return true;
}


void BFS(int x, int y)
{
	queue&lt;node&gt; q;
	Node.x=x;
	Node.y=y;
	q.push(Node);	//将起点入队列
	while(!q.empty())	//队列不空就扩散
	{
		top=q.front();	//取出队首元素
		int nx=top.x;
		int ny=top.y;	//从四个方面机进行扩散
         if(nx == ex &amp;&amp; ny == ey) //找到终点
             return top;
		for(int i=0; i&lt;4; i++)
		{
			if(judge(nx+X[i], ny+Y[i])) //检查四个方向，如果有路就进队列
			{
				Node.x=nx+X[i];
				Node.y=ny+Y[i];
				q.push(Node);	
			}
		}
		ans++;	//计数器
		vis[nx][ny]=true;
		q.pop();	//表示这个点的邻接点已经全部入队列，丢弃这个点
	}
}
</code></pre>
<h3 id="7-二分模板"><a href="#7-二分模板" class="headerlink" title="7-二分模板"></a>7.二分模板</h3>
<pre><code class="language-c++">/*
    作者:FengBOOOOOOOOOOOOOOO
    二分模板返回大于x的第一个位置    
*/
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#define N 1005
using namespace std;

int a[N],n,q;

int find(int l,int r,int key)//l为-1，r为数组长度
{
    while(l + 1 &lt; r)
    {
        int mid = l + r&gt;&gt;1;
        if(a[mid] &lt;= key)
        　　l = mid;
        else
        　　r = mid;
    }
    return r;//返回大于Key的第一个位置
}

int main()
{
    int k;
    scanf("%d%d",&amp;n,&amp;q);
    for(int i = 0; i &lt; n; ++i)
    　　scanf("%d",&amp;a[i]);
    for(int i = 0; i &lt; q; ++i)
    {
        scanf("%d",&amp;k);
        printf("%d\n",find(-1,n,k));
    }
} 

</code></pre>
<h2 id="最短路径问题"><a href="#最短路径问题" class="headerlink" title="最短路径问题"></a>最短路径问题</h2>
<h3 id="1-SPFA最短路径-类似与BFS"><a href="#1-SPFA最短路径-类似与BFS" class="headerlink" title="1-SPFA最短路径-类似与BFS"></a>1.SPFA最短路径(类似与BFS)</h3>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;algorithm&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
#define ll long long
#define inf 0x3f3f3f3f
#define pii pair&lt;int, int&gt;
const int mod = 1e9+7;
const int maxn = 2e5+7;
using namespace std;
struct node {int to,w,next;} edge[maxn];
int head[maxn], cnt;
int dis[maxn], vis[maxn];
int n, m, s, t;
struct Spfa
{
    void init()
    {
        memset(head,-1,sizeof(head));
        memset(dis,0x3f3f3f3f,sizeof(dis));
        memset(vis,0,sizeof(vis));
        cnt = 0;
    }
 
    void add(int u,int v,int w)
    {
        edge[cnt].to = v;
        edge[cnt].w = w;
        edge[cnt].next = head[u];
        head[u] = cnt ++;
    }
 
    void spfa()
    {
        dis[s] = 0; vis[s] = 1;
        queue &lt;int&gt; Q; Q.push(s);
        while(!Q.empty())
        {
            int now = Q.front();
            Q.pop(); vis[now] = 0;    //从队列中弹出now , vis[now] 标记为未访问
            for(int i = head[now]; i != -1; i = edge[i].next)
            {
                int v = edge[i].to;
                if(dis[v] &lt; dis[now] + edge[i].w)
                {
                    dis[v] = dis[now] + edge[i].w;
                    if(vis[v]) continue;    //如果访问过了(也就是 已经在队列中),就不用再push
                    vis[v] = 1; Q.push(v);
                }
            }
        }
    }
}sp;
 
int main()
{
    while(~scanf("%d%d",&amp;n,&amp;m) &amp;&amp; n+m)
    {
        sp.init();
        for(int i = 0; i &lt; m; i++)
        {
            int u, v, w;
            scanf("%d%d%d",&amp;u, &amp;v, &amp;w);
            sp.add(u, v, w);
            sp.add(v, u, w);
        }
        s = 1, t = n; //s起点，t终点
        sp.spfa();
        printf("%d\n", dis[t]);
    }
}

</code></pre>
<h3 id="2-Dijkstra"><a href="#2-Dijkstra" class="headerlink" title="2-Dijkstra"></a>2.Dijkstra</h3>
<pre><code class="language-c++">//主要思想一个大循环+两个小循环
void dijkstra(){
	int u, minx;
	book[S] = 1;
	for(int i = 0; i &lt; N; i++){
	//dist[]数组初始化，把起始结点S到i结点的距离赋值给diat[i]
		dist[i] = v[S][i];
	}

	for(int i = 0; i &lt; N; i++){//大循环
		minx = INT_MAX;
		for(int j = 0; j &lt; N; j++){//寻找没有被标记并且最短的路径，并记录此结点 
			if(!book[j] &amp;&amp; minx &gt; dist[j]){
				minx = dist[j];
				u = j;
			} 
		}
		book[u] = 1;
		for(int k = 0; k &lt; N; k++){
		//如果A到B的距离大于A到C的距离加C到B的距离，那么更新数据
			if(!book[k] &amp;&amp; dist[k] &gt; dist[u]+v[u][k]){
				dist[k] = dist[u]+v[u][k];
			}
		}
	}
}

</code></pre>
<h3 id="3-Floyd"><a href="#3-Floyd" class="headerlink" title="3-Floyd"></a>3.Floyd</h3>
<pre><code class="language-c++">//初始化：
    for (int i = 1; i &lt;= n; i ++ )
        for (int j = 1; j &lt;= n; j ++ )
            if (i == j) d[i][j] = 0;
            else d[i][j] = INF;

// 算法结束后，d[a][b]表示a到b的最短距离
void floyd()
{
    for (int k = 1; k &lt;= n; k ++ )
        for (int i = 1; i &lt;= n; i ++ )
            for (int j = 1; j &lt;= n; j ++ )
                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
}

</code></pre>
<div id="paginator"></div></div><div id="post-footer"><div id="pages" style="justify-content: flex-start"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2023/04/10/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AE%9E%E9%AA%8C/">← Next 密码学实验</a></div></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="To Top" style="opacity: 0; display: none;">∧ </a><a class="i-index" id="to-index" href="#toc-div" title="To Catalog">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="Change Theme"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><h1 id="Dr"><a href="/">枕木</a></h1><div id="description"><p>当你觉得生活都不顺心如意的时候，来学习pwn吧！</p></div></div><div id="aside-block"><div id="toc-div"><h1>Catalog</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number"></span> <span class="toc-text">救赎</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">1.</span> <span class="toc-text">基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E6%B3%95-%E6%B1%82%E8%A7%A3-%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0-%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0"><span class="toc-number">1.1.</span> <span class="toc-text">1.欧几里得辗转相除法 求解 最大公约数 最小公倍数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%B1%82%E8%B4%A8%E6%95%B0"><span class="toc-number">1.2.</span> <span class="toc-text">2.求质数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%A0%88"><span class="toc-number">1.3.</span> <span class="toc-text">3.栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%98%9F%E5%88%97"><span class="toc-number">1.4.</span> <span class="toc-text">4.队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-DFS-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88"><span class="toc-number">1.5.</span> <span class="toc-text">5.DFS(深度优先)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-BFS-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="toc-number">1.6.</span> <span class="toc-text">6.BFS(广度优先搜索)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E4%BA%8C%E5%88%86%E6%A8%A1%E6%9D%BF"><span class="toc-number">1.7.</span> <span class="toc-text">7.二分模板</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98"><span class="toc-number">2.</span> <span class="toc-text">最短路径问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-SPFA%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-%E7%B1%BB%E4%BC%BC%E4%B8%8EBFS"><span class="toc-number">2.1.</span> <span class="toc-text">1.SPFA最短路径(类似与BFS)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Dijkstra"><span class="toc-number">2.2.</span> <span class="toc-text">2.Dijkstra</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Floyd"><span class="toc-number">2.3.</span> <span class="toc-text">3.Floyd</span></a></li></ol></li></ol></div></div><footer><nobr>Published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr> by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script src="/js/arknights.js"></script><script src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script src="/js/pjax.js"></script><script class="pjax-js">reset= () => {document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script></body></html>