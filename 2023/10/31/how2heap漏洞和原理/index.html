<!DOCTYPE html><html lang="zh-CN" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>how2heap漏洞和解析 | Ky不是枕木</title><link rel="icon" type="image/x-icon" href="/favicon.ico"><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"键入以继续","blurHolder":"数据检索","noResult":"无 $0 相关数据"},"code":{"codeInfo":"$0 - $1 行","copy":"code.copy","copyFinish":"code.copyFinish","expand":"code.expand"}}</script><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/css/all.min.css"><link rel="stylesheet" href="/css/arknights.css"><script>if (window.localStorage.getItem('theme-mode') === 'light')
 document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark')
 document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: Bender;
 src: local('Bender'), url("/font/Bender.ttf"), url("/font/Bender.otf");
}
@font-face {
 font-family: BenderLight;
 src: local('BenderLight'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
  --dark-background: url('https://ak.hypergryph.com/assets/index/images/ak/pc/bk.jpg');
  --light-background: url('/img/bk.jpg');
}</style><meta name="generator" content="Hexo 6.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="Ky不是枕木" type="application/atom+xml">
</head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><nav><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="数据检索" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>how2heap漏洞和解析</h1><div id="post-info"><span>文章发布时间: <div class="control"><time datetime="2023-10-31T15:14:29.000Z" id="date"> 2023-10-31</time></div></span><br><span>最后更新时间: <div class="control"><time datetime="2023-10-31T08:05:32.089Z" id="updated"> 2023-10-31</time></div></span><br><span>文章总字数: <div class="control">4k</div></span><br><span>预计阅读时间: <div class="control">16 分钟</div></span></div></div><hr><div id="post-content"><h2 id="First-fit"><a href="#First-fit" class="headerlink" title="First fit"></a>First fit</h2><p><strong>原理</strong></p>
<figure class="highlight llvm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs llvm">演示glibc 的分配机制<br>glibc 使用首次适应算法选择空闲的堆块<br>如果有一个空闲堆块且足够大，那么 <span class="hljs-keyword">malloc</span> 将选择它<br>如果存在 use-after-<span class="hljs-keyword">free</span> 的情况那可以利用这一特性<br>首先申请两个比较大的 chunk<br>第一个 a <span class="hljs-operator">=</span> <span class="hljs-keyword">malloc</span>(<span class="hljs-number">0x512</span>) 在: <span class="hljs-number">0x1682010</span><br>第二个 b <span class="hljs-operator">=</span> <span class="hljs-keyword">malloc</span>(<span class="hljs-number">0x256</span>) 在: <span class="hljs-number">0x1682530</span><br>我们可以继续分配它<br>现在我们把 <span class="hljs-string">"AAAAAAAA"</span> 这个字符串写到 a 那里 <br>第一次申请的 <span class="hljs-number">0x1682010</span> 指向 AAAAAAAA<br>接下来 <span class="hljs-keyword">free</span> 掉第一个...<br>接下来只要我们申请一块小于 <span class="hljs-number">0x512</span> 的 chunk，那就会分配到原本 a 那里: <span class="hljs-number">0x1682010</span><br>第三次 <span class="hljs-keyword">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">malloc</span>(<span class="hljs-number">0x500</span>) 在: <span class="hljs-number">0x1682010</span><br>我们这次往里写一串 <span class="hljs-string">"CCCCCCCC"</span> 到刚申请的 <span class="hljs-keyword">c</span> 中<br>第三次申请的 <span class="hljs-keyword">c</span> <span class="hljs-number">0x1682010</span> 指向 CCCCCCCC<br>第一次申请的 a <span class="hljs-number">0x1682010</span> 指向 CCCCCCCC<br>可以看到，虽然我们刚刚看的是 a 的，但它的内容却是 <span class="hljs-string">"CCCCCCCC"</span><br></code></pre></td></tr></tbody></table></figure>

<p><strong>操作</strong></p>
<ul>
<li>存在uaf，首先释放一个堆块p1，里面有内容</li>
<li>再申请一个相同大小的堆块p2</li>
<li>这两个堆块实际上指向同一个内存区域</li>
</ul>
<p><strong>结果</strong></p>
<p>这两个堆块实际上指向同一个内存区域</p>
<h2 id="UAF"><a href="#UAF" class="headerlink" title="UAF"></a>UAF</h2><p><strong>原理</strong></p>
<figure class="highlight armasm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs armasm">申请<span class="hljs-number">0x20</span>大小的内存<span class="hljs-built_in">p1</span> 的地址: <span class="hljs-number">0x1f11010</span><br>把<span class="hljs-built_in">p1</span>[<span class="hljs-number">1</span>]赋值为Printf函数，然后打印出<span class="hljs-string">"Hello CTFshow"</span><br><span class="hljs-symbol">Hello</span> CTFshow<br><br><span class="hljs-symbol">free</span> 掉 <span class="hljs-built_in">p1</span><br>因为并没有置为null，所以<span class="hljs-built_in">p1</span>[<span class="hljs-number">1</span>]仍然是Printf函数，仍然可以输出打印了<span class="hljs-string">"Hello CTFshow again"</span><br><span class="hljs-symbol">Hello</span> CTFshow again<br>接下来再去malloc一个<span class="hljs-built_in">p2</span>，会把释放掉的<span class="hljs-built_in">p1</span>给分配出来，可以看到他俩是同一地址的<br><span class="hljs-symbol">p2</span> 的地址: <span class="hljs-number">0x1f11010</span><br><span class="hljs-symbol">p1</span> 的地址: <span class="hljs-number">0x1f11010</span><br>然后把<span class="hljs-built_in">p2</span>[<span class="hljs-number">1</span>]给改成demoflag也就是system函数<br><br><span class="hljs-symbol">Then</span> <span class="hljs-meta">get</span> the flag &amp;&amp; enjoy <span class="hljs-keyword">it</span> !<br><br></code></pre></td></tr></tbody></table></figure>



<p><strong>操作</strong></p>
<ul>
<li>free掉chunk1</li>
<li>再申请一个相同大小的chunk2，修改内容</li>
<li>再使用chunk1，会输出修改内容</li>
</ul>
<p><strong>结果</strong></p>
<p>chunk1和chunk2是同一个chunk</p>
<h2 id="Double-Free"><a href="#Double-Free" class="headerlink" title="Double Free"></a>Double Free</h2><p><strong>原理</strong></p>
<figure class="highlight llvm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs llvm">演示 fastbin 的 <span class="hljs-keyword">double</span> <span class="hljs-keyword">free</span><br>首先申请 <span class="hljs-number">3</span> 个 chunk<br>第一个 <span class="hljs-keyword">malloc</span>(<span class="hljs-number">8</span>): <span class="hljs-number">0x188f010</span><br>第二个 <span class="hljs-keyword">malloc</span>(<span class="hljs-number">8</span>): <span class="hljs-number">0x188f030</span><br>第三个 <span class="hljs-keyword">malloc</span>(<span class="hljs-number">8</span>): <span class="hljs-number">0x188f050</span><br><span class="hljs-keyword">free</span> 掉第一个<br>当我们再次 <span class="hljs-keyword">free</span> <span class="hljs-number">0x188f010</span> 的时候<span class="hljs-punctuation">,</span> 程序将会崩溃因为 <span class="hljs-number">0x188f010</span> 在 <span class="hljs-keyword">free</span> 链表的第一个位置上<br>我们先 <span class="hljs-keyword">free</span> <span class="hljs-number">0x188f030</span>.<br>现在我们就可以再次 <span class="hljs-keyword">free</span> <span class="hljs-number">0x188f010</span> 了<span class="hljs-punctuation">,</span> 因为他现在不在 <span class="hljs-keyword">free</span> 链表的第一个位置上<br>现在空闲链表是这样的 [ <span class="hljs-number">0x188f010</span><span class="hljs-punctuation">,</span> <span class="hljs-number">0x188f030</span><span class="hljs-punctuation">,</span> <span class="hljs-number">0x188f010</span> ]. 如果我们 <span class="hljs-keyword">malloc</span> 三次<span class="hljs-punctuation">,</span> 我们会得到两次 <span class="hljs-number">0x188f010</span> <br>第一次 <span class="hljs-keyword">malloc</span>(<span class="hljs-number">8</span>): <span class="hljs-number">0x188f010</span><br>第二次 <span class="hljs-keyword">malloc</span>(<span class="hljs-number">8</span>): <span class="hljs-number">0x188f030</span><br>第三次 <span class="hljs-keyword">malloc</span>(<span class="hljs-number">8</span>): <span class="hljs-number">0x188f010</span><br></code></pre></td></tr></tbody></table></figure>



<p><strong>操作</strong></p>
<ul>
<li>申请3个chunk，p1，p2，p3</li>
<li>free p1，再freep2，形成 p2 -&gt; p1</li>
<li>再free p1 形成 p1 -&gt; p2 -&gt; p1</li>
<li>连续申请三次chunk</li>
</ul>
<p><strong>结果</strong></p>
<p>得到两个相同地址的chunk</p>
<h2 id="Fastbin-dup-into-stack-–-Double-free"><a href="#Fastbin-dup-into-stack-–-Double-free" class="headerlink" title="Fastbin_dup_into_stack – Double free"></a>Fastbin_dup_into_stack – Double free</h2><p><strong>原理</strong></p>
<figure class="highlight x86asm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">通过欺骗 malloc 使得返回一个指向受控位置的指针（本例为栈上）<br>通过 malloc 申请到 <span class="hljs-number">0x7ffec12adb40</span>.<br>先申请<span class="hljs-number">3</span> 个 chunk<br>chunk a: <span class="hljs-number">0x209a010</span><br>chunk b: <span class="hljs-number">0x209a030</span><br>chunk c: <span class="hljs-number">0x209a050</span><br>free 掉 chunk a<br>如果还对 <span class="hljs-number">0x209a010</span> 进行 free, 程序会崩溃。因为 <span class="hljs-number">0x209a010</span> 现在是 fastbin 的第一个<br>先对 b <span class="hljs-number">0x209a030</span> 进行 free<br>接下来就可以对 <span class="hljs-number">0x209a010</span> 再次进行 free 了, 现在已经不是它在 fastbin 的第一个了<br>现在 fastbin 的链表是 [ <span class="hljs-number">0x209a010</span>, <span class="hljs-number">0x209a030</span>, <span class="hljs-number">0x209a010</span> ] 接下来通过修改 <span class="hljs-number">0x209a010</span> 上的内容来进行攻击.<br>第一次 malloc(<span class="hljs-number">8</span>): <span class="hljs-number">0x209a010</span><br>第二次 malloc(<span class="hljs-number">8</span>): <span class="hljs-number">0x209a030</span><br>现在 fastbin 表中只剩 [ <span class="hljs-number">0x209a010</span> ] 了<br>接下来往 <span class="hljs-number">0x209a010</span> 栈上写一个假的 size，这样 malloc 会误以为那里有一个空闲的 chunk，从而申请到栈上去<br>现在覆盖 <span class="hljs-number">0x209a010</span> 前面的 <span class="hljs-number">8</span> 字节，修改 fd 指针指向 stack_var 前面 <span class="hljs-number">0x20</span> 的位置<br>第三次 malloc(<span class="hljs-number">8</span>): <span class="hljs-number">0x209a010</span>, 把栈地址放到 fastbin 链表中<br>这一次 malloc(<span class="hljs-number">8</span>) 就申请到了栈上去: <span class="hljs-number">0x7ffec12adb40</span><br><br></code></pre></td></tr></tbody></table></figure>

<p><strong>操作</strong></p>
<ul>
<li>申请3个chunk，p1，p2，p3</li>
<li>free p1，再freep2，形成 p2 -&gt; p1</li>
<li>再free p1 形成 p1 -&gt; p2 -&gt; p1</li>
<li>修改p1的fd指向任意地址，栈上都可</li>
<li>连续申请三次chunk</li>
<li>第四次申请chunk会申请到目标地址</li>
</ul>
<p><strong>结果</strong></p>
<p>任意地址读写</p>
<h2 id="Fastbin-dup-consolidate"><a href="#Fastbin-dup-consolidate" class="headerlink" title="Fastbin_dup_consolidate"></a>Fastbin_dup_consolidate</h2><p><strong>原理</strong></p>
<figure class="highlight smali"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs smali">申请两个 fastbin 范围内的 chunk: p1=0xbba010 p2=0xbba030<br>先 free p1<br>去申请 largebin 大小的 chunk，触发 malloc_consolidate(): p3=0xbba050<br>因为 malloc_consolidate(), p1 会被放到 unsorted bin 中<br>这时候 p1 不在 fastbin 链表的头部了，所以可以再次 free p1 造成<span class="hljs-built_in"> double </span>free<br>现在 fastbin 和 unsortedbin 中都放着 p1 的指针，所以我们可以 malloc 两次都到 p1: 0xbba010 0xbba010<br></code></pre></td></tr></tbody></table></figure>

<p><strong>操作</strong></p>
<pre><code>- 1.free 一个fastbin大小的chunk 1
- 2.申请一个largin bin 大小的chunk，此时因为 malloc_consolidate(), chunk1 会被放到 unsorted bin 中
- 再次free chunk1
</code></pre>
<p><strong>结果</strong></p>
<p>​	现在 fastbin 和 unsortedbin 中都放着 p1 的指针，所以我们可以 malloc 两次都到 p1: 0xbba010 0xbba010，任意地址读写</p>
<h2 id="Unsafe-Unlink"><a href="#Unsafe-Unlink" class="headerlink" title="Unsafe_Unlink"></a>Unsafe_Unlink</h2><p><strong>原理</strong></p>
<figure class="highlight xl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xl">当你在已知位置有指向某个区域的指针时，可以调用 unlink<br>最常见的情况是易受攻击的缓冲区，可能会溢出并具有全局指针<br>本练习的重点是使用 free 破坏全局 chunk0_ptr 来实现任意内存写入<br><br>全局变量 chunk0_ptr 在 <span class="hljs-number">0</span>x6020d0, 指向 <span class="hljs-number">0</span>x161e010<br>我们想要破坏的 chunk 在 <span class="hljs-number">0</span>x161e0a0<br>在 chunk0 那里伪造一个 chunk<br>我们设置 <span class="hljs-function"><span class="hljs-title">fake</span> chunk 的 'next_free_chunk' (也就是 fd) 指向 &amp;chunk0_ptr 使得 P-&gt;</span><span class="hljs-function"><span class="hljs-title">fd</span>-&gt;</span>bk = P.<br>我们设置 <span class="hljs-function"><span class="hljs-title">fake</span> chunk 的 'previous_free_chunk' (也就是 bk) 指向 &amp;chunk0_ptr 使得 P-&gt;</span><span class="hljs-function"><span class="hljs-title">bk</span>-&gt;</span>fd = P.<br>通过上面的设置可以绕过检查: (P-&gt;<span class="hljs-function"><span class="hljs-title">fd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">bk</span> != P || P-&gt;</span><span class="hljs-function"><span class="hljs-title">bk</span>-&gt;</span>fd != P) == False<br>Fake chunk 的 fd: <span class="hljs-number">0</span>x6020b8<br>Fake chunk 的 bk: <span class="hljs-number">0</span>x6020c0<br><br>现在假设 chunk0 中存在一个溢出漏洞，可以更改 chunk1 的数据<br>通过修改 chunk1 中 prev_size 的大小使得 chunk1 在 free 的时候误以为 前面的 free chunk 是从我们伪造的 free chunk 开始的<br>如果正常的 free chunk0 的话 chunk1 的 prev_size 应该是 <span class="hljs-number">0</span>x90 但现在被改成了 <span class="hljs-number">0</span>x80<br>接下来通过把 chunk1 的 prev_inuse 改成 <span class="hljs-number">0</span> 来把伪造的堆块标记为空闲的堆块<br><br>现在释放掉 chunk1，会触发 unlink，合并两个 free chunk<br>此时，我们可以用 chunk0_ptr 覆盖自身以指向任意位置<br>chunk0_ptr 现在指向我们想要的位置，我们用它来覆盖我们的 victim string。<br>之前的值是: Hello!~<br>新的值是: BBBBAAAA<br><br></code></pre></td></tr></tbody></table></figure>

<p><strong>操作</strong></p>
<p>​	fd = goal - 0x18 </p>
<p>​	bk = goal - 0x10</p>
<p><strong>结果</strong></p>
<p>任意地址写</p>
<h2 id="house-of-spirit"><a href="#house-of-spirit" class="headerlink" title="house_of_spirit"></a>house_of_spirit</h2><p><strong>原理</strong></p>
<figure class="highlight dns"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dns">这个例子演示了 house of spirit 攻击<br>我们将构造一个 fake chunk 然后释放掉它，这样再次申请的时候就会申请到它<br>覆盖一个指向 fastbin 的指针<br>这块区域 (长度为: <span class="hljs-number">80</span>) 包含两个 chunk. 第一个在 <span class="hljs-number">0</span>x7fff<span class="hljs-number">5f0e7268</span> 第二个在 <span class="hljs-number">0</span>x7fff<span class="hljs-number">5f0e72a8</span>.<br>构造 fake chunk 的 size，要比 chunk 大 <span class="hljs-number">0</span>x10（因为 chunk 头），同时还要保证属于 fastbin，对于 fastbin 来说 prev_inuse 不会改变，但是其他两个位需要注意都要位 <span class="hljs-number">0</span><br>next chunk 的大小也要注意，要大于 <span class="hljs-number">0</span>x10 小于 av-&gt;system_mem（<span class="hljs-number">128</span>kb）<br>现在，我们拿伪造的那个 fake chunk 的地址进行 free, <span class="hljs-number">0</span>x7fff<span class="hljs-number">5f0e7270</span>.<br>free!<br>现在 malloc 的时候将会把 <span class="hljs-number">0</span>x7fff<span class="hljs-number">5f0e7270</span> 给返回回来<br>malloc(<span class="hljs-number">0</span>x30): <span class="hljs-number">0</span>x7fff<span class="hljs-number">5f0e7270</span><br>Finish!<br><br></code></pre></td></tr></tbody></table></figure>

<p><strong>操作</strong></p>
<p>构造fake fastbin chunk，free掉这个chunk，再次申请可以拿回这个chunk</p>
<p>前提有一个可控的指针</p>
<p><strong>结果</strong></p>
<p>任意地址写，前提有可控指针</p>
<h2 id="Posion-null-byte"><a href="#Posion-null-byte" class="headerlink" title="Posion_null_byte"></a>Posion_null_byte</h2><p><strong>原理</strong></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c">当存在 off by null 的时候可以使用该技术<br>申请 <span class="hljs-number">0x100</span> 的 chunk a<br>a 在: <span class="hljs-number">0x1eb2010</span><br>因为我们想要溢出 chunk a，所以需要知道他的实际大小: <span class="hljs-number">0x108</span><br>b: <span class="hljs-number">0x1eb2120</span><br>c: <span class="hljs-number">0x1eb2330</span><br>另外再申请了一个 chunk c：<span class="hljs-number">0x1eb2440</span>，防止 <span class="hljs-built_in">free</span> 的时候与 top chunk 发生合并的情况<br>会检查 chunk size 与 next chunk 的 prev_size 是否相等，所以要在后面一个 <span class="hljs-number">0x200</span> 来绕过检查<br>b 的 size: <span class="hljs-number">0x211</span><br>假设我们写 chunk a 的时候多写了一个 <span class="hljs-number">0x00</span> 在 b 的 size 的 p 位上<br>b 现在的 size: <span class="hljs-number">0x200</span><br>c 的 prev_size 是 <span class="hljs-number">0x210</span><br>但他根据 chunk b 的 size 找的时候会找到 b+<span class="hljs-number">0x1f0</span> 那里，我们将会成功绕过 chunk 的检测 chunksize(P) == <span class="hljs-number">0x200</span> == <span class="hljs-number">0x200</span> == prev_size (next_chunk(P))<br>申请一个 <span class="hljs-number">0x100</span> 大小的 b1: <span class="hljs-number">0x1eb2120</span><br>现在我们 <span class="hljs-built_in">malloc</span> 了 b1 他将会放在 b 的位置，这时候 c 的 prev_size 依然是: <span class="hljs-number">0x210</span><br>但是我们之前写 <span class="hljs-number">0x200</span> 那个地方已经改成了: f0<br>接下来 <span class="hljs-built_in">malloc</span> <span class="hljs-string">'b2'</span>, 作为 <span class="hljs-string">'victim'</span> chunk.<br>b2 申请在: <span class="hljs-number">0x1eb2230</span><br>现在 b2 填充的内容是:<br>BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB<br>现在对 b1 和 c 进行 <span class="hljs-built_in">free</span> 因为 c 的 prev_size 是 <span class="hljs-number">0x210</span>，所以会把他俩给合并，但是这时候里面还包含 b2 呐.<br>这时候我们申请一个 <span class="hljs-number">0x300</span> 大小的 chunk 就可以覆盖着 b2 了<br>d 申请到了: <span class="hljs-number">0x1eb2120</span>，我们填充一下 d 为 <span class="hljs-string">"D"</span><br>现在 b2 的内容就是:<br>DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD<br></code></pre></td></tr></tbody></table></figure>

<p><strong>操作</strong></p>
<ul>
<li>申请0x100大小的chunk a，0x200大小的chunk b，chunk c 防合并</li>
<li>free b</li>
<li>通过off-by-one覆写chunk b的size从0x211-&gt;0x200 </li>
<li>chunk b中b+0x1f0的位置放prev_size = 0x200 我们将会成功绕过 chunk 的检测 chunksize(P) == 0x200 == 0x200 == prev_size (next_chunk(P))</li>
<li>申请一个0x100的b1，b1会放到b的位置，c的prev_size仍然是0x210，但是我们之前写 0x200 那个地方已经改成了: f0</li>
<li>申请b2，作为 ‘victim’ chunk </li>
<li>free b1 和 c，由于c的prev_size是0x210，会合并b1和c，此时b2仍在</li>
</ul>
<p><strong>结果</strong></p>
<p>在一个大的free堆块中存在一个未被free的堆块</p>
<h2 id="House-of-lore"><a href="#House-of-lore" class="headerlink" title="House_of_lore"></a>House_of_lore</h2><p><strong>原理</strong></p>
<figure class="highlight mipsasm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">定义了两个数组stack_buffer_1 在 <span class="hljs-number">0x7ffc7a946070</span><br>stack_buffer_2 在 <span class="hljs-number">0x7ffc7a946050</span><br>申请第一块属于 fastbin 的 chunk 在 <span class="hljs-number">0x211c010</span><br>在栈上伪造一块 fake chunk<br>设置 fd 指针指向 victim chunk，来绕过 small <span class="hljs-keyword">bin </span>的检查，这样的话就能把堆栈地址放在到 small <span class="hljs-keyword">bin </span>的列表上<br>设置 stack_buffer_1 的 <span class="hljs-keyword">bk </span>指针指向 stack_buffer_2，设置 stack_buffer_2 的 fd 指针指向 stack_buffer_1 来绕过最后一个 malloc 中 small <span class="hljs-keyword">bin </span>corrupted, 返回指向栈上假块的指针另外再分配一块，避免与 top chunk 合并 <span class="hljs-number">0x211c080</span><br>Free victim chunk <span class="hljs-number">0x211c010</span>, 他会被插入到 fastbin 中<br><br>此时 victim chunk 的 fd、<span class="hljs-keyword">bk </span>为零<br>victim-&gt;fd: (nil)<br>victim-&gt;<span class="hljs-keyword">bk: </span>(nil)<br><br>这时候去申请一个 chunk，触发 fastbin 的合并使得 victim 进去 unsortedbin 中处理，最终被整理到 small <span class="hljs-keyword">bin </span>中 <span class="hljs-number">0x211c010</span><br>现在 victim chunk 的 fd 和 <span class="hljs-keyword">bk </span>更新为 unsorted <span class="hljs-keyword">bin </span>的地址<br>victim-&gt;fd: <span class="hljs-number">0x7f6610ee7bd8</span><br>victim-&gt;<span class="hljs-keyword">bk: </span><span class="hljs-number">0x7f6610ee7bd8</span><br><br>现在模拟一个可以覆盖 victim 的 <span class="hljs-keyword">bk </span>指针的漏洞，让他的 <span class="hljs-keyword">bk </span>指针指向栈上<br>然后申请跟第一个 chunk 大小一样的 chunk<br>他应该会返回 victim chunk 并且它的 <span class="hljs-keyword">bk </span>为修改掉的 victim 的 <span class="hljs-keyword">bk</span><br><span class="hljs-keyword"></span>最后 malloc 一次会返回 victim-&gt;<span class="hljs-keyword">bk </span>指向的那里<br>p4 = malloc(<span class="hljs-number">100</span>)<br><br>在最后一个 malloc 之后，stack_buffer_2 的 fd 指针已更改 <span class="hljs-number">0x7f6610ee7bd8</span><br><br>p4 在栈上 <span class="hljs-number">0x7ffc7a946080</span><br><br></code></pre></td></tr></tbody></table></figure>

<p><strong>操作</strong></p>
<ul>
<li>在栈上定义了两个数组 stack1，stack2</li>
<li>申请了一块 fastbin chunk，在栈上伪造一块 fake chunk，设置stack1 fd -&gt; victim chunk，绕过small bin检查</li>
<li>设置 stack_buffer_1 的 bk 指针指向 stack_buffer_2 &amp; 设置 stack_buffer_2 的 fd 指针指向 stack_buffer_1 </li>
<li>再分配个chunk，避免和top chunk 合并</li>
<li>free victim chunk，会被放入fastbin中同时fd、bk为0</li>
<li>再申请一个large bin chunk触发xx使得victim chunk 进入 unsortedbin</li>
<li>fd 和 bk 被更新为main_arena_88</li>
<li>存在一个漏洞可以使得victim的bk -&gt; stack 1</li>
<li>申请一个大小相同的chunk取出victim chunk,并且它的bk为修改掉的victim的bk</li>
<li>再次malloc一次会返回 victim -&gt; bk 指向的那里，也就是stack1，stack2 fd 指针也更改main_arena_88</li>
</ul>
<p><strong>结果</strong></p>
<p>任意地址malloc</p>
<h2 id="Overlapping-chunks"><a href="#Overlapping-chunks" class="headerlink" title="Overlapping_chunks"></a>Overlapping_chunks</h2><p><strong>原理</strong></p>
<figure class="highlight smali"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs smali">这是一个简单的堆块重叠问题，首先申请 3 个 chunk<br>这三个 chunk 分别申请到了:<br>p1：0x2088010<br>p2：0x2088110<br>p3：0x2088210<br>给他们分别填充<span class="hljs-string">"1"</span><span class="hljs-string">"2"</span><span class="hljs-string">"3"</span><br><br>free 掉 p2<br>p2 被放到 unsorted bin 中<br>现在假设有一个堆溢出漏洞，可以覆盖 p2<br>为了保证堆块稳定性，我们至少需要让 prev_inuse 为 1，确保 p1 不会被认为是空闲的堆块<br>我们将 p2 的大小设置为 385, 这样的话我们就能用 376 大小的空间<br><br>现在让我们分配另一个块，其大小等于块p2注入大小的数据大小<br>malloc 将会把前面 free 的 p2 分配给我们（p2 的 size 已经被改掉了）<br><br>p4 分配在 0x2088110 到 0x2088288 这一区域<br>p3 从 0x2088210 到 0x2088288<br>p4 应该与 p3 重叠，在这种情况下 p4 包括所有 p3<br>这时候通过编辑 p4 就可以修改 p3 的内容，修改 p3 也可以修改 p4 的内容<br><br>接下来验证一下，现在 p3 与 p4:<br>p4 = 22222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222<br>p3 = 3333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333�<br><br>如果我们使用 memset(p4, '4', 376), 将会:<br>p4 = 44444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444�<br>p3 = 4444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444�<br><br></code></pre></td></tr></tbody></table></figure>



<p><strong>操作</strong></p>
<ul>
<li>申请三个堆块大小为0xf8，0xf8，0x78</li>
<li>free p2，p2被放到 unsorted bin 中</li>
<li>假设存在一个堆溢出漏洞，可以覆盖p2</li>
</ul>
<p><strong>结果</strong></p>
<p>堆块重叠</p>
<h2 id="Overlapping-chunks-2"><a href="#Overlapping-chunks-2" class="headerlink" title="Overlapping_chunks_2"></a>Overlapping_chunks_2</h2><p><strong>原理</strong></p>
<p><strong>操作</strong></p>
<p><strong>结果</strong></p>
<h2 id="Mmap-overlapping-chunks"><a href="#Mmap-overlapping-chunks" class="headerlink" title="Mmap_overlapping_chunks"></a>Mmap_overlapping_chunks</h2><p><strong>原理</strong></p>
<p><strong>操作</strong></p>
<p><strong>结果</strong></p>
<h2 id="Unsorted-bin-attack"><a href="#Unsorted-bin-attack" class="headerlink" title="Unsorted_bin_attack"></a>Unsorted_bin_attack</h2><p><strong>原理</strong></p>
<figure class="highlight mipsasm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">unsorted <span class="hljs-keyword">bin </span>attack 实现了把一个超级大的数（unsorted <span class="hljs-keyword">bin </span>的地址）写到一个地方<br>实际上这种攻击方法常常用来修改 global_max_fast 来为进一步的 fastbin attack 做准备<br><br>我们准备把这个地方 <span class="hljs-number">0x7ffe5b09ba18</span> 的值 <span class="hljs-number">0</span> 更改为一个很大的数<br><br>一开始先申请一个比较正常的 chunk: <span class="hljs-number">0x14fe010</span><br>再分配一个避免与 top chunk 合并<br><br>当我们释放掉第一个 chunk 之后他会被放到 unsorted <span class="hljs-keyword">bin </span>中，同时它的 <span class="hljs-keyword">bk </span>指针为 <span class="hljs-number">0x7efe12f93b78</span><br>现在假设有个漏洞，可以让我们修改 free 了的 chunk 的 <span class="hljs-keyword">bk </span>指针<br>我们把目标地址（想要改为超大值的那个地方）减去 <span class="hljs-number">0x10</span> 写到 <span class="hljs-keyword">bk </span>指针:<span class="hljs-number">0x7ffe5b09ba08</span><br><br>再去 malloc 的时候可以发现那里的值已经改变为 unsorted <span class="hljs-keyword">bin </span>的地址<br><span class="hljs-number">0x7ffe5b09ba18</span>: <span class="hljs-number">0x7efe12f93b78</span><br><br></code></pre></td></tr></tbody></table></figure>



<p><strong>操作</strong></p>
<ul>
<li>申请一个chunk p1 (0x410)，再申请一个chunk p2避免与top chunk 合并</li>
<li>free p1，p1会被放入 unsorted bin 中，同时fd 和 bk指针为main_arena_88</li>
<li>假设有个漏洞，可以修改p1的bk指针</li>
<li>修改 bk -&gt; (goal - 0x10)</li>
<li>再malloc相同大小的chunk p，goal已经为unsorted bin 的地址</li>
</ul>
<p><strong>结果</strong></p>
<p>修改任意位置为 一个很大的数</p>
<h2 id="Large-bin-attack"><a href="#Large-bin-attack" class="headerlink" title="Large_bin_attack"></a>Large_bin_attack</h2><p><strong>原理</strong></p>
<figure class="highlight x86asm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">跟 unsorted bin attack 实现的功能差不多，都是把一个地址的值改为一个很大的数<br><br>先来看一下目标:<br>stack_var1 (<span class="hljs-number">0x7fff83c2e410</span>): <span class="hljs-number">0</span><br>stack_var2 (<span class="hljs-number">0x7fff83c2e418</span>): <span class="hljs-number">0</span><br><br>分配第一个 large chunk: <span class="hljs-number">0x6ac000</span><br>再分配一个 fastbin 大小的 chunk，来避免 free 的时候下一个 large chunk 与第一个合并了<br><br>申请第二个 large chunk 在: <span class="hljs-number">0x6ac360</span><br>同样在分配一个 fastbin 大小的 chunk 防止合并掉<br><br>最后申请第三个 large chunk 在: <span class="hljs-number">0x6ac7a0</span><br>申请一个 fastbin 大小的防止 free 的时候第三个 large chunk 与 top chunk 合并<br><br>free 掉第一个和第二个 chunk，他们会被放在 unsorted bin 中 [ <span class="hljs-number">0x6ac360</span> &lt;--&gt; <span class="hljs-number">0x6ac000</span> ]<br><br>现在去申请一个比他俩小的，然后会把第一个分割出来，第二个则被整理到 largebin 中，第一个剩下的会放回到 unsortedbin 中 [ <span class="hljs-number">0x6ac0a0</span> ]<br><br>free 掉第三个，他会被放到 unsorted bin 中: [ <span class="hljs-number">0x6ac7a0</span> &lt;--&gt; <span class="hljs-number">0x6ac0a0</span> ]<br><br>假设有个漏洞，可以覆盖掉第二个 chunk 的 <span class="hljs-string">"size"</span> 以及 <span class="hljs-string">"bk"</span>、<span class="hljs-string">"bk_nextsize"</span> 指针<br>减少释放的第二个 chunk 的大小强制 malloc 把将要释放的第三个 large chunk 插入到 largebin 列表的头部（largebin 会按照大小排序）。覆盖掉栈变量。覆盖 bk 为 stack_var1-<span class="hljs-number">0x10</span>，bk_nextsize 为 stack_var2-<span class="hljs-number">0x20</span><br><br>再次 malloc，会把释放的第三个 chunk 插入到 largebin 中，同时我们的目标已经改写了:<br>stack_var1 (<span class="hljs-number">0x7fff83c2e410</span>): <span class="hljs-number">0x6ac7a0</span><br>stack_var2 (<span class="hljs-number">0x7fff83c2e418</span>): <span class="hljs-number">0x6ac7a0</span><br><br></code></pre></td></tr></tbody></table></figure>



<p><strong>操作</strong></p>
<ul>
<li>分配第一个large bin chunk，再申请一个fast bin chunk 隔绝，避免和下一个large bin chunk合并</li>
<li>分配第二个large bin chunk，再申请一个fast bin chunk 隔绝，避免和下一个large bin chunk合并</li>
<li>分配第三个large bin chunk，再申请一个fast bin chunk 隔绝，避免和下一个large bin chunk合并</li>
<li>free chunk1 和 chunk2  均被放入unsorted bin 中</li>
<li>现在去申请一个比他俩小的，然后会把第一个分割出来，第二个则被整理到 largebin 中，第一个剩下的会放回到 unsortedbin 中</li>
<li>free chunk3 放到unsorted bin 中</li>
<li>存在漏洞，可以覆盖掉第二个chunk 的size bk bk_nextsize</li>
<li>减少释放的第二个 chunk 的大小强制 malloc 把将要释放的第三个 large chunk 插入到 largebin 列表的头部（largebin 会按照大小排序）。覆盖掉栈变量。覆盖 bk 为 stack_var1-0x1</li>
<li>再次 malloc，会把释放的第三个 chunk 插入到 largebin 中，同时我们的目标已经改写了</li>
</ul>
<p><strong>结果</strong></p>
<p>​	栈上地址被覆盖</p>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2023/11/07/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91%E5%AE%9E%E9%AA%8C2%EF%BC%9ARecycleView/">← 下一篇 移动开发实验2：RecycleView和Activity跳转</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2023/10/31/%E7%AE%97%E6%B3%95%E4%B8%8E%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E9%AA%8C/">算法与程序设计实验 上一篇 →</a></div></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="回到顶部" style="opacity: 0; display: none;">∧ </a><a class="i-index" id="to-index" href="#toc-div" title="文章目录">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="切换主题"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><h1 id="Dr"><a href="/">Kylinxin</a></h1><div id="description"><p>当你觉得生活都不顺心如意的时候，来学习pwn吧！</p></div></div><div id="aside-block"><div id="toc-div"><h1>目录</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#First-fit"><span class="toc-number">1.</span> <span class="toc-text">First fit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UAF"><span class="toc-number">2.</span> <span class="toc-text">UAF</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Double-Free"><span class="toc-number">3.</span> <span class="toc-text">Double Free</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fastbin-dup-into-stack-%E2%80%93-Double-free"><span class="toc-number">4.</span> <span class="toc-text">Fastbin_dup_into_stack – Double free</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fastbin-dup-consolidate"><span class="toc-number">5.</span> <span class="toc-text">Fastbin_dup_consolidate</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unsafe-Unlink"><span class="toc-number">6.</span> <span class="toc-text">Unsafe_Unlink</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#house-of-spirit"><span class="toc-number">7.</span> <span class="toc-text">house_of_spirit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Posion-null-byte"><span class="toc-number">8.</span> <span class="toc-text">Posion_null_byte</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#House-of-lore"><span class="toc-number">9.</span> <span class="toc-text">House_of_lore</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Overlapping-chunks"><span class="toc-number">10.</span> <span class="toc-text">Overlapping_chunks</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Overlapping-chunks-2"><span class="toc-number">11.</span> <span class="toc-text">Overlapping_chunks_2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mmap-overlapping-chunks"><span class="toc-number">12.</span> <span class="toc-text">Mmap_overlapping_chunks</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unsorted-bin-attack"><span class="toc-number">13.</span> <span class="toc-text">Unsorted_bin_attack</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Large-bin-attack"><span class="toc-number">14.</span> <span class="toc-text">Large_bin_attack</span></a></li></ol></div></div><footer><nobr>构建自 <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> 使用主题 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr> 主题作者 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script src="/js/arknights.js"></script><script src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script src="/js/pjax.js"></script><script class="pjax-js">reset= () => {document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script></body></html>