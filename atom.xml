<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ky不是枕木</title>
  
  <subtitle>分享学习经验</subtitle>
  <link href="https://kylinxin.github.io/atom.xml" rel="self"/>
  
  <link href="https://kylinxin.github.io/"/>
  <updated>2023-04-07T12:44:57.790Z</updated>
  <id>https://kylinxin.github.io/</id>
  
  <author>
    <name>枕木</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://kylinxin.github.io/2023/04/08/BBC/"/>
    <id>https://kylinxin.github.io/2023/04/08/BBC/</id>
    <published>2023-04-08T15:59:16.148Z</published>
    <updated>2023-04-07T12:44:57.790Z</updated>
    
    <content type="html"><![CDATA[<h1 id="救赎"><a href="#救赎" class="headerlink" title="救赎"></a>救赎</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="1-欧几里得辗转相除法-求解-最大公约数-最小公倍数"><a href="#1-欧几里得辗转相除法-求解-最大公约数-最小公倍数" class="headerlink" title="1.欧几里得辗转相除法 求解 最大公约数 最小公倍数"></a>1.欧几里得辗转相除法 求解 最大公约数 最小公倍数</h3><pre><code class="c++">int gcd(int a, int b){return b == 0 ? a : gcd(b, a % b);}int lcm(int a, int b){return a / gcd(a, b) * b;}</code></pre><h3 id="2-求质数"><a href="#2-求质数" class="headerlink" title="2.求质数"></a>2.求质数</h3><pre><code class="c++">/* 判断素数 */bool isPrime(LL n) {    for (int i = 2; i * i &lt;= n; ++i)        if (n % i == 0)            return false;    return true;}</code></pre><h3 id="3-栈"><a href="#3-栈" class="headerlink" title="3.栈"></a>3.栈</h3><pre><code class="c++">#include &lt;stack&gt;stack&lt;类型&gt; mystack;s.empty();         //如果栈为空则返回true, 否则返回false;s.size();          //返回栈中元素的个数s.top();           //返回栈顶元素, 但不删除该元素s.pop();           //弹出栈顶元素, 但不返回其值s.push();          //将元素压入栈顶</code></pre><h3 id="4-队列"><a href="#4-队列" class="headerlink" title="4.队列"></a>4.队列</h3><pre><code class="c++">#include &lt;queue&gt;queue&lt;类型&gt; myqueue;push() //在队尾插入一个元素pop() //删除队列第一个元素size() //返回队列中元素个数empty() //如果队列空则返回truefront() //返回队列中的第一个元素back() //返回队列中最后一个元素</code></pre><h3 id="5-DFS-深度优先"><a href="#5-DFS-深度优先" class="headerlink" title="5.DFS(深度优先)"></a>5.DFS(深度优先)</h3><pre><code class="c++">int dx[4] = {0,0,-1,1};int dy[4] = {-1,1,0,0};int mp[N][N];//存放迷宫int vis[N][N];//表示是否访问过，初始为flasevoid DFS(int x, int y)//x,y是坐标点的位置 {    if(vis[x][y] || (x==n &amp;&amp; y==n)) return; //表示已经访问过了或者到达终点,递归的出口    vis[x][y] = true; //表示没有访问过，现在正在访问，置为访问过    for(int i=0; i &lt; 4; i++){//遍历四个方向，顺序依次是，上下左右        int nx = x + dx[i];        int ny = y + dy[i];      //进行了合法性检验，      //1.首先判断了该点是否越界，即是否在迷宫内  nx &gt; 0 &amp;&amp; nx &lt;= n &amp;&amp; ny &gt; 0 &amp;&amp; ny &lt;= n      //2.然后判断是否访问过  !vis[nx][ny] 未访问过就继续      //3.最后判断是否为路  mp[nx][ny] == '0' 为路就继续        if(nx &gt; 0 &amp;&amp; nx &lt;= n &amp;&amp; ny &gt; 0 &amp;&amp; ny &lt;= n &amp;&amp; !vis[nx][ny] &amp;&amp; mp[nx][ny] == '0')            dfs(nx,ny);    } }//注意!! 应该判断一下起点是否可走</code></pre><h3 id="6-BFS-广度优先搜索"><a href="#6-BFS-广度优先搜索" class="headerlink" title="6.BFS(广度优先搜索)"></a>6.BFS(广度优先搜索)</h3><pre><code class="c++">int X[4]={0, 0, -1, 1};int Y[4]={-1, 1, 0, 0};int matrix[N][N]; //存储迷宫信息int vis[N][N];//存储每个状态点是否走过struct node{    int x;    int y;}Node, top;bool judge(int xx, int yy){    if(xx&lt;0||yy&lt;0||xx&gt;=N||yy&gt;=N) //注意边界        return false;    if(vis[xx][yy]==true||matrix[xx][yy]==0)//下一个点走过或者为墙 0不能走，1能走        return false;    return true;}void BFS(int x, int y){    queue&lt;node&gt; q;    Node.x=x;    Node.y=y;    q.push(Node);//将起点入队列    while(!q.empty())//队列不空就扩散    {        top=q.front();//取出队首元素        int nx=top.x;        int ny=top.y;//从四个方面机进行扩散         if(nx == ex &amp;&amp; ny == ey) //找到终点             return top;        for(int i=0; i&lt;4; i++)        {            if(judge(nx+X[i], ny+Y[i])) //检查四个方向，如果有路就进队列            {                Node.x=nx+X[i];                Node.y=ny+Y[i];                q.push(Node);            }        }        ans++;//计数器        vis[nx][ny]=true;        q.pop();//表示这个点的邻接点已经全部入队列，丢弃这个点    }}</code></pre><h3 id="7-二分模板"><a href="#7-二分模板" class="headerlink" title="7.二分模板"></a>7.二分模板</h3><pre><code class="c++">/*    作者:FengBOOOOOOOOOOOOOOO    二分模板返回大于x的第一个位置    */#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 1005using namespace std;int a[N],n,q;int find(int l,int r,int key)//l为-1，r为数组长度{    while(l + 1 &lt; r)    {        int mid = l + r&gt;&gt;1;        if(a[mid] &lt;= key)        　　l = mid;        else        　　r = mid;    }    return r;//返回大于Key的第一个位置}int main(){    int k;    scanf("%d%d",&amp;n,&amp;q);    for(int i = 0; i &lt; n; ++i)    　　scanf("%d",&amp;a[i]);    for(int i = 0; i &lt; q; ++i)    {        scanf("%d",&amp;k);        printf("%d\n",find(-1,n,k));    }} </code></pre><h2 id="最短路径问题"><a href="#最短路径问题" class="headerlink" title="最短路径问题"></a>最短路径问题</h2><h3 id="1-SPFA最短路径-类似与BFS"><a href="#1-SPFA最短路径-类似与BFS" class="headerlink" title="1.SPFA最短路径(类似与BFS)"></a>1.SPFA最短路径(类似与BFS)</h3><pre><code class="c++">#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#define ll long long#define inf 0x3f3f3f3f#define pii pair&lt;int, int&gt;const int mod = 1e9+7;const int maxn = 2e5+7;using namespace std;struct node {int to,w,next;} edge[maxn];int head[maxn], cnt;int dis[maxn], vis[maxn];int n, m, s, t;struct Spfa{    void init()    {        memset(head,-1,sizeof(head));        memset(dis,0x3f3f3f3f,sizeof(dis));        memset(vis,0,sizeof(vis));        cnt = 0;    }     void add(int u,int v,int w)    {        edge[cnt].to = v;        edge[cnt].w = w;        edge[cnt].next = head[u];        head[u] = cnt ++;    }     void spfa()    {        dis[s] = 0; vis[s] = 1;        queue &lt;int&gt; Q; Q.push(s);        while(!Q.empty())        {            int now = Q.front();            Q.pop(); vis[now] = 0;    //从队列中弹出now , vis[now] 标记为未访问            for(int i = head[now]; i != -1; i = edge[i].next)            {                int v = edge[i].to;                if(dis[v] &lt; dis[now] + edge[i].w)                {                    dis[v] = dis[now] + edge[i].w;                    if(vis[v]) continue;    //如果访问过了(也就是 已经在队列中),就不用再push                    vis[v] = 1; Q.push(v);                }            }        }    }}sp; int main(){    while(~scanf("%d%d",&amp;n,&amp;m) &amp;&amp; n+m)    {        sp.init();        for(int i = 0; i &lt; m; i++)        {            int u, v, w;            scanf("%d%d%d",&amp;u, &amp;v, &amp;w);            sp.add(u, v, w);            sp.add(v, u, w);        }        s = 1, t = n; //s起点，t终点        sp.spfa();        printf("%d\n", dis[t]);    }}</code></pre><h3 id="2-Dijkstra"><a href="#2-Dijkstra" class="headerlink" title="2.Dijkstra"></a>2.Dijkstra</h3><pre><code class="c++">//主要思想一个大循环+两个小循环void dijkstra(){    int u, minx;    book[S] = 1;    for(int i = 0; i &lt; N; i++){    //dist[]数组初始化，把起始结点S到i结点的距离赋值给diat[i]        dist[i] = v[S][i];    }    for(int i = 0; i &lt; N; i++){//大循环        minx = INT_MAX;        for(int j = 0; j &lt; N; j++){//寻找没有被标记并且最短的路径，并记录此结点             if(!book[j] &amp;&amp; minx &gt; dist[j]){                minx = dist[j];                u = j;            }         }        book[u] = 1;        for(int k = 0; k &lt; N; k++){        //如果A到B的距离大于A到C的距离加C到B的距离，那么更新数据            if(!book[k] &amp;&amp; dist[k] &gt; dist[u]+v[u][k]){                dist[k] = dist[u]+v[u][k];            }        }    }}</code></pre><h3 id="3-Floyd"><a href="#3-Floyd" class="headerlink" title="3.Floyd"></a>3.Floyd</h3><pre><code class="c++">//初始化：    for (int i = 1; i &lt;= n; i ++ )        for (int j = 1; j &lt;= n; j ++ )            if (i == j) d[i][j] = 0;            else d[i][j] = INF;// 算法结束后，d[a][b]表示a到b的最短距离void floyd(){    for (int k = 1; k &lt;= n; k ++ )        for (int i = 1; i &lt;= n; i ++ )            for (int j = 1; j &lt;= n; j ++ )                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);}</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;救赎&quot;&gt;&lt;a href=&quot;#救赎&quot; class=&quot;headerlink&quot; title=&quot;救赎&quot;&gt;&lt;/a&gt;救赎&lt;/h1&gt;&lt;h2 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;headerlink&quot; title=&quot;基础知识&quot;&gt;&lt;/a&gt;基础知识&lt;/h</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>My New Post</title>
    <link href="https://kylinxin.github.io/2023/04/08/My-New-Post/"/>
    <id>https://kylinxin.github.io/2023/04/08/My-New-Post/</id>
    <published>2023-04-08T15:58:02.000Z</published>
    <updated>2023-04-08T15:58:27.066Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://kylinxin.github.io/2023/04/08/hello-world/"/>
    <id>https://kylinxin.github.io/2023/04/08/hello-world/</id>
    <published>2023-04-08T15:01:54.527Z</published>
    <updated>2023-04-08T15:01:54.528Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new "My New Post"</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
