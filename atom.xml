<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kyのblog</title>
  
  <subtitle>分享学习经验</subtitle>
  <link href="https://kylinxin.github.io/atom.xml" rel="self"/>
  
  <link href="https://kylinxin.github.io/"/>
  <updated>2023-04-07T12:44:57.790Z</updated>
  <id>https://kylinxin.github.io/</id>
  
  <author>
    <name>枕木</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://kylinxin.github.io/2023/04/08/BBC/"/>
    <id>https://kylinxin.github.io/2023/04/08/BBC/</id>
    <published>2023-04-08T15:59:16.148Z</published>
    <updated>2023-04-07T12:44:57.790Z</updated>
    
    <content type="html"><![CDATA[<h1 id="救赎"><a href="#救赎" class="headerlink" title="救赎"></a>救赎</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="1-欧几里得辗转相除法-求解-最大公约数-最小公倍数"><a href="#1-欧几里得辗转相除法-求解-最大公约数-最小公倍数" class="headerlink" title="1.欧几里得辗转相除法 求解 最大公约数 最小公倍数"></a>1.欧几里得辗转相除法 求解 最大公约数 最小公倍数</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>{<span class="keyword">return</span> b == <span class="number">0</span> ? a : <span class="built_in">gcd</span>(b, a % b);}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lcm</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>{<span class="keyword">return</span> a / <span class="built_in">gcd</span>(a, b) * b;}</span><br></pre></td></tr></tbody></table></figure><h3 id="2-求质数"><a href="#2-求质数" class="headerlink" title="2.求质数"></a>2.求质数</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 判断素数 */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPrime</span><span class="params">(LL n)</span> </span>{</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i * i &lt;= n; ++i)</span><br><span class="line"><span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="3-栈"><a href="#3-栈" class="headerlink" title="3.栈"></a>3.栈</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line">stack&lt;类型&gt; mystack;</span><br><span class="line">s.<span class="built_in">empty</span>();         <span class="comment">//如果栈为空则返回true, 否则返回false;</span></span><br><span class="line">s.<span class="built_in">size</span>();          <span class="comment">//返回栈中元素的个数</span></span><br><span class="line">s.<span class="built_in">top</span>();           <span class="comment">//返回栈顶元素, 但不删除该元素</span></span><br><span class="line">s.<span class="built_in">pop</span>();           <span class="comment">//弹出栈顶元素, 但不返回其值</span></span><br><span class="line">s.<span class="built_in">push</span>();          <span class="comment">//将元素压入栈顶</span></span><br></pre></td></tr></tbody></table></figure><h3 id="4-队列"><a href="#4-队列" class="headerlink" title="4.队列"></a>4.队列</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line">queue&lt;类型&gt; myqueue;</span><br><span class="line"><span class="built_in">push</span>() <span class="comment">//在队尾插入一个元素</span></span><br><span class="line"><span class="built_in">pop</span>() <span class="comment">//删除队列第一个元素</span></span><br><span class="line"><span class="built_in">size</span>() <span class="comment">//返回队列中元素个数</span></span><br><span class="line"><span class="built_in">empty</span>() <span class="comment">//如果队列空则返回true</span></span><br><span class="line"><span class="built_in">front</span>() <span class="comment">//返回队列中的第一个元素</span></span><br><span class="line"><span class="built_in">back</span>() <span class="comment">//返回队列中最后一个元素</span></span><br></pre></td></tr></tbody></table></figure><h3 id="5-DFS-深度优先"><a href="#5-DFS-深度优先" class="headerlink" title="5.DFS(深度优先)"></a>5.DFS(深度优先)</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = {<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>};</span><br><span class="line"><span class="type">int</span> dy[<span class="number">4</span>] = {<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>};</span><br><span class="line"><span class="type">int</span> mp[N][N];<span class="comment">//存放迷宫</span></span><br><span class="line"><span class="type">int</span> vis[N][N];<span class="comment">//表示是否访问过，初始为flase</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span><span class="comment">//x,y是坐标点的位置 </span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span>(vis[x][y] || (x==n &amp;&amp; y==n)) <span class="keyword">return</span>; <span class="comment">//表示已经访问过了或者到达终点,递归的出口</span></span><br><span class="line">vis[x][y] = <span class="literal">true</span>; <span class="comment">//表示没有访问过，现在正在访问，置为访问过</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i &lt; <span class="number">4</span>; i++){<span class="comment">//遍历四个方向，顺序依次是，上下左右</span></span><br><span class="line"><span class="type">int</span> nx = x + dx[i];</span><br><span class="line"><span class="type">int</span> ny = y + dy[i];</span><br><span class="line">      <span class="comment">//进行了合法性检验，</span></span><br><span class="line">      <span class="comment">//1.首先判断了该点是否越界，即是否在迷宫内  nx &gt; 0 &amp;&amp; nx &lt;= n &amp;&amp; ny &gt; 0 &amp;&amp; ny &lt;= n</span></span><br><span class="line">      <span class="comment">//2.然后判断是否访问过  !vis[nx][ny] 未访问过就继续</span></span><br><span class="line">      <span class="comment">//3.最后判断是否为路  mp[nx][ny] == '0' 为路就继续</span></span><br><span class="line"><span class="keyword">if</span>(nx &gt; <span class="number">0</span> &amp;&amp; nx &lt;= n &amp;&amp; ny &gt; <span class="number">0</span> &amp;&amp; ny &lt;= n &amp;&amp; !vis[nx][ny] &amp;&amp; mp[nx][ny] == <span class="string">'0'</span>)</span><br><span class="line"><span class="built_in">dfs</span>(nx,ny);</span><br><span class="line">} </span><br><span class="line">}</span><br><span class="line"><span class="comment">//注意!! 应该判断一下起点是否可走</span></span><br></pre></td></tr></tbody></table></figure><h3 id="6-BFS-广度优先搜索"><a href="#6-BFS-广度优先搜索" class="headerlink" title="6.BFS(广度优先搜索)"></a>6.BFS(广度优先搜索)</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> X[<span class="number">4</span>]={<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>};</span><br><span class="line"><span class="type">int</span> Y[<span class="number">4</span>]={<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>};</span><br><span class="line"><span class="type">int</span> matrix[N][N]; <span class="comment">//存储迷宫信息</span></span><br><span class="line"><span class="type">int</span> vis[N][N];<span class="comment">//存储每个状态点是否走过</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>{</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> y;</span><br><span class="line">}Node, top;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">judge</span><span class="params">(<span class="type">int</span> xx, <span class="type">int</span> yy)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span>(xx&lt;<span class="number">0</span>||yy&lt;<span class="number">0</span>||xx&gt;=N||yy&gt;=N) <span class="comment">//注意边界</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(vis[xx][yy]==<span class="literal">true</span>||matrix[xx][yy]==<span class="number">0</span>)<span class="comment">//下一个点走过或者为墙 0不能走，1能走</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">queue&lt;node&gt; q;</span><br><span class="line">Node.x=x;</span><br><span class="line">Node.y=y;</span><br><span class="line">q.<span class="built_in">push</span>(Node);<span class="comment">//将起点入队列</span></span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>())<span class="comment">//队列不空就扩散</span></span><br><span class="line">{</span><br><span class="line">top=q.<span class="built_in">front</span>();<span class="comment">//取出队首元素</span></span><br><span class="line"><span class="type">int</span> nx=top.x;</span><br><span class="line"><span class="type">int</span> ny=top.y;<span class="comment">//从四个方面机进行扩散</span></span><br><span class="line">         <span class="keyword">if</span>(nx == ex &amp;&amp; ny == ey) <span class="comment">//找到终点</span></span><br><span class="line">             <span class="keyword">return</span> top;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">judge</span>(nx+X[i], ny+Y[i])) <span class="comment">//检查四个方向，如果有路就进队列</span></span><br><span class="line">{</span><br><span class="line">Node.x=nx+X[i];</span><br><span class="line">Node.y=ny+Y[i];</span><br><span class="line">q.<span class="built_in">push</span>(Node);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">ans++;<span class="comment">//计数器</span></span><br><span class="line">vis[nx][ny]=<span class="literal">true</span>;</span><br><span class="line">q.<span class="built_in">pop</span>();<span class="comment">//表示这个点的邻接点已经全部入队列，丢弃这个点</span></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="7-二分模板"><a href="#7-二分模板" class="headerlink" title="7.二分模板"></a>7.二分模板</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    作者:FengBOOOOOOOOOOOOOOO</span></span><br><span class="line"><span class="comment">    二分模板返回大于x的第一个位置    </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N],n,q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> key)</span><span class="comment">//l为-1，r为数组长度</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">while</span>(l + <span class="number">1</span> &lt; r)</span><br><span class="line">    {</span><br><span class="line">        <span class="type">int</span> mid = l + r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid] &lt;= key)</span><br><span class="line">        　　l = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        　　r = mid;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> r;<span class="comment">//返回大于Key的第一个位置</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    　　<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; q; ++i)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="built_in">find</span>(<span class="number">-1</span>,n,k));</span><br><span class="line">    }</span><br><span class="line">} </span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="最短路径问题"><a href="#最短路径问题" class="headerlink" title="最短路径问题"></a>最短路径问题</h2><h3 id="1-SPFA最短路径-类似与BFS"><a href="#1-SPFA最短路径-类似与BFS" class="headerlink" title="1.SPFA最短路径(类似与BFS)"></a>1.SPFA最短路径(类似与BFS)</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">2e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> {<span class="type">int</span> to,w,next;} edge[maxn];</span><br><span class="line"><span class="type">int</span> head[maxn], cnt;</span><br><span class="line"><span class="type">int</span> dis[maxn], vis[maxn];</span><br><span class="line"><span class="type">int</span> n, m, s, t;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Spfa</span></span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="built_in">sizeof</span>(head));</span><br><span class="line">        <span class="built_in">memset</span>(dis,<span class="number">0x3f3f3f3f</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        edge[cnt].to = v;</span><br><span class="line">        edge[cnt].w = w;</span><br><span class="line">        edge[cnt].next = head[u];</span><br><span class="line">        head[u] = cnt ++;</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        dis[s] = <span class="number">0</span>; vis[s] = <span class="number">1</span>;</span><br><span class="line">        queue &lt;<span class="type">int</span>&gt; Q; Q.<span class="built_in">push</span>(s);</span><br><span class="line">        <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())</span><br><span class="line">        {</span><br><span class="line">            <span class="type">int</span> now = Q.<span class="built_in">front</span>();</span><br><span class="line">            Q.<span class="built_in">pop</span>(); vis[now] = <span class="number">0</span>;    <span class="comment">//从队列中弹出now , vis[now] 标记为未访问</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = head[now]; i != <span class="number">-1</span>; i = edge[i].next)</span><br><span class="line">            {</span><br><span class="line">                <span class="type">int</span> v = edge[i].to;</span><br><span class="line">                <span class="keyword">if</span>(dis[v] &lt; dis[now] + edge[i].w)</span><br><span class="line">                {</span><br><span class="line">                    dis[v] = dis[now] + edge[i].w;</span><br><span class="line">                    <span class="keyword">if</span>(vis[v]) <span class="keyword">continue</span>;    <span class="comment">//如果访问过了(也就是 已经在队列中),就不用再push</span></span><br><span class="line">                    vis[v] = <span class="number">1</span>; Q.<span class="built_in">push</span>(v);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}sp;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m) &amp;&amp; n+m)</span><br><span class="line">    {</span><br><span class="line">        sp.<span class="built_in">init</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        {</span><br><span class="line">            <span class="type">int</span> u, v, w;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;u, &amp;v, &amp;w);</span><br><span class="line">            sp.<span class="built_in">add</span>(u, v, w);</span><br><span class="line">            sp.<span class="built_in">add</span>(v, u, w);</span><br><span class="line">        }</span><br><span class="line">        s = <span class="number">1</span>, t = n; <span class="comment">//s起点，t终点</span></span><br><span class="line">        sp.<span class="built_in">spfa</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dis[t]);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="2-Dijkstra"><a href="#2-Dijkstra" class="headerlink" title="2.Dijkstra"></a>2.Dijkstra</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主要思想一个大循环+两个小循环</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">()</span></span>{</span><br><span class="line"><span class="type">int</span> u, minx;</span><br><span class="line">book[S] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++){</span><br><span class="line"><span class="comment">//dist[]数组初始化，把起始结点S到i结点的距离赋值给diat[i]</span></span><br><span class="line">dist[i] = v[S][i];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++){<span class="comment">//大循环</span></span><br><span class="line">minx = INT_MAX;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j++){<span class="comment">//寻找没有被标记并且最短的路径，并记录此结点 </span></span><br><span class="line"><span class="keyword">if</span>(!book[j] &amp;&amp; minx &gt; dist[j]){</span><br><span class="line">minx = dist[j];</span><br><span class="line">u = j;</span><br><span class="line">} </span><br><span class="line">}</span><br><span class="line">book[u] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; N; k++){</span><br><span class="line"><span class="comment">//如果A到B的距离大于A到C的距离加C到B的距离，那么更新数据</span></span><br><span class="line"><span class="keyword">if</span>(!book[k] &amp;&amp; dist[k] &gt; dist[u]+v[u][k]){</span><br><span class="line">dist[k] = dist[u]+v[u][k];</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="3-Floyd"><a href="#3-Floyd" class="headerlink" title="3.Floyd"></a>3.Floyd</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化：</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (i == j) d[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> d[i][j] = INF;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 算法结束后，d[a][b]表示a到b的最短距离</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">                d[i][j] = <span class="built_in">min</span>(d[i][j], d[i][k] + d[k][j]);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;救赎&quot;&gt;&lt;a href=&quot;#救赎&quot; class=&quot;headerlink&quot; title=&quot;救赎&quot;&gt;&lt;/a&gt;救赎&lt;/h1&gt;&lt;h2 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;headerlink&quot; title=&quot;基础知识&quot;&gt;&lt;/a&gt;基础知识&lt;/h</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>My New Post</title>
    <link href="https://kylinxin.github.io/2023/04/08/My-New-Post/"/>
    <id>https://kylinxin.github.io/2023/04/08/My-New-Post/</id>
    <published>2023-04-08T15:58:02.000Z</published>
    <updated>2023-04-08T15:58:27.066Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://kylinxin.github.io/2023/04/08/hello-world/"/>
    <id>https://kylinxin.github.io/2023/04/08/hello-world/</id>
    <published>2023-04-08T15:01:54.527Z</published>
    <updated>2023-04-08T15:01:54.528Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
