<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ky不是枕木</title>
  
  <subtitle>分享学习经验</subtitle>
  <link href="https://kylinxin.github.io/atom.xml" rel="self"/>
  
  <link href="https://kylinxin.github.io/"/>
  <updated>2023-05-05T09:55:19.767Z</updated>
  <id>https://kylinxin.github.io/</id>
  
  <author>
    <name>枕木</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://kylinxin.github.io/2023/05/05/%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/"/>
    <id>https://kylinxin.github.io/2023/05/05/%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/</id>
    <published>2023-05-05T06:51:58.070Z</published>
    <updated>2023-05-05T09:55:19.767Z</updated>
    
    <content type="html"><![CDATA[<h2 id="心路历程：记录5-6月软件杯-信息安全竞赛的备赛过程"><a href="#心路历程：记录5-6月软件杯-信息安全竞赛的备赛过程" class="headerlink" title="心路历程：记录5-6月软件杯 信息安全竞赛的备赛过程"></a>心路历程：记录5-6月软件杯 信息安全竞赛的备赛过程</h2><hr><h3 id="2023-4-20-星期四"><a href="#2023-4-20-星期四" class="headerlink" title="2023.4.20 星期四"></a>2023.4.20 星期四</h3><ol><li>集中开会，大家针对软件杯选题进行了合理分析，结合信息安全竞赛，决定从软件杯的选题中选择跟安全相关的进行剖析，最后确立了<strong>《基于机器学习的分布式机器》</strong></li><li>由于我们四个人都是大二，初步接触相关内容，我们认为得先恶补知识，才能进一步完成选题</li></ol><hr><h3 id="2023-4-26-星期三"><a href="#2023-4-26-星期三" class="headerlink" title="2023.4.26  星期三"></a>2023.4.26  星期三</h3><ol><li>通过大赛对于赛题的解读和要求，我们整理了一下整个过程，在课上进行了讲解，得到了导师的指导，告诉了我们应该从哪些方向入手，选择什么框架进行具体的搭建实现。</li><li>通过具体指点，我们集中开会确立分工 ，由我和某个队员实现具体算法，通过分析相关代码，提升题目要求的数据F1，其余两个队员实现前后端搭建，采用vue + sprintboot + JavaScript 的方法</li></ol><hr><h3 id="2023-5-5-星期四"><a href="#2023-5-5-星期四" class="headerlink" title="2023.5.5 星期四"></a>2023.5.5 星期四</h3><p>计划讨论内容：五一准备了啥，自己学习的知识内容，哪方面的，如何结合起来，如何提升</p><p>SVM + VISIO</p><p>​1.讨论完后，算法部分还得继续加油，这周争取跑到0.85，多深入学习一下机器学习，人工智能算法，之后可以拿测试数据进行预测，做一套符合要求的demo版本。</p><p>​2.web前后端，目前…</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;心路历程：记录5-6月软件杯-信息安全竞赛的备赛过程&quot;&gt;&lt;a href=&quot;#心路历程：记录5-6月软件杯-信息安全竞赛的备赛过程&quot; class=&quot;headerlink&quot; title=&quot;心路历程：记录5-6月软件杯 信息安全竞赛的备赛过程&quot;&gt;&lt;/a&gt;心路历程：记录5</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>蓝桥杯</title>
    <link href="https://kylinxin.github.io/2023/04/10/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>https://kylinxin.github.io/2023/04/10/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/</id>
    <published>2023-04-10T15:14:29.000Z</published>
    <updated>2023-04-10T15:22:25.952Z</updated>
    
    <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="救赎"><a href="#救赎" class="headerlink" title="救赎"></a>救赎</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="1-欧几里得辗转相除法-求解-最大公约数-最小公倍数"><a href="#1-欧几里得辗转相除法-求解-最大公约数-最小公倍数" class="headerlink" title="1.欧几里得辗转相除法 求解 最大公约数 最小公倍数"></a>1.欧几里得辗转相除法 求解 最大公约数 最小公倍数</h3><pre><code class="c++">int gcd(int a, int b){return b == 0 ? a : gcd(b, a % b);}int lcm(int a, int b){return a / gcd(a, b) * b;}</code></pre><h3 id="2-求质数"><a href="#2-求质数" class="headerlink" title="2.求质数"></a>2.求质数</h3><pre><code class="c++">/* 判断素数 */bool isPrime(LL n) {    for (int i = 2; i * i &lt;= n; ++i)        if (n % i == 0)            return false;    return true;}</code></pre><h3 id="3-栈"><a href="#3-栈" class="headerlink" title="3.栈"></a>3.栈</h3><pre><code class="c++">#include &lt;stack&gt;stack&lt;类型&gt; mystack;s.empty();         //如果栈为空则返回true, 否则返回false;s.size();          //返回栈中元素的个数s.top();           //返回栈顶元素, 但不删除该元素s.pop();           //弹出栈顶元素, 但不返回其值s.push();          //将元素压入栈顶</code></pre><h3 id="4-队列"><a href="#4-队列" class="headerlink" title="4.队列"></a>4.队列</h3><pre><code class="c++">#include &lt;queue&gt;queue&lt;类型&gt; myqueue;push() //在队尾插入一个元素pop() //删除队列第一个元素size() //返回队列中元素个数empty() //如果队列空则返回truefront() //返回队列中的第一个元素back() //返回队列中最后一个元素</code></pre><h3 id="5-DFS-深度优先"><a href="#5-DFS-深度优先" class="headerlink" title="5.DFS(深度优先)"></a>5.DFS(深度优先)</h3><pre><code class="c++">int dx[4] = {0,0,-1,1};int dy[4] = {-1,1,0,0};int mp[N][N];//存放迷宫int vis[N][N];//表示是否访问过，初始为flasevoid DFS(int x, int y)//x,y是坐标点的位置 {    if(vis[x][y] || (x==n &amp;&amp; y==n)) return; //表示已经访问过了或者到达终点,递归的出口    vis[x][y] = true; //表示没有访问过，现在正在访问，置为访问过    for(int i=0; i &lt; 4; i++){//遍历四个方向，顺序依次是，上下左右        int nx = x + dx[i];        int ny = y + dy[i];      //进行了合法性检验，      //1.首先判断了该点是否越界，即是否在迷宫内  nx &gt; 0 &amp;&amp; nx &lt;= n &amp;&amp; ny &gt; 0 &amp;&amp; ny &lt;= n      //2.然后判断是否访问过  !vis[nx][ny] 未访问过就继续      //3.最后判断是否为路  mp[nx][ny] == '0' 为路就继续        if(nx &gt; 0 &amp;&amp; nx &lt;= n &amp;&amp; ny &gt; 0 &amp;&amp; ny &lt;= n &amp;&amp; !vis[nx][ny] &amp;&amp; mp[nx][ny] == '0')            dfs(nx,ny);    } }//注意!! 应该判断一下起点是否可走</code></pre><h3 id="6-BFS-广度优先搜索"><a href="#6-BFS-广度优先搜索" class="headerlink" title="6.BFS(广度优先搜索)"></a>6.BFS(广度优先搜索)</h3><pre><code class="c++">int X[4]={0, 0, -1, 1};int Y[4]={-1, 1, 0, 0};int matrix[N][N]; //存储迷宫信息int vis[N][N];//存储每个状态点是否走过struct node{    int x;    int y;}Node, top;bool judge(int xx, int yy){    if(xx&lt;0||yy&lt;0||xx&gt;=N||yy&gt;=N) //注意边界        return false;    if(vis[xx][yy]==true||matrix[xx][yy]==0)//下一个点走过或者为墙 0不能走，1能走        return false;    return true;}void BFS(int x, int y){    queue&lt;node&gt; q;    Node.x=x;    Node.y=y;    q.push(Node);//将起点入队列    while(!q.empty())//队列不空就扩散    {        top=q.front();//取出队首元素        int nx=top.x;        int ny=top.y;//从四个方面机进行扩散         if(nx == ex &amp;&amp; ny == ey) //找到终点             return top;        for(int i=0; i&lt;4; i++)        {            if(judge(nx+X[i], ny+Y[i])) //检查四个方向，如果有路就进队列            {                Node.x=nx+X[i];                Node.y=ny+Y[i];                q.push(Node);            }        }        ans++;//计数器        vis[nx][ny]=true;        q.pop();//表示这个点的邻接点已经全部入队列，丢弃这个点    }}</code></pre><h3 id="7-二分模板"><a href="#7-二分模板" class="headerlink" title="7.二分模板"></a>7.二分模板</h3><pre><code class="c++">/*    作者:FengBOOOOOOOOOOOOOOO    二分模板返回大于x的第一个位置    */#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 1005using namespace std;int a[N],n,q;int find(int l,int r,int key)//l为-1，r为数组长度{    while(l + 1 &lt; r)    {        int mid = l + r&gt;&gt;1;        if(a[mid] &lt;= key)        　　l = mid;        else        　　r = mid;    }    return r;//返回大于Key的第一个位置}int main(){    int k;    scanf("%d%d",&amp;n,&amp;q);    for(int i = 0; i &lt; n; ++i)    　　scanf("%d",&amp;a[i]);    for(int i = 0; i &lt; q; ++i)    {        scanf("%d",&amp;k);        printf("%d\n",find(-1,n,k));    }} </code></pre><h2 id="最短路径问题"><a href="#最短路径问题" class="headerlink" title="最短路径问题"></a>最短路径问题</h2><h3 id="1-SPFA最短路径-类似与BFS"><a href="#1-SPFA最短路径-类似与BFS" class="headerlink" title="1.SPFA最短路径(类似与BFS)"></a>1.SPFA最短路径(类似与BFS)</h3><pre><code class="c++">#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#define ll long long#define inf 0x3f3f3f3f#define pii pair&lt;int, int&gt;const int mod = 1e9+7;const int maxn = 2e5+7;using namespace std;struct node {int to,w,next;} edge[maxn];int head[maxn], cnt;int dis[maxn], vis[maxn];int n, m, s, t;struct Spfa{    void init()    {        memset(head,-1,sizeof(head));        memset(dis,0x3f3f3f3f,sizeof(dis));        memset(vis,0,sizeof(vis));        cnt = 0;    }     void add(int u,int v,int w)    {        edge[cnt].to = v;        edge[cnt].w = w;        edge[cnt].next = head[u];        head[u] = cnt ++;    }     void spfa()    {        dis[s] = 0; vis[s] = 1;        queue &lt;int&gt; Q; Q.push(s);        while(!Q.empty())        {            int now = Q.front();            Q.pop(); vis[now] = 0;    //从队列中弹出now , vis[now] 标记为未访问            for(int i = head[now]; i != -1; i = edge[i].next)            {                int v = edge[i].to;                if(dis[v] &lt; dis[now] + edge[i].w)                {                    dis[v] = dis[now] + edge[i].w;                    if(vis[v]) continue;    //如果访问过了(也就是 已经在队列中),就不用再push                    vis[v] = 1; Q.push(v);                }            }        }    }}sp; int main(){    while(~scanf("%d%d",&amp;n,&amp;m) &amp;&amp; n+m)    {        sp.init();        for(int i = 0; i &lt; m; i++)        {            int u, v, w;            scanf("%d%d%d",&amp;u, &amp;v, &amp;w);            sp.add(u, v, w);            sp.add(v, u, w);        }        s = 1, t = n; //s起点，t终点        sp.spfa();        printf("%d\n", dis[t]);    }}</code></pre><h3 id="2-Dijkstra"><a href="#2-Dijkstra" class="headerlink" title="2.Dijkstra"></a>2.Dijkstra</h3><pre><code class="c++">//主要思想一个大循环+两个小循环void dijkstra(){    int u, minx;    book[S] = 1;    for(int i = 0; i &lt; N; i++){    //dist[]数组初始化，把起始结点S到i结点的距离赋值给diat[i]        dist[i] = v[S][i];    }    for(int i = 0; i &lt; N; i++){//大循环        minx = INT_MAX;        for(int j = 0; j &lt; N; j++){//寻找没有被标记并且最短的路径，并记录此结点             if(!book[j] &amp;&amp; minx &gt; dist[j]){                minx = dist[j];                u = j;            }         }        book[u] = 1;        for(int k = 0; k &lt; N; k++){        //如果A到B的距离大于A到C的距离加C到B的距离，那么更新数据            if(!book[k] &amp;&amp; dist[k] &gt; dist[u]+v[u][k]){                dist[k] = dist[u]+v[u][k];            }        }    }}</code></pre><h3 id="3-Floyd"><a href="#3-Floyd" class="headerlink" title="3.Floyd"></a>3.Floyd</h3><pre><code class="c++">//初始化：    for (int i = 1; i &lt;= n; i ++ )        for (int j = 1; j &lt;= n; j ++ )            if (i == j) d[i][j] = 0;            else d[i][j] = INF;// 算法结束后，d[a][b]表示a到b的最短距离void floyd(){    for (int k = 1; k &lt;= n; k ++ )        for (int i = 1; i &lt;= n; i ++ )            for (int j = 1; j &lt;= n; j ++ )                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);}</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;h1 id=&quot;救赎&quot;&gt;&lt;a href=&quot;#救赎&quot; class=&quot;headerlink&quot; title=&quot;救赎&quot;&gt;&lt;/a&gt;救赎&lt;/h1&gt;&lt;h2 id=&quot;基础知识&quot;&gt;</summary>
      
    
    
    
    
    <category term="蓝桥杯刷题总结" scheme="https://kylinxin.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>密码学实验</title>
    <link href="https://kylinxin.github.io/2023/04/10/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AE%9E%E9%AA%8C/"/>
    <id>https://kylinxin.github.io/2023/04/10/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AE%9E%E9%AA%8C/</id>
    <published>2023-04-10T15:14:29.000Z</published>
    <updated>2023-04-10T15:21:34.273Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DES"><a href="#DES" class="headerlink" title="DES"></a>DES</h2><pre><code class="C++">#include &lt;bits/stdc++.h&gt;using namespace std;string string_to_hex(const string&amp; str) //字符串转化为十六进制{    string result="";    string tmp;    stringstream ss;    for(int i=0;i&lt;str.size();i++)    {        ss&lt;&lt;hex&lt;&lt;int(str[i])&lt;&lt;endl;        ss&gt;&gt;tmp;        result+=tmp;    }    return result;}string hex_to_string(const std::string&amp; str){    std::string result;    for (size_t i = 0; i &lt; str.length(); i += 2)//十六进制两个字符为原始字符一个字符    {        std::string byte = str.substr(i, 2);//每次切两个字符        //将十六进制的string转成long再强转成int再转成char        char chr = (char)(int)strtol(byte.c_str(), NULL, 16);        result.push_back(chr);//将处理完的字符压入result中    }    return result;}string hex2bin(string s){    //十六进制转化为二进制    unordered_map&lt;char, string&gt; mp;    mp['0'] = "0000";    mp['1'] = "0001";    mp['2'] = "0010";    mp['3'] = "0011";    mp['4'] = "0100";    mp['5'] = "0101";    mp['6'] = "0110";    mp['7'] = "0111";    mp['8'] = "1000";    mp['9'] = "1001";    mp['A'] = "1010";    mp['B'] = "1011";    mp['C'] = "1100";    mp['D'] = "1101";    mp['E'] = "1110";    mp['F'] = "1111";    string bin = "";    for (int i = 0; i &lt; s.size(); i++) {        bin += mp[s[i]];    }    return bin;}string bin2hex(string s){    // 二进制转化为16进制    unordered_map&lt;string, string&gt; mp;    mp["0000"] = "0";    mp["0001"] = "1";    mp["0010"] = "2";    mp["0011"] = "3";    mp["0100"] = "4";    mp["0101"] = "5";    mp["0110"] = "6";    mp["0111"] = "7";    mp["1000"] = "8";    mp["1001"] = "9";    mp["1010"] = "A";    mp["1011"] = "B";    mp["1100"] = "C";    mp["1101"] = "D";    mp["1110"] = "E";    mp["1111"] = "F";    string hex = "";    for (int i = 0; i &lt; s.length(); i += 4) {        string ch = "";        ch += s[i];        ch += s[i + 1];        ch += s[i + 2];        ch += s[i + 3];        hex += mp[ch];    }    return hex;}string permute(string k, int* arr, int n){    string per = "";    for (int i = 0; i &lt; n; i++) {        per += k[arr[i] - 1];    }    return per;}string shift_left(string k, int shifts){    string s = "";    for (int i = 0; i &lt; shifts; i++) {        for (int j = 1; j &lt; 28; j++) {            s += k[j];        }        s += k[0];        k = s;        s = "";    }    return k;}string xor_(string a, string b){    string ans = "";    for (int i = 0; i &lt; a.size(); i++) {        if (a[i] == b[i]) {            ans += "0";        }        else {            ans += "1";        }    }    return ans;}string encrypt(string pt, vector&lt;string&gt; rkb,               vector&lt;string&gt; rk){    // 16-&gt;2    pt = hex2bin(pt);    // 初始置换    int initial_perm[64]            = { 58, 50, 42, 34, 26, 18, 10, 2,  60, 52, 44,                36, 28, 20, 12, 4,  62, 54, 46, 38, 30, 22,                14, 6,  64, 56, 48, 40, 32, 24, 16, 8,  57,                49, 41, 33, 25, 17, 9,  1,  59, 51, 43, 35,                27, 19, 11, 3,  61, 53, 45, 37, 29, 21, 13,                5,  63, 55, 47, 39, 31, 23, 15, 7 };    // 初始置换    pt = permute(pt, initial_perm, 64);    cout &lt;&lt; "初始置换后: " &lt;&lt; bin2hex(pt)         &lt;&lt; endl;    // 拆分成左右32比特    string left = pt.substr(0, 32);    string right = pt.substr(32, 32);    cout &lt;&lt; "拆分后: L0=" &lt;&lt; bin2hex(left)         &lt;&lt; " R0=" &lt;&lt; bin2hex(right) &lt;&lt; endl;    // E盒扩展    int exp_d[48]            = { 32, 1,  2,  3,  4,  5,  4,  5,  6,  7,  8,  9,                8,  9,  10, 11, 12, 13, 12, 13, 14, 15, 16, 17,                16, 17, 18, 19, 20, 21, 20, 21, 22, 23, 24, 25,                24, 25, 26, 27, 28, 29, 28, 29, 30, 31, 32, 1 };    // S盒    int s[8][4][16] = {            { 14, 4,  13, 1, 2,  15, 11, 8,  3,  10, 6,  12, 5,                                                                 9,  0,  7,  0, 15, 7,  4,  14, 2,  13, 1,  10, 6,                                                                                                                    12, 11, 9,  5, 3,  8,  4,  1,  14, 8,  13, 6,  2,                                                                                                                                                                       11, 15, 12, 9, 7,  3,  10, 5,  0,  15, 12, 8,  2,                                                    4,  9,  1,  7, 5,  11, 3,  14, 10, 0,  6,  13 },            { 15, 1,  8,  14, 6,  11, 3, 4,  9,  7,  2,  13, 12,                                                                 0,  5,  10, 3,  13, 4,  7, 15, 2,  8,  14, 12, 0,                                                                                                                    1,  10, 6,  9,  11, 5,  0, 14, 7,  11, 10, 4,  13,                                                                                                                                                                       1,  5,  8,  12, 6,  9,  3, 2,  15, 13, 8,  10, 1,                                                    3,  15, 4,  2,  11, 6,  7, 12, 0,  5,  14, 9 },            { 10, 0,  9,  14, 6,  3,  15, 5,  1,  13, 12,                                                         7,  11, 4,  2,  8,  13, 7,  0,  9,  3,  4,                                                                                                    6,  10, 2,  8,  5,  14, 12, 11, 15, 1,  13,                                                                                                                                               6,  4,  9,  8,  15, 3,  0,  11, 1,  2,  12,                    5,  10, 14, 7,  1,  10, 13, 0,  6,  9,  8,                                                                7,  4,  15, 14, 3,  11, 5,  2,  12 },            { 7,  13, 14, 3,  0,  6,  9,  10, 1,  2, 8,  5,  11,                                                                 12, 4,  15, 13, 8,  11, 5,  6,  15, 0, 3,  4,  7,                                                                                                                    2,  12, 1,  10, 14, 9,  10, 6,  9,  0, 12, 11, 7,                                                                                                                                                                       13, 15, 1,  3,  14, 5,  2,  8,  4,  3, 15, 0,  6,                                                    10, 1,  13, 8,  9,  4,  5,  11, 12, 7, 2,  14 },            { 2,  12, 4, 1,  7,  10, 11, 6, 8,  5,  3,  15, 13,                                                                 0,  14, 9, 14, 11, 2,  12, 4, 7,  13, 1,  5,  0,                                                                                                                    15, 10, 3, 9,  8,  6,  4,  2, 1,  11, 10, 13, 7,                                                                                                                                                                       8,  15, 9, 12, 5,  6,  3,  0, 14, 11, 8,  12, 7,                                                    1,  14, 2, 13, 6,  15, 0,  9, 10, 4,  5,  3 },            { 12, 1,  10, 15, 9,  2,  6,  8,  0,  13, 3, 4, 14,                                                                 7,  5,  11, 10, 15, 4,  2,  7,  12, 9,  5, 6, 1,                                                                                                                    13, 14, 0,  11, 3,  8,  9,  14, 15, 5,  2, 8, 12,                                                                                                                                                                       3,  7,  0,  4,  10, 1,  13, 11, 6,  4,  3, 2, 12,                                                    9,  5,  15, 10, 11, 14, 1,  7,  6,  0,  8, 13 },            { 4,  11, 2,  14, 15, 0,  8, 13, 3,  12, 9,  7,  5,                                                                 10, 6,  1,  13, 0,  11, 7, 4,  9,  1,  10, 14, 3,                                                                                                                    5,  12, 2,  15, 8,  6,  1, 4,  11, 13, 12, 3,  7,                                                                                                                                                                       14, 10, 15, 6,  8,  0,  5, 9,  2,  6,  11, 13, 8,                                                    1,  4,  10, 7,  9,  5,  0, 15, 14, 2,  3,  12 },            { 13, 2,  8, 4,  6,  15, 11, 1,  10, 9, 3, 14, 5,                                                                 0,  12, 7, 1,  15, 13, 8,  10, 3,  7, 4, 12, 5,                                                                                                                    6,  11, 0, 14, 9,  2,  7,  11, 4,  1, 9, 12, 14,                                                                                                                                                                       2,  0,  6, 10, 13, 15, 3,  5,  8,  2, 1, 14, 7,                                                    4,  10, 8, 13, 15, 12, 9,  0,  3,  5, 6, 11 }    };    // P盒置换    int per[32]            = { 16, 7, 20, 21, 29, 12, 28, 17, 1,  15, 23,                26, 5, 18, 31, 10, 2,  8,  24, 14, 32, 27,                3,  9, 19, 13, 30, 6,  22, 11, 4,  25 };    cout &lt;&lt; endl;    for (int i = 0; i &lt; 16; i++) {        string right_expanded = permute(right, exp_d, 48);        string x = xor_(rkb[i], right_expanded);        // S        string op = "";        for (int i = 0; i &lt; 8; i++) {            int row = 2 * int(x[i * 6] - '0')                      + int(x[i * 6 + 5] - '0');            int col = 8 * int(x[i * 6 + 1] - '0')                      + 4 * int(x[i * 6 + 2] - '0')                      + 2 * int(x[i * 6 + 3] - '0')                      + int(x[i * 6 + 4] - '0');            int val = s[i][row][col];            op += char(val / 8 + '0');            val = val % 8;            op += char(val / 4 + '0');            val = val % 4;            op += char(val / 2 + '0');            val = val % 2;            op += char(val + '0');        }        op = permute(op, per, 32);        x = xor_(op, left);        left = x;        // 交换左右        if (i != 15) {            swap(left, right);        }        cout &lt;&lt; "轮数: " &lt;&lt; i + 1 &lt;&lt; " " &lt;&lt; bin2hex(left)             &lt;&lt; " " &lt;&lt; bin2hex(right) &lt;&lt; " " &lt;&lt; rk[i]             &lt;&lt; endl;    }    // 左右结合    string combine = left + right;    // IP逆置换    int final_perm[64]            = { 40, 8,  48, 16, 56, 24, 64, 32, 39, 7,  47,                15, 55, 23, 63, 31, 38, 6,  46, 14, 54, 22,                62, 30, 37, 5,  45, 13, 53, 21, 61, 29, 36,                4,  44, 12, 52, 20, 60, 28, 35, 3,  43, 11,                51, 19, 59, 27, 34, 2,  42, 10, 50, 18, 58,                26, 33, 1,  41, 9,  49, 17, 57, 25 };    string cipher = bin2hex(permute(combine, final_perm, 64));    return cipher;}int main(){    string pt, key;    cout&lt;&lt;"请输入明文: ";    cin&gt;&gt;pt;    cout&lt;&lt;"请输入密文: ";    cin&gt;&gt;key;    pt = string_to_hex(pt);    cout&lt;&lt;pt;    key = string_to_hex(key);    key = hex2bin(key);    int keyp[56]            = { 57, 49, 41, 33, 25, 17, 9,  1,  58, 50, 42, 34,                26, 18, 10, 2,  59, 51, 43, 35, 27, 19, 11, 3,                60, 52, 44, 36, 63, 55, 47, 39, 31, 23, 15, 7,                62, 54, 46, 38, 30, 22, 14, 6,  61, 53, 45, 37,                29, 21, 13, 5,  28, 20, 12, 4 };    //密钥生成    key = permute(key, keyp, 56);    int shift_table[16] = { 1, 1, 2, 2, 2, 2, 2, 2,                            1, 2, 2, 2, 2, 2, 2, 1 };    int key_comp[48] = { 14, 17, 11, 24, 1,  5,  3,  28,                         15, 6,  21, 10, 23, 19, 12, 4,                         26, 8,  16, 7,  27, 20, 13, 2,                         41, 52, 31, 37, 47, 55, 30, 40,                         51, 45, 33, 48, 44, 49, 39, 56,                         34, 53, 46, 42, 50, 36, 29, 32 };    string left = key.substr(0, 28);    string right = key.substr(28, 28);    vector&lt;string&gt; rkb;    vector&lt;string&gt; rk;    for (int i = 0; i &lt; 16; i++) {        left = shift_left(left, shift_table[i]);        right = shift_left(right, shift_table[i]);        string combine = left + right;        string RoundKey = permute(combine, key_comp, 48);        rkb.push_back(RoundKey);        rk.push_back(bin2hex(RoundKey));    }    cout &lt;&lt; "加密:\n";    string cipher = encrypt(pt, rkb, rk);    cout &lt;&lt; "密文: " &lt;&lt; cipher &lt;&lt; endl;    cout &lt;&lt; "解密:\n";    reverse(rkb.begin(), rkb.end());    reverse(rk.begin(), rk.end());    string text = encrypt(cipher, rkb, rk);    text = hex_to_string(text);    cout &lt;&lt; "明文: " &lt;&lt; text &lt;&lt; endl;}</code></pre><h2 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h2><pre><code class="c++">#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt;#include &lt;stdint.h&gt;#include&lt;iomanip&gt;void AddRoundKey(uint8_t mtx[],uint32_t w[]);uint32_t SubKeys(uint32_t temp);void SubBytes(uint8_t mtx[],int len);void KeyExpansion(uint8_t key[], uint32_t new_key[]);void Display(uint8_t Matrix[]);void DisplayKeys(uint8_t Matrix[][16]);uint32_t left_bit_move(uint32_t val, int n);using namespace std;uint32_t T[4][256];//存储4张列混淆表int mixCol[4][4] = {        {0x02, 0x03, 0x01, 0x01},        {0x01, 0x02, 0x03, 0x01},        {0x01, 0x01, 0x02, 0x03},        {0x03, 0x01, 0x01, 0x02}};//列混淆矩阵uint8_t S_Box[16][16] =        {                {0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76},                {0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0},                {0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15},                {0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75},                {0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84},                {0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF},                {0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8},                {0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2},                {0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73},                {0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB},                {0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79},                {0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08},                {0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A},                {0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E},                {0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF},                {0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16}        };//逆S盒uint8_t Inv_S_Box[16][16] =        {                {0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB},                {0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB},                {0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E},                {0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25},                {0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92},                {0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84},                {0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06},                {0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B},                {0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73},                {0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E},                {0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B},                {0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4},                {0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F},                {0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF},                {0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61},                {0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D}        };//轮密钥加uint32_t LunMiYaoJia[10] = {0x01000000, 0x02000000, 0x04000000, 0x08000000, 0x10000000,                            0x20000000, 0x40000000, 0x80000000, 0x1b000000, 0x36000000};uint32_t left_bit_move(uint32_t val, int n) {    uint32_t size = sizeof(val) * 8;    n = n % size;    return (val &gt;&gt; (size - n) | (val &lt;&lt; n));//左移    //return (val &lt;&lt; (size - n) | (val &gt;&gt; n));//右移}string string_to_hex(const string&amp; str) //字符串转化为十六进制{    string result="";    string tmp;    stringstream ss;    for(int i=0;i&lt;str.size();i++)    {        ss&lt;&lt;hex&lt;&lt;int(str[i])&lt;&lt;endl;        ss&gt;&gt;tmp;        result+=tmp;    }    return result;}string hex_to_string(const std::string&amp; str){    std::string result;    for (size_t i = 0; i &lt; str.length(); i += 2)//十六进制两个字符为原始字符一个字符    {        std::string byte = str.substr(i, 2);//每次切两个字符        //将十六进制的string转成long再强转成int再转成char        char chr = (char)(int)strtol(byte.c_str(), NULL, 16);        result.push_back(chr);//将处理完的字符压入result中    }    return result;}//制作列混淆表uint8_t Mul_02(uint8_t x){    if((x&gt;&gt;7) == 0)        return x&lt;&lt;1;    else        return ((x&lt;&lt;1)^0x1b)&amp;0xff;}uint32_t get_output_col1(uint8_t x){    x = (uint32_t)x;    return (Mul_02(x)&lt;&lt;24)|(x&lt;&lt;16)|(x&lt;&lt;8)|(x^ Mul_02(x));    //2113}uint32_t get_output_col2(uint8_t x){    x = (uint32_t)x;    return ((x^Mul_02(x))&lt;&lt;24)|(Mul_02(x)&lt;&lt;16)|(x&lt;&lt;8)|(x);    //3211}uint32_t get_output_col3(uint8_t x){    x = (uint32_t)x;    return (x&lt;&lt;24)|((x^Mul_02(x))&lt;&lt;16)|(Mul_02(x)&lt;&lt;8)|(x);    //1321}uint32_t get_output_col4(uint8_t x){    x = (uint32_t)x;    return (x&lt;&lt;24)|(x&lt;&lt;16)|((x^Mul_02(x))&lt;&lt;8)|(Mul_02(x));    //1132}void get_TAB(){    for(int i=0;i&lt;4;i++) {        for (int j = 0; j &lt; 256; j++) {            T[i][j]=0;        }    }    for(int i=0;i&lt;256;i++) {        T[0][i] = get_output_col1((uint8_t) i);        T[1][i] = get_output_col2((uint8_t) i);        T[2][i] = get_output_col3((uint8_t) i);        T[3][i] = get_output_col4((uint8_t) i);    }    //输出列混淆表//    for(int i=0;i&lt;4;i++) {//        for (int j = 0; j &lt; 256; j++) {//            //printf("%8x ",T[i][j]);//            cout &lt;&lt;setw(8)&lt;&lt;setfill('0')&lt;&lt; hex &lt;&lt; T[i][j] &lt;&lt; " ";//        }//        cout&lt;&lt;endl;//    }}uint8_t GFMul(uint8_t a, uint8_t b) {    uint8_t p = 0;    uint8_t high;    for (int counter = 0; counter &lt; 8; counter++)    {        if ((b &amp; uint8_t(1)) != 0){//判断当前b的最后一位是否为0            p ^= a;}// p与a异或  即如果b当前最后一位不是0，就加上现在的a        high = (uint8_t) (a &amp; uint8_t(0x80));//高4位，看是否会溢出，high=1就是溢出        a &lt;&lt;= 1;//a左移一位，即乘以2        if (high != 0){//发生溢出            a ^= 0x1b; }// x^8 + x^4 + x^3 + x + 1        b &gt;&gt;= 1;//右移，看b的下一位了    }    return p;}void KeyExpansion(uint8_t key[], uint32_t w[]){    int j=0;    uint32_t temp=0;    // w[]的前4个就是输入的key    //初始化w[0]-&gt;w[3]    for(int i=0; i&lt;4;i++){        w[i] = (key[4*i]&lt;&lt;24)|(key[4*i+1]&lt;&lt;16)|(key[4*i+2]&lt;&lt;8)|(key[4*i+3]);        //printf("%d:%x\n",i,w[i]);    }    //创建w[4]-&gt;w[43]    for(int i=4; i&lt;44;i++){        if(i%4==0){            temp = left_bit_move(w[i-1],8);//循环左移8位            temp =  SubKeys(temp);            w[i] = temp ^ w[i-4] ^ LunMiYaoJia[j++];            //printf("%d:%x\n",i,w[i]);        }        else {            w[i] = w[i - 1] ^ w[i - 4];            //printf("%d:%x\n",i,w[i]);        }    }}void AddRoundKey(uint8_t mtx[],uint32_t w[]){    for(int i=0; i&lt;4; i++){        uint8_t w1 = w[i] &gt;&gt; 24 &amp; 0xff;        uint8_t w2 = (w[i] &gt;&gt; 16) &amp; 0xff;        uint8_t w3 = (w[i] &gt;&gt; 8) &amp; 0xff;        uint8_t w4 = (w[i]) &amp; 0xff;        mtx[i] ^= w1;  //按列异或        mtx[i+4] ^= w2;        mtx[i+8] ^= w3;        mtx[i+12] ^= w4;    }}//  S盒密钥变换 - 前4位为行号，后4位为列号uint32_t SubKeys(uint32_t temp){    uint8_t w[4] = {0};    int j=0;    //循环4次    for(int i=3; i&gt;=0; i--){        w[j++] = (temp&gt;&gt;(i*8))&amp;0xff;    }    SubBytes(w,4);    return (w[0]&lt;&lt;24|w[1]&lt;&lt;16|w[2]&lt;&lt;8|w[3]);}//  S盒变换 - 前4位为行号，后4位为列号void SubBytes(uint8_t mtx[],int len){    for(int i=0; i&lt;len; ++i)    {        int row = ((mtx[i]&gt;&gt;7)&amp;0x1)*8 + ((mtx[i]&gt;&gt;6)&amp;0x1)*4 + ((mtx[i]&gt;&gt;5)&amp;0x1)*2 + ((mtx[i]&gt;&gt;4)&amp;0x1)*1;    //第4 5 6 7位确定行        int col = ((mtx[i]&gt;&gt;3)&amp;0x1)*8 + ((mtx[i]&gt;&gt;2)&amp;0x1)*4 + ((mtx[i]&gt;&gt;1)&amp;0x1)*2 + (mtx[i]&amp;0x1)*1;       //第0 1 2 3位确定列        mtx[i] = S_Box[row][col];    }}void InvSubBytes(uint8_t mtx[],int len){    for(int i=0; i&lt;len; ++i)    {        int row = ((mtx[i]&gt;&gt;7)&amp;0x1)*8 + ((mtx[i]&gt;&gt;6)&amp;0x1)*4 + ((mtx[i]&gt;&gt;5)&amp;0x1)*2 + ((mtx[i]&gt;&gt;4)&amp;0x1)*1;    //第4 5 6 7位确定行        int col = ((mtx[i]&gt;&gt;3)&amp;0x1)*8 + ((mtx[i]&gt;&gt;2)&amp;0x1)*4 + ((mtx[i]&gt;&gt;1)&amp;0x1)*2 + (mtx[i]&amp;0x1)*1;       //第0 1 2 3位确定列        mtx[i] = Inv_S_Box[row][col];    }}//行移位void ShiftRows(uint8_t mtx[]){    uint8_t temp=mtx[4];    //第二行左移一位    for(int i=0; i&lt;3; i++){        mtx[i+4] = mtx[i+5];    }    mtx[7] = temp;    //第三行左移二位    for(int i=0; i&lt;2; i++){        temp = mtx[i+8];        mtx[i+8] = mtx[i+10];        mtx[i+10] = temp;    }    //第四行左移三位    temp = mtx[15];    for(int i=3; i&gt;0; i--) {        mtx[i + 12] = mtx[i + 11];    }    mtx[12] = temp;}void InvShiftRows(uint8_t mtx[]){    // 第二行循环右移一位    uint8_t temp = mtx[7];    for(int i=3; i&gt;0; --i)        mtx[i+4] = mtx[i+3];    mtx[4] = temp;    // 第三行循环右移两位    for(int i=0; i&lt;2; ++i)    {        temp = mtx[i+8];        mtx[i+8] = mtx[i+10];        mtx[i+10] = temp;    }    // 第四行循环右移三位    temp = mtx[12];    for(int i=0; i&lt;3; ++i)        mtx[i+12] = mtx[i+13];    mtx[15] = temp;}void MixColumns(uint8_t c[]){    uint32_t total[4]={0};  //存储每一列取出的4个32比特字节异或的结果，即列混淆后的第i列    uint32_t temp[16]={0};  //存储16个 每个字节从T表得到的32比特的4字节一列    for(int i=0;i&lt;16;i++){        temp[i] = T[i/4][c[i]];    }    for(int i=0; i&lt;4;i++) {        total[i] = temp[i] ^ temp[i+4] ^ temp[i+8] ^ temp[i+12];        c[i] = (total[i]&gt;&gt;24)&amp;0xff;        c[i+4]=(total[i]&gt;&gt;16)&amp;0xff;        c[i+8] = (total[i]&gt;&gt;8)&amp;0xff;        c[i+12] = (total[i])&amp;0xff;    }}void InvMixColumns(uint8_t mtx[]){    uint8_t arr[4];    for(int i=0; i&lt;4; ++i) {        for (int j = 0; j &lt; 4; ++j)            arr[j] = mtx[i + j * 4];        mtx[i] = GFMul(0x0e, arr[0]) ^ GFMul(0x0b, arr[1]) ^ GFMul(0x0d, arr[2]) ^ GFMul(0x09, arr[3]);        mtx[i + 4] = GFMul(0x09, arr[0]) ^ GFMul(0x0e, arr[1]) ^ GFMul(0x0b, arr[2]) ^ GFMul(0x0d, arr[3]);        mtx[i + 8] = GFMul(0x0d, arr[0]) ^ GFMul(0x09, arr[1]) ^ GFMul(0x0e, arr[2]) ^ GFMul(0x0b, arr[3]);        mtx[i + 12] = GFMul(0x0b, arr[0]) ^ GFMul(0x0d, arr[1]) ^ GFMul(0x09, arr[2]) ^ GFMul(0x0e, arr[3]);    }}void Encrypt(uint8_t m[],uint32_t key[],uint8_t c[]){    //首先进行开始的轮密钥加    int round=0;    uint32_t w[4]={0};    for(int k=0; k&lt;4; k++)        w[k] = key[4*round+k];    for(int i=0; i&lt;16; i++)        c[i] = m[i];    AddRoundKey(c,w);    //接下来是9轮一摸一样的函数    for(int i = 1;i&lt;=9;i++)    {        SubBytes(c,16);//字节替代        ShiftRows(c);//行移位        MixColumns(c);//列混淆        round++;        //cout&lt;&lt;"轮数"&lt;&lt;round&lt;&lt;endl;        for(int k=0; k&lt;4; k++) {            w[k] = key[4 * round + k];        }        AddRoundKey(c,w);//轮密钥加    }    //最后一轮    round++;    //cout&lt;&lt;"轮数"&lt;&lt;round&lt;&lt;endl;    for(int k=0; k&lt;4; k++) {        w[k] = key[4 * round + k];        //("%x ",w[k]);    }    SubBytes(c,16);//字节替代    ShiftRows(c);//行移位    AddRoundKey(c,w);//轮密钥加}void Decrypt(uint8_t c[],uint32_t key[],uint8_t m[]){    //首先进行开始的轮密钥加    //注意密钥反着来    int round=10;    uint32_t w[4]={0};    for(int k=0; k&lt;4; k++)        w[k] = key[4*round+k];  //密钥赋值    for(int i=0; i&lt;16; i++)        m[i] = c[i];    AddRoundKey(m,w);    //接下来是9轮一摸一样的函数    for(int i = 1;i&lt;=9;i++)    {        InvShiftRows(m);//行移位        InvSubBytes(m,16);//字节替代        round--;        //cout&lt;&lt;"轮数"&lt;&lt;round&lt;&lt;endl;        for(int k=0; k&lt;4; k++) {            w[k] = key[4 * round + k];        }        AddRoundKey(m,w);//轮密钥加        InvMixColumns(m);//列混淆    }    //最后一轮    round--;    //cout&lt;&lt;"轮数"&lt;&lt;round&lt;&lt;endl;    for(int k=0; k&lt;4; k++) {        w[k] = key[4 * round + k];        //("%x ",w[k]);    }    InvShiftRows(m);//行移位    InvSubBytes(m,16);//字节替代    AddRoundKey(m,w);//轮密钥加}void Display(uint8_t Matrix[]){    for(int i=0; i&lt;16; i++) {        printf("%x ", Matrix[i]);        if(i%4==3)            cout&lt;&lt;endl;    }}void DisplayKeys(uint32_t Matrix[]){    for(int i=0; i&lt;44; i++) {        printf("第%d列:%x\n",i,Matrix[i]);    }}int main(){    string mingwen;    string miwen;    uint8_t key[16]={0};    uint8_t m[16]={0};    cout&lt;&lt;"请输入明文(128bits):";    cin&gt;&gt;mingwen;    cout&lt;&lt;"请输入密文(128bits):";    cin&gt;&gt;miwen;    for(int i=0;i&lt;16;i++)    {        m[i] = (uint8_t)(mingwen[i]);        key[i] = (uint8_t)(miwen[i]);    }    uint8_t c[16]={0};    uint8_t x[16]={0};    uint32_t new_key[44]={0};   //存储44列密钥    cout&lt;&lt;"明文:"&lt;&lt;endl;    Display(m);    cout&lt;&lt;"密钥:"&lt;&lt;endl;    Display(key);    get_TAB();//生成列混淆表    KeyExpansion(key,new_key);    cout&lt;&lt;"生成密钥"&lt;&lt;endl;    //DisplayKeys(new_key);    Encrypt(m,new_key,c);    cout&lt;&lt;"加密结果"&lt;&lt;endl;    Display(c);    Decrypt(c,new_key,x);    cout&lt;&lt;"解密结果(hex)"&lt;&lt;endl;    Display(x);    cout&lt;&lt;"解密结果(string)"&lt;&lt;endl;    for(int i=0;i&lt;16;i++)        cout&lt;&lt;(char)x[i];    return 0;}</code></pre><h2 id="SM4"><a href="#SM4" class="headerlink" title="SM4"></a>SM4</h2><pre><code class="c++">#include "string.h"#include&lt;iostream&gt;#include &lt;stdint.h&gt;#include&lt;string&gt;using namespace std;uint32_t shift_l(uint32_t s,int n)//循环左移n位{    int size=sizeof (s)*8;      //字节数乘以8代表一共多少位    return s&lt;&lt;(n)|(s&gt;&gt;size-n);}uint32_t Sb(uint32_t s) {    uint8_t SboxTable[16][16] =            {                    {0xd6, 0x90, 0xe9, 0xfe, 0xcc, 0xe1, 0x3d, 0xb7, 0x16, 0xb6, 0x14, 0xc2, 0x28, 0xfb, 0x2c, 0x05},                    {0x2b, 0x67, 0x9a, 0x76, 0x2a, 0xbe, 0x04, 0xc3, 0xaa, 0x44, 0x13, 0x26, 0x49, 0x86, 0x06, 0x99},                    {0x9c, 0x42, 0x50, 0xf4, 0x91, 0xef, 0x98, 0x7a, 0x33, 0x54, 0x0b, 0x43, 0xed, 0xcf, 0xac, 0x62},                    {0xe4, 0xb3, 0x1c, 0xa9, 0xc9, 0x08, 0xe8, 0x95, 0x80, 0xdf, 0x94, 0xfa, 0x75, 0x8f, 0x3f, 0xa6},                    {0x47, 0x07, 0xa7, 0xfc, 0xf3, 0x73, 0x17, 0xba, 0x83, 0x59, 0x3c, 0x19, 0xe6, 0x85, 0x4f, 0xa8},                    {0x68, 0x6b, 0x81, 0xb2, 0x71, 0x64, 0xda, 0x8b, 0xf8, 0xeb, 0x0f, 0x4b, 0x70, 0x56, 0x9d, 0x35},                    {0x1e, 0x24, 0x0e, 0x5e, 0x63, 0x58, 0xd1, 0xa2, 0x25, 0x22, 0x7c, 0x3b, 0x01, 0x21, 0x78, 0x87},                    {0xd4, 0x00, 0x46, 0x57, 0x9f, 0xd3, 0x27, 0x52, 0x4c, 0x36, 0x02, 0xe7, 0xa0, 0xc4, 0xc8, 0x9e},                    {0xea, 0xbf, 0x8a, 0xd2, 0x40, 0xc7, 0x38, 0xb5, 0xa3, 0xf7, 0xf2, 0xce, 0xf9, 0x61, 0x15, 0xa1},                    {0xe0, 0xae, 0x5d, 0xa4, 0x9b, 0x34, 0x1a, 0x55, 0xad, 0x93, 0x32, 0x30, 0xf5, 0x8c, 0xb1, 0xe3},                    {0x1d, 0xf6, 0xe2, 0x2e, 0x82, 0x66, 0xca, 0x60, 0xc0, 0x29, 0x23, 0xab, 0x0d, 0x53, 0x4e, 0x6f},                    {0xd5, 0xdb, 0x37, 0x45, 0xde, 0xfd, 0x8e, 0x2f, 0x03, 0xff, 0x6a, 0x72, 0x6d, 0x6c, 0x5b, 0x51},                    {0x8d, 0x1b, 0xaf, 0x92, 0xbb, 0xdd, 0xbc, 0x7f, 0x11, 0xd9, 0x5c, 0x41, 0x1f, 0x10, 0x5a, 0xd8},                    {0x0a, 0xc1, 0x31, 0x88, 0xa5, 0xcd, 0x7b, 0xbd, 0x2d, 0x74, 0xd0, 0x12, 0xb8, 0xe5, 0xb4, 0xb0},                    {0x89, 0x69, 0x97, 0x4a, 0x0c, 0x96, 0x77, 0x7e, 0x65, 0xb9, 0xf1, 0x09, 0xc5, 0x6e, 0xc6, 0x84},                    {0x18, 0xf0, 0x7d, 0xec, 0x3a, 0xdc, 0x4d, 0x20, 0x79, 0xee, 0x5f, 0x3e, 0xd7, 0xcb, 0x39, 0x48}};    uint8_t a[4];    a[0]=(s&gt;&gt;24)&amp;0xff;     //最高8位    a[1]=(s&gt;&gt;16)&amp;0xff;    a[2]=(s&gt;&gt;8)&amp;0xff;    a[3]=s&amp;0xff;    uint8_t b[4];    for(int i=0;i&lt;4;i++) {        int row = ((a[i] &gt;&gt; 7) &amp; 1) * 8 + ((a[i] &gt;&gt; 6) &amp; 1) * 4 + ((a[i] &gt;&gt; 5) &amp; 1) * 2 + ((a[i] &gt;&gt; 4) &amp; 1) * 1;        int col = ((a[i] &gt;&gt; 3) &amp; 1) * 8 + ((a[i] &gt;&gt; 2) &amp; 1) * 4 + ((a[i] &gt;&gt; 1) &amp; 1) * 2 + ((a[i]) &amp; 1) * 1;        b[i] = SboxTable[row][col];    }    uint32_t result;    result=(b[0]&lt;&lt;24)|(b[1]&lt;&lt;16)|(b[2]&lt;&lt;8)|b[3];    return result;}uint32_t L_change(uint32_t s){    return s^ shift_l(s,13)^ shift_l(s,23);}uint32_t T_change(uint32_t s){    return L_change(Sb(s));}void keyexpand(uint32_t MK[4],uint32_t rk[32]){    uint32_t FK[4]={0xA3B1BAC6, 0x56AA3350,0x677D9197, 0xB27022DC};    uint32_t CK[32] = { 0x00070E15, 0x1C232A31, 0x383F464D, 0x545B6269,                        0x70777E85, 0x8C939AA1, 0xA8AFB6BD, 0xC4CBD2D9,                        0xE0E7EEF5, 0xFC030A11, 0x181F262D, 0x343B4249,                        0x50575E65, 0x6C737A81, 0x888F969D, 0xA4ABB2B9,                        0xC0C7CED5, 0xDCE3EAF1, 0xF8FF060D, 0x141B2229,                        0x30373E45, 0x4C535A61, 0x686F767D, 0x848B9299,                        0xA0A7AEB5, 0xBCC3CAD1, 0xD8DFE6ED, 0xF4FB0209,                        0x10171E25, 0x2C333A41, 0x484F565D, 0x646B7279 };    uint32_t k[4]={MK[0]^FK[0],MK[1]^FK[1],MK[2]^FK[2],MK[3]^FK[3]};    uint32_t K[36];    for(int i=0;i&lt;=3;i++)        K[i]=k[i];    for(int i=0;i&lt;32;i++)    {        K[i+4]=K[i]^ T_change(K[i+1]^K[i+2]^K[i+3]^CK[i]);    }    for(int i=0;i&lt;32;i++)        rk[i]=K[i+4];}uint32_t Lchange(uint32_t s){    return s^shift_l(s,2)^shift_l(s,10)^shift_l(s,18)^shift_l(s,24);}uint32_t Tchange(uint32_t s){    return Lchange(Sb(s));}uint32_t fround(uint32_t X[4],uint32_t rk){    uint32_t B=X[1]^X[2]^X[3]^rk;    return X[0]^ L_change(Sb(B));}static uint32_t out1[4];void SM4(uint32_t X[4],uint32_t rk[32]){    uint32_t Y[36];    Y[0]=X[0];    Y[1]=X[1];    Y[2]=X[2];    Y[3]=X[3];    for(int i=0;i&lt;=31;i++) {        Y[i + 4] = Y[i] ^ Tchange(Y[i + 1] ^ Y[i + 2] ^ Y[i + 3] ^ rk[i]);    }//    for(int i=0;i&lt;36;i++) {//        printf("第%d轮:%x \n",i,Y[i]);//    }    out1[0]=Y[35];    out1[1]=Y[34];    out1[2]=Y[33];    out1[3]=Y[32];}static uint32_t out2[4];void sm4(uint32_t Y[4],uint32_t rk[32]){    uint32_t X[36];    X[35]=Y[0];    X[34]=Y[1];    X[33]=Y[2];    X[32]=Y[3];    for(int i=31;i&gt;=0;i--)    {        X[i]=X[i+4]^ Tchange(X[i+3]^X[i+2]^X[i+1]^rk[i]);    }    out2[0]=X[0];    out2[1]=X[1];    out2[2]=X[2];    out2[3]=X[3];}int main() {    uint32_t ming[4]={0x01234567,0x89ABCDEF,0xFEDCBA98,0x76543210};    cout&lt;&lt;"明文:"&lt;&lt;endl;    for(int i=0;i&lt;4;i++)        cout&lt;&lt;hex&lt;&lt;ming[i]&lt;&lt;" ";    cout&lt;&lt;endl;    uint32_t MK[4]={0x01234567,0x89ABCDEF,0xFEDCBA98,0x76543210};    cout&lt;&lt;"密钥："&lt;&lt;endl;    for(int i=0;i&lt;4;i++)        cout&lt;&lt;hex&lt;&lt;MK[i]&lt;&lt;" ";    cout&lt;&lt;endl;    uint32_t rk[32];    keyexpand(MK,rk);//    cout&lt;&lt;"扩展密钥："&lt;&lt;endl;//    for(int i=0;i&lt;32;i++)//        cout&lt;&lt;i&lt;&lt;"轮扩展密钥"&lt;&lt;rk[i]&lt;&lt;endl;    cout&lt;&lt;"加密结果："&lt;&lt;endl;    SM4(ming,rk);    for(int i=0;i&lt;4;i++)        cout&lt;&lt;out1[i]&lt;&lt;" ";    cout&lt;&lt;endl;    cout&lt;&lt;"解密结果:"&lt;&lt;endl;    sm4(out1,rk);    for(int i=0;i&lt;4;i++)        cout&lt;&lt;out2[i]&lt;&lt;" ";    cout&lt;&lt;endl;    return 0;}</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;DES&quot;&gt;&lt;a href=&quot;#DES&quot; class=&quot;headerlink&quot; title=&quot;DES&quot;&gt;&lt;/a&gt;DES&lt;/h2&gt;&lt;pre&gt;&lt;code class=&quot;C++&quot;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace</summary>
      
    
    
    
    
    <category term="密码学实验代码集合" scheme="https://kylinxin.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AE%9E%E9%AA%8C%E4%BB%A3%E7%A0%81%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
</feed>
